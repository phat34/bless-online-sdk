#pragma once

// Unreal Engine 3 (3) SDK

#ifdef _MSC_VER
	#pragma pack(push, 0x8)
#endif

#include "UE3_BLGame_structs.hpp"

namespace SDK
{
//---------------------------------------------------------------------------
//Classes
//---------------------------------------------------------------------------

// Class BLGame.ABLSDLTypes
// 0x0000 (0x0060 - 0x0060)
class UABLSDLTypes : public UObject
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.ABLSDLTypes");
		return ptr;
	}

};


// Class BLGame.ABLUtils
// 0x0000 (0x0060 - 0x0060)
class UABLUtils : public UObject
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.ABLUtils");
		return ptr;
	}


	struct FColor STATIC_GetCompanionGradeColor(TEnumAsByte<ECECompanionGradeType> Grade);
	int STATIC_GetMaxCharacterCount();
	void STATIC_ConvertROStatueItemDataToEquipedItemData(TArray<struct FROGuildStatueItemData>* InROStatueItemData, TArray<struct FEquipedItemData>* OutEquipedItemData);
	struct FString STATIC_MakeString_Location_COGuildName(TEnumAsByte<ECERealmType> InRealmType, const struct FString& InGuildName);
	struct FString STATIC_MakeString_Location_ROGuildName(TEnumAsByte<ECERealmType> InRealmType, const struct FString& InGuildName);
	void STATIC_ConvertBLGuildMarkDataToUIData(TEnumAsByte<ECERealmType> InRealmType, struct FBLGuildMarkData* InMarkData, struct FBLGuildMarkUIData* OutUIData);
	void STATIC_ConvertGuildMarkDataToBLGuildMarkData(bool InIsRO, bool InIsCO, int InLastSeasonWinCount, struct FGuildMarkData* InData, struct FBLGuildMarkData* OutData);
	bool STATIC_UseCookedBLInfo();
	struct FString STATIC_ConvertFilteringIconEnumToString(int FilterType);
	int STATIC_ConvertStringToFilteringIconEnum(const struct FString& FilterType);
	struct FColor STATIC_GetItemGradeColor(TEnumAsByte<ECEItemGradeType> InGrade);
	int STATIC_FindForbidString(const struct FString& InSource, struct FString* OutForbidString);
	void STATIC_SetSystemMessageParamValueDatafloat(float Num, struct FSystemMessageParamValueData* ParamValueData);
	void STATIC_SetSystemMessageParamValueDataInt(int Num, struct FSystemMessageParamValueData* ParamValueData);
	TEnumAsByte<ELevelGapClass> STATIC_GetLevelGapClass(int TargetLevel, int PcLevel, struct FColor* LevelGapColor);
	void STATIC_MakeKeyInputDataToDWORD(const struct FName& InHighMod, const struct FName& InHighKey, const struct FName& InLowMod, const struct FName& InLowKey, int* OutDWORD);
	void STATIC_ParseToKeyInputData(int InDWORD, struct FName* OutHighMod, struct FName* OutHighKey, struct FName* OutLowMod, struct FName* OutLowKey);
	struct FName STATIC_ToKeyNameByAscii(unsigned char AsciiByte);
	struct FName STATIC_ToKeyName(unsigned char VKeyByte);
	unsigned char STATIC_ToVKeyByte(const struct FName& KeyName);
	struct FVector STATIC_LineToPlaneIntersection(const struct FVector& LineOrigin, const struct FVector& LineDirection, const struct FVector& PlaneOrigin, const struct FVector& PlaneNormal);
	struct FString STATIC_MakeFontTag_Param_Size_And_Color(const struct FString& InText, int InSize, const struct FColor& InColor);
	struct FString STATIC_MakeFontTag_Param_Color(const struct FString& InText, const struct FColor& InColor);
	struct FString STATIC_MakeFontTag_Param_Size(const struct FString& InText, int InSize);
	struct FString STATIC_MakeAlignTag(const struct FString& InText, const struct FString& InAlign);
	float STATIC_GetLocalMachineTime();
	struct FQWord STATIC_GetServerFutureTime(int Sec);
	void STATIC_GetServerRemainTime(const struct FQWord& Time, int* Day, int* Hour, int* Minute, int* Second);
	void STATIC_GetServerElapseTime(const struct FQWord& Time, int* Day, int* Hour, int* Minute, int* Second);
	struct FString STATIC_GetGoldStringToCooper(const struct FQWord& InCooper);
	void STATIC_ConvertGoldToCooper(const struct FQWord& InCooper, int* Gold, int* Silver, int* Cooper);
	struct FString STATIC_ConvertTextToHyperlink(const struct FString& Text);
	struct FString STATIC_ConvertHyperlinkToText(const struct FString& Text);
	TEnumAsByte<ECEContentTokenType> STATIC_ConvertCoinTypeToContentTokenType(TEnumAsByte<ECoinType> InCoinType);
	TEnumAsByte<ECoinType> STATIC_ConvertContentTokenTypeToCoinType(TEnumAsByte<ECEContentTokenType> InTokenType);
	struct FString STATIC_ConvertScaleformTanslatorString(const struct FString& CodeName);
	struct FString STATIC_ConvertColorToHexCutOutAlpha(const struct FColor& InColor, bool IsHtmlTag);
	struct FString STATIC_ConvertHtmlTagToText(const struct FString& Text);
	void STATIC_Add_GameString_Param_String(const struct FString& InString, TArray<struct FSystemMessageParamValueData>* Params);
	void STATIC_Add_GameString_Param_Int(int InInt, TArray<struct FSystemMessageParamValueData>* Params);
	void STATIC_Add_GameString_Param_Float(float InFloat, TArray<struct FSystemMessageParamValueData>* Params);
	struct FString STATIC_GetLocalizeString(const struct FString& Section, const struct FString& Key, const struct FString& Package, TArray<struct FString> Params, const struct FString& LangExt);
	struct FQWord STATIC_ConvertStringToQWORD(const struct FString& InString);
	struct FQWord STATIC_MergeQword(const struct FQWord& InA, const struct FQWord& InB);
	struct FQWord STATIC_GetQwordFromInt(int InValue);
	struct FString STATIC_GetStringFrom64Int(const struct FQWord& InValue);
	struct FString STATIC_ConvertRGBToDWORDString(int InColorR, int InColorG, int InColorB);
	bool STATIC_IsIntersectSphereToLine(const struct FVector& Start, const struct FVector& Dir, float Length, const struct FVector& Origin, float Radius);
	void STATIC_SphereToLineIntersection(const struct FVector& SphereOrigin, float SphereRadius, const struct FVector& LineOrigin, const struct FVector& LineDir, struct FVector* OutClosestPoint);
	bool STATIC_LineExtentBoxIntersection(const struct FVector& InMin, const struct FVector& InMax, const struct FVector& Start, const struct FVector& End, struct FVector* OutHitLocation);
	TEnumAsByte<ECEItemEquipCategory> STATIC_GetWeaponTypeToEquip(unsigned char InCostume);
	TEnumAsByte<ECEItemEquipCategory> STATIC_GetWeaponTypeToCostume(unsigned char InEquip);
	TEnumAsByte<EBLEquipItemCategory> STATIC_GetBLEquipItemCategory(TEnumAsByte<ECEItemEquipCategory> InCategory);
	void STATIC_Add_AS_Boolean(bool InValue, TArray<struct FASValue>* OutArray);
	void STATIC_Add_AS_String(const struct FString& InValue, TArray<struct FASValue>* OutArray);
	void STATIC_Add_AS_Number(int InValue, TArray<struct FASValue>* OutArray);
	void STATIC_Add_AS_Float(float InValue, TArray<struct FASValue>* OutArray);
	void STATIC_Add_AS_Int(int InValue, TArray<struct FASValue>* OutArray);
	void STATIC_Add_AS_Dummy(TArray<struct FASValue>* OutArray);
	int STATIC_GetPartyIDBySlotIndex(int InSlotIndex);
	bool STATIC_TraceOnStaticLevel(const struct FVector& End, const struct FVector& Start, const struct FVector& Extent, struct FVector* OutLocation, struct FVector* OutNormal, struct FTraceHitInfo* HitInfo);
	void STATIC_ActivateFadeInOut(class UParticleSystemComponent* PSC, int Aug);
	void STATIC_ActivateParticleMeshMITV(class UParticleSystemComponent* PSC, const struct FName& ScalarParamName);
	float STATIC_HyperCos(float X);
	struct FQWord STATIC_Mul_QWORD_FLOAT(const struct FQWord& lhs, float rhs);
	struct FQWord STATIC_Mul_QWORD_INT(const struct FQWord& lhs, int rhs);
	struct FString STATIC_NumStringToCommaString(const struct FString& InNumStr);
	struct FString STATIC_QWORDToCommaString(const struct FQWord& InNum);
	struct FString STATIC_IntToCommaString(int InNum);
	bool STATIC_GetCenterPositionInDivision(const struct FString& Division, int SubDivision, struct FVector2D* OutLocation);
	struct FString STATIC_LocalizeBL(const struct FString& Package, const struct FString& Section, const struct FString& Key, const struct FString& LangExt);
	struct FString STATIC_LocalizePCParam(TEnumAsByte<ECEClassType> InClassType, const struct FString& InParamName, const struct FString& InSubSection);
	struct FString STATIC_LocalizeBLEnumDesc(class UObject* E, int Index, const struct FString& LangExt);
	struct FString STATIC_LocalizeBLEnum(class UObject* E, int Index, const struct FString& LangExt);
	float STATIC_GetYawDegAngleRefToTarget(struct FVector* RefLocation, struct FRotator* RefRotation, struct FVector* TargetLocation);
	bool STATIC_OutOfAngle(const struct FVector& InDirA, const struct FVector& InDirB, float InAngle);
	float STATIC_GetAngleOfRadian(class AActor* InMySelf, class AActor* InTarget);
	float STATIC_GetAngle(class AActor* InMySelf, class AActor* InTarget);
	bool STATIC_OutOfAngleBetweenActor(class AActor* InMySelf, class AActor* InTarget, float InAngle);
	float STATIC_GetAngleByYaw(int Yaw);
};


// Class BLGame.BLAudioManager
// 0x0014 (0x0074 - 0x0060)
class UBLAudioManager : public UObject
{
public:
	TEnumAsByte<ESOUND_LISTENER_TYPE>                  ListenerType;                                             // 0x0060(0x0001)
	TEnumAsByte<ESOUND_LISTENER_TYPE>                  ProcessedListenerType;                                    // 0x0061(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x0062(0x0002) MISSED OFFSET
	struct FString                                     InitSoundListenerType;                                    // 0x0064(0x0010) (Config, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAudioManager");
		return ptr;
	}


	void DisplayDebug(class AHUD* HUD, float* out_YL, float* out_YPos);
	TEnumAsByte<ESOUND_LISTENER_TYPE> GetProecessedListenerType();
	TEnumAsByte<ESOUND_LISTENER_TYPE> GetListenerType();
	void SetListenerType(TEnumAsByte<ESOUND_LISTENER_TYPE> InListenerType);
};


// Class BLGame.BLCharacterLightProperty
// 0x01E0 (0x0240 - 0x0060)
class UBLCharacterLightProperty : public UObject
{
public:
	struct FSpotLightProperties                        MainLight;                                                // 0x0060(0x0030) (Edit, Config)
	struct FSpotLightProperties                        BackLight;                                                // 0x0090(0x0030) (Edit, Config)
	struct FSpotLightProperties                        SideLight;                                                // 0x00C0(0x0030) (Edit, Config)
	struct FPointLightProperties                       FillLight;                                                // 0x00F0(0x002C) (Edit, Config)
	TArray<struct FCharLightLocationRotation>          LightLocation;                                            // 0x011C(0x0010) (Edit, Config, NeedCtorLink)
	struct FSpotLightProperties                        Statue_MainLight;                                         // 0x012C(0x0030) (Edit, Config)
	struct FSpotLightProperties                        Statue_BackLight;                                         // 0x015C(0x0030) (Edit, Config)
	struct FSpotLightProperties                        Statue_SideLight;                                         // 0x018C(0x0030) (Edit, Config)
	struct FPointLightProperties                       Statue_FillLight;                                         // 0x01BC(0x002C) (Edit, Config)
	struct FCharLightLocationRotation                  Statue_LightLocation;                                     // 0x01E8(0x0058) (Edit, Config)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLCharacterLightProperty");
		return ptr;
	}

};


// Class BLGame.BlessLocalPlayer
// 0x033C (0x09E8 - 0x06AC)
class UBlessLocalPlayer : public ULocalPlayer
{
public:
	class UClass*                                      NetHandlerClass;                                          // 0x06AC(0x0008) (Const)
	class UBLNetHandlerBase*                           NetHandlerBase;                                           // 0x06B4(0x0008)
	class UBLNetHandler*                               NETHandler;                                               // 0x06BC(0x0008)
	class UBLLocalPlayerAgent*                         Agent;                                                    // 0x06C4(0x0008)
	unsigned long                                      bPlayerStartOverride : 1;                                 // 0x06CC(0x0004)
	unsigned long                                      bIsPersistentChanged : 1;                                 // 0x06CC(0x0004)
	unsigned long                                      bIsTeleport : 1;                                          // 0x06CC(0x0004)
	unsigned long                                      bReloadUIData : 1;                                        // 0x06CC(0x0004)
	unsigned long                                      bTutorialMode : 1;                                        // 0x06CC(0x0004)
	unsigned long                                      bRestrictTradeMode : 1;                                   // 0x06CC(0x0004)
	unsigned long                                      bPlayedTutorialCinema : 1;                                // 0x06CC(0x0004)
	unsigned long                                      ReloadActionBarSkillCidList : 1;                          // 0x06CC(0x0004)
	unsigned long                                      bAlertMode : 1;                                           // 0x06CC(0x0004)
	unsigned long                                      bIsOutBounds : 1;                                         // 0x06CC(0x0004)
	class UBLMsgKernel*                                MsgKernel;                                                // 0x06D0(0x0008)
	struct FCAWorldServerInfo                          CurrentServerInfo;                                        // 0x06D8(0x0054) (Native)
	TArray<struct FCharacterInfo>                      CharactersOfPlayer;                                       // 0x072C(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<int>                                        SkillCidList;                                             // 0x073C(0x0010) (NeedCtorLink)
	TArray<int>                                        ItemSkillCidList;                                         // 0x074C(0x0010) (NeedCtorLink)
	TArray<int>                                        ActionBarSkillCidList;                                    // 0x075C(0x0010) (NeedCtorLink)
	class UPlayerRepInfo*                              PlayerRepInfo;                                            // 0x076C(0x0008) (ExportObject, Component, EditInline)
	int                                                LoginCount;                                               // 0x0774(0x0004)
	class UBLPlayerInventory*                          Inventory;                                                // 0x0778(0x0008)
	class UBLWarehouse*                                Warehouse;                                                // 0x0780(0x0008)
	class UBLChannel*                                  Channel;                                                  // 0x0788(0x0008) (ExportObject, NeedCtorLink, EditInline)
	struct FQWord                                      Gold;                                                     // 0x0790(0x0008)
	class UBLPartyRaidManager*                         PartyRaidManager;                                         // 0x0798(0x0008)
	class UBLPartyMatchingManager*                     PartyMatchingManager;                                     // 0x07A0(0x0008)
	class UBLPartyEffectManager*                       PartyEffectManager;                                       // 0x07A8(0x0008)
	class UBLGroundManager*                            GroundManager;                                            // 0x07B0(0x0008)
	class UBLAutoPathManager*                          AutoPathManager;                                          // 0x07B8(0x0008)
	int                                                InteractingMerchantSid;                                   // 0x07C0(0x0004)
	class UAlertManager*                               AlertManager;                                             // 0x07C4(0x0008) (ExportObject, NeedCtorLink, EditInline)
	class UQuestManager*                               QuestManager;                                             // 0x07CC(0x0008) (ExportObject, NeedCtorLink, EditInline)
	class UWorldMapManager*                            WorldMapManager;                                          // 0x07D4(0x0008)
	class UActionMappingManager*                       ActionMappingManager;                                     // 0x07DC(0x0008)
	class UOrderManager*                               OrderManager;                                             // 0x07E4(0x0008) (ExportObject, NeedCtorLink, EditInline)
	class UTutorialOrderManager*                       TutorialOrderMgr;                                         // 0x07EC(0x0008) (ExportObject, NeedCtorLink, EditInline)
	class UBLSkillDataManager*                         SkillDataManager;                                         // 0x07F4(0x0008)
	class UBLSkillDeckManager*                         SkillDeckManager;                                         // 0x07FC(0x0008)
	class UBLSkillTacticsDeckManager*                  SkillTacticsDeckManager;                                  // 0x0804(0x0008)
	class UBLSkillQTEHUDManager*                       SkillQTEHUDManager;                                       // 0x080C(0x0008)
	class UBLSkillGemManager*                          SkillGemManager;                                          // 0x0814(0x0008)
	class UAnimaManager*                               AnimaManager;                                             // 0x081C(0x0008)
	class UBLTamingManager*                            TamingManager;                                            // 0x0824(0x0008)
	class UBLConquestManager*                          ConquestManager;                                          // 0x082C(0x0008)
	class UCitadelOwnershipAuction*                    COAuction;                                                // 0x0834(0x0008)
	class URealmOwnershipBattle*                       ROBattle;                                                 // 0x083C(0x0008)
	class UBLPlayerPostProcessController*              PPPController;                                            // 0x0844(0x0008) (ExportObject, Component, EditInline)
	class UDeathController*                            DeathController;                                          // 0x084C(0x0008) (ExportObject, Transient, NeedCtorLink, EditInline)
	class UBLToolTipDataGenerator*                     TooltipDataGenerator;                                     // 0x0854(0x0008)
	class UTranslationContext*                         ConditionalTagContext;                                    // 0x085C(0x0008)
	TArray<class USwfMovie*>                           DebugMovieInfos;                                          // 0x0864(0x0010) (NeedCtorLink)
	TArray<struct FSkillModifiedCostInfo>              SkillModifiedCostInfoListForFiring;                       // 0x0874(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<struct FSkillModifiedCostInfo>              SkillModifiedCostInfoListForLaunch;                       // 0x0884(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<struct FSkillModifiedInvokableCombatFlairInfo> SkillModifiedInvokableCombatFlairInfoList;                // 0x0894(0x0010) (NeedCtorLink)
	float                                              CacheSkillAssetCheckInterval;                             // 0x08A4(0x0004) (Const)
	float                                              CacheSkillAssetCheckTimer;                                // 0x08A8(0x0004)
	TArray<struct FItemData>                           PrivateTradeMyItemDataList;                               // 0x08AC(0x0010) (NeedCtorLink)
	TArray<struct FItemData>                           PrivateTradeOtherItemDataList;                            // 0x08BC(0x0010) (NeedCtorLink)
	TArray<struct FRestrictRealmInfo>                  restrictRealmList;                                        // 0x08CC(0x0010) (NeedCtorLink)
	class UBLGuild*                                    Guild;                                                    // 0x08DC(0x0008)
	class UBLContentsToken*                            ContentsToken;                                            // 0x08E4(0x0008)
	class URPProductManager*                           RP_ProductManager;                                        // 0x08EC(0x0008)
	class UBLPlayerEnvironment*                        PlayerEnvSetting;                                         // 0x08F4(0x0008)
	class UCraftManager*                               Craft;                                                    // 0x08FC(0x0008)
	class UV2CraftManager*                             V2CraftManager;                                           // 0x0904(0x0008)
	class UCraftGatherDataManager*                     CraftGatherDataManager;                                   // 0x090C(0x0008)
	class UCraftChoiceManager*                         CraftChoiceManager;                                       // 0x0914(0x0008)
	class UCompanionManager*                           CompanionManager;                                         // 0x091C(0x0008)
	class UEquipmentCustom*                            EquipCustom;                                              // 0x0924(0x0008)
	class UCollectionBook*                             CollectionBook;                                           // 0x092C(0x0008)
	class UBLMissionManager*                           MissionManager;                                           // 0x0934(0x0008)
	int                                                ActingPoint;                                              // 0x093C(0x0004) (Const)
	int                                                ActingPointMax;                                           // 0x0940(0x0004) (Const)
	int                                                ActingPointRegenTime;                                     // 0x0944(0x0004) (Const)
	int                                                ActingPointChargeCount;                                   // 0x0948(0x0004) (Const)
	int                                                ActingPointChargeCountMax;                                // 0x094C(0x0004) (Const)
	int                                                FixedChargeLevel;                                         // 0x0950(0x0004)
	struct FQWord                                      FixedChargeExpireTime;                                    // 0x0954(0x0008)
	int                                                FixedChargeUpdatedMinutes;                                // 0x095C(0x0004)
	class UGatherCraftLevelManager*                    GatherCraftLevelManager;                                  // 0x0960(0x0008)
	class ULumenaShop*                                 LumenaShop;                                               // 0x0968(0x0008)
	class UFlashShop*                                  FlashShop;                                                // 0x0970(0x0008)
	class UBLTeleportManager*                          TeleportManager;                                          // 0x0978(0x0008)
	class UFieldRaidManager*                           FieldRaidManager;                                         // 0x0980(0x0008)
	class UWebSessionManager*                          WebSessionManager;                                        // 0x0988(0x0008)
	class UBLFriend*                                   Friend;                                                   // 0x0990(0x0008)
	class UBLBlockPlayer*                              BlockPlayer;                                              // 0x0998(0x0008)
	class UBLAweWebViewComponent*                      WebViewComponent;                                         // 0x09A0(0x0008)
	class UV2RuneManager*                              V2RuneManager;                                            // 0x09A8(0x0008)
	class UBLTargetSign*                               TargetSign;                                               // 0x09B0(0x0008)
	TArray<struct FPendingMessageInfo>                 PendingMessageInfoList;                                   // 0x09B8(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TEnumAsByte<EBeginnerKeyGuideType>                 BeginnerKeyGuideType;                                     // 0x09C8(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x3];                                       // 0x09C9(0x0003) MISSED OFFSET
	float                                              FallingLimitTime;                                         // 0x09CC(0x0004)
	float                                              FallingStartTime;                                         // 0x09D0(0x0004)
	int                                                CharacterSlotExpansionCount;                              // 0x09D4(0x0004)
	class ABLPlayerPreview*                            PlayerPreview;                                            // 0x09D8(0x0008)
	class UBLTimerComponent*                           Timer;                                                    // 0x09E0(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BlessLocalPlayer");
		return ptr;
	}


	class UTexture* GetRenderTargetTextureForGFx(const struct FString& RequestName);
	void RotateLumenaShopPreveiw(const struct FRotator& InRotator);
	void RotateEquipPreveiw(const struct FRotator& InRotator);
	void ClearPlayerPreview();
	void SetPlayerPreview(class ABLPlayerPreview* InPlayerPreview);
	void OnCreatePlayerPreview();
	void CreatePlayerPreview();
	void SetInterFaceEnvShowMonsterBookHeadIcon(bool InValue);
	void SetFallingLimitTime(float InSeconds);
	void ExitAbnormalFallingFinal();
	void ExitAbnormalFalling(bool InIsAccepted);
	void ToggleWorldMapMode(TEnumAsByte<EWorldMapMode> Mode);
	void OnAbnormalFallingFinal();
	void CheckAbnormalFalling();
	void SetFallingStart();
	void InitAbnormalFallingParam();
	void SetValueOfDontShowingBeginnerBasicKeyGuide(bool InValue);
	bool GetValueOfDontShowingBeginnerBasicKeyGuide();
	void CheckBeginnerBasicKeyGuideWhenLevelup(int InPastLevel, int inCurrentLevel);
	void RemoveBeginnerBasicKeyGuide(bool InApplyToUserSetting);
	void ShowBeginnerBasicKeyGuide();
	void SetBeginnersGuideData(TEnumAsByte<EBeginnerKeyGuideType> InBeginnerKeyGuideType);
	bool FindPrivateTradeItem(int InSid, struct FItemData* OutItemData);
	void ClearPrivateTradeItemDataList();
	void SetPrivateTradeOtherItemDataList(TArray<struct FItemData> InItemDataList);
	void SetPrivateTradeMyItemDataList(TArray<struct FItemData> InItemDataList);
	class UBLMerchantInventory* GetMerchantInventory();
	void InitJournal();
	int GetActingPoint();
	struct FGuildMemberData GetMyGuildMemberData();
	bool IsPlayerSPMaxLevel();
	bool IsPlayerMaxLevel();
	int GetPlayerSPLevel();
	int GetPlayerLevel();
	TEnumAsByte<ECEClassType> GetPlayerClass();
	TEnumAsByte<ECEGenderType> GetPlayerGender();
	TEnumAsByte<ECERaceType> GetPlayerRace();
	TEnumAsByte<ECERealmType> GetPlayerRealm();
	TEnumAsByte<ERestrictRealmReasonType> GetRestrictRealmReason(TEnumAsByte<ECERealmType> rType);
	void AddRestrictRealm(const struct FRestrictRealmInfo& InRestrcitRealm);
	void ClearRestrictRealms();
	TEnumAsByte<ECERealmType> GetCharRealmTypeByIndex(int i_char);
	TEnumAsByte<ECERaceType> GetCharRaceTypeByIndex(int i_char);
	void ShowMonsterBookWorldMap(int MonsterBookID);
	void ShowQuestWorldMap(int questId);
	void GetFieldRaidMapInfoList(TArray<struct FFieldRaidMapInfo>* OutMapInfoList);
	bool GetDeadBodyIconInfo(struct FPlayerDeadBodyMapIconInfo* Info);
	void GetDeathPointInfo(TArray<struct FDeathPointInfo>* InfoArray);
	void GetUnderAttackInfo(TArray<struct FUnderAttackInfo>* InfoArray);
	void GetPropMapIconInfo(TArray<struct FPropMapIconInfo>* InfoArray);
	void GetNpcMapIconInfo(TArray<struct FNpcMapIconInfo>* InfoArray);
	void GetRaidMapIconInfo(TArray<struct FPartyMapIconInfo>* InfoArray);
	void GetPartyMapIconInfo(TArray<struct FPartyMapIconInfo>* InfoArray);
	void InitializePartyData();
	void CompleteLevelLoading();
	void ReloadUI();
	void OnUpdateQuestItemData(int ItemCid);
	void OnRemoveEquipedItem(TEnumAsByte<ECEEquipSlotType> InEquipSlotType);
	void OnRemoveItem(const struct FInventoryItemData& Item);
	void OnAcquireItem(const struct FInventoryItemData& Item);
	void OnUpdateItems(TArray<struct FInventoryItemData> Items, int UpdateFlag);
	int GetExistentCharacterCount();
	void UpdateCharactersOfPlayer(TArray<struct FSelectPCData>* InSelectPCDataList);
	void SendMessage(int InMsg, class UBLMsgProcArgBase* InArg);
	void UnResisterMsgProc(int InInstigatorId);
	void ResigsterMsgProc(TArray<class UBLMSGProcInterface*> InMsgProcs, int InInstigatorId);
	class UBLSkillQTEHUDManager* GetSkillQTEHUDManager();
	class UBLSkillGemManager* GetSkillGemManager();
	class UBLSkillDeckManager* GetSkillDeckManager();
	class UBLSkillDataManager* GetSkillDataManager();
	class UTranslationContext* GetConditionalTagContext();
	class UQuestNPCManager* GetQuestNPCManager();
	class UQuestJournalManager* GetQuestJournalManager();
	class UBLTargetSelectComponent* GetTargetSelectComponent();
	class UQuestManager* GetQuestManager();
	class UBLMissionManager* GetMissionManager();
	class UBLConquestManager* GetConquestManager();
	class UAnimaManager* GetAnimaManager();
	class UTutorialOrderManager* GetTutorialOrderManager();
	class UOrderManager* GetOrderManager();
	void TickFixedChargeInfo(float InDeltaTime);
	void SetFixedChargeInfo(int InLevel, const struct FQWord& InExpireTime);
	void UpdateDungeonTimer(float InRemainTime, float InDuration);
	void PlayDungeonTimerEndSound();
	void PlayDungeonTimerAlertSound();
	void EndDungeonTimer(bool bPlayEndSound);
	void StartDungeonTimer(int InRemainTime, bool InIsAlertMode);
	void OnLeaveDungeon();
	void QuestLevelLoaded(int questId);
	TEnumAsByte<ECEParamType> GetLPClassConceptStat();
	bool IsRestrictTradeMode();
	void SetRestrictTradeMode(bool bRestrictMode);
	bool IsPlayedTutorialCinema();
	bool IsTutorialMode();
	void SetPlayedTutorialCinema(bool PlayCinema);
	void SetTutorialMode(bool TutorialMode);
	void UpdateAllCoin();
	int IsCompareGold(const struct FQWord& InGold);
	void NotifyTerritoryVolumeTouchWithCodeName(const struct FString& volumeCodeName, bool isTouch);
	void NotifyTerritoryVolumeTouch(int volumeCid, bool isTouch, bool isLocation);
	class UBLConquest* GetWar(TEnumAsByte<ECEBattleFieldWarType> InWarType);
	struct FQWord GetGold();
	void SetGold(const struct FQWord& InGold);
	void SetEnableFog(bool bEnableFog);
	class UAlertManager* GetAlertManager();
	bool UpdateActionBarSkillCidList();
	bool LoadCacheSkillAsset(int InSkillCid);
	void CheckCacheSkillAsset(float InDeltaSeconds, bool bForce);
	bool AddItemSkill(int InSkillCid);
	bool RemoveSkill(int InSkillCid);
	bool AddSkill(int InSkillCid, bool IsShowMsg);
	bool LoadLobbyResources();
	bool LoadAutoPathQuadtree(const struct FString& InFilePath);
	int GetWorldType();
	void SetWorldType(int InWorldType);
	void PreProcOnLeaveWorld(int InWorldType);
	bool LoadWorld(int InWorldType, int InWorldMapCid);
	class UBLNetHandlerBase* GetNetHandler();
	void RemoveAnimaAsset();
	void SetAnimaFellowAsset(int Cid);
	void SetAnimaPetAsset(int Cid);
	void SetAnimaMountAsset(int Cid);
	void ClearPortraitAsset();
	void SetLumenaShopFellowCostumePreviewAsset(int Cid);
	void SetLumenaShopPetCostumePreviewAsset(int Cid);
	void SetLumenaShopMountCostumePreviewAsset(int Cid);
	void SetLumenaShopPlayerCostumePreviewAsset(class ABLPlayerPreview* InPlayerPreview);
	void SetPlayerEquipPreviewAsset(class ABLPlayerPreview* InPlayerPreview);
	void SetCollectionBookFellowAsset(int Cid);
	void SetCollectionBookMountAsset(int Cid);
	void SetCollectionBookPetAsset(int Cid);
	void SetMonsterBookAsset(int Cid);
	void RegisterWebChangeFocusCallback();
	void SendPendingMessageToComponent();
	void OnAweWebChangeFocus(int FocusState);
	class UBLAweWebViewComponent* GetWebViewComponent();
};


// Class BLGame.BLContentsToken
// 0x0048 (0x00A8 - 0x0060)
class UBLContentsToken : public UObject
{
public:
	struct FMap_Mirror                                 Tokens;                                                   // 0x0060(0x0048) (Native, Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLContentsToken");
		return ptr;
	}


	void OnUpdatedProcess(TEnumAsByte<ECEContentTokenType> TokenType, const struct FQWord& FinalValue, const struct FQWord& DeltaValue, bool IsIncrease, TEnumAsByte<EContentTokenUpdateType> UpdateReasonType);
	struct FString GetToString(TEnumAsByte<ECEContentTokenType> TokenType);
	void UpdateToUI(TEnumAsByte<ECEContentTokenType> TokenType);
	void UpdateToUIAll();
	struct FQWord Get(TEnumAsByte<ECEContentTokenType> TokenType);
	bool Update(TEnumAsByte<ECEContentTokenType> TokenType, const struct FQWord& FinalValue, const struct FQWord& DeltaValue, bool IsIncrease, TEnumAsByte<EContentTokenUpdateType> UpdateReasonType);
	void InitContentsToken(TArray<struct FContentTokenData>* InContentTokenDataList);
};


// Class BLGame.BLDestinationPoint
// 0x0024 (0x0274 - 0x0250)
class ABLDestinationPoint : public AActor
{
public:
	unsigned long                                      bStickToTerrain : 1;                                      // 0x0250(0x0004) (Edit)
	TEnumAsByte<ECEWorldMapType>                       WorldMapType;                                             // 0x0254(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0255(0x0003) MISSED OFFSET
	int                                                WorldMapCId;                                              // 0x0258(0x0004) (Edit)
	struct FString                                     DestinationPointName;                                     // 0x025C(0x0010) (Edit, NeedCtorLink)
	class UBLDestinationPointRenderingComponent*       RenderingComp;                                            // 0x026C(0x0008) (ExportObject, Transient, Component, EditInline)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLDestinationPoint");
		return ptr;
	}

};


// Class BLGame.BLDestinationPointRenderingComponent
// 0x0008 (0x0240 - 0x0238)
class UBLDestinationPointRenderingComponent : public UPrimitiveComponent
{
public:
	struct FName                                       SpriteCategoryName;                                       // 0x0238(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLDestinationPointRenderingComponent");
		return ptr;
	}

};


// Class BLGame.BLEmergencyEscapePoint
// 0x001C (0x026C - 0x0250)
class ABLEmergencyEscapePoint : public AActor
{
public:
	unsigned long                                      bStickToTerrain : 1;                                      // 0x0250(0x0004) (Edit)
	struct FString                                     EmergencyEscapePointName;                                 // 0x0254(0x0010) (Edit, NeedCtorLink)
	class UBLEmergencyEscapePointRenderingComponent*   RenderingComp;                                            // 0x0264(0x0008) (ExportObject, Transient, Component, EditInline)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLEmergencyEscapePoint");
		return ptr;
	}

};


// Class BLGame.BLEmergencyEscapePointRenderingComponent
// 0x0008 (0x0240 - 0x0238)
class UBLEmergencyEscapePointRenderingComponent : public UPrimitiveComponent
{
public:
	struct FName                                       SpriteCategoryName;                                       // 0x0238(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLEmergencyEscapePointRenderingComponent");
		return ptr;
	}

};


// Class BLGame.BLEmitterPool
// 0x0010 (0x02E0 - 0x02D0)
class ABLEmitterPool : public AUDKEmitterPool
{
public:
	TArray<struct FBLEmitterRequestInfo>               RequestList;                                              // 0x02D0(0x0010) (Transient, Component, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLEmitterPool");
		return ptr;
	}


	void DisplayDebug(class AHUD* HUD, float* out_YL, float* out_YPos);
	void HideVFXAttachedPawn(bool bHide, class ABLPawn* InBLPawn);
	int GetDeactivatedAlivePSC(struct FString* Err);
	void OnParticleSystemFinished(class UParticleSystemComponent* PSC);
	class UParticleSystemComponent* SpawnEmitterVertSurfActorBroadway(class UParticleSystem* InEmitterTemplate, class AActor* InTargetActor, class UBLBroadwayPlayer* a_Broadway, int a_InstID);
	class UParticleSystemComponent* SpawnEmitterMeshAttachment_AbsoluteRotation(class UParticleSystem* EmitterTemplate, class USkeletalMeshComponent* Mesh, const struct FName& AttachPointName, bool bAttachToSocket, const struct FVector& RelativeLoc);
	class UParticleSystemComponent* SpawnEmitterVertSurfActor(class UParticleSystem* InEmitterTemplate, class AActor* InTargetActor);
	class UParticleSystemComponent* SpawnEmitterMeshAttachmentBroadway(class UParticleSystem* EmitterTemplate, class USkeletalMeshComponent* Mesh, const struct FName& AttachPointName, bool bAttachToSocket, const struct FVector& RelativeLoc, const struct FRotator& RelativeRot, class UBLBroadwayPlayer* a_Broadway, int a_InstID);
	class UParticleSystemComponent* SpawnEmitterBroadway(class UParticleSystem* EmitterTemplate, const struct FVector& SpawnLocation, const struct FRotator& SpawnRotation, class AActor* AttachToActor, bool bInheritScaleFromBase, class UBLBroadwayPlayer* a_Broadway, int a_InstID);
	bool IsActivePSC(class UParticleSystemComponent* a_PSC);
	class UUDKExplosionLight* SpawnExplosionLightCopy(class UUDKExplosionLight* InLight, const struct FVector& SpawnLocation, class AActor* AttachToActor);
	class UUDKExplosionLight* SpawnExplosionLightType(TEnumAsByte<EBAR_ImpactLight> a_Type, const struct FVector& SpawnLocation, class AActor* AttachToActor);
	class UUDKExplosionLight* GetExplosionLightFromType(TEnumAsByte<EBAR_ImpactLight> a_Type);
};


// Class BLGame.BLGameInfo
// 0x002C (0x04C8 - 0x049C)
class ABLGameInfo : public AGameInfo
{
public:
	class UClass*                                      DefaultNPCPawnClass;                                      // 0x049C(0x0008)
	unsigned long                                      bBLEnvVolumeInteractPlayerController : 1;                 // 0x04A4(0x0004) (Config)
	unsigned long                                      bOpeningPlayed : 1;                                       // 0x04A4(0x0004) (Transient)
	unsigned long                                      bPlayInEditorWithDefaultID : 1;                           // 0x04A4(0x0004)
	unsigned long                                      bWillAdjustWarpLocation : 1;                              // 0x04A4(0x0004)
	TEnumAsByte<ECERaceType>                           DefaultRaceTypeInPIE;                                     // 0x04A8(0x0001) (Transient)
	TEnumAsByte<ECEGenderType>                         DefaultGenderTypeInPIE;                                   // 0x04A9(0x0001) (Transient)
	TEnumAsByte<ECEClassType>                          DefaultClassTypeInPIE;                                    // 0x04AA(0x0001) (Transient)
	TEnumAsByte<ECERaceType>                           DefaultRaceType;                                          // 0x04AB(0x0001) (Config)
	TEnumAsByte<ECEGenderType>                         DefaultGenderType;                                        // 0x04AC(0x0001) (Config)
	TEnumAsByte<ECEClassType>                          DefaultClassType;                                         // 0x04AD(0x0001) (Config)
	unsigned char                                      UnknownData00[0x2];                                       // 0x04AE(0x0002) MISSED OFFSET
	class UPawnAsset*                                  DefaultPawnInfoInPIE;                                     // 0x04B0(0x0008) (Transient)
	struct FScriptDelegate                             __NPCSpawned__Delegate;                                   // 0x04B8(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData01[0x4];                                       // 0x04B8(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLGameInfo");
		return ptr;
	}


	void StandaloneMapTravel();
	class ABLNpc* SimpleSpawnNpc(int Cid, const struct FVector& SpawnLocation, const struct FRotator& SpawnRotation, int Sid);
	void NPCSpawned(class ABLNpc* pNPC, int UserData);
	class APawn* SpawnDefaultPawnByLocation(class AController* NewPlayer, const struct FVector& SpawnLocation, const struct FRotator& SpawnRotation);
	void RestartPlayer(class AController* NewPlayer);
	class APlayerController* Login(const struct FString& Portal, const struct FString& Options, const struct FUniqueNetId& UniqueId, struct FString* ErrorMessage);
	void PostLogin(class APlayerController* NewPlayer);
	class ABLDummyServer* GetDummyServer();
	void PostSetupPlaySkillMode(class APawn* a_Pawn);
	void SetNullToDummyServer();
	bool PreSetupPlaySkillMode();
	bool STATIC_IsPlaySkillMode();
	void STATIC_DoLogging(bool IsWarn, const struct FName& Category, const struct FString& LogMessage);
	void ListLog();
	void ToggleLog(const struct FName& Category);
	bool LogSuppressed(const struct FName& Category);
	struct FString STATIC_MakeStringLower(const struct FString& Str);
	void InitGame(const struct FString& Options, struct FString* ErrorMessage);
	class UPawnDLEManager* STATIC_GetPawnDLEManager();
	class USkillRadialBlurManager* STATIC_GetSkillRadialBlurManager();
	class UBLAudioManager* STATIC_GetBLAudioManager();
	void SetPlayerDefaults(class APawn* PlayerPawn);
	void SetBLEnvVolumeInteractPlayerController(bool bInteract);
	bool IsBLEnvVolumeInteractPlayerController();
	class UBLGameRes* STATIC_GetDefaultGameResource();
	class UBLGameRes* GetDefaultGameResourceInner();
	bool STATIC_FindPackageFile(const struct FString& InName, const struct FString& Language, struct FString* OutFullPath);
	float STATIC_GetMaximumFallingEscapeDistance();
	float STATIC_GetLocationSaveTime();
	int STATIC_GetMaxLocationNum();
	float STATIC_GetCantFindMinDistance();
	float STATIC_GetEscEscape_time();
	float STATIC_GetCantEscape_Time();
	bool STATIC_IsRestrictPersonalTrade();
	class ABLPlayer* STATIC_GetLocalPlayerPawn();
	class ABLPawn* STATIC_GetLocalPawn();
	class ABlessPC* STATIC_GetBlessPC();
	class UBlessLocalPlayer* STATIC_GetLP();
};


// Class BLGame.BlessGame
// 0x0000 (0x04C8 - 0x04C8)
class ABlessGame : public ABLGameInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BlessGame");
		return ptr;
	}


	bool AllowCheats(class APlayerController* P);
	bool IsForceAllowCheat();
	void PostBeginPlay();
	class UClass* STATIC_SetGameType(const struct FString& MapName, const struct FString& Options, const struct FString& Portal);
};


// Class BLGame.BLGameRes
// 0x0898 (0x08F8 - 0x0060)
class UBLGameRes : public UObject
{
public:
	class UParticleSystem*                             LevelUpEffect;                                            // 0x0060(0x0008) (Edit)
	class UParticleSystem*                             CraftLevelUpEffect;                                       // 0x0068(0x0008) (Edit)
	class UParticleSystem*                             GatherLevelUpEffect;                                      // 0x0070(0x0008) (Edit)
	class UParticleSystem*                             MoveTargetMark;                                           // 0x0078(0x0008) (Edit)
	class UMaterial*                                   BLDecalTargetFloor;                                       // 0x0080(0x0008) (Edit)
	class UMaterial*                                   BLDecalSemiAutoTargetFloor;                               // 0x0088(0x0008) (Edit)
	class UPropGlobalAsset*                            PropGlobalAsset;                                          // 0x0090(0x0008) (Edit)
	class UBroadwayInfo*                               DeadBodyBroadway;                                         // 0x0098(0x0008) (Edit)
	class UBroadwayInfo*                               DeathBroadway;                                            // 0x00A0(0x0008) (Edit)
	class UBroadwayInfo*                               ReviveStandaloneBroadway;                                 // 0x00A8(0x0008) (Edit)
	class UBroadwayInfo*                               ReviveByOtherAtCasterBroadway;                            // 0x00B0(0x0008) (Edit)
	class UBroadwayInfo*                               ReviveByOtherAtDeadbodyBroadway;                          // 0x00B8(0x0008) (Edit)
	class UBroadwayInfo*                               PartySummonBroadway;                                      // 0x00C0(0x0008) (Edit)
	class UBroadwayInfo*                               PCSmith1;                                                 // 0x00C8(0x0008) (Edit)
	class UBroadwayInfo*                               PCSmith2;                                                 // 0x00D0(0x0008) (Edit)
	class UBroadwayInfo*                               PCHandiwork1;                                             // 0x00D8(0x0008) (Edit)
	class UBroadwayInfo*                               PCHandiwork2;                                             // 0x00E0(0x0008) (Edit)
	class UBroadwayInfo*                               PCImbue1;                                                 // 0x00E8(0x0008) (Edit)
	class UBroadwayInfo*                               PCImbue2;                                                 // 0x00F0(0x0008) (Edit)
	class UBroadwayInfo*                               PCCook1;                                                  // 0x00F8(0x0008) (Edit)
	class UBroadwayInfo*                               PCCook2;                                                  // 0x0100(0x0008) (Edit)
	class UBroadwayInfo*                               PCAlchemy1;                                               // 0x0108(0x0008) (Edit)
	class UBroadwayInfo*                               PCAlchemy2;                                               // 0x0110(0x0008) (Edit)
	class UBroadwayInfo*                               PCTamingCasting;                                          // 0x0118(0x0008) (Edit)
	class UBroadwayInfo*                               PCTaming;                                                 // 0x0120(0x0008) (Edit)
	class UBroadwayInfo*                               PCTamingSafeZoneSuccess;                                  // 0x0128(0x0008) (Edit)
	class UBroadwayInfo*                               PCTamingGameSuccess;                                      // 0x0130(0x0008) (Edit)
	class UBroadwayInfo*                               PCTamingGameFail;                                         // 0x0138(0x0008) (Edit)
	class UParticleSystem*                             TamingGameSuccessUncommon;                                // 0x0140(0x0008) (Edit)
	class UParticleSystem*                             TamingGameSuccessRare;                                    // 0x0148(0x0008) (Edit)
	class UParticleSystem*                             TamingGameSuccessEpic;                                    // 0x0150(0x0008) (Edit)
	class UParticleSystem*                             TamingGameSuccessLegend;                                  // 0x0158(0x0008) (Edit)
	class UMaterialInstanceConstant*                   SpiritCharMIC;                                            // 0x0160(0x0008) (Edit)
	class UMaterialInterface*                          StealthCharMI;                                            // 0x0168(0x0008) (Edit)
	class UDeathEffectInfo*                            DeathEffect;                                              // 0x0170(0x0008) (Edit)
	class UMaterialInstanceTimeVarying*                ReturnCompleteEffect;                                     // 0x0178(0x0008) (Edit)
	class UMaterialInterface*                          BlobShadowDecalMI;                                        // 0x0180(0x0008) (Edit)
	class UAkEvent*                                    DeadAkEvent;                                              // 0x0188(0x0008) (Edit)
	class UAkEvent*                                    SpiritAkEvent;                                            // 0x0190(0x0008) (Edit)
	class UAkEvent*                                    RevivalAkEvent;                                           // 0x0198(0x0008) (Edit)
	class UAkEvent*                                    StopSkillAkEvent;                                         // 0x01A0(0x0008) (Edit)
	class UAkEvent*                                    MountAkEvent;                                             // 0x01A8(0x0008) (Edit)
	class UAkEvent*                                    UnmountAkEvent;                                           // 0x01B0(0x0008) (Edit)
	class UAkEvent*                                    LevelUpAkEvent;                                           // 0x01B8(0x0008) (Edit)
	class UAkEvent*                                    TeleportAkEvent;                                          // 0x01C0(0x0008) (Edit)
	class UAkEvent*                                    ConflictKeySetAkEvent;                                    // 0x01C8(0x0008) (Edit)
	class UMaterialInstanceTimeVarying*                Short_In;                                                 // 0x01D0(0x0008) (Edit)
	class UMaterialInstanceTimeVarying*                Short_Out;                                                // 0x01D8(0x0008) (Edit)
	class UMaterialInstanceTimeVarying*                Long_In;                                                  // 0x01E0(0x0008) (Edit)
	class UMaterialInstanceTimeVarying*                Long_Out;                                                 // 0x01E8(0x0008) (Edit)
	struct FVehicleMountResource                       VehicleMountResources[0x5];                               // 0x01F0(0x0008) (Edit)
	class UHitVFXSet*                                  HitVisualEffectSet;                                       // 0x0218(0x0008) (Edit)
	class UHitSFXSet*                                  HitSoundEffectSet;                                        // 0x0220(0x0008) (Edit)
	class UTexture2D*                                  MerchantTexture;                                          // 0x0228(0x0008) (Edit)
	class UTexture2D*                                  ReturnManagerTexture;                                     // 0x0230(0x0008) (Edit)
	class UTexture2D*                                  SkillTrainerTexture;                                      // 0x0238(0x0008) (Edit)
	class UTexture2D*                                  RevivalManagerTexture;                                    // 0x0240(0x0008) (Edit)
	class UTexture2D*                                  DungeonTexture;                                           // 0x0248(0x0008) (Edit)
	class UTexture2D*                                  UserTexture;                                              // 0x0250(0x0008) (Edit)
	class UTexture2D*                                  PartyTexture;                                             // 0x0258(0x0008) (Edit)
	class UTexture2D*                                  PartyOtherChannelTexture;                                 // 0x0260(0x0008) (Edit)
	class UTexture2D*                                  DeadBodyTexture;                                          // 0x0268(0x0008) (Edit)
	class UTexture2D*                                  UserfinderTexture;                                        // 0x0270(0x0008) (Edit)
	class UTexture2D*                                  EpisodeQuestAreaTexture;                                  // 0x0278(0x0008) (Edit)
	class UTexture2D*                                  StoryQuestAreaTexture;                                    // 0x0280(0x0008) (Edit)
	class UTexture2D*                                  RoyalQuestAreaTexture;                                    // 0x0288(0x0008) (Edit)
	class UTexture2D*                                  GuideQuestAreaTexture;                                    // 0x0290(0x0008) (Edit)
	class UTexture2D*                                  MailAreaTexture;                                          // 0x0298(0x0008) (Edit)
	class UTexture2D*                                  MonsterBookAreaTexture;                                   // 0x02A0(0x0008) (Edit)
	class UTexture2D*                                  StoryQuestIconTexture;                                    // 0x02A8(0x0008) (Edit)
	class UTexture2D*                                  StoryQuestIconTexture_DropZone;                           // 0x02B0(0x0008) (Edit)
	class UTexture2D*                                  EpisodeQuestCompleteTexture;                              // 0x02B8(0x0008) (Edit)
	class UTexture2D*                                  EpisodeQuestAcceptTexture;                                // 0x02C0(0x0008) (Edit)
	class UTexture2D*                                  EpisodeQuestProgressDefaultTexture;                       // 0x02C8(0x0008) (Edit)
	class UTexture2D*                                  EpisodeQuestProgressDefaultTexture_DropZone;              // 0x02D0(0x0008) (Edit)
	class UTexture2D*                                  RoyalQuestProgressDefaultTexture;                         // 0x02D8(0x0008) (Edit)
	class UTexture2D*                                  RoyalQuestProgressDefaultTexture_DropZone;                // 0x02E0(0x0008) (Edit)
	TArray<class UTexture2D*>                          EpisodeQuestProgressTextures;                             // 0x02E8(0x0010) (Edit, NeedCtorLink)
	TArray<class UTexture2D*>                          EpisodeQuestProgressTextures_DropZone;                    // 0x02F8(0x0010) (Edit, NeedCtorLink)
	TArray<class UTexture2D*>                          RoyalQuestProgressTextures;                               // 0x0308(0x0010) (Edit, NeedCtorLink)
	TArray<class UTexture2D*>                          RoyalQuestProgressTextures_DropZone;                      // 0x0318(0x0010) (Edit, NeedCtorLink)
	TArray<class UTexture2D*>                          GuideQuestProgressTextures;                               // 0x0328(0x0010) (Edit, NeedCtorLink)
	TArray<class UTexture2D*>                          GuideQuestProgressTextures_DropZone;                      // 0x0338(0x0010) (Edit, NeedCtorLink)
	class UTexture2D*                                  WaypointManagerStartTexture;                              // 0x0348(0x0008) (Edit)
	class UTexture2D*                                  WaypointManagerArriveTexture;                             // 0x0350(0x0008) (Edit)
	class UTexture2D*                                  WaypointManagerNotArriveTexture;                          // 0x0358(0x0008) (Edit)
	class UTexture2D*                                  WaypointManagerTexture;                                   // 0x0360(0x0008) (Edit)
	class UTexture2D*                                  WaypointManagerStartTextureAirship;                       // 0x0368(0x0008) (Edit)
	class UTexture2D*                                  WaypointManagerStartTextureBoat;                          // 0x0370(0x0008) (Edit)
	class UTexture2D*                                  WaypointStartAirshipTexture;                              // 0x0378(0x0008) (Edit)
	class UTexture2D*                                  WaypointArriveAirshipTexture;                             // 0x0380(0x0008) (Edit)
	class UTexture2D*                                  WaypointNotArriveAirshipTexture;                          // 0x0388(0x0008) (Edit)
	class UTexture2D*                                  WaypointStartBoatTexture;                                 // 0x0390(0x0008) (Edit)
	class UTexture2D*                                  WaypointArriveBoatTexture;                                // 0x0398(0x0008) (Edit)
	class UTexture2D*                                  WaypointNotArriveBoatTexture;                             // 0x03A0(0x0008) (Edit)
	class UTexture2D*                                  ConquestStoneNeutralTexture;                              // 0x03A8(0x0008) (Edit)
	class UTexture2D*                                  ConquestStoneHieronTexture;                               // 0x03B0(0x0008) (Edit)
	class UTexture2D*                                  ConquestStoneUnionTexture;                                // 0x03B8(0x0008) (Edit)
	class UTexture2D*                                  ConquestTreeTexture;                                      // 0x03C0(0x0008) (Edit)
	class UTexture2D*                                  ConquestTreeGhostTexture;                                 // 0x03C8(0x0008) (Edit)
	class UTexture2D*                                  ConquestGhostTexture;                                     // 0x03D0(0x0008) (Edit)
	class UTexture2D*                                  ConquestGateTexture;                                      // 0x03D8(0x0008) (Edit)
	class UTexture2D*                                  ConquestNPCHieronTexture;                                 // 0x03E0(0x0008) (Edit)
	class UTexture2D*                                  ConquestNPCUnionTexture;                                  // 0x03E8(0x0008) (Edit)
	class UTexture2D*                                  UnderAttackTexture;                                       // 0x03F0(0x0008) (Edit)
	class UTexture2D*                                  ROManagerTexture;                                         // 0x03F8(0x0008) (Edit)
	class UTexture2D*                                  PortalTexture;                                            // 0x0400(0x0008) (Edit)
	class UTexture2D*                                  GuildShopTexture;                                         // 0x0408(0x0008) (Edit)
	class UTexture2D*                                  NPCCraftTexture;                                          // 0x0410(0x0008) (Edit)
	class UTexture2D*                                  CustomWaypointTexture;                                    // 0x0418(0x0008) (Edit)
	class UTexture2D*                                  RaidFieldEntranceTexture;                                 // 0x0420(0x0008) (Edit)
	class UTexture2D*                                  WarehouseTexture;                                         // 0x0428(0x0008) (Edit)
	class UTexture2D*                                  LimitedRankManagerTexture;                                // 0x0430(0x0008) (Edit)
	class UTexture2D*                                  ROAttackerFirstBaseTexture;                               // 0x0438(0x0008) (Edit)
	class UTexture2D*                                  ROAttackerSecondBaseTexture;                              // 0x0440(0x0008) (Edit)
	class UTexture2D*                                  ROAttackerFinalBaseTexture;                               // 0x0448(0x0008) (Edit)
	class UTexture2D*                                  RODefenderFirstBaseTexture;                               // 0x0450(0x0008) (Edit)
	class UTexture2D*                                  RODefenderSecondBaseTexture;                              // 0x0458(0x0008) (Edit)
	class UTexture2D*                                  RODefenderFinalBaseTexture;                               // 0x0460(0x0008) (Edit)
	class UTexture2D*                                  ROAttackerWeaponTexture;                                  // 0x0468(0x0008) (Edit)
	class UTexture2D*                                  RODefenderWeaponTexture;                                  // 0x0470(0x0008) (Edit)
	class UTexture2D*                                  ROCastleDoorTexture;                                      // 0x0478(0x0008) (Edit)
	class UTexture2D*                                  RoyalQuestGiverTexture;                                   // 0x0480(0x0008) (Edit)
	class UTexture2D*                                  ExchangeManagerTexture;                                   // 0x0488(0x0008) (Edit)
	class UTexture2D*                                  RaidMemberTexture;                                        // 0x0490(0x0008) (Edit)
	class UTexture2D*                                  RaidMemberOtherChannelTexture;                            // 0x0498(0x0008) (Edit)
	class UTexture2D*                                  InstanceRevivalPointPersonalTexture;                      // 0x04A0(0x0008) (Edit)
	class UTexture2D*                                  InstanceRevivalPointPartyTexture;                         // 0x04A8(0x0008) (Edit)
	class UTexture2D*                                  InstanceRevivalPointRaidTexture;                          // 0x04B0(0x0008) (Edit)
	class UTexture2D*                                  ZoneNamePVP_HieronProtectTexture;                         // 0x04B8(0x0008) (Edit)
	class UTexture2D*                                  ZoneNamePVP_union_protectTexture;                         // 0x04C0(0x0008) (Edit)
	class UTexture2D*                                  ZoneNamePVP_PVPTexture;                                   // 0x04C8(0x0008) (Edit)
	class UTexture2D*                                  ZoneNamePVP_NonPVPTexture;                                // 0x04D0(0x0008) (Edit)
	class UTexture2D*                                  AutoPathTexture;                                          // 0x04D8(0x0008) (Edit)
	class UTexture2D*                                  CraftChoiceTexture;                                       // 0x04E0(0x0008) (Edit)
	class UTexture2D*                                  CraftTexture;                                             // 0x04E8(0x0008) (Edit)
	class UTexture2D*                                  CraftSmithTexture;                                        // 0x04F0(0x0008) (Edit)
	class UTexture2D*                                  CraftSmeltTexture;                                        // 0x04F8(0x0008) (Edit)
	class UTexture2D*                                  CraftHandiWorkTexture;                                    // 0x0500(0x0008) (Edit)
	class UTexture2D*                                  CraftCookTexture;                                         // 0x0508(0x0008) (Edit)
	class UTexture2D*                                  CraftAlchemyTexture;                                      // 0x0510(0x0008) (Edit)
	class UTexture2D*                                  ItemRepairTexture;                                        // 0x0518(0x0008) (Edit)
	class UTexture2D*                                  ItemUpgradeTexture;                                       // 0x0520(0x0008) (Edit)
	class UTexture2D*                                  ItemDesynthesisTexture;                                   // 0x0528(0x0008) (Edit)
	class UTexture2D*                                  OccupationWarHieronNormalBaseTexture;                     // 0x0530(0x0008) (Edit)
	class UTexture2D*                                  OccupationWarUnionNormalBaseTexture;                      // 0x0538(0x0008) (Edit)
	class UTexture2D*                                  OccupationWarNoneNormalBaseTexture;                       // 0x0540(0x0008) (Edit)
	class UTexture2D*                                  OccupationWarHeironHalfNormalBaseTexture;                 // 0x0548(0x0008) (Edit)
	class UTexture2D*                                  OccupationWarUnionHalfNormalBaseTexture;                  // 0x0550(0x0008) (Edit)
	class UTexture2D*                                  OccupationWarHieronSpecialBaseTexture;                    // 0x0558(0x0008) (Edit)
	class UTexture2D*                                  OccupationWarUnionSpecialBaseTexture;                     // 0x0560(0x0008) (Edit)
	class UTexture2D*                                  OccupationWarNoneSpecialBaseTexture;                      // 0x0568(0x0008) (Edit)
	class UTexture2D*                                  OccupationWarHieronHalfSpecialBaseTexture;                // 0x0570(0x0008) (Edit)
	class UTexture2D*                                  OccupationWarUnionHalfSpecialBaseTexture;                 // 0x0578(0x0008) (Edit)
	class UTexture2D*                                  OccupationWarItemRedTexture;                              // 0x0580(0x0008) (Edit)
	class UTexture2D*                                  OccupationWarItemGreenTexture;                            // 0x0588(0x0008) (Edit)
	class UTexture2D*                                  OccupationWarItemBlueTexture;                             // 0x0590(0x0008) (Edit)
	class UTexture2D*                                  ChallengeTowerEntranceTexture;                            // 0x0598(0x0008) (Edit)
	class UTexture2D*                                  ChallengeTowerHolyTexture;                                // 0x05A0(0x0008) (Edit)
	class UTexture2D*                                  ChallengeTowerHellGateTexture;                            // 0x05A8(0x0008) (Edit)
	class UMaterialInstanceTimeVarying*                LowHPMITV;                                                // 0x05B0(0x0008) (Edit)
	class UMaterialInstanceTimeVarying*                LowHPBlinkMITV;                                           // 0x05B8(0x0008) (Edit)
	class UAkEvent*                                    LowHPAkEvent;                                             // 0x05C0(0x0008) (Edit)
	class UAkEvent*                                    NormalHPAkEvent;                                          // 0x05C8(0x0008) (Edit)
	class UParticleSystem*                             StoryQuestObjectEfect;                                    // 0x05D0(0x0008) (Edit)
	class UParticleSystem*                             EpisodeQuestObjectEfect;                                  // 0x05D8(0x0008) (Edit)
	class UAkEvent*                                    EquipAkEvent;                                             // 0x05E0(0x0008) (Edit)
	class UAkEvent*                                    UnequipAkEvent;                                           // 0x05E8(0x0008) (Edit)
	class UBLInterpCurveData*                          AxisXCurve;                                               // 0x05F0(0x0008) (Edit)
	class UBLInterpCurveData*                          AxisYCurve;                                               // 0x05F8(0x0008) (Edit)
	class UBLInterpCurveData*                          AxisZCurve;                                               // 0x0600(0x0008) (Edit)
	class UParticleSystem*                             ChannelMoveParticle;                                      // 0x0608(0x0008) (Edit)
	class UParticleSystem*                             NPCAudibleRangeParticle;                                  // 0x0610(0x0008) (Edit)
	class UAkEvent*                                    EquipWeaponSound;                                         // 0x0618(0x0008) (Edit)
	class UAkEvent*                                    EquipRobeSound;                                           // 0x0620(0x0008) (Edit)
	class UAkEvent*                                    EquipLightSound;                                          // 0x0628(0x0008) (Edit)
	class UAkEvent*                                    EquipMediumSound;                                         // 0x0630(0x0008) (Edit)
	class UAkEvent*                                    EquipHeavySound;                                          // 0x0638(0x0008) (Edit)
	class UAkEvent*                                    EquipMassiveSound;                                        // 0x0640(0x0008) (Edit)
	class UAkEvent*                                    EquipAccessorySound;                                      // 0x0648(0x0008) (Edit)
	class UAkEvent*                                    UnEquipWeaponSound;                                       // 0x0650(0x0008) (Edit)
	class UAkEvent*                                    UnEquipRobeSound;                                         // 0x0658(0x0008) (Edit)
	class UAkEvent*                                    UnEquipLightSound;                                        // 0x0660(0x0008) (Edit)
	class UAkEvent*                                    UnEquipMediumSound;                                       // 0x0668(0x0008) (Edit)
	class UAkEvent*                                    UnEquipHeavySound;                                        // 0x0670(0x0008) (Edit)
	class UAkEvent*                                    UnEquipMassiveSound;                                      // 0x0678(0x0008) (Edit)
	class UAkEvent*                                    UnEquipAccessorySound;                                    // 0x0680(0x0008) (Edit)
	class UParticleSystem*                             TargetingVFX;                                             // 0x0688(0x0008) (Edit)
	class UParticleSystem*                             AutoTargetingVFX;                                         // 0x0690(0x0008) (Edit)
	class UParticleSystem*                             LockOnTargetingVFX;                                       // 0x0698(0x0008) (Edit)
	class UAkEvent*                                    TargetingSFX;                                             // 0x06A0(0x0008) (Edit)
	class UParticleSystem*                             DirectionVFX;                                             // 0x06A8(0x0008) (Edit)
	class UParticleSystem*                             DestinationVFX;                                           // 0x06B0(0x0008) (Edit)
	class UStaticMesh*                                 AutoPathMesh;                                             // 0x06B8(0x0008) (Edit)
	class UAnimTree*                                   PassengerAnimTreeTemplate;                                // 0x06C0(0x0008) (Edit)
	class USkeletalMesh*                               WyvernMesh;                                               // 0x06C8(0x0008) (Edit)
	TArray<class UAnimSet*>                            WyvernAnimSets;                                           // 0x06D0(0x0010) (Edit, NeedCtorLink)
	class UParticleSystem*                             WyvernWarpCloudParticle;                                  // 0x06E0(0x0008) (Edit)
	class USkeletalMesh*                               GondolaMesh;                                              // 0x06E8(0x0008) (Edit)
	TArray<class UAnimSet*>                            GondolaAnimSets;                                          // 0x06F0(0x0010) (Edit, NeedCtorLink)
	class USkeletalMesh*                               FlyingBoatMesh;                                           // 0x0700(0x0008) (Edit)
	TArray<class UAnimSet*>                            FlyingBoatAnimSets;                                       // 0x0708(0x0010) (Edit, NeedCtorLink)
	class UParticleSystem*                             FlyingBoatWarpCloudParticle;                              // 0x0718(0x0008) (Edit)
	class UAkEvent*                                    StopPropStateAkEvent;                                     // 0x0720(0x0008) (Edit)
	class UDungeonSoundAsset*                          DungeonSound;                                             // 0x0728(0x0008) (Edit)
	class UROSoundAsset*                               ROSound;                                                  // 0x0730(0x0008) (Edit)
	class UUISoundAsset*                               UISound;                                                  // 0x0738(0x0008) (Edit)
	class UInGameSoundAsset*                           InGameSound;                                              // 0x0740(0x0008) (Edit)
	class UMountResourceAsset*                         MountResource;                                            // 0x0748(0x0008) (Edit)
	class UPreloadingAsset*                            PreloadingProxyData;                                      // 0x0750(0x0008) (Edit)
	class UBoneDeformationTemplate*                    BoneDeformationTemplate;                                  // 0x0758(0x0008) (Edit, ExportObject, NeedCtorLink, EditInline)
	TArray<struct FWhispyHairData>                     WhispyHairDataList;                                       // 0x0760(0x0010) (Edit, NeedCtorLink)
	class UIconSheetAsset*                             InGameIconSheets;                                         // 0x0770(0x0008) (Edit)
	class UAkEvent*                                    DefaultReverbOn;                                          // 0x0778(0x0008) (Edit)
	class UAkEvent*                                    DefaultReverbOff;                                         // 0x0780(0x0008) (Edit)
	class UAkEvent*                                    AkEvent_LobbyOpenning;                                    // 0x0788(0x0008) (Edit)
	class UAkEvent*                                    AkEvent_LobbyMain;                                        // 0x0790(0x0008) (Edit)
	class UAkEvent*                                    AkEvent_LobbyMain_Stop;                                   // 0x0798(0x0008) (Edit)
	class UAkEvent*                                    AkEvent_LobbySelect;                                      // 0x07A0(0x0008) (Edit)
	class UParticleSystem*                             PS_WT_Rain;                                               // 0x07A8(0x0008) (Edit)
	class UParticleSystem*                             PS_WT_Snow;                                               // 0x07B0(0x0008) (Edit)
	class UParticleSystem*                             PS_WT_Dust;                                               // 0x07B8(0x0008) (Edit)
	class UUDKExplosionLight*                          ImpactLightFire;                                          // 0x07C0(0x0008) (Edit, ExportObject, Component, EditInline)
	class UUDKExplosionLight*                          ImpactLightIce;                                           // 0x07C8(0x0008) (Edit, ExportObject, Component, EditInline)
	class UUDKExplosionLight*                          ImpactLightSword;                                         // 0x07D0(0x0008) (Edit, ExportObject, Component, EditInline)
	class UMaterial*                                   FailedCompositionMaterial;                                // 0x07D8(0x0008) (Edit)
	class USkeletalMesh*                               FailedCompositionSkelMesh;                                // 0x07E0(0x0008) (Edit)
	class UTexture2D*                                  AltHudTexture;                                            // 0x07E8(0x0008) (Edit)
	TArray<struct FParentBufferMICInfo>                ParentBufferMICInfos;                                     // 0x07F0(0x0010) (Edit, NeedCtorLink)
	class UMaterialInterface*                          PointDecal;                                               // 0x0800(0x0008) (Edit)
	class UMaterialInterface*                          outerDecal;                                               // 0x0808(0x0008) (Edit)
	class UMaterialInterface*                          AroundDecal;                                              // 0x0810(0x0008) (Edit)
	class UParticleSystem*                             PointParticle;                                            // 0x0818(0x0008) (Edit)
	class UMaterialInstanceConstant*                   Huge_Circular;                                            // 0x0820(0x0008) (Edit)
	class UMaterialInstanceConstant*                   Huge_Rectangle;                                           // 0x0828(0x0008) (Edit)
	class UMaterialInstanceConstant*                   Large_Circular;                                           // 0x0830(0x0008) (Edit)
	class UMaterialInstanceConstant*                   Large_Rectangle;                                          // 0x0838(0x0008) (Edit)
	class UMaterialInstanceConstant*                   Medium_Circular;                                          // 0x0840(0x0008) (Edit)
	class UMaterialInstanceConstant*                   Medium_Rectangle;                                         // 0x0848(0x0008) (Edit)
	class UMaterialInstanceConstant*                   Small_Circular;                                           // 0x0850(0x0008) (Edit)
	class UMaterialInstanceConstant*                   Small_Rectangle;                                          // 0x0858(0x0008) (Edit)
	class UAkEvent*                                    MasterVolumeTestEvent;                                    // 0x0860(0x0008) (Edit)
	class UTexture2D*                                  PlayerPositioning;                                        // 0x0868(0x0008) (Edit)
	class UBLPhysicalMaterial*                         BLPhysicalMaterialDefault;                                // 0x0870(0x0008) (Edit)
	class UAkEvent*                                    FootStepAkEvent;                                          // 0x0878(0x0008) (Edit)
	class UParticleSystem*                             ConcentrationLines;                                       // 0x0880(0x0008) (Edit)
	class UMaterialInstanceConstant*                   AirFlowMIC;                                               // 0x0888(0x0008) (Edit)
	TArray<class UAnimSet*>                            BodyShakeAnimSet;                                         // 0x0890(0x0010) (Edit, NeedCtorLink)
	TArray<class UParticleSystem*>                     AbnormalStatusRestrictEventListParticle;                  // 0x08A0(0x0010) (Edit, NeedCtorLink)
	class UDecalMaterial*                              AreaDefaultInnerDecal;                                    // 0x08B0(0x0008) (Edit)
	class UDecalMaterial*                              AreaDefaultOuterDecal;                                    // 0x08B8(0x0008) (Edit)
	class UAkEvent*                                    WaterSurfaceSound;                                        // 0x08C0(0x0008) (Edit)
	class UAkEvent*                                    WaterUnderSound;                                          // 0x08C8(0x0008) (Edit)
	class UBroadwayInfo*                               DespawnDeadbodyBroadway;                                  // 0x08D0(0x0008) (Edit)
	class UAnimTree*                                   BodyAnimTreeTemplate;                                     // 0x08D8(0x0008) (Edit)
	class UAnimTree*                                   HeadAnimTreeTemplate;                                     // 0x08E0(0x0008) (Edit)
	class UParticleSystem*                             RecognitionParticle;                                      // 0x08E8(0x0008) (Edit)
	class UParticleSystem*                             GuideQuestAcceptEffect;                                   // 0x08F0(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLGameRes");
		return ptr;
	}

};


// Class BLGame.BLGameViewportClient
// 0x008C (0x022C - 0x01A0)
class UBLGameViewportClient : public UGameViewportClient
{
public:
	class UDynamicLightEnvironmentComponent*           PrevPickedDLE;                                            // 0x01A0(0x0008) (ExportObject, Transient, Component, EditInline)
	unsigned long                                      bCachedLastMousePos : 1;                                  // 0x01A8(0x0004)
	unsigned long                                      bIsActiveWindow : 1;                                      // 0x01A8(0x0004) (Native)
	unsigned long                                      bMaterialPickingMode : 1;                                 // 0x01A8(0x0004)
	int                                                CachedLastTurnOnMouseX;                                   // 0x01AC(0x0004)
	int                                                CachedLastTurnOnMouseY;                                   // 0x01B0(0x0004)
	int                                                LastMousePosX;                                            // 0x01B4(0x0004)
	int                                                LastMousePosY;                                            // 0x01B8(0x0004)
	int                                                CurrentMousePosX;                                         // 0x01BC(0x0004)
	int                                                CurrentMousePosY;                                         // 0x01C0(0x0004)
	float                                              PeakMouseSpeed;                                           // 0x01C4(0x0004)
	float                                              PeakElapsedTime;                                          // 0x01C8(0x0004)
	class AActor*                                      CachedPickedActor;                                        // 0x01CC(0x0008) (Transient)
	class AActor*                                      PreviousPickedActor;                                      // 0x01D4(0x0008) (Transient)
	float                                              MPLimitMouseVelocity;                                     // 0x01DC(0x0004)
	float                                              MPLimitTime;                                              // 0x01E0(0x0004)
	unsigned char                                      MPSemantic;                                               // 0x01E4(0x0001)
	unsigned char                                      MPSize;                                                   // 0x01E5(0x0001) (Config)
	unsigned char                                      UnknownData00[0x2];                                       // 0x01E6(0x0002) MISSED OFFSET
	float                                              MaxHeuristic;                                             // 0x01E8(0x0004)
	struct FMouseClientInfo                            BLMouseInfo;                                              // 0x01EC(0x0008)
	class UBLPortraitView*                             PortraitViewRenderer[0x5];                                // 0x01F4(0x0008) (Native)
	TArray<struct FPortraitViewRendererStruct>         PortraitViewRendererStructInfo;                           // 0x021C(0x0010) (Config, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLGameViewportClient");
		return ptr;
	}


	bool Init(struct FString* OutError);
	void ClearPickededActor();
	class ULocalPlayer* CreatePlayer(int ControllerId, bool bSpawnActor, struct FString* OutError);
	void MPSetSemantic(unsigned char semanticValue);
	void MPSetSize(unsigned char sz);
	void MPSetLimitTime(float lim);
	void MPSetLimitMouseVelocity(float lim);
	TEnumAsByte<ERenderTargetName> GetRenderTargetIndexByName(const struct FString& InCheckRenderTargetName);
	void TurnOffCursor(TEnumAsByte<ECursorPosCacheType> InCursorPosType);
	void TurnOnCursor();
	void RestoreLastTurnOnMousePos();
	void CacheLastTurnOnMousePos();
	void LoadMousePos();
	void SaveMousePos();
};


// Class BLGame.BLGuild
// 0x023C (0x029C - 0x0060)
class UBLGuild : public UObject
{
public:
	TEnumAsByte<EBLGuildUIType>                        OpenedUIType;                                             // 0x0060(0x0001)
	TEnumAsByte<ESortingOrder>                         GuildWarSeasonHistorySortingOrder;                        // 0x0061(0x0001) (Transient)
	TEnumAsByte<EBLGuildTabType>                       CurrentTab;                                               // 0x0062(0x0001) (Transient)
	TEnumAsByte<EDialogType>                           ShowingDialog;                                            // 0x0063(0x0001) (Transient)
	TEnumAsByte<EBLGuildMemberUIViewCategory>          GuildMemberUIViewCategory;                                // 0x0064(0x0001) (Transient)
	TEnumAsByte<ESortingOrder>                         GuildManagementHistorySortingOrder;                       // 0x0065(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x2];                                       // 0x0066(0x0002) MISSED OFFSET
	struct FGuildData                                  GuildInfo;                                                // 0x0068(0x006C) (Transient, NeedCtorLink)
	struct FGuildMemberData                            LocalPlayerMemberData;                                    // 0x00D4(0x0050) (Transient, NeedCtorLink)
	TArray<struct FGuildMemberData>                    Member;                                                   // 0x0124(0x0010) (Transient, NeedCtorLink)
	TArray<struct FGuildGradeData>                     Grade;                                                    // 0x0134(0x0010) (Transient, NeedCtorLink)
	class UBLGuildCreateDialog*                        CreateDialog;                                             // 0x0144(0x0008) (Transient)
	class UBLGuildCreateAgreementDialog*               CreateAgreementDialog;                                    // 0x014C(0x0008) (Transient)
	int                                                TalkNpcSid;                                               // 0x0154(0x0004) (Transient)
	struct FGuildWarData                               GuildWarData;                                             // 0x0158(0x002C) (Transient, NeedCtorLink)
	struct FGuildWarRecordData                         GuildWarRecordData;                                       // 0x0184(0x0024) (Transient)
	TArray<struct FGuildWarHistoryData>                GuildWarHistoryList;                                      // 0x01A8(0x0010) (Transient, NeedCtorLink)
	TArray<struct FBLGuildWarHistoryUIData>            GuildWarHistoryUIDataList;                                // 0x01B8(0x0010) (Transient, NeedCtorLink)
	struct FSortingInfo                                GuildWarHistorySortingInfo;                               // 0x01C8(0x0008) (Transient)
	struct FPageInfo                                   GuildWarHistoryPageInfo;                                  // 0x01D0(0x0008) (Transient)
	TArray<struct FBLGuildWarSeasonHistoryUIData>      GuildWarSeasonHistoryUIDataList;                          // 0x01D8(0x0010) (Transient, NeedCtorLink)
	struct FPageInfo                                   GuildWarSeasonHistoryPageInfo;                            // 0x01E8(0x0008) (Transient)
	struct FString                                     SelectedTargetMember;                                     // 0x01F0(0x0010) (Transient, NeedCtorLink)
	unsigned long                                      IsShowOfflineMember : 1;                                  // 0x0200(0x0004) (Transient)
	unsigned long                                      bWaitingUpdateGuildMarkAck : 1;                           // 0x0200(0x0004) (Transient)
	int                                                LastUpdatedMemberCount;                                   // 0x0204(0x0004) (Transient)
	struct FSortingInfo                                GuildMemberUIMemberViewSortingInfo;                       // 0x0208(0x0008) (Transient)
	int                                                SelectedAuthorityIndex;                                   // 0x0210(0x0004) (Transient)
	struct FSortingInfo                                GuildMemberInfluenceViewSortingInfo;                      // 0x0214(0x0008) (Transient)
	TArray<struct FGuildHistoryData>                   HistoryList;                                              // 0x021C(0x0010) (Transient, NeedCtorLink)
	TArray<struct FBLGuildHistoryUIData>               HistoryUIDataList;                                        // 0x022C(0x0010) (Transient, NeedCtorLink)
	struct FPageInfo                                   GuildManagementHistoryPageInfo;                           // 0x023C(0x0008) (Transient)
	struct FBLGuildMarkUISettingData                   GuildMarkUISettingData;                                   // 0x0244(0x000C) (Transient)
	struct FBLGuildMarkUISettingData                   GuildMarkUISettingBackupData;                             // 0x0250(0x000C) (Transient)
	TArray<int>                                        GuildMarkBackgroundDataList;                              // 0x025C(0x0010) (Transient, NeedCtorLink)
	TArray<int>                                        GuildMarkSymbolDataList;                                  // 0x026C(0x0010) (Transient, NeedCtorLink)
	struct FGuildMarkData                              ServerGuildMarkData;                                      // 0x027C(0x000C) (Transient)
	struct FBLGuildMarkData                            GuildMarkData;                                            // 0x0288(0x0014) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLGuild");
		return ptr;
	}


	void SC_UPDATE_GUILDMARK_ACK(TEnumAsByte<EGuildErrorCode> InErrorCode);
	void CS_UPDATE_GUILDMARK(struct FGuildMarkData* InData);
	struct FString MakeString_GuildMark_UnLockLevel(int InLevel);
	void AU_GuildMark_Regist_GuildMark();
	void AU_GuildMark_Click_SymbolColor(int InSelectedIndex);
	void AU_GuildMark_Click_Symbol(int InSelectedIndex);
	void AU_GuildMark_Click_BG(int InSelectedIndex);
	void AU_GuildMark_UI_Close();
	void AU_GuildMark_UI_Open();
	void UA_GuildMark_Update_RegistBtn_EnableState();
	void UA_GuildMark_Update_UILock();
	void UA_GuildMark_Update_Mark();
	void UA_GuildMark_Update_SymbolList();
	void UA_GuildMark_Update_BackgroundList();
	void UA_GuildInfo_Update_GuildMark();
	void GetBLGuildMarkData(struct FBLGuildMarkData* OutData);
	void UpdateBLGuildMarkData();
	void UpdateGuildMarkData(struct FGuildMarkData* InGuildMarkData);
	void InitGuildMarkData();
	bool IsEnableSurrenderWarUI();
	bool IsEnableDeclareWarUI();
	TEnumAsByte<EBLGuildWarResultType> GetBLGuildWarResultType(struct FGuildWarHistoryData* InGuildWarHistoryData);
	struct FString MakeString_GuildWar_GuildWarSeasonHistory_Result(int InWarCount, int InWinCount, int InDrawCount, int InLoseCount);
	struct FString MakeString_GuildWar_GuildWarSeasonHistory_Date(struct FDateYMD* InDate);
	struct FString MakeString_GuildWar_GuildWarSeasonHistory_TotalRecord(int InTotalWarCount, int InTotalWinCount, int InTotalDrawCount, int InTotalLoseCount, int InSeasonWarCount, int InSeasonWinCount, int InSeasonDrawCount, int InSeasonLoseCount);
	struct FString MakeString_GuildWar_GuildWarHistory_Result(TEnumAsByte<EBLGuildWarResultType> InresultType);
	struct FString MakeString_GuildWar_GuildWarHistory_Date(struct FDateYMD* InDate);
	struct FString MakeString_GuildWar_GuildWarHistory_TotalRecord(int InTotalWarCount, int InTotalWinCount, int InTotalDrawCount, int InTotalLoseCount, int InLastSeasonWarCount, int InLastSeasonWinCount, int InLastSeasonDrawCount, int InLastSeasonLoseCount, int InSeasonWarCount, int InSeasonWinCount, int InSeasonDrawCount, int InSeasonLoseCount);
	struct FString MakeString_GuildWar_DoingWarWar_OpponentGuildScore(const struct FString& InOpponentGuildName, int InScore);
	struct FString MakeString_GuildWar_DoingWar_MyGuildScore(const struct FString& InMyGuildName, int InScore);
	struct FString MakeString_GuildWar_DoingWar_GuildName(const struct FString& InMyGuildName, const struct FString& InOpponentGuildName);
	struct FString MakeString_GuildWar_StartWar_WarCount(int InWarRemainCount, int InWarTotalCount);
	struct FString MakeString_GuildWar_StartWar_DeclareCount(int InDeclareRemainCount, int InDeclareCount);
	void CS_SURRENDER_GUILDWAR();
	void CS_DECLARE_GUILDWAR(struct FString* InGuildName);
	void AU_GuildWar_Click_SeasonHistory_Page_Stepper(int InPage);
	void AU_GuildWar_Click_SeasonHistory_Sort(int InIndex);
	void AU_GuildWar_Click_Page_Stepper(int InPage);
	void AU_GuildWar_Click_History_Sort(int InIndex);
	void AU_GuildWar_Click_Surrender();
	void AU_GuildWar_Click_Confirm(const struct FString& InGuildName);
	void UA_GuildWar_Update_SeasonHistory_Page();
	void UA_GuildWar_Update_SeasonHistory_Data();
	void UA_GuildWar_Update_SeasonHistory_SortType();
	void UA_GuildWar_Update_SeasonHistory_Record();
	void UA_GuildWar_Update_WarHistory_Page();
	void UA_GuildWar_Update_WarHistory_Data();
	void UA_GuildWar_Update_WarHistory_SortType();
	void UA_GuildWar_Update_WarHistory_Record();
	void UA_GuildWar_Update_DoingWar_Guild_Score();
	void UA_GuildWar_Update_DoingWar_RemainTime();
	void UA_GuildWar_Update_DoingWar_GuildName();
	void UA_GuildWar_Update_SurrenderWarUI_EnableState();
	void UA_GuildWar_Update_DeclareWarUI_EnableState();
	void UA_GuildWar_Update_War_Count();
	void UA_GuildWar_Update_War_State();
	void OpenDialog_GuildWar_SurrenderDeclareWar();
	void OpenDialog_GuildWar_ConfirmDeclareWar(struct FString* InGuildName);
	void SortGuildWarSeasonHistoryUIDataList(TEnumAsByte<ESortingOrder> InOrder);
	void SortGuildWarHistoryUIDataList(TEnumAsByte<EBLGuildWareHistorySortingColumnType> InColumnType, TEnumAsByte<ESortingOrder> InOrder);
	void OnUpdateGuildWarSeasonHistoryData();
	void OnUpdateGuildWarHistoryData();
	void AddGuildWarSeasonHistoryData(struct FGuildWarRecordSeasonHistoryData* InData);
	void AddGuildWarHistoryData(struct FGuildWarHistoryData* InData);
	void UpdateGuildWarLastSeasonWinCount(int InCount);
	void UpdateGuildWarDeathPoint(int InPoint);
	void UpdateGuildWarKillPoint(int InPoint);
	void UpdateGuildWarSeason(struct FGuildWarSeasonData* InData);
	void UpdateGuildWarRemainStateTime(const struct FQWord& InRemainTime);
	void UpdateGuildWarState(TEnumAsByte<EGuildWarState> InState);
	void UpdateGuildWarSeaonHistory(TArray<struct FGuildWarRecordSeasonHistoryData> InDataList);
	void UpdateGuildWarHistory(TArray<struct FGuildWarHistoryData> InGuildWarHistoryDataList);
	void UpdateGuildWarRecordData(const struct FGuildWarRecordData& InData);
	void UpdateGuildWarData(const struct FGuildWarData& InData);
	void UpdateAllGuildWarUI();
	TEnumAsByte<ECERealmType> GetGuildRealm();
	bool FindGuildHistory(int InIndex, struct FBLGuildHistoryUIData* OutData);
	struct FString MakeString_GuildManagement_History_Date(struct FDateYMD* InDate);
	void AU_GuildManagement_Click_History_Sort();
	void AU_GuildManagement_Click_Page_Stepper(int InPage);
	void UA_GUildManagement_Update_SortingType();
	void UA_GuildManagement_Update_History_Page();
	void UA_GuildManagement_Update_History();
	void SortGuildHistoryUIDataList();
	void OnUpdateGuildHistoryUIDataList();
	void AddGuildHistory(struct FGuildHistoryData* InData);
	void UpdateGuildHistoryUIDataList();
	void UpdateGuildHistory(TArray<struct FGuildHistoryData> InDataList);
	void AU_GuildMember_Click_Refresh();
	void AU_GuildMember_Click_InfluenceView_SortingList(int InIndex);
	void AU_GuildMember_Change_Menu(int InSelectedIndex);
	void AU_GuildMember_Click_MemberView_SortingList(int InIndex);
	void UA_GuildMember_Update_InfluenceInfoData();
	void UA_GuildMember_Update_MemberInfoData();
	void UA_GuildMember_Update_SortingType();
	void UA_GuildMember_Init_Menu_Data();
	int ConvertInfluenceViewColumnToUIIndex(TEnumAsByte<EBLGuildMemberUIColumnType> InEnum);
	int ConvertMemberViewColumnToUIIndex(TEnumAsByte<EBLGuildMemberUIColumnType> InEnum);
	TEnumAsByte<EBLGuildMemberUIColumnType> ConvertUIIndexToInfluenceViewColumn(int InIndex);
	TEnumAsByte<EBLGuildMemberUIColumnType> ConvertUIIndexToMemberViewColumn(int InIndex);
	struct FString MakeDecreaseRPString(int InDecreaseRP);
	struct FString ConvertGuildInfluenceAmountToString();
	void PostAkEvent(class UAkEvent* InAkEvent);
	void PrintGuildNoticeToChatWindow();
	void OnRemoveGuildMember(struct FGuildMemberData* InData);
	void OnEnableGrantButton();
	void OnChangeShowOfflineMemeber(bool IsShow);
	void OnTabSelect(int Index);
	void UpdateGuildGradeList(TArray<struct FGuildGradeData>* InListData);
	void UpdateGuildMemberList(TArray<struct FGuildMemberData>* InListData);
	void UpdateRankManagementRankNames();
	void UpdateGuildName(struct FString* InGuildName);
	void UpdateLocalPlayerMemberData(struct FGuildMemberData* InData);
	void UpdateGuildMember(struct FGuildMemberData* InData);
	void UpdateGuildInformation(struct FGuildData* InData);
	void DelegateGuildLeaderSelectConfirm(bool IsOk, const struct FString& TargetName);
	void DelegateGuildLeaderAgreementConfirm(bool IsOk);
	void DelegateGuildLeaderConfirm(bool IsOk, const struct FString& TargetName);
	void ModifyGuildMemberGradeConfirm(bool IsOk, const struct FString& TargetName, int ModifyGradeID);
	void DisbandGuildConfirm(bool IsOk);
	void InviteMemberInputConfirm(bool IsOk, const struct FString& TargetName);
	void InviteGuildAgreementConfirm(bool IsOk, int SenderSid);
	void RemoveMemberConfirm(bool IsOk, const struct FString& TargetName);
	void LeaveGuildConfirm(bool IsOk);
	void SortMemberList(TEnumAsByte<EBLGuildMemberUIColumnType> InColumnType, TEnumAsByte<ESortingOrder> InOrder);
	void Res_GrantRP(TEnumAsByte<EGuildErrorCode> InErrorCode);
	void Res_OpenGrantDialog(TArray<struct FString> InCOGuildList);
	void Req_SendEditedGuildNotice(const struct FString& EditedNotice);
	void Req_GrantRP(const struct FString& InCoGuildName, int InGrantRP);
	void Req_OpenGrantDialog();
	void Req_DelegationGuildLeaderRequest(const struct FString& TargetName);
	void Req_RefreshGuildMemberData();
	void OnGuildDisband(struct FMsgCommandArgData* InArgData);
	void OnGuildNotice(struct FMsgCommandArgData* InArgData);
	void OnGuildModifyGuildMemberGradeDemote(const struct FString& TargetName, int SelectedIndex);
	void OnGuildDemote(struct FMsgCommandArgData* InArgData);
	void OnGuildPromote(struct FMsgCommandArgData* InArgData);
	void OnGuildLeader(struct FMsgCommandArgData* InArgData);
	void OnGuildRemove(struct FMsgCommandArgData* InArgData);
	void OnGuildLeave(struct FMsgCommandArgData* InArgData);
	void OnGuildInvite(struct FMsgCommandArgData* InArgData);
	void OnGuildInfo(struct FMsgCommandArgData* InArgData);
	void OnGuildOfficerChat(struct FMsgCommandArgData* InArgData);
	void OnGuildChat(struct FMsgCommandArgData* InArgData);
	void OnGuildJoinConfirm(struct FMsgCommandArgData* InArgData);
	void OnGuildCreateConfirm(struct FMsgCommandArgData* InArgData);
	void OnUpdateLocalUserGrade();
	void OnUpdate_InviteGuildMemberbutton();
	void OnUpdateMemberInformation();
	void OnUpdateGuildInformation();
	void OnUpdateRP();
	void OnClosedFromUI();
	void CloseGuildUIForShopGift();
	void CloseShowingDialog();
	void CloseMemberPopupMenu();
	void CloseGuildUI();
	void OnOpenedFromUI();
	void OpenGrantRPConfirmDialog(const struct FString& InCoGuildName, int InGrantRP);
	void OpenDelegateGuildLeaderSelectDialog();
	void OpenDelegateGuildLeaderAgreementDialog(const struct FString& PreLeaderName);
	void OpenDelegateGuildLeaderDialog(const struct FString& TargetName);
	void OpenGradeModifyDialog(const struct FString& TargetName, int ModifyGradeID);
	void OpenInviteGuildMemberDialog();
	void OpenInviteGuildAgreementDialog(const struct FString& InviteGuildName, const struct FString& SenderName, int SenderSid);
	void OpenGuildUIForShopGift();
	void OpenMemberPopupMenu(const struct FString& TargetName);
	void OpenGuildUI();
	bool IsCOGuildMember(int COGuildCID);
	bool IsCompareQWORD_INT(const struct FQWord& InSrc, int InDest, const struct FString& InCompare);
	bool IsInGradeAuthorityFlag(const struct FQWord& flagSet, TEnumAsByte<ECEGuildAuthorityType> auth);
	bool IsInLocalUserAuthority(TEnumAsByte<ECEGuildAuthorityType> AuthorityType);
	bool IsMember(const struct FString& InMemberName);
	void SetAuthorityDialogViewSelectedIndex(int InSelectedIndex);
	void SetAuthorityDialogView();
	void SetGuildTalkNpcSID(int Sid);
	struct FString GetTimeOffsetByNow(const struct FQWord& sourceTime);
	struct FString GetNoticeDateString();
	TEnumAsByte<EBLGuildUIType> GetOpenedUIType();
	struct FString GetLocationName(int Cid);
	struct FString GetTargetName();
	struct FGuildMemberData GetMember(const struct FString& InMemberName);
	struct FGuildGradeData GetGrade(int GradeID);
	void Tick(float InDeltaTime);
	void Clear();
	void Initialize();
};


// Class BLGame.BLGuildCreateAgreementDialog
// 0x0024 (0x0084 - 0x0060)
class UBLGuildCreateAgreementDialog : public UObject
{
public:
	unsigned long                                      IsMasterMode : 1;                                         // 0x0060(0x0004) (Transient)
	TArray<struct FGuildRespondentData>                PartyMemberSidList;                                       // 0x0064(0x0010) (Transient, NeedCtorLink)
	int                                                PartyMemberCount;                                         // 0x0074(0x0004) (Transient)
	int                                                AgreeUserCount;                                           // 0x0078(0x0004) (Transient)
	int                                                ResquesterSid;                                            // 0x007C(0x0004) (Transient)
	int                                                TalkNpcSid;                                               // 0x0080(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLGuildCreateAgreementDialog");
		return ptr;
	}


	void Res_CloseAgreementQueryDialog();
	void Res_ShowCreateAgreementQueryDialog(int InTalkNpcSid, int Sid, const struct FString& GuildName);
	void Res_CloseAgreementMasterDialog();
	void Res_UpdateCreateAgreementMasterDialog(int ResponserSid, const struct FString& ResponserName, bool isAgree);
	void Res_SetResponserCountMasterDialog(int ResponserCount);
	void Res_ShowCreateAgreementMasterDialog(int InTalkNpcSid, const struct FString& GuildName);
	void Req_CreateAgree(bool isAgree);
	void Req_CreateMasertControl(bool IsOk);
	struct FString GetPartyMemberName(int Sid);
};


// Class BLGame.BLGuildCreateDialog
// 0x0019 (0x0079 - 0x0060)
class UBLGuildCreateDialog : public UObject
{
public:
	unsigned long                                      IsLowGuildMasterLevel : 1;                                // 0x0060(0x0004) (Transient)
	unsigned long                                      IsInvitedOtherGuild : 1;                                  // 0x0060(0x0004) (Transient)
	unsigned long                                      IsLeaveOtherGuild : 1;                                    // 0x0060(0x0004) (Transient)
	unsigned long                                      IsRemoveOtherGuild : 1;                                   // 0x0060(0x0004) (Transient)
	unsigned long                                      IsDisbandOtherGuild : 1;                                  // 0x0060(0x0004) (Transient)
	unsigned long                                      IsHaveNoMoney : 1;                                        // 0x0060(0x0004) (Transient)
	unsigned long                                      IsNotEnoughPartyPlayer : 1;                               // 0x0060(0x0004) (Transient)
	unsigned long                                      IsInvalidName : 1;                                        // 0x0060(0x0004) (Transient)
	struct FString                                     GuildName;                                                // 0x0064(0x0010) (Transient, NeedCtorLink)
	int                                                TalkNpcSid;                                               // 0x0074(0x0004) (Transient)
	TEnumAsByte<EGuildCreateStep>                      CurrentStep;                                              // 0x0078(0x0001)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLGuildCreateDialog");
		return ptr;
	}


	void OnChangedInputGuildNameEditBox(const struct FString& ChangedText);
	void OnUpdateCondition();
	void PostClosedDialog();
	void Res_CheckName(bool IsInvalid, const struct FString& ErrorString);
	void Res_OpenCreateDialog();
	void SetDialogInfo(int InTalkNpcSid, bool In_isLowGuildMasterLevel, bool In_isInvitedOtherGuild, bool In_IsLeaveOtherGuild, bool In_IsRemoveOtherGuild, bool In_IsDisbandOtherGuild, bool In_isHaveNoMoney, bool In_isNotEnoughPartyPlayer);
	void Req_CreateTerminate();
	void Req_Create();
	void Req_CheckName(const struct FString& InGuildName);
};


// Class BLGame.BLInterpCurveData
// 0x003C (0x009C - 0x0060)
class UBLInterpCurveData : public UObject
{
public:
	struct FInterpCurveFloat                           CurveFloat;                                               // 0x0060(0x0014) (Edit, NeedCtorLink)
	struct FInterpCurveVector                          CurveVector;                                              // 0x0074(0x0014) (Edit, NeedCtorLink)
	struct FInterpCurveLinearColor                     CurveLinearColor;                                         // 0x0088(0x0014) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLInterpCurveData");
		return ptr;
	}


	TEnumAsByte<EBLInterpCurveDataType> GetCurveDataType();
};


// Class BLGame.BLPathwayInfo
// 0x0058 (0x02A8 - 0x0250)
class ABLPathwayInfo : public AActor
{
public:
	TArray<struct FBLPathway>                          Pathways;                                                 // 0x0250(0x0010) (Edit, NeedCtorLink)
	struct FMap_Mirror                                 PathwayNameMap;                                           // 0x0260(0x0048) (Native, Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLPathwayInfo");
		return ptr;
	}


	bool GetPathwayPosList_Name(const struct FString& InName, bool InConsiderCycleType, TArray<struct FVector>* OutPosList);
	bool GetPathwayPosList_Index(int InIndex, bool InConsiderCycleType, TArray<struct FVector>* OutPosList);
	int GetPathwayDestAngle(int InIndex);
	TEnumAsByte<EPATHWAY_CYCLE_TYPE> GetPathwayCycleType(int InIndex);
	struct FString GetPathwayName(int InIndex);
	int GetPathwayCount();
	void InitPathwayNameMap();
	void RefreshHeadPathwayPoints();
	void UpdateHeadPathwayPoint(class ABLPathwayPoint* InPathwayPoint);
	void RemoveHeadPathwayPoint(class ABLPathwayPoint* InPathwayPoint);
	void AddHeadPathwayPoint(class ABLPathwayPoint* InPathwayPoint);
};


// Class BLGame.BLPathwayPoint
// 0x0058 (0x02A8 - 0x0250)
class ABLPathwayPoint : public AActor
{
public:
	unsigned long                                      bStickToTerrain : 1;                                      // 0x0250(0x0004) (Edit)
	struct FString                                     PathwayName;                                              // 0x0254(0x0010) (Edit, NeedCtorLink)
	int                                                DestAngle;                                                // 0x0264(0x0004) (Edit)
	TEnumAsByte<EPATHWAY_CYCLE_TYPE>                   CycleType;                                                // 0x0268(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0269(0x0003) MISSED OFFSET
	struct FColor                                      EditorLineColor;                                          // 0x026C(0x0004) (Edit)
	class ABLPathwayPoint*                             LinkTo;                                                   // 0x0270(0x0008)
	class ABLPathwayPoint*                             LinkFrom;                                                 // 0x0278(0x0008)
	class USpriteComponent*                            SpriteComp;                                               // 0x0280(0x0008) (ExportObject, Transient, Component, EditInline)
	class UBLPathwayRenderingComponent*                RenderingComp;                                            // 0x0288(0x0008) (ExportObject, Transient, Component, EditInline)
	class ABLPathwayInfo*                              CachedPathwayInfo;                                        // 0x0290(0x0008) (Transient)
	float                                              defaultScale;                                             // 0x0298(0x0004) (Transient)
	float                                              ScaleFactorPathwayStart;                                  // 0x029C(0x0004) (Transient)
	float                                              ScaleFactorPathwayEnd;                                    // 0x02A0(0x0004) (Transient)
	float                                              ScaleFactorPathwayMiddle;                                 // 0x02A4(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLPathwayPoint");
		return ptr;
	}


	class ABLPathwayInfo* GetPathwayInfo();
	void UpdateSprite();
	void UpdateLinkedPathwayPoint(bool InProcessLinkTo, bool InProcessLinkFrom);
	class ABLPathwayPoint* FindHeadPathwayPoint();
	bool IsLinkTo(class ABLPathwayPoint* InPathwayPoint);
	void BreakLinkFrom();
	void BreakLinkTo();
	void SetLinkTo(class ABLPathwayPoint* InPathwayPoint);
	void SpriteHiddenGame(bool InHidden);
};


// Class BLGame.BLPathwayRenderingComponent
// 0x000C (0x0244 - 0x0238)
class UBLPathwayRenderingComponent : public UPrimitiveComponent
{
public:
	float                                              SphereRadius;                                             // 0x0238(0x0004) (Transient)
	struct FName                                       SpriteCategoryName;                                       // 0x023C(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLPathwayRenderingComponent");
		return ptr;
	}

};


// Class BLGame.BlessPCBase
// 0x0034 (0x0778 - 0x0744)
class ABlessPCBase : public AGamePlayerController
{
public:
	class UMouseEventDecider*                          MouseEventDecider;                                        // 0x0744(0x0008) (Transient)
	class UKeyBindAdopter*                             KeyBindAdopter;                                           // 0x074C(0x0008) (Transient)
	float                                              CM_RemainTime;                                            // 0x0754(0x0004)
	float                                              SourceValue;                                              // 0x0758(0x0004)
	float                                              targetvalue;                                              // 0x075C(0x0004)
	struct FCustomizeData                              CachedCustomizeData;                                      // 0x0760(0x0010) (NeedCtorLink)
	class UDeferredSystemMessageComponent*             PendingMessageComponent;                                  // 0x0770(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BlessPCBase");
		return ptr;
	}


	void CustomMatineeIsDeactivated(class USeqAct_Interp* InTarget);
	void GetCustomizeData(struct FCustomizeData* OutData);
	void OnFinishUIState(int InUIState);
	void OnLoadCompleteUIState(int InUIState);
	void OnStartUIState(int InUIState);
	void CustomizeF(TEnumAsByte<ECECustomizeType> InType, float Value);
	void SaveCustomizeData();
	void LoadPresetFile(const struct FString& InFilename);
	void SavePresetFile(const struct FString& InFilename);
	class UBLCustomizingController* GetCustomizingController();
	class ABLPawn* GetCustomizingTarget();
	bool InternalOnHandleInputChar(int ControllerId, const struct FString& Unicode);
	bool HandleInputAxis(int ControllerId, const struct FName& Key, float Delta, float DeltaTime, bool bGamepad);
	bool InternalOnHandleInputKey(int ControllerId, const struct FName& Key, TEnumAsByte<EInputEvent> EventType, float AmountDepressed, bool bGamepad);
	TEnumAsByte<EChatMode> GetChatMode();
	void SetChatMode(TEnumAsByte<EChatMode> InChatMode);
	void EnterAction();
	void EscapeAction();
	class UBLUIPlayer* GetLocalUIPlayerBase();
	class ABLHUDBase* GetLocalHUDBase();
	void Destroyed();
	void PostBeginPlay();
	void InitInputSystem();
	void InitComponent();
	TEnumAsByte<EKindOfPC> GetKindOfGameMode();
	class ABLPawn* GetPossessedPawn();
	class ABLVehiclePawn* GetVehiclePawn();
};


// Class BLGame.BlessPC
// 0x0284 (0x09FC - 0x0778)
class ABlessPC : public ABlessPCBase
{
public:
	class ABLPawn*                                     LocalPawn;                                                // 0x0778(0x0008)
	unsigned long                                      bPawnRotationLocked : 1;                                  // 0x0780(0x0004) (Transient)
	unsigned long                                      bInitializedFreeCamera : 1;                               // 0x0780(0x0004) (Transient)
	unsigned long                                      bEnableAutoTarget : 1;                                    // 0x0780(0x0004)
	unsigned long                                      bRootMoveTargetDecal : 1;                                 // 0x0780(0x0004) (Transient)
	unsigned long                                      WasBackward : 1;                                          // 0x0780(0x0004) (Transient)
	unsigned long                                      bKeepWalkingIncludeForwardInput : 1;                      // 0x0780(0x0004) (Transient)
	unsigned long                                      bDoingMoveToTarget : 1;                                   // 0x0780(0x0004) (Transient)
	unsigned long                                      bDoingMoveToServer : 1;                                   // 0x0780(0x0004) (Transient)
	unsigned long                                      bIgnoreRotationOnCinema : 1;                              // 0x0780(0x0004) (Transient)
	unsigned long                                      bDoingNormalAttack : 1;                                   // 0x0780(0x0004) (Transient)
	unsigned long                                      bKeepWalkingMode : 1;                                     // 0x0780(0x0004) (Transient)
	unsigned long                                      bMouseKeepWalkingMode : 1;                                // 0x0780(0x0004) (Transient)
	unsigned long                                      bEnableMouseKeepWalkingMode : 1;                          // 0x0780(0x0004) (Transient)
	unsigned long                                      bPressedForwardInput : 1;                                 // 0x0780(0x0004) (Transient)
	unsigned long                                      bPressedKeyUIMode : 1;                                    // 0x0780(0x0004) (Transient)
	unsigned long                                      bUseSprintingCasting : 1;                                 // 0x0780(0x0004) (Config)
	unsigned long                                      IsLockOn : 1;                                             // 0x0780(0x0004) (Transient)
	unsigned long                                      bIsReturnTeleport : 1;                                    // 0x0780(0x0004) (Transient)
	unsigned long                                      bJumpFallKeyEnabled : 1;                                  // 0x0780(0x0004) (Transient)
	unsigned long                                      bPendingInteractiveMode : 1;                              // 0x0780(0x0004) (Transient)
	unsigned long                                      bRestrictMoveControl : 1;                                 // 0x0780(0x0004) (Transient)
	unsigned long                                      bRestrictTurnControl : 1;                                 // 0x0780(0x0004) (Transient)
	unsigned long                                      bRestrictTargetingControl : 1;                            // 0x0780(0x0004) (Transient)
	unsigned long                                      bRemoteMoveControl : 1;                                   // 0x0780(0x0004) (Transient)
	unsigned long                                      bChatFocusModeEnable : 1;                                 // 0x0780(0x0004)
	unsigned long                                      bCalledIgnoreMoveInputInSkillState : 1;                   // 0x0780(0x0004) (Transient)
	unsigned long                                      bDelayPawnRotation : 1;                                   // 0x0780(0x0004) (Transient)
	unsigned long                                      bEnablePlayerCameraRotation : 1;                          // 0x0780(0x0004) (Transient)
	unsigned long                                      bWaitingTakeOffAndDownAck : 1;                            // 0x0780(0x0004)
	unsigned long                                      IsUseFixedCameraControl : 1;                              // 0x0780(0x0004) (Transient)
	unsigned long                                      bDoLookBack : 1;                                          // 0x0780(0x0004)
	TEnumAsByte<EBLTargetingMode>                      TargetingMode;                                            // 0x0784(0x0001) (Transient)
	TEnumAsByte<ETargetSelectType>                     TargetSelectComponentType;                                // 0x0785(0x0001) (Edit, Config)
	TEnumAsByte<ESprintState>                          SprintState;                                              // 0x0786(0x0001) (Transient)
	unsigned char                                      Boost;                                                    // 0x0787(0x0001) (Input, Transient)
	struct FName                                       PrevStateName;                                            // 0x0788(0x0008)
	class APawn*                                       BackupPawnForFreeCamera;                                  // 0x0790(0x0008) (Transient)
	struct FVector                                     FreeCameraLocation;                                       // 0x0798(0x000C) (Transient)
	struct FRotator                                    FreeCameraRotation;                                       // 0x07A4(0x000C) (Transient)
	class UBLTargetSelectComponent*                    TargetSelectComp;                                         // 0x07B0(0x0008) (Edit, ExportObject, Transient, Component, EditInline)
	class UDLEChangeComponent*                         DLEChangeComp;                                            // 0x07B8(0x0008) (Edit, ExportObject, Transient, Component, EditInline)
	class ABLSpawnableEmitter*                         MoveTargetEmitter;                                        // 0x07C0(0x0008) (Transient)
	class ABLDecalActor*                               TargetFloorDecal;                                         // 0x07C8(0x0008) (Transient)
	class ABLDecalActor*                               AutoTargetFloorDecal;                                     // 0x07D0(0x0008) (Transient)
	float                                              JumpPressedTime;                                          // 0x07D8(0x0004) (Transient)
	struct FVector                                     OldAccel;                                                 // 0x07DC(0x000C) (Transient)
	struct FName                                       TargetDecalOriginBoneName;                                // 0x07E8(0x0008)
	struct FVector                                     MoveToTargetLocation;                                     // 0x07F0(0x000C) (Transient)
	int                                                MoveToTargetID;                                           // 0x07FC(0x0004) (Transient)
	int                                                NormalAttackTargetID;                                     // 0x0800(0x0004) (Transient)
	float                                              SprintIn_Change_Time;                                     // 0x0804(0x0004) (Edit, Config)
	float                                              SprintOut_Delay_Time;                                     // 0x0808(0x0004) (Edit, Config)
	float                                              Sprint_Change_Velocity_Ratio;                             // 0x080C(0x0004) (Edit, Config)
	float                                              SprintInChangeCount;                                      // 0x0810(0x0004) (Transient)
	float                                              SprintOutDelayCount;                                      // 0x0814(0x0004) (Transient)
	float                                              SprintReadyTime;                                          // 0x0818(0x0004) (Edit, Config)
	float                                              SprintOffDelayTime;                                       // 0x081C(0x0004) (Edit, Config)
	float                                              SprintStateTransitionCount;                               // 0x0820(0x0004) (Transient)
	float                                              SprintingConditionTimeSeconds;                            // 0x0824(0x0004) (Config)
	float                                              StopMotionConditionTimeSeconds;                           // 0x0828(0x0004) (Config)
	int                                                HostileAutoTargetID;                                      // 0x082C(0x0004) (Transient)
	int                                                FriendlyAutoTargetID;                                     // 0x0830(0x0004) (Transient)
	float                                              TargetingEventDistance;                                   // 0x0834(0x0004) (Transient)
	int                                                MouseOverTargetID;                                        // 0x0838(0x0004) (Transient)
	int                                                RequestedTargetID;                                        // 0x083C(0x0004) (Transient)
	int                                                EscortTargetID;                                           // 0x0840(0x0004) (Transient)
	int                                                InteractionPropID;                                        // 0x0844(0x0004) (Transient)
	class UBLEnvComponent*                             EnvVolComponent;                                          // 0x0848(0x0008) (ExportObject, Component, EditInline)
	struct FRotator                                    PlayerControllerDirection;                                // 0x0850(0x000C) (Transient)
	int                                                InteractiveDoorID;                                        // 0x085C(0x0004) (Transient)
	class UActionController*                           ActionController;                                         // 0x0860(0x0008) (ExportObject, Transient, Component, EditInline)
	class UHPAlertController*                          HPAlertController;                                        // 0x0868(0x0008) (ExportObject, Transient, NeedCtorLink, EditInline)
	class UPawnVisibilityController*                   PawnVisibilityController;                                 // 0x0870(0x0008) (ExportObject, Transient, NeedCtorLink, EditInline)
	class UAimController*                              AimController;                                            // 0x0878(0x0008) (ExportObject, Transient, Component, EditInline)
	class UMoveController*                             MoveController;                                           // 0x0880(0x0008) (ExportObject, Transient, Component, EditInline)
	class UCombatSoundController*                      CombatSoundController;                                    // 0x0888(0x0008) (ExportObject, Transient, NeedCtorLink, EditInline)
	float                                              FiringTimeTemp;                                           // 0x0890(0x0004) (Transient)
	float                                              IgnoreMoveInputBreakTimeCheck;                            // 0x0894(0x0004) (Transient)
	float                                              ClimbMoveThreshold;                                       // 0x0898(0x0004) (Config)
	float                                              CanClimbCountDown;                                        // 0x089C(0x0004) (Transient)
	class ULevelStreamingBlessCinematic*               CurrentCinematicStreamingLevel;                           // 0x08A0(0x0008) (Transient)
	struct FPointAreaSettingInfo                       PointAreaInfo;                                            // 0x08A8(0x0018)
	class UBLPointAreaComponent*                       PointAreaComp;                                            // 0x08C0(0x0008) (ExportObject, Component, EditInline)
	float                                              CamAngleToTarget;                                         // 0x08C8(0x0004) (Edit, Const, Config)
	float                                              ForwardMaxVelocity;                                       // 0x08CC(0x0004) (Edit, Const, Config)
	float                                              R_Forward;                                                // 0x08D0(0x0004) (Edit, Const, Config)
	float                                              Tr_Forward;                                               // 0x08D4(0x0004) (Edit, Const, Config)
	float                                              ForwardBoostMaxVelocity;                                  // 0x08D8(0x0004) (Edit, Const, Config)
	float                                              R_ForwardBoost;                                           // 0x08DC(0x0004) (Edit, Const, Config)
	float                                              Tr_ForwardBoost;                                          // 0x08E0(0x0004) (Edit, Const, Config)
	float                                              BackwardMaxVelocity;                                      // 0x08E4(0x0004) (Edit, Const, Config)
	float                                              R_Backward;                                               // 0x08E8(0x0004) (Edit, Const, Config)
	float                                              Tr_Backward;                                              // 0x08EC(0x0004) (Edit, Const, Config)
	float                                              R_Stop;                                                   // 0x08F0(0x0004) (Edit, Const, Config)
	float                                              Tr_Stop;                                                  // 0x08F4(0x0004) (Edit, Const, Config)
	float                                              Gravity;                                                  // 0x08F8(0x0004) (Edit, Const, Config)
	float                                              FlyYawVelocity;                                           // 0x08FC(0x0004) (Edit, Const, Config)
	float                                              FlyMountRollC;                                            // 0x0900(0x0004) (Transient)
	float                                              FlyMountRollK;                                            // 0x0904(0x0004) (Transient)
	float                                              FlyMountRollTweakValue;                                   // 0x0908(0x0004) (Transient)
	int                                                RollTarget;                                               // 0x090C(0x0004) (Transient)
	float                                              UnitTime;                                                 // 0x0910(0x0004) (Transient)
	float                                              VFXVelocity;                                              // 0x0914(0x0004) (Transient)
	float                                              VFXDisplacement;                                          // 0x0918(0x0004) (Transient)
	float                                              RollAccel;                                                // 0x091C(0x0004) (Transient)
	float                                              RollVelocity;                                             // 0x0920(0x0004) (Transient)
	float                                              IntervalTime;                                             // 0x0924(0x0004) (Transient)
	int                                                recentItemBagId;                                          // 0x0928(0x0004)
	class UParticleSystemComponent*                    PSC;                                                      // 0x092C(0x0008) (ExportObject, Transient, Component, EditInline)
	float                                              AirFlowDefaultVelocity;                                   // 0x0934(0x0004) (Transient)
	class UMaterialInstanceConstant*                   AirFlowMICInstance;                                       // 0x0938(0x0008) (Transient)
	struct FString                                     TrackMovePkgName;                                         // 0x0940(0x0010) (Transient, Config, GlobalConfig, NeedCtorLink)
	class UBLAkAmbientEventComponent*                  AkAmbientEventComponent;                                  // 0x0950(0x0008) (ExportObject, Component, EditInline)
	class ABLPawn*                                     SpectatorTargetPawn;                                      // 0x0958(0x0008)
	class ABLPawn*                                     OriginalPlayerPawn;                                       // 0x0960(0x0008)
	int                                                ChatMode;                                                 // 0x0968(0x0004)
	class UBLZoneVolumeComponent*                      ZoneVolumeComponent;                                      // 0x096C(0x0008) (ExportObject, Component, EditInline)
	struct FRotator                                    DelayedPawnRotation;                                      // 0x0974(0x000C) (Transient)
	struct FPendingSkillActionInfo                     PendingSkillAction;                                       // 0x0980(0x000C) (Transient)
	float                                              PendingSkillActionTime;                                   // 0x098C(0x0004) (Transient)
	int                                                RequestedChargeSkillCombatID;                             // 0x0990(0x0004) (Transient)
	float                                              AngleForAllowingFallAtWaterSurface;                       // 0x0994(0x0004) (Config)
	class UMsgCommandDecider*                          MsgCmdDecider;                                            // 0x0998(0x0008) (Const, ExportObject, Component, EditInline)
	class UAutoFiringComponent*                        AutoFiring;                                               // 0x09A0(0x0008) (ExportObject, Component, EditInline)
	TArray<struct FName>                               CameraStyleStack;                                         // 0x09A8(0x0010) (Transient, NeedCtorLink)
	TArray<struct FSummonEffectData>                   SummonEffectDataList;                                     // 0x09B8(0x0010) (NeedCtorLink)
	int                                                DrawBattleMessageCountOnTick;                             // 0x09C8(0x0004) (Const, Config)
	int                                                MaxBattleMessageBufferSize;                               // 0x09CC(0x0004) (Const, Config)
	int                                                DrawBattleMessageIntervalTickCount;                       // 0x09D0(0x0004) (Const, Config)
	int                                                LookBackYawRot;                                           // 0x09D4(0x0004)
	int                                                UseCombatCid;                                             // 0x09D8(0x0004)
	struct FScriptDelegate                             __PlayerSkillFired__Delegate;                             // 0x09DC(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x09DC(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY
	struct FScriptDelegate                             __PlayerSkillCanceled__Delegate;                          // 0x09EC(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData01[0x4];                                       // 0x09EC(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BlessPC");
		return ptr;
	}


	void SetUseCombatCid(int InCombatCid);
	int GetUseCombatCid();
	void CloseUIWhenSkillFire();
	void OnHideUI(bool bIsHide);
	void SetRotationDiscardRoll(const struct FRotator& InRotation);
	void DeletePathButton();
	void SetAutoPathDest();
	void TutorialOrderCheck(const struct FString& ActionName);
	void OnCameraTurnEvent();
	bool IsInTransport();
	void OnStartUIState(int InUIState);
	void AddSummonEffect(TEnumAsByte<ESUMMON_EFFECT_TYPE> InType, int InSummoneeSid);
	void RequestSummonPet(const struct FQWord& Uid);
	void RequestMount(const struct FQWord& Uid);
	void WorldMapTeleportMove();
	void OnChangedAbnormalStatus(int InChangedPawnServerID);
	bool IsDoingRuneSynthesis();
	bool IsDoingNPCCraft();
	bool IsDoingPCCraft();
	void CastingNPCCraft(int InCraftCId, int InCurrentIndex, int InMaxIndex);
	void EndNPCCraft();
	void ProgressNPCCraft(int InCraftCId, int InCurrentIndex, int InMaxIndex);
	void CastingCraft(int CraftID, int CurrentStep, int MaxStep, float CastingTime);
	void EndCraft();
	void ProgressCraft(int CraftID, int CurrentStep, int MaxStep, float CastingTime);
	void ReleaseInputField();
	void EndTaming();
	void CancelTaming();
	void ToggleRanking();
	void ToggleChatFocusedMode();
	void ToggleOrderUI();
	void ToggleRuneUI();
	void ToggleServerExchange();
	void ToggleFriend();
	void ToggleDungeon();
	void ToggleTokenExchang();
	void RequestSocialAction(int InSocialActionID);
	void SetRequestedTargetID(int InTargetID);
	void SetFlyMode(bool bFlyOn);
	void EndWaypoint(float RetCamDelayTime);
	void StartWaypoint();
	void RemoveCameraStyle(const struct FName& CameraStyle);
	void PushCameraStyle(const struct FName& CameraStyle);
	void ResetCameraStyleStack();
	TEnumAsByte<EChatMode> GetChatMode();
	void SetChatMode(TEnumAsByte<EChatMode> InChatMode);
	TEnumAsByte<EBattleMessageType> ConvertRCResistToBattleMessage(TEnumAsByte<ESkillDamageType> inDamageType, int DamageCount);
	TEnumAsByte<EBattleMessageType> ConvertExtendAttackChanceToBattleMessage(TEnumAsByte<ECEExtendAttackChanceType> InExtendAttackChanceType);
	TEnumAsByte<EBattleMessageType> ConvertAttackChanceToBattleMessage(TEnumAsByte<ECEAttackChanceType> InAttackChanceType, TEnumAsByte<ESkillDamageType> inDamageType, bool bAbnormalHit);
	bool IsUsefulBattleMessage(class ABLPawnBase* InDamager, class ABLPawnBase* InVictim, bool IsHeal, TEnumAsByte<EPartyMemberType>* OutMemberType);
	void UpdatePartyUI();
	void UpdateTrapVisible();
	void OnUpdateLevel();
	void OnUpdateEnergy();
	void OnUpdateMP();
	void OnUpdateHP();
	void PreRender(class UCanvas* Canvas);
	void RenderAllPawnNames_New(float InTimeSeconds);
	void RenderAllPawnNames(float InTimeSeconds);
	void OnUpdateConditionalPhase(TEnumAsByte<ECEConditionPhaseType> Type);
	void RefreshPartyAbnormalStatus();
	void SetUIMode(bool UIMode);
	void ReleaseTargetSign(bool IsAll);
	void SetTargetSign(int InSignType);
	void SelectPartyMember(int OrderedIndex);
	void InputSkillDeckChange(int InSkillDeckIndex);
	void InputStanceSkillQTE(int InSlotIndex, bool bPress);
	class UBLSkillQTEHUDUIManager* GetSkillQTEHUDUIManager();
	class UBLSkillQTEHUDManager* GetSkillQTEHUDManager();
	void InputSkillQTE(int InSlotIndex, bool bPress);
	void PrevFavoritePage();
	void NextFavoritePage();
	void InputFavoriteActionBarSlot(int InSlotIndex);
	void InputStanceChange(bool bPress);
	void InputActionBarSlot(const struct FString& InType, int InSlotIndex, bool bPress);
	void InputVoluntaryAction(bool bPress);
	void InputKeyUIMode(bool bPress);
	void OnUseQTEQuestItem();
	void UseQTEQuestItem(bool bPress);
	void DoInteraction();
	void InputInteraction(bool bPress);
	void WorldMapMoveLocation(int LocationCId);
	void WorldMapSetFilter(bool bAdd, TEnumAsByte<EFiltering_Icon> Filter);
	void WorldMapReturnMoveCameraCenterPlayer();
	void WorldMapZoom(bool bCursor, bool bZoomIn);
	void FlushAsyncLoading();
	void WorldMapMovePlayer();
	void WorldMapMoveHotSpot();
	void WorldMapPositionToLocation();
	void HideWorldMap();
	void ShowWorldMap();
	void ToggleWorldMap(bool bForceClose);
	void ToggleHideUI();
	void ChatModeWhisperReply();
	void ToggleGameOnWebShop();
	void ToggleWebShop();
	void ToggleLumenaShop();
	void ToggleCraft();
	void ToggleCollectionBook();
	void ToggleMission();
	void ShowRealmOwnershipProgress(bool bShow);
	void ToggleMinimapExtension();
	void ToggleCitadelOwnership();
	void ToggleConquest();
	void ToggleGuild();
	void ToggleMail();
	void ToggleInterfaceSetting();
	void ToggleSystemSetting();
	void ToggleSkillBook();
	void ToggleSkillDeck();
	void ToggleQuestJournal();
	void ToggleCharStat();
	void ToggleInventory();
	bool IsInWarpWaypoint();
	bool DoPendingSkillAction();
	bool IsAvailablePendingSkillAction();
	void CleanPendingSkillAction();
	void RegisterPendingSkillAction(int InCombatID, bool UserInput);
	void OnFinishedCinematic();
	bool ExecuteMsgCommand(const struct FString& InMsg);
	void UpdateRemoteMoveControl();
	void UpdateRestrictTargetingControl();
	void UpdateRestrictTurnControl();
	void UpdateRestrictMoveControl();
	bool IsRestrictExecuteVoluntrayAction();
	bool IsRestrictExecuteSkill(int InSkillCid);
	void EndSpectatorMode();
	bool IsSpectatorTargetPawn(class ABLPawn* TargetPawn);
	void SetSpectatorTargetPawn(class ABLPawn* TargetPawn);
	void StartSpectatorMode(const struct FString& PawnName);
	void CameraGameToEditor();
	TEnumAsByte<EKindOfPC> GetKindOfGameMode();
	void PostBeginPlay();
	void ProcessAreaDecal();
	void DisableAreaTargetingMode();
	void EnableAreaTargetingMode(TEnumAsByte<EAREA_TARGETING_TYPE> InType, int InCid, float Inradius, float InNearLimit, float InDistance, float InLimitDistance);
	bool CheckLOS_PointType(const struct FVector& InDestLoc);
	void OnUpdateTargetReleased();
	void OnUpdateItems(TArray<struct FItemData> updatedItems);
	void ToggleWeaponStatus();
	void SheatheWeapon();
	void UnsheatheWeapon();
	bool IsPressedMoveButton();
	void OnMountActiveSkill(int SkillNum);
	void OnSprint();
	void OnReleasedPawnRotateInputEvent(int RotateDir);
	void OnPressedPawnRotateInputEvent(int RotateDir);
	void RotatePCPawnToCamera();
	void OnPressedMoveInputEvent(int Forward, int Strafe, bool bAutoForward, bool bJump);
	void OnReleasedForwardMoveInput();
	void OnPressedForwardMoveInput();
	void OnReleasedMoveInputEvent(int Forward, int Strafe, bool AutoForward);
	void UpdateMoveToTarget(float DeltaTime);
	void StopMove(bool bIsStopByServer, bool bNotSync);
	void CancelAutoPath();
	void CancelMoveToTarget(bool bIsStopByServer);
	void StopMoveToTarget();
	void MoveToTarget(const struct FVector& InLocation, bool bMoveToServer, float InDistance, int InTargetID);
	void ChangeNextHostileTarget();
	void NotifyPathChanged();
	void Go();
	void Chat(const struct FString& msg);
	void ZoomOut();
	void ZoomIn();
	void UpdateAutoCamRotation(float DeltaTime, struct FRotator* DeltaRot);
	bool ShouldPawnRotate();
	void LookBackRotate(float DeltaTime, struct FRotator* NewRotator);
	void UpdateRotation(float DeltaTime);
	bool IsCameraControlMode();
	void SetEnablePlayerCameraRotation(bool bEnable);
	void UpdatePawnRotation(const struct FRotator& NewRotation, float DeltaTime);
	bool InFlyMountCam();
	void CancelSkillCasting();
	void ProcessEtc(float DeltaTime);
	void ProcessGameEvents(float DeltaTime);
	void OnUpdateWorldCursor(const struct FVector& a_Location, bool a_bHide);
	void UpdateDecalPos();
	void ProcessGameSystemWidget(float DeltaTime);
	void JumpDropDown();
	void DisplayDebug(class AHUD* HUD, float* out_YL, float* out_YPos);
	void PostProcessPhysics(float DeltaSeconds);
	void ProcessMove(float DeltaTime, const struct FVector& newAccel, TEnumAsByte<EDoubleClickDir> DoubleClickMove, const struct FRotator& DeltaRot);
	void PlayerMove(float DeltaTime);
	void OnDespawnMount();
	void UpdateFlyingVehicleFlyingMountMoveFOVInfo(float* OutMoveFOV, float* OutMoveFOV_Inc, float* OutMoveFOV_Dec, float* OutMoveFOV_DelayTime);
	void GotoFlyingVehicleState();
	void OnReceivedTakeDownAck(bool bSuccess);
	void OnReceivedTakeOffAck(bool bSuccess);
	bool IsFlyableZone();
	bool IsWalkablePlace();
	void DoSpecial();
	void UpdateMountMoveFOVInfo(float* OutMoveFOV, float* OutMoveFOV_Inc, float* OutMoveFOV_Dec, float* OutMoveFOV_DelayTime);
	bool IsMountState(const struct FName& InStateName);
	void OnReleaseMountSkill(int SkillCid);
	void DoMountSkillActionCommand(int SkillCid);
	void OnUpdateMountRunForwardSpeed();
	void NotifyPhysicsVolumeChange(class APhysicsVolume* NewVolume);
	void UpdateSprintState(float DeltaTime);
	void StopSprint(bool bUseOutDelayCount);
	void StartSprint(bool bUseReadyTime);
	void StartSprintREQ();
	void StopSprintFOV();
	void StartSprintFOV();
	void OnReleaseJump();
	void SetStateKeepWalking(bool InSet);
	void SetMouseKeepWalking(bool InSet);
	void ToggleKeepWalkingButton();
	void KeepWalkingButton();
	void OnReturnComplete();
	void UpdateTargetEffect(int InPrevTargetSid);
	void OnUpdateTargetChanged(int InPrevTargetSid);
	void MakeAccel(float InForward, float InStrafe, float InUpward, float InAccelerate, struct FVector* OutNewAccel);
	void MakeNewAccel(const struct FVector& InAxIs_X, const struct FVector& InAxIs_Y, const struct FVector& InAxIs_Z, float InForward, float InStrafe, float InUpward, float InAccelerate, struct FVector* OutNewAccel);
	void MakeNewAccel2D(const struct FVector& InAxIs_X, const struct FVector& InAxIs_Y, float InFoward, float InStrafe, float InAccelerate, struct FVector* OutNewAccel);
	void SetMovementState();
	void UpdatePawnPhysics();
	void EndWalkingState();
	void InitWalkingState();
	bool IsOfflineCinematicPlaying();
	bool CanMove();
	void ApplyBubbleStack(class UGFxUI_NameTagObject* InNameTagObj, TArray<struct FCombatFlairData> InBubbleStackList, int InTargetPawnSID);
	bool IsValidCombatFlairForClass(TEnumAsByte<ECEClassType> InClassTy, TEnumAsByte<ECECombatElementType> InFlairTy);
	bool ExtractBubbleStack(class UPlayerRepInfo* InPlayerInfo, TArray<struct FCombatFlairData>* OutData);
	void SetViewTarget(class AActor* NewViewTarget, const struct FViewTargetTransitionParams& TransitionParams);
	void PIEAction_Aura(const struct FString& Argument);
	void PIEAction_Abnormal(const struct FString& Argument);
	void PIEPlaySkillSlot(int Index);
	void ToggleChatFocusMode(bool InEnable);
	void ToggleChat(int SendChatMessage);
	void EnterAction();
	void EscapeAction();
	bool CheckItemOnuseEffect(const struct FPointer& InItemInfoData);
	bool CheckItemActionRestriction();
	bool CheckVoluntaryActionRestriction(bool bShowSysMsg);
	bool CheckSkillRestriction(int InSkillCid);
	bool IsSkillCoolDown(int InSkillCid);
	bool CheckSkillCoolDown(int InSkillCid);
	bool CheckSkillLevel(int InCombatCid);
	void DoChargeSkillReleaseActionCommand(int InSkillCid);
	void DoUseAddCompanionItemActionCommand(int InItemSid, int InItemCid);
	void DoUseCraftMaterialItemActionCommand(int InItemCid);
	void DoUseQuestItemActionCommand(int InItemCid);
	void DoUseRepairItemActionCommand(int InItemCid);
	void DoUseItemActionCommand(int InItemSid, int InItemCid, int InTargetID);
	void DoVoluntaryActionCommand(int Cid, bool bStart);
	void ExecutePointAreaSkillByItem(const struct FVector& InPointLocation);
	void ExecutePointAreaSkill(int InSkillCombatCid, const struct FVector& InPointLocation);
	void ExecuteSkill(int Cid, int InSkillTargetID, bool bAutoFiring);
	void DoSkillActionCommand(int Cid, bool bUsePending, int InSkillTargetID, bool bAutoFiring);
	void DoSkillActionCommand_InPIE(int Cid);
	void RPC_TOUCH_DOOR(int DoorID, bool bOpen);
	void RPC_SERVER_MOUNT_ACTIVE_SKILL_ACTION_REQUEST_END_REP(int a_SkillCid);
	void RPC_SERVER_MOUNT_ACTIVE_SKILL_ACTION_REQUEST_REP(int a_SkillCid);
	void RPC_SERVER_END_SPRINT_REP(bool bUseOutDelayCount);
	void RPC_SERVER_START_SPRINT_REQ();
	void RPC_SKILL_CANCEL();
	void RPC_SERVER_CHAT(const struct FString& msg, TEnumAsByte<EChatChannel> Channel);
	void RPC_CHANGE_STATE_SHEATHE(bool InIsSheathe);
	void RPC_POSE_ACTION_REQ(TEnumAsByte<ECEStatePoseType> InPoseType, bool InStandingForce);
	void RPC_SERVER_CHANGE_WEAPON_STATUS(TEnumAsByte<EBLWeaponStatus> a_Status);
	void RPC_SERVER_CHANGE_CHAR_STATUS(TEnumAsByte<EBLCombatStatus> a_Status, bool a_bForce);
	void RPC_SERVER_SKILL_ACTION_TO_TARGET(int InSkillCombatCid, int InTargetID, const struct FVector& InTargetLocation, bool InExplicitInput);
	void RPC_SERVER_SKILL_ACTION_TO_TARGET_LOCATION(int a_SkillCombatCid, const struct FVector& a_vTargetLocation);
	void RPC_SERVER_SKILL_ACTION_TO_TARGET_PAWN(int a_SkillCombatCid, int a_TargetID, bool a_AutoFiring);
	void RPC_SERVER_CANCEL_PC_TRACKING();
	void RPC_SERVER_MOVE_TO_LOCATION_ACK(TEnumAsByte<EMoveToAckReason> a_Reason);
	void RPC_SERVER_MOVE_TO_TARGET_ACK(TEnumAsByte<EMoveToAckReason> a_Reason);
	void RPC_SERVER_USEITEM_CID(int a_itemCID, int a_TargetID);
	void RPC_SERVER_USEITEM(int a_itemID, int a_TargetID);
	void RPC_SERVER_ACTION(int a_TargetID);
	void RPC_SERVER_MOVE(const struct FVector& a_Location, const struct FVector& a_Velocity, bool bJump, bool bForceSync);
	int GetSkillCidByCombatCid(int InCombatCid);
	void InitGameSystemWidget();
	void InitComponent();
	void RegisterCustomPlayerDataStores();
	void ShowHUD(bool bShow);
	void ShowCursorByUI(bool bShow);
	void FadeScreen(bool bFadeOut, float FadeTime, bool Continuous);
	void FadeOutClientScreen(float FadeTime, bool bFadeUI, bool bFadeCursor, bool bFadeSound);
	void FadeInClientScreen(float FadeTime, bool bFadeUI, bool bFadeCursor, bool bFadeSound);
	void FadeClientScreen(bool bFadeOut, float FadeTime, bool bFadeUI, bool bFadeCursor, bool bFadeSound);
	void ResetCameraMode();
	void SpawnPlayerCameraByParamClass(class UClass* CamClass);
	void SetIgnoreLookInput(bool bInIgnoreLookInput);
	void SetIgnoreMoveInput(bool bInIgnoreMoveInput);
	void SpawnPlayerCamera();
	void CheckTouchingDoor();
	void EnterStartState();
	void Restart(bool bVehicleTransition);
	void SetTargetingMode(TEnumAsByte<EBLTargetingMode> InTargetingMode);
	void SetUseFitBounds(bool bUse);
	void UnPossess();
	void Possess(class APawn* inPawn, bool bVehicleTransition);
	void SetLocalPawn(class ABLPawn* InLocalPawn);
	void ResetTouchingActor();
	void CreatePlayer();
	void OnChangedTarget(int InTargetID);
	void NotifyCheckTargetUpdate(int InTargetServerID);
	void SetFriendlyAutoTargetID(int InNewTargetId);
	void SetHostileAutoTargetID(int InNewTargetId);
	void ResetAutoTarget();
	bool CanUsePlayerViewInCinematic();
	void StopCinematicPlay();
	void PlayCinematic(class ULevelStreamingBlessCinematic* StreamingLevel);
	void CancelNormalAttack();
	void DoNormalAttack(int InTargetID);
	void InteractTarget(int InTargetID);
	bool ChangeTarget(int InTargetID, bool IsTabOrdering);
	void DoLookBack();
	void LockOnTargeting(bool InIsLockOn);
	void ToggleLockOnTarget();
	void ToggleRun();
	void DoJump();
	void ActionToTarget(bool bPress);
	void ToggleNormalAttack();
	void AssistTarget();
	void ChangePrevTarget();
	void FreeMoveTargetDecal(bool T);
	void PlayerTick(float DeltaTime);
	void ToggleSitDown();
	class UActionMappingManager* GetActionMappingManager();
	void OnDetachCarryObject();
	void OnPutDownAnimEnd();
	void OnPickUpAnimEnd();
	void EndCarry();
	void PutDownCarryObject(bool bSuccess);
	void DropCarryObject();
	void PickUpCarryObject();
	void ClearCurrentPickedActor();
	void HideTooltip();
	void ShowTooltip(class ABLPawnBase* TargetPawn);
	void UpdateFriendlyAutoTarget(int InPrevTargetSid);
	void OnChangedFriendlyAutoTarget(int InPrevTargetSid);
	void UpdateAutoTargetEffect(int InPrevTargetSid);
	void OnChangedHostileAutoTarget(int PreviousTargetSID);
	void OnChangedPickedPawn(class ABLPawnBase* CurrentPickedPawn, class ABLPawnBase* PreviousPickedPawn);
	int GetCurrentSkillID();
	void CompleteLevelLoading();
	class UBLNetHandlerBase* GetNetHandler();
	class UBLUIPlayer* GetTestUI();
	void NewLog(const struct FString& msg);
	void IgnoreMoveInput(bool bNewMoveInput);
	bool IsPawnRotationLocked();
	void SetPawnRotationLock(bool IsLock);
	bool NotifyLanded(const struct FVector& HitNormal, class AActor* FloorActor);
	void PlayerSkillCanceled();
	void PlayerSkillFired();
};


// Class BLGame.BLPointAreaComponent
// 0x0044 (0x00B4 - 0x0070)
class UBLPointAreaComponent : public UComponent
{
public:
	class ABLDecalActor*                               OuterDecalActor;                                          // 0x0070(0x0008)
	class ABLDecalActor*                               PointDecalActor;                                          // 0x0078(0x0008)
	class ABLDecalActor*                               AroundDecalActor;                                         // 0x0080(0x0008)
	struct FVector                                     PointLocation;                                            // 0x0088(0x000C)
	float                                              PointRadius;                                              // 0x0094(0x0004)
	float                                              AroundRadius;                                             // 0x0098(0x0004)
	float                                              PointDecalSize;                                           // 0x009C(0x0004)
	float                                              OuterDecalSize;                                           // 0x00A0(0x0004)
	float                                              AroundDecalSize;                                          // 0x00A4(0x0004)
	unsigned long                                      bRecentEnable : 1;                                        // 0x00A8(0x0004)
	unsigned long                                      bRecentCorrectRange : 1;                                  // 0x00A8(0x0004)
	unsigned long                                      bRecentCorrectLOS : 1;                                    // 0x00A8(0x0004)
	class UParticleSystemComponent*                    PointPSC;                                                 // 0x00AC(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLPointAreaComponent");
		return ptr;
	}


	void UpdatePointPSCLocation(const struct FVector& InLocation);
	void OnParticleSystemFinished(class UParticleSystemComponent* InPSC);
	void UpdateSize(float InPointRadius, float InAroundRadius);
	void UpdatePointLocation(const struct FVector& InLocation);
	void UpdatePointAreaData(const struct FVector& InLocation, float InCheckDistance, float InNearDistance, float InFarDistance, float InPointRadius, float InAroundRadius);
	void SetEnable(bool bEnable, bool bCorrectRange);
};


// Class BLGame.BLRevivalPoint
// 0x001C (0x026C - 0x0250)
class ABLRevivalPoint : public AActor
{
public:
	unsigned long                                      bStickToTerrain : 1;                                      // 0x0250(0x0004) (Edit)
	struct FString                                     RevivalPointName;                                         // 0x0254(0x0010) (Edit, NeedCtorLink)
	class UBLRevivalPointRenderingComponent*           RenderingComp;                                            // 0x0264(0x0008) (ExportObject, Transient, Component, EditInline)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLRevivalPoint");
		return ptr;
	}

};


// Class BLGame.BLRevivalPointRenderingComponent
// 0x0008 (0x0240 - 0x0238)
class UBLRevivalPointRenderingComponent : public UPrimitiveComponent
{
public:
	struct FName                                       SpriteCategoryName;                                       // 0x0238(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLRevivalPointRenderingComponent");
		return ptr;
	}

};


// Class BLGame.BLShortLivedWindPointSource
// 0x0018 (0x0270 - 0x0258)
class ABLShortLivedWindPointSource : public AWindPointSource
{
public:
	float                                              Lifetime;                                                 // 0x0258(0x0004)
	float                                              VanishingTime;                                            // 0x025C(0x0004)
	float                                              ElapsedTime;                                              // 0x0260(0x0004) (Transient)
	float                                              OriginStrength;                                           // 0x0264(0x0004) (Transient)
	float                                              OriginSpeed;                                              // 0x0268(0x0004) (Transient)
	float                                              OriginRadius;                                             // 0x026C(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLShortLivedWindPointSource");
		return ptr;
	}

};


// Class BLGame.BLShortLivedWindPointSourceComponent
// 0x0018 (0x00DC - 0x00C4)
class UBLShortLivedWindPointSourceComponent : public UWindPointSourceComponent
{
public:
	float                                              Lifetime;                                                 // 0x00C4(0x0004) (Edit)
	float                                              ElapsedTime;                                              // 0x00C8(0x0004) (Transient)
	float                                              VanishingTime;                                            // 0x00CC(0x0004) (Edit)
	float                                              OriginStrength;                                           // 0x00D0(0x0004) (Transient)
	float                                              OriginSpeed;                                              // 0x00D4(0x0004) (Transient)
	float                                              OriginRadius;                                             // 0x00D8(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLShortLivedWindPointSourceComponent");
		return ptr;
	}

};


// Class BLGame.BLTamingManager
// 0x007C (0x00DC - 0x0060)
class UBLTamingManager : public UObject
{
public:
	int                                                TamingItemCid;                                            // 0x0060(0x0004)
	int                                                TamingTargetSid;                                          // 0x0064(0x0004)
	int                                                TargetIconIndex;                                          // 0x0068(0x0004)
	int                                                CurrentGameCid;                                           // 0x006C(0x0004)
	int                                                CurrentStage;                                             // 0x0070(0x0004)
	int                                                TotalStage;                                               // 0x0074(0x0004)
	int                                                SafeZoneSize;                                             // 0x0078(0x0004)
	int                                                TotalPlayTime;                                            // 0x007C(0x0004)
	float                                              BarSpeed;                                                 // 0x0080(0x0004)
	float                                              BarStopTime;                                              // 0x0084(0x0004)
	TArray<int>                                        SafeZoneList;                                             // 0x0088(0x0010) (NeedCtorLink)
	TArray<int>                                        SuccessIndexList;                                         // 0x0098(0x0010) (NeedCtorLink)
	unsigned long                                      IsCriticalGame : 1;                                       // 0x00A8(0x0004)
	struct FTamingMiniGameData                         CachingTamingMiniGameData;                                // 0x00AC(0x0030) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLTamingManager");
		return ptr;
	}


	void EndTamingCriticalBGM();
	void EndTamingBGM();
	void PlayTamingFailed();
	void PlayTamingSuccess();
	void PlayTamingInputMiss();
	void PlayTamingInputSuccess();
	void PlayTamingCriticalBGM();
	void PlayTamingBGM();
	void PlayTamingCriticalStart();
	void PlayTamingStart();
	void ReceiveTamingResult(TArray<struct FV2MPFItemData> InResultItemList, const struct FMPFRandomData& InResultMPData);
	void ReceiveTamingStartPacket();
	void SetTamingData(const struct FTamingMiniGameData& InMiniGameData);
	void SendCancelTaming();
	void SendResultInputList();
	void SendTamingGameHitSuccess();
	void ShowTamingResult();
	void UpdateTamingGameUI();
	void ClearGameData();
	void EndTamingGame(TEnumAsByte<ETamingEndState> InTamingEndState);
	void OnHitFailed();
	void OnHitSuccess(int InIndex);
	void PressedCancelKey();
	void PressedTamingKey();
	void StartTamingSession();
	void Init();
};


// Class BLGame.BLTcpClient
// 0x004C (0x00AC - 0x0060)
class UBLTcpClient : public UObject
{
public:
	struct FPointer                                    Socket;                                                   // 0x0060(0x0008) (Native, Transient)
	unsigned long                                      bIsInTick : 1;                                            // 0x0068(0x0004)
	unsigned long                                      bWantsDeferredDestroy : 1;                                // 0x0068(0x0004)
	TEnumAsByte<EBLTCPClientState>                     ClientState;                                              // 0x006C(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x006D(0x0003) MISSED OFFSET
	float                                              RequestTimeout;                                           // 0x0070(0x0004) (Config)
	float                                              PingFrequencyTime;                                        // 0x0074(0x0004) (Config)
	float                                              RequestElapsedTime;                                       // 0x0078(0x0004)
	float                                              SendElapsedTime;                                          // 0x007C(0x0004)
	struct FDouble                                     StatUpdateTime;                                           // 0x0080(0x0008) (Transient)
	int                                                InBytes;                                                  // 0x0088(0x0004) (Transient)
	int                                                OutBytes;                                                 // 0x008C(0x0004) (Transient)
	int                                                InPackets;                                                // 0x0090(0x0004) (Transient)
	int                                                OutPackets;                                               // 0x0094(0x0004) (Transient)
	int                                                RttCheckKey;                                              // 0x0098(0x0004) (Native, Transient)
	struct FDouble                                     RttCheckStartTime;                                        // 0x009C(0x0008) (Native, Transient)
	int                                                PingTime;                                                 // 0x00A4(0x0004) (Transient)
	int                                                MaxPingTime;                                              // 0x00A8(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLTcpClient");
		return ptr;
	}


	void DestroyBLClient();
	void OnBLTcpClientClose();
	void OnBLTcpClientConnectionComplete(TEnumAsByte<EBLClientConnectionResult> ConnectionResult);
	void ServerConnectionErr(TEnumAsByte<EBLClientConnectionErrorState> Err, int arg1, int arg2);
};


// Class BLGame.BLTeleportManager
// 0x002C (0x008C - 0x0060)
class UBLTeleportManager : public UObject
{
public:
	class UBlessLocalPlayer*                           LP;                                                       // 0x0060(0x0008)
	TArray<struct FCustomWaypointData>                 CustomWaypointDataList;                                   // 0x0068(0x0010) (NeedCtorLink)
	TArray<int>                                        WaypointDataList;                                         // 0x0078(0x0010) (NeedCtorLink)
	int                                                UseItem;                                                  // 0x0088(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLTeleportManager");
		return ptr;
	}


	void TeleportToCustomWaypoint(int UseItemCid, int InCid);
	void TeleportToWaypoint(int UseItemCid, int InCid);
	void OpenUnregistCustomWaypointUI(int InCid);
	void OpenRegistCustomWaypointUI(int UseItemCid, int InCid);
	void OpenTeleportConformUI(int InCid, bool InIsCustomWaypoint);
	void CloseTeleportUI();
	void OpenTeleportUI(int InUseItemCid, TArray<int>* InWaypointDataList);
	bool GetCustomWaypointData(int InCid, struct FCustomWaypointData* OutData);
	void GetCustomWaypointDataList(TArray<struct FCustomWaypointData>* outDataList);
	void GetWaypointDataList(TArray<int>* outDataList);
	void Initialize(class UBlessLocalPlayer* InLP);
	void UnRegistCustomWaypoint(int InCustomWaypointUID);
	void RegistCustomWaypoint(struct FCustomWaypointData* InData);
	void InitCustomWaypointList(TArray<struct FCustomWaypointData>* InInitDataList);
};


// Class BLGame.BLTransportActor
// 0x0260 (0x0520 - 0x02C0)
class ABLTransportActor : public ASkeletalMeshActor
{
public:
	class UBLTransportRoute*                           CurrentRoute;                                             // 0x02C0(0x0008) (Transient)
	float                                              PrevTripTime;                                             // 0x02C8(0x0004) (Transient)
	float                                              CurrentTripTime;                                          // 0x02CC(0x0004) (Transient)
	unsigned long                                      bIsCarryLocalPlayer : 1;                                  // 0x02D0(0x0004) (Transient)
	unsigned long                                      bIsInWarp : 1;                                            // 0x02D0(0x0004) (Transient)
	unsigned long                                      bIsLoadingLevel : 1;                                      // 0x02D0(0x0004) (Transient)
	unsigned long                                      bCanSafeClear : 1;                                        // 0x02D0(0x0004) (Transient)
	unsigned long                                      bIsCanceled : 1;                                          // 0x02D0(0x0004) (Transient)
	unsigned long                                      bIsOnWorldIn : 1;                                         // 0x02D0(0x0004) (Transient)
	unsigned long                                      bIsStarted : 1;                                           // 0x02D0(0x0004) (Transient)
	unsigned long                                      bCollectedStreamingLevelsToLandWaypoint : 1;              // 0x02D0(0x0004) (Transient)
	unsigned long                                      bInterpCameraLocation : 1;                                // 0x02D0(0x0004) (Transient)
	unsigned long                                      bMatineeCameraMode : 1;                                   // 0x02D0(0x0004) (Transient)
	unsigned long                                      bDrawDebugLandingLocation : 1;                            // 0x02D0(0x0004) (Config)
	class UBLAnimTransportRoute*                       TransportAnimNode;                                        // 0x02D4(0x0008) (Transient)
	class UBLAnimTransportRoute*                       PassengerAnimNode;                                        // 0x02DC(0x0008) (Transient)
	class UAnimNodeSequence*                           TemporaryAnimNodeForAnimNotify;                           // 0x02E4(0x0008) (Transient)
	class ABLPawn*                                     Passenger;                                                // 0x02EC(0x0008) (Transient)
	class UAnimTree*                                   PassengerAnimTreeTemplate;                                // 0x02F4(0x0008)
	float                                              WarpInBlendTime;                                          // 0x02FC(0x0004) (Config)
	float                                              WarpInCountDown;                                          // 0x0300(0x0004) (Transient)
	float                                              WarpOutTime;                                              // 0x0304(0x0004) (Transient)
	struct FBLEnvVolumeSettings                        DefaultEnvVolumeSettings;                                 // 0x0308(0x0170) (Config, Component, NeedCtorLink)
	class ABLEnvPPVolume*                              TransportVolume;                                          // 0x0478(0x0008) (Transient)
	class UParticleSystemComponent*                    CloudEffect;                                              // 0x0480(0x0008) (ExportObject, Transient, Component, EditInline)
	struct FRotator                                    AutoCameraTarget;                                         // 0x0488(0x000C) (Config)
	float                                              AutoCameraBlendSpeedMax;                                  // 0x0494(0x0004) (Config)
	float                                              AutoCameraBlendExponential;                               // 0x0498(0x0004) (Config)
	float                                              SecondsAfterAutoCameraBlend;                              // 0x049C(0x0004) (Transient)
	float                                              RollingMaxAngle;                                          // 0x04A0(0x0004) (Config)
	float                                              YawingMaxVelocity;                                        // 0x04A4(0x0004) (Config)
	struct FVector                                     InterpVelocity;                                           // 0x04A8(0x000C) (Transient)
	struct FVector                                     PrevCheckPoint;                                           // 0x04B4(0x000C) (Transient)
	class UParticleSystem*                             WarpCloudParticle;                                        // 0x04C0(0x0008) (Transient)
	struct FVector                                     PrevLocation;                                             // 0x04C8(0x000C) (Transient)
	struct FRotator                                    SmoothlyRotate;                                           // 0x04D4(0x000C) (Transient)
	struct FVector                                     DispMatineeCameraToOriginalCamera;                        // 0x04E0(0x000C) (Transient)
	struct FVector                                     InterpolatedDispMatineeCameraToOriginalCamera;            // 0x04EC(0x000C) (Transient)
	struct FVector                                     CameraToPawnDisp;                                         // 0x04F8(0x000C) (Transient)
	float                                              RetCamDelayAccTimeForTransport;                           // 0x0504(0x0004) (Transient)
	float                                              RetCamDelayTimeForTransport;                              // 0x0508(0x0004) (Config)
	float                                              RetCamDelayTimeForGetOffTransport;                        // 0x050C(0x0004) (Config)
	float                                              CamFocusInterpVelocity;                                   // 0x0510(0x0004) (Transient)
	float                                              CamFocusInterpVelocityForGetOnTransport;                  // 0x0514(0x0004) (Config)
	float                                              CamFocusInterpVelocityForTransport;                       // 0x0518(0x0004) (Config)
	float                                              CamFocusInterpVelocityRetMatineeForTransport;             // 0x051C(0x0004) (Config)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLTransportActor");
		return ptr;
	}


	void PreBeginPlay();
	void InitResource();
	bool ReAboard(class ABLPawn* Pawn);
	bool Aboard(class ABLPawn* Pawn);
};


// Class BLGame.BLTransportActorFlyingBoat
// 0x0000 (0x0520 - 0x0520)
class ABLTransportActorFlyingBoat : public ABLTransportActor
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLTransportActorFlyingBoat");
		return ptr;
	}


	void InitResource();
};


// Class BLGame.BLTransportActorGondola
// 0x0000 (0x0520 - 0x0520)
class ABLTransportActorGondola : public ABLTransportActor
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLTransportActorGondola");
		return ptr;
	}


	void InitResource();
};


// Class BLGame.BLTransportActorWyvern
// 0x0000 (0x0520 - 0x0520)
class ABLTransportActorWyvern : public ABLTransportActor
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLTransportActorWyvern");
		return ptr;
	}


	void InitResource();
};


// Class BLGame.BLTransportRoute
// 0x0118 (0x0178 - 0x0060)
class UBLTransportRoute : public UObject
{
public:
	class ABLTransportWaypoint*                        DepartureWaypoint;                                        // 0x0060(0x0008)
	class ABLTransportWaypoint*                        ArrivalWaypoint;                                          // 0x0068(0x0008)
	struct FName                                       DepartureWaypointName;                                    // 0x0070(0x0008) (Edit, EditConst)
	struct FName                                       ArrivalWaypointName;                                      // 0x0078(0x0008) (Edit, EditConst)
	struct FTransportRouteInfoUC                       RouteInfo;                                                // 0x0080(0x0058) (Edit, NeedCtorLink)
	unsigned long                                      bUsable : 1;                                              // 0x00D8(0x0004) (Edit)
	struct FInterpCurveVector                          RoutePath;                                                // 0x00DC(0x0014) (Edit, NeedCtorLink)
	TArray<struct FRotationAdjustInfo>                 Rotations;                                                // 0x00F0(0x0010) (Edit, NeedCtorLink)
	TArray<struct FCrossingLevelsInfo>                 CrossingLevels;                                           // 0x0100(0x0010) (Edit, EditConst, NeedCtorLink)
	struct FInterpCurveVector                          CamRelativeLocations;                                     // 0x0110(0x0014) (Edit, NeedCtorLink)
	struct FInterpCurveVector                          CamRelativeRotations;                                     // 0x0124(0x0014) (Edit, NeedCtorLink)
	TArray<struct FTransportRouteAnimEvent>            Animations;                                               // 0x0138(0x0010) (Edit, NeedCtorLink)
	TArray<struct FTransportRouteAnimEvent>            PassengerAnimations;                                      // 0x0148(0x0010) (Edit, NeedCtorLink)
	TArray<struct FTransportRouteEffectEvent>          EffectEvents;                                             // 0x0158(0x0010) (Edit, NeedCtorLink)
	TArray<struct FTransportRouteWarpEvent>            WarpEvents;                                               // 0x0168(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLTransportRoute");
		return ptr;
	}

};


// Class BLGame.BLTransportRouteTaxi
// 0x0000 (0x0178 - 0x0178)
class UBLTransportRouteTaxi : public UBLTransportRoute
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLTransportRouteTaxi");
		return ptr;
	}

};


// Class BLGame.BLTransportWaypoint
// 0x006C (0x02BC - 0x0250)
class ABLTransportWaypoint : public AActor
{
public:
	struct FWaypointInfoUC                             WaypointInfo;                                             // 0x0250(0x0054) (Edit, NeedCtorLink)
	TArray<class UBLTransportRoute*>                   Routes;                                                   // 0x02A4(0x0010) (Edit, NeedCtorLink, NoClear, EditInline, EditInlineUse)
	class USpriteComponent*                            IconOnEditor;                                             // 0x02B4(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLTransportWaypoint");
		return ptr;
	}


	class UBLTransportRoute* ChangeRouteClass(class UBLTransportRoute* PrevRoute, class UClass* RouteClass);
	class UBLTransportRoute* AddRoute(class ABLTransportWaypoint* Destination, class UClass* RouteClass);
	class UBLTransportRoute* FindRoute(class ABLTransportWaypoint* Destination);
};


// Class BLGame.BLTransportWaypoint_WyvernPlatform
// 0x0000 (0x02BC - 0x02BC)
class ABLTransportWaypoint_WyvernPlatform : public ABLTransportWaypoint
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLTransportWaypoint_WyvernPlatform");
		return ptr;
	}


	class UBLTransportRoute* AddRoute(class ABLTransportWaypoint* Destination, class UClass* RouteClass);
};


// Class BLGame.BLTransportWaypointComponent
// 0x0004 (0x023C - 0x0238)
class UBLTransportWaypointComponent : public UPrimitiveComponent
{
public:
	float                                              PathResolution;                                           // 0x0238(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLTransportWaypointComponent");
		return ptr;
	}

};


// Class BLGame.BLWorldMapWaypointManager
// 0x00C4 (0x0124 - 0x0060)
class UBLWorldMapWaypointManager : public UObject
{
public:
	int                                                DepartureID;                                              // 0x0060(0x0004)
	int                                                Ticket;                                                   // 0x0064(0x0004)
	TArray<int>                                        ArriveIDs;                                                // 0x0068(0x0010) (NeedCtorLink)
	struct FMap_Mirror                                 Cached_Available_Route_Map;                               // 0x0078(0x0048) (Native)
	struct FMap_Mirror                                 Cached_Available_Element_Map;                             // 0x00C0(0x0048) (Native)
	TArray<int>                                        RequestRouteIds;                                          // 0x0108(0x0010) (NeedCtorLink)
	struct FDestinationData                            Dest_Data;                                                // 0x0118(0x000C)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLWorldMapWaypointManager");
		return ptr;
	}


	void DepartToDestination();
	void SetDestinationData(int InDest_id, const struct FLONGLONGWrapper& InGameGuardValueWrapper);
	bool RouteInfo(class ABLWorldMapWaypointInfo* Info, struct FString* Cost);
	void InitializeWaypointElements(TArray<class ABLWorldMapElement*>* WorldMapElements);
};


// Class BLGame.BoneDeformationTemplate
// 0x0058 (0x00B8 - 0x0060)
class UBoneDeformationTemplate : public UObject
{
public:
	TArray<struct FBoneDeformingPartsInfo>             DeformInfoList;                                           // 0x0060(0x0010) (Edit, Const, NeedCtorLink)
	unsigned char                                      UnknownData00[0x48];                                      // 0x0070(0x0048) UNKNOWN PROPERTY: MapProperty BLGame.BoneDeformationTemplate.DeformInfoMap

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BoneDeformationTemplate");
		return ptr;
	}


	bool HasScaleValueInDeformInfoList(int Index);
	struct FString GetLocalizedPropertyName(TEnumAsByte<EBoneDeformPart> DeformPart);
	struct FString GetLocalizedCategoryName(TEnumAsByte<EBoneDeformPart> DeformPart);
	float ByteToScale(TEnumAsByte<EBoneDeformPart> DeformPart, unsigned char B);
	unsigned char ScaleToByte(TEnumAsByte<EBoneDeformPart> DeformPart, float F);
	float ScaleToValue(TEnumAsByte<EBoneDeformPart> DeformPart, float Scale);
	float ValueToScale(TEnumAsByte<EBoneDeformPart> DeformPart, float Value);
};


// Class BLGame.BodyBoneDeformationTemplate
// 0x0000 (0x00B8 - 0x00B8)
class UBodyBoneDeformationTemplate : public UBoneDeformationTemplate
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BodyBoneDeformationTemplate");
		return ptr;
	}

};


// Class BLGame.HeadBoneDeformationTemplate
// 0x0000 (0x00B8 - 0x00B8)
class UHeadBoneDeformationTemplate : public UBoneDeformationTemplate
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.HeadBoneDeformationTemplate");
		return ptr;
	}

};


// Class BLGame.CinematicReadyQueueData
// 0x000C (0x006C - 0x0060)
class UCinematicReadyQueueData : public UObject
{
public:
	class ULevelStreamingBlessCinematic*               StreamingLevel;                                           // 0x0060(0x0008)
	float                                              RequestTime;                                              // 0x0068(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CinematicReadyQueueData");
		return ptr;
	}

};


// Class BLGame.CinematicOnlineReadyQueueData
// 0x0008 (0x0074 - 0x006C)
class UCinematicOnlineReadyQueueData : public UCinematicReadyQueueData
{
public:
	int                                                PawnServerID;                                             // 0x006C(0x0004)
	float                                              pos;                                                      // 0x0070(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CinematicOnlineReadyQueueData");
		return ptr;
	}

};


// Class BLGame.CinematicOnlineSeekReadyQueueData
// 0x0000 (0x0074 - 0x0074)
class UCinematicOnlineSeekReadyQueueData : public UCinematicOnlineReadyQueueData
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CinematicOnlineSeekReadyQueueData");
		return ptr;
	}

};


// Class BLGame.ClikWidgetBase
// 0x0008 (0x00B8 - 0x00B0)
class UClikWidgetBase : public UGFxClikWidget
{
public:
	class UBLUIPlayer*                                 UIPlayer;                                                 // 0x00B0(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.ClikWidgetBase");
		return ptr;
	}


	void Init(class UBLUIPlayer* BLUIPlayer);
};


// Class BLGame.GFxUI_PopupMenu
// 0x0028 (0x00E0 - 0x00B8)
class UGFxUI_PopupMenu : public UClikWidgetBase
{
public:
	class UClikWidgetBase*                             PopupMenuWidget;                                          // 0x00B8(0x0008)
	class UGFxObject*                                  PopupOwner;                                               // 0x00C0(0x0008)
	TEnumAsByte<EPopupMenuType>                        PopupMenuType;                                            // 0x00C8(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x00C9(0x0003) MISSED OFFSET
	int                                                PopupIntValue;                                            // 0x00CC(0x0004)
	struct FString                                     PopupStringValue;                                         // 0x00D0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.GFxUI_PopupMenu");
		return ptr;
	}


	bool WidgetUnloaded(const struct FName& WidgetName, const struct FName& WidgetPath, class UGFxObject* Widget);
	bool WidgetInitialized(const struct FName& WidgetName, const struct FName& WidgetPath, class UGFxObject* Widget);
	struct FString GetPartyRaidPopupMenuName(TEnumAsByte<EPopupMenuItem> InMenuItem);
	void RequestPartyToRaid(TEnumAsByte<EPopupMenuItem> RaidType);
	void SelectEquipHand_Costume_Weapon_PopupMenuHandler(const struct FEventData& ev);
	void SelectEquipHand_Ring_PopupMenuHandler(const struct FEventData& ev);
	void SelectEquipHand_Weapon_PopupMenuHandler(const struct FEventData& ev);
	void WorldMapAutoPathPopupMenuHandler(const struct FEventData& ev);
	void OpenerAvailablePopupMenuHandler(const struct FEventData& ev);
	void PartyRaidPopupMenuHandler(TEnumAsByte<EPopupMenuItem> InSelectedPopupMenuItem, int InTargetSid, const struct FString& InStringVaule);
	void RaidMemberPopupMenuHandler(const struct FEventData& ev);
	void RaidFramePopupMenuHandler(const struct FEventData& ev);
	void BlockListPopupMenuHandler(const struct FEventData& ev);
	void FriendPopupMenuHandler(const struct FEventData& ev);
	void CloseFriendPopupMenu();
	void TalkerNamePopupMenuHandler(const struct FEventData& ev);
	void TeleportPopupMenuHandler(const struct FEventData& ev);
	void MailBoxPopupMenuHandler(const struct FEventData& ev);
	void GuildPopupMenuHandler(const struct FEventData& ev);
	void PartyPopupMenuHandler(const struct FEventData& ev);
	void TargetSignPopupMenuHandler(TEnumAsByte<EPopupMenuItem> InPopupMenuItem, int InTargetSid);
	void TargetPopupMenuHandler(const struct FEventData& ev);
	void PCPopupMenuHandler(const struct FEventData& ev);
	void PopupMenuHandler(const struct FEventData& ev);
	void ShowSelectEquipHandPopup_Costume_Weapon(int InItemSid);
	void ShowSelectEquipHandPopup_Ring(int InItemSid);
	void ShowSelectEquipHandPopup_Weapon(int InItemSid);
	void CloseWorldMapAutoPathPopupMenu();
	void ShowWorldMapAutoPathPopup(bool bIsAutoPathMode, bool bIsOnDestinationIcon);
	void ShowOpenerAvailablePopup(const struct FString& OpenerType, bool IsAdd);
	void ShowRaidMemberPopupMenu(int InPartyID, int InMemberIndex, const struct FString& InMemberSID);
	void ShowRaidFramePopupMenu(int InPartyID);
	void ShowBlockPopupMenu(const struct FString& InPlayerName);
	void ShowTalkerPopupMenu(int InTalkerSid, const struct FString& InTalkerName, bool IsInviteToParty, bool IsFriend, bool IsBlock);
	void ShowFriendPopupMenu(const struct FString& InFriendUID);
	void ShowTeleportPopup(int TeleportCid);
	bool ShowMailBoxPopup(TEnumAsByte<EMailBoxState> State, int MailIndex);
	bool ShowGuildPopupMenu(const struct FString& CharacterName, bool isIntroduce, bool isLeave, bool isRemove, bool IsLeader, bool isSecond_Position, bool isThird_Position, bool isFourth_Postion, bool isFifth_Position, bool isAddFriend, bool isAddParty);
	bool ShowPartyPopupMenu(class UGFxObject* PopupOwnerObject);
	void AddTargetSignPopupMenuItem(int TargetSId, bool OnlyShowAuthority, TArray<TEnumAsByte<EPopupMenuItem>>* outMenuItemList);
	bool ShowTargetPopupMenu(class UGFxObject* PopupOwnerObject);
	void AddPartyPopupMenu(bool InPlayerState_Raid, bool InPlayerState_Party, bool InPlayerState_PartyLeader, bool InTargetState_Me, bool InTargetState_Enemy, bool InTargetState_PartyMember, TArray<TEnumAsByte<EPopupMenuItem>>* outMenuItemList);
	bool ShowPCPopupMenu(class UGFxObject* PopupOwnerObject);
	bool IsTitleMenu(TEnumAsByte<EPopupMenuItem> InMenuItem);
	bool IsMenuDisable(TEnumAsByte<EPopupMenuItem> InMenuItem);
	struct FString GetMenuItemName(TEnumAsByte<EPopupMenuItem> PopupMenuItem);
	struct FString GetDistributeMethodItemName(TEnumAsByte<EPartyDistributeMethod> InMethod);
	struct FString GetRollDiceGradeItemName(TEnumAsByte<ECEItemGradeType> InGrade);
	struct FString GetDistributeMethodMenuName();
	struct FString GetRollDiceMenuName();
	struct FString GetDistributeMethodName(TEnumAsByte<EPartyDistributeMethod> InMethod);
	struct FString GetDiceGradeName(TEnumAsByte<ECEItemGradeType> InItemGrade);
	void RequestDungeonInitialization();
	void RequestPrivateTrade(int InTargetSid);
	void CloseTargetPopupMenu();
	class UGFxObject* MakePopupItemDataGFxObjectWithAuthority(TEnumAsByte<EPopupMenuItem> ItemType, bool IsPermit);
	class UGFxObject* MakePopupItemDataGFxObjectEx(const struct FPopupMenuItemData& InItemData);
	class UGFxObject* MakePopupItemDataGFxObject(TEnumAsByte<EPopupMenuItem> ItemType);
	class UGFxObject* MakeSignSubListPopUpGFxData();
	class UGFxObject* MakeSubListPopUpGFxData(int StartIndex, int EndIndex);
	class UGFxObject* GetSubList(TEnumAsByte<EPopupMenuItem> ItemType);
	void UA_PopupMenu_Hide();
	void UA_Hide_PopupMenu();
	void UA_PopupMenu_Show();
	void UA_Show_PopupMenu();
	void OpenPopupMenuEx(TEnumAsByte<EPopupMenuType> MenuType, TArray<struct FPopupMenuItemData> MenuItemList);
	void OpenPopupMenu(TEnumAsByte<EPopupMenuType> MenuType, TArray<TEnumAsByte<EPopupMenuItem>> MenuItemList);
	void Unload();
	void Init(class UBLUIPlayer* Player);
};


// Class BLGame.GFxWidget_RevivalDialog
// 0x0008 (0x00C0 - 0x00B8)
class UGFxWidget_RevivalDialog : public UClikWidgetBase
{
public:
	int                                                RVVDSidExecutor;                                          // 0x00B8(0x0004)
	int                                                RVVDSidTarget;                                            // 0x00BC(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.GFxWidget_RevivalDialog");
		return ptr;
	}


	void UA_Revival_Button_Disable(bool Disable, unsigned char Flags);
	void UA_Update_Revival_Dialog(TEnumAsByte<ERevivalState> RevivalState, class UGFxObject* DialogTexts, TEnumAsByte<EDialogStyle> DialogStyle, TArray<class UGFxObject*> ButtonDatas, int TimeOut, bool IsToken);
	void UA_Close_Revival_Dialog(TEnumAsByte<ERevivalState> RevivalState);
	void UA_Open_Revival_Dialog(TEnumAsByte<ERevivalState> RevivalState, class UGFxObject* DialogTexts, TEnumAsByte<EDialogStyle> DialogStyle, TArray<class UGFxObject*> ButtonDatas, int TimeOut, bool IsToken);
	void RevivalDialogHandler(const struct FEventData& ev);
	class UGFxObject* MakeButtonValue(const struct FString& CodeName, TEnumAsByte<EDialogValue> eValue, bool DisableFlag);
	TArray<class UGFxObject*> GetButtonDataByStyle(TEnumAsByte<EDialogStyle> DialogStyle, unsigned char ButtonFlags);
	void UpdateRevivalDialog(const struct FRevivalDialogData& InData);
	void OpenRevivalDialog(const struct FRevivalDialogData& InData);
	void Unload();
	void Init(class UBLUIPlayer* BLUIPlayer);
};


// Class BLGame.CraftChoiceManager
// 0x0002 (0x0062 - 0x0060)
class UCraftChoiceManager : public UObject
{
public:
	TEnumAsByte<ECraftChoiceUIType>                    CurrentChoiceUIType;                                      // 0x0060(0x0001)
	TEnumAsByte<ECEV2CraftCategoryType>                CurrentSelectedCraft;                                     // 0x0061(0x0001)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CraftChoiceManager");
		return ptr;
	}


	void PlaySkillSelectedSound();
	void PlaySkillSelectSound();
	void PlayCloseSound();
	void PlayOpenSound();
	void OnReceiveCraftSkill();
	void SendSubCategoryChoice(TEnumAsByte<ECEV2CraftCategoryType> InCategoryType);
	void SendMainCategoryChoice(TEnumAsByte<ECEV2CraftCategoryType> InCategoryType);
	void OnClickCategoryChoiceDialog(int InCategoryType);
	void OpenCraftChoiceConfirmDialog(TEnumAsByte<ECEV2CraftCategoryType> InSelectCategory);
	void MakeCraftDetailDataObject(TEnumAsByte<ECEV2CraftCategoryType> InCraftType, class UGFxObject** OutObject);
	void UpdateCraftChoiceUI();
	void OnClickCraftChoiceUI(int InType);
	void OnCloseCraftChoiceUI();
	void OnOpenCraftChoiceUI();
	void CloseSubCategoryChoiceUI();
	void OpenSubCategoryChoiceUI();
	void CloseMainCategoryChoiceUI();
	void OpenMainCategoryChoiceUI();
	void ShowCraftChoiceUI();
};


// Class BLGame.CraftGatherDataManager
// 0x0174 (0x01D4 - 0x0060)
class UCraftGatherDataManager : public UObject
{
public:
	struct FSet_Mirror                                 LearnedRecipeList;                                        // 0x0060(0x0048) (Native)
	struct FSet_Mirror                                 MainCraftList;                                            // 0x00A8(0x0048) (Native)
	struct FSet_Mirror                                 SubCraftList;                                             // 0x00F0(0x0048) (Native)
	struct FSet_Mirror                                 NewRecipeList;                                            // 0x0138(0x0048) (Native)
	TArray<int>                                        MainCraftFavoriteList;                                    // 0x0180(0x0010) (Native, AlwaysInit)
	TArray<int>                                        SubCraftFavoriteList;                                     // 0x0190(0x0010) (Native, AlwaysInit)
	TEnumAsByte<ECEV2CraftCategoryType>                MainCraftCategory;                                        // 0x01A0(0x0001)
	TEnumAsByte<ECEV2CraftCategoryType>                SubCraftCategory;                                         // 0x01A1(0x0001)
	TEnumAsByte<ELivingTabType>                        CurrentStatusTab;                                         // 0x01A2(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x1];                                       // 0x01A3(0x0001) MISSED OFFSET
	int                                                MainCraftLevel;                                           // 0x01A4(0x0004) (Transient)
	int                                                MainCraftExp;                                             // 0x01A8(0x0004) (Transient)
	int                                                SubCraftLevel;                                            // 0x01AC(0x0004) (Transient)
	int                                                SubCraftExp;                                              // 0x01B0(0x0004) (Transient)
	int                                                MiningLevel;                                              // 0x01B4(0x0004) (Transient)
	int                                                MiningExp;                                                // 0x01B8(0x0004) (Transient)
	int                                                PlantsLevel;                                              // 0x01BC(0x0004) (Transient)
	int                                                PlantsExp;                                                // 0x01C0(0x0004) (Transient)
	int                                                TamingLevel;                                              // 0x01C4(0x0004) (Transient)
	int                                                TamingExp;                                                // 0x01C8(0x0004) (Transient)
	unsigned long                                      IsMainCraftLevelInit : 1;                                 // 0x01CC(0x0004) (Transient)
	unsigned long                                      IsMainCraftExpInit : 1;                                   // 0x01CC(0x0004) (Transient)
	unsigned long                                      IsSubCraftLevelInit : 1;                                  // 0x01CC(0x0004) (Transient)
	unsigned long                                      IsSubCraftExpInit : 1;                                    // 0x01CC(0x0004) (Transient)
	unsigned long                                      IsMiningLevelInit : 1;                                    // 0x01CC(0x0004) (Transient)
	unsigned long                                      IsMiningExpInit : 1;                                      // 0x01CC(0x0004) (Transient)
	unsigned long                                      IsPlantsLevelInit : 1;                                    // 0x01CC(0x0004) (Transient)
	unsigned long                                      IsPlantsExpInit : 1;                                      // 0x01CC(0x0004) (Transient)
	unsigned long                                      IsTamingLevelInit : 1;                                    // 0x01CC(0x0004) (Transient)
	unsigned long                                      IsTamingExpInit : 1;                                      // 0x01CC(0x0004) (Transient)
	int                                                CurrentStatusPage;                                        // 0x01D0(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CraftGatherDataManager");
		return ptr;
	}


	void PlayNeedGradeUpSound();
	void PlayAcceptQuestSound();
	void PlayRecipeGetSound();
	void OpenLivingTabByType(TEnumAsByte<ECEV2CraftCategoryType> InCraftType);
	void OpenNeedCraftGradeUpDialog(TEnumAsByte<ECEV2CraftCategoryType> InCraftType);
	void OpenGatherLevelUpDialog(TEnumAsByte<ECEGatherCategoryType> InGatherType, int InFromLevel, int InToLevel);
	void OpenCraftLevelUpDialog(TEnumAsByte<ECEV2CraftCategoryType> InCraftType, int InFromLevel, int InToLevel);
	void RequestSubQuest();
	void RequestMainQuest();
	void OnClickReqQuest(int InCraftType);
	void OnClickPrevPage();
	void OnClickNextPage();
	void UpdateStatusPage();
	void UpdateStatusTab();
	void SetPage(int InPage);
	void SetTab(int InTabType);
	void InitStatusPage();
	void RequestFavoriteDataToServer(int InCraftCId, bool InIsAdd);
	bool IsInSubFavoriteList(int InCid);
	bool IsInMainFavoriteList(int InCid);
	void GetFavoriteList(TEnumAsByte<ECEV2CraftCategoryType> InCategory, TArray<int>* OutList);
	void RemoveSubFavorite(int InCid);
	void AddSubFavorite(int InCid);
	void RemoveMainFavorite(int InCid);
	void AddMainFavorite(int InCid);
	bool IsAcquireSubCraftQuest();
	bool IsAcquireMainCraftQuest();
	bool CheckNeedGradeUpQuest(TEnumAsByte<ECEV2CraftCategoryType> InCraftType, int InLevel, int InCraftExp);
	int GetCraftLevelByType(TEnumAsByte<ECEV2CraftCategoryType> InCategory);
	void UpdateTamingExp(int InExp);
	void UpdateTamingLevel(int InLevel);
	void UpdateTamingLevelExp(int InLevel, int InExp);
	void UpdatePlantsExp(int InExp);
	void UpdateMiningExp(int InExp);
	void UpdatePlantsLevel(int InLevel);
	void UpdateMiningLevel(int InLevel);
	void UpdateSubCraftCategory(TEnumAsByte<ECEV2CraftCategoryType> InCategory);
	void UpdateSubCraftExp(int InExp);
	void UpdateSubCraftLevel(int InLevel);
	void UpdateMainCraftExp(int InExp);
	void UpdateMainCraftLevel(int InLevel);
	void UpdateMainCraftCategory(TEnumAsByte<ECEV2CraftCategoryType> InCategory);
	void DrawGatherExpMessage(TEnumAsByte<ECEGatherCategoryType> InGatherType, int InDeltaExp);
	void DrawCraftExpMessage(TEnumAsByte<ECEV2CraftCategoryType> InCraftType, int InDeltaExp);
	void InitSubCraftStatus(TEnumAsByte<EV2SubCraftType> InCategory, int InLevel, int InExp);
	void InitMainCraftStatus(TEnumAsByte<EV2MainCraftType> InCategory, int InLevel, int InExp);
	void SendAcquireRecipe(int InCid);
	void ClearNewRecipeList();
	void RemoveNewRecipeList(int InCid);
	bool IsLearnRecipe(int InCid);
	bool IsInNewRecipeList(int InCid);
	int GetNewRecipeListCount();
	void GetSubCraftList(TArray<int>* OutCidList);
	void GetMainCraftList(TArray<int>* OutCidList);
	void GetRecipeList(TEnumAsByte<ECEV2CraftCategoryType> InType, TArray<int>* OutCidList);
	void SetSubDefaultCraftList();
	void SetMainDefaultCraftList();
	void ResetSubCraftList();
	void ResetMainCraftList();
	void SetCraftList(TArray<int> InCidList);
	void RemoveRecipe(int InCid);
	void LearnRecipe(int InCid);
	void InitCraftList(TArray<unsigned char> InBitList);
	void Init();
};


// Class BLGame.CraftManager
// 0x0078 (0x00D8 - 0x0060)
class UCraftManager : public UObject
{
public:
	int                                                NPCCraft_npcSid;                                          // 0x0060(0x0004) (Transient)
	int                                                NPCCraft_lastCraftCid;                                    // 0x0064(0x0004) (Transient)
	int                                                NPCCraft_SelectCid;                                       // 0x0068(0x0004) (Transient)
	int                                                NPCCraft_SelectAmount;                                    // 0x006C(0x0004) (Transient)
	int                                                PCCraft_lastCraftCid;                                     // 0x0070(0x0004) (Transient)
	int                                                PCCraft_SelectCid;                                        // 0x0074(0x0004) (Transient)
	int                                                PCCraft_SelectAmount;                                     // 0x0078(0x0004) (Transient)
	unsigned long                                      bNeedUpdatePCCraftListUI : 1;                             // 0x007C(0x0004) (Transient)
	unsigned long                                      bNeedUpdateNPCCraftListUI : 1;                            // 0x007C(0x0004) (Transient)
	unsigned long                                      bNeedUpdatePCCraftItemUI : 1;                             // 0x007C(0x0004) (Transient)
	unsigned long                                      bNeedUpdateNPCCraftItemUI : 1;                            // 0x007C(0x0004) (Transient)
	struct FCraftFilter                                PCCraftFilter;                                            // 0x0080(0x001C)
	struct FCraftFilter                                NPCCraftFilter;                                           // 0x009C(0x001C)
	TArray<int>                                        PCCraftList;                                              // 0x00B8(0x0010) (NeedCtorLink)
	TArray<int>                                        NPCCraftList;                                             // 0x00C8(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CraftManager");
		return ptr;
	}


	void GenerateCraftUIToolTip(TEnumAsByte<ETooltipType> InToolTipType, struct FString* Desc);
	void GetPCCraftTypeSetting(int* OutType, struct FString* OutMainTitleText, struct FString* OutListTitleText);
	void MakePCCraftMaterialList(int CraftCId, int Amount, TArray<class UGFxObject*>* OutMaterialList, class UGFxObject** OutActingData, class UGFxObject** OutExpData);
	void MakePCCraftItemData(int CraftCId, int CraftAmount, class UGFxObject** OutItemData);
	void MakePCCraftList(TArray<class UGFxObject*>* List);
	void RefreshPCCraftList();
	int GetPCCraftPossibleCount(int InCraftCId);
	void MakeNPCCraftMaterialList(int NPCCraftCid, int Amount, TArray<class UGFxObject*>* OutMaterialList, struct FString* OutGold);
	void MakeNPCCraftItemData(int NPCCraftCid, int CraftAmount, class UGFxObject** OutItemData);
	void MakeNPCCraftList(TArray<class UGFxObject*>* List);
	void RefreshNPCCraftList();
	int GetNPCCraftPossibleCount(int InCraftCId);
	void GetEssentialMaterialSearchSetting(int InEssentialMaterialCid, int* MinLevel, int* MaxLevel, TArray<class UGFxObject*>* GradeList, TArray<class UGFxObject*>* Category1, TArray<class UGFxObject*>* Category2);
	void GetDefaultSearchSetting(int* MinLevel, int* MaxLevel, TArray<class UGFxObject*>* GradeList, TArray<class UGFxObject*>* Category1, TArray<class UGFxObject*>* Category2);
	void GetNPCCraftDefaultSearchSetting(int* MinLevel, int* MaxLevel, TArray<class UGFxObject*>* GradeList, TArray<class UGFxObject*>* Category1, TArray<class UGFxObject*>* Category2);
	void GetPCCraftDefaultSearchSetting(int* MinLevel, int* MaxLevel, TArray<class UGFxObject*>* GradeList, TArray<class UGFxObject*>* Category1, TArray<class UGFxObject*>* Category2);
	void Tick();
	void SetNPCCraftPage(int InNewPage);
	void SetPCCraftPage(int InNewPage);
	void SetNPCCraftItemAmount(int inAmount);
	void SetPCCraftItemAmount(int inAmount);
	void SetNPCCraftItemCid(int InCid);
	void SetPCCraftItemCid(int InCid);
	void ResetNPCCraftList();
	void ResetPCCraftList();
	void PlayCloseSound();
	void PlayOpenSound();
	void OnClosedNPCCraftUI();
	void OnOpenedNPCCraftUI();
	void OnClosedPCCraftUI();
	void OnOpenedPCCraftUI();
	void OnUpdatedActingPoint();
	void OnUpdatedContentsToken();
	void OnUpdatedInventoryItem();
	void OnUpdatedCraftExp();
	void OnUpdatedCraftLevel();
	void SendCraft(int InCraftCId, int inAmount);
	void SendNPCCraft(int InCraftCId, int inAmount);
	void InitCraftFiler(int MinLevel, int MaxLevel, struct FCraftFilter* Filter);
	void Initialize();
};


// Class BLGame.DecorationEffectInfo
// 0x0010 (0x0070 - 0x0060)
class UDecorationEffectInfo : public UObject
{
public:
	TArray<struct FDecorationEffect>                   DecorationEffects;                                        // 0x0060(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.DecorationEffectInfo");
		return ptr;
	}

};


// Class BLGame.FlashShop
// 0x006C (0x00CC - 0x0060)
class UFlashShop : public UObject
{
public:
	TArray<struct FFlashShopItemData>                  ServerItemDataList;                                       // 0x0060(0x0010) (NeedCtorLink)
	TArray<int>                                        CategoryList;                                             // 0x0070(0x0010) (NeedCtorLink)
	TArray<struct FFlashShopCategoryItemInfo>          CategoryItemList;                                         // 0x0080(0x0010) (NeedCtorLink)
	int                                                CategoryCid;                                              // 0x0090(0x0004)
	int                                                SelectedPage;                                             // 0x0094(0x0004)
	int                                                MaxPage;                                                  // 0x0098(0x0004)
	struct FFlashShopBuyInfo                           BuyInfo;                                                  // 0x009C(0x0020) (NeedCtorLink)
	unsigned long                                      bInitializedUI : 1;                                       // 0x00BC(0x0004)
	unsigned long                                      bOpenedUI : 1;                                            // 0x00BC(0x0004)
	unsigned long                                      bActivated : 1;                                           // 0x00BC(0x0004)
	unsigned long                                      bNeedUIUpdateCategory : 1;                                // 0x00BC(0x0004)
	unsigned long                                      bNeedUIUpdateCategoryItemList : 1;                        // 0x00BC(0x0004)
	struct FQWord                                      CloseTime;                                                // 0x00C0(0x0008)
	float                                              RemainSeconds;                                            // 0x00C8(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.FlashShop");
		return ptr;
	}


	int GetCurrentLumena();
	int GetProductItemAmount(int InProductCid);
	void OnUpdatedCurrentLumena();
	void OnSelectedPurchaseItemFromDialogUI();
	void OnClickedAddLumenaFromUI();
	void OnClickedPageFromUI(int InPage);
	void OpenPurchaseConfirmDialog(int InItemCount);
	void OnClickedPurchaseAmountFromUI(int InShopProductCid);
	void OnClickedBuyFromUI(int InShopProductCid);
	void OnClosedFromUI();
	void OnOpenedFromUI();
	void OnFinalizedFromUI();
	void OnInitializedFromUI();
	void UpdateLumenaToUI();
	void UpdateCategoryPageToUI();
	void UpdateCategoryItemListToUI();
	void UpdateCategoryToUI();
	void UpdateRemainTimeToUI();
	void PlayCloseUISound();
	void PlayOpenUISound();
	void UpdateCategoryItemList();
	void UpdateRemainTime();
	void UpdateFlashShopItem(const struct FFlashShopItemData& InItemData);
	void DeactivateFlashShop();
	void ActivateFlashShop(int InFlashShopCid, const struct FQWord& InCloseTime, TArray<struct FFlashShopItemData>* InItemDataList);
	void Tick(float InDeltaSeconds);
	void Init();
};


// Class BLGame.GatherCraftLevelManager
// 0x0014 (0x0074 - 0x0060)
class UGatherCraftLevelManager : public UObject
{
public:
	int                                                GatherLevel;                                              // 0x0060(0x0004) (Transient)
	int                                                GatherExp;                                                // 0x0064(0x0004) (Transient)
	int                                                CraftLevel;                                               // 0x0068(0x0004) (Transient)
	int                                                CraftExp;                                                 // 0x006C(0x0004) (Transient)
	unsigned long                                      bInitializedGatherLevel : 1;                              // 0x0070(0x0004) (Transient)
	unsigned long                                      bInitializedGatherExp : 1;                                // 0x0070(0x0004) (Transient)
	unsigned long                                      bInitializedCraftLevel : 1;                               // 0x0070(0x0004) (Transient)
	unsigned long                                      bInitializedCraftExp : 1;                                 // 0x0070(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.GatherCraftLevelManager");
		return ptr;
	}


	void DrawAcquireCraftExp(int deltaExp);
	void AddCraftExp(int deltaExp);
	void CraftLevelUp(int ToSetCraftLevel);
	void RemoveCraftData();
	void DrawAcquireGatherExp(int deltaExp);
	void AddGatherExp(int deltaExp);
	void GatherLevelUp(int ToSetGatherLevel);
	void RemoveGatherData();
	void Initialize();
};


// Class BLGame.HIKHollowClimbHold
// 0x0004 (0x0254 - 0x0250)
class AHIKHollowClimbHold : public AInfo
{
public:
	unsigned long                                      bIsPreempted : 1;                                         // 0x0250(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.HIKHollowClimbHold");
		return ptr;
	}

};


// Class BLGame.HitSFXSet
// 0x0050 (0x00B0 - 0x0060)
class UHitSFXSet : public UObject
{
public:
	struct FName                                       HitSFXSetDesc;                                            // 0x0060(0x0008) (Edit)
	struct FName                                       HitResultSwitchGroupName;                                 // 0x0068(0x0008) (Edit)
	struct FName                                       OffenceSwitchGroupName;                                   // 0x0070(0x0008) (Edit)
	struct FName                                       DefenceSwitchGroupName;                                   // 0x0078(0x0008) (Edit)
	TArray<struct FName>                               HitResultSwitchNames;                                     // 0x0080(0x0010) (Edit, NeedCtorLink)
	TArray<struct FName>                               OffenceSwitchNames;                                       // 0x0090(0x0010) (Edit, NeedCtorLink)
	TArray<struct FName>                               DefenceSwitchNames;                                       // 0x00A0(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.HitSFXSet");
		return ptr;
	}


	void SetSoundSwitch_Defence(class AActor* InSoundTargetActor, TEnumAsByte<ESoundMaterialDefenceType> InDefenceType);
	void SetSoundSwitch_Offence(class AActor* InSoundTargetActor, TEnumAsByte<EMaterialOffenceType> InOffenceType);
	void SetSoundSwitch_HitResult(class AActor* InSoundTargetActor, TEnumAsByte<ECEAttackChanceType> InAttackChance);
	struct FName GetDefenceSwitchName(TEnumAsByte<ESoundMaterialDefenceType> InType);
	struct FName GetOffenceSwitchName(TEnumAsByte<EMaterialOffenceType> InType);
	struct FName GetHitResultSwitchName(TEnumAsByte<ECEAttackChanceType> InType);
	bool SetDefenceSwitchName(TEnumAsByte<ESoundMaterialDefenceType> InType, const struct FName& InName);
	bool SetOffenceSwitchName(TEnumAsByte<EMaterialOffenceType> InType, const struct FName& InName);
	bool SetHitResultSwitchName(TEnumAsByte<ECEAttackChanceType> InType, const struct FName& InName);
};


// Class BLGame.HitVFXSet
// 0x002C (0x008C - 0x0060)
class UHitVFXSet : public UObject
{
public:
	struct FName                                       HitVFXSetDesc;                                            // 0x0060(0x0008) (Edit)
	TArray<class UParticleSystem*>                     Particles;                                                // 0x0068(0x0010) (Edit, NeedCtorLink)
	TArray<class UMaterialInstanceTimeVarying*>        DecalMITVs;                                               // 0x0078(0x0010) (Edit, NeedCtorLink)
	int                                                LastColumnMax;                                            // 0x0088(0x0004) (Edit, EditConst)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.HitVFXSet");
		return ptr;
	}


	bool ConvertData();
	bool SetDecalMITV(int InRowIndex, int InColumnIndex, class UMaterialInstanceTimeVarying* InDecalMITV);
	bool SetParticle(int InRowIndex, int InColumnIndex, class UParticleSystem* InPS);
	class UMaterialInstanceTimeVarying* GetDecalMITV(int InRowIndex, int InColumnIndex);
	class UMaterialInstanceTimeVarying* FindDecalMITV(TEnumAsByte<EMaterialOffenceType> InOffenceType, TEnumAsByte<EVisualMaterialDefenceType> InDefenceType);
	class UParticleSystem* GetParticle(int InRowIndex, int InColumnIndex);
	class UParticleSystem* FindParticle(TEnumAsByte<EMaterialOffenceType> InOffenceType, TEnumAsByte<EVisualMaterialDefenceType> InDefenceType);
	int GetRowMax();
	int GetColumnMax();
};


// Class BLGame.LevelStreamingBlessCinematic
// 0x0018 (0x012C - 0x0114)
class ULevelStreamingBlessCinematic : public ULevelStreamingKismet
{
public:
	TArray<class UCinematicReadyQueueData*>            CallBackDatas;                                            // 0x0114(0x0010) (AlwaysInit, NeedCtorLink)
	float                                              LastPlayTime;                                             // 0x0124(0x0004)
	int                                                BeingQueue;                                               // 0x0128(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.LevelStreamingBlessCinematic");
		return ptr;
	}

};


// Class BLGame.LevelStreamingBlessDivision
// 0x0018 (0x012C - 0x0114)
class ULevelStreamingBlessDivision : public ULevelStreaming
{
public:
	int                                                MapIndex;                                                 // 0x0114(0x0004)
	struct FString                                     DivisionIndexName;                                        // 0x0118(0x0010) (Edit, Transient, NeedCtorLink)
	unsigned long                                      bSendedSubLevels : 1;                                     // 0x0128(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.LevelStreamingBlessDivision");
		return ptr;
	}

};


// Class BLGame.LevelStreamingBlessLobbyCinematic
// 0x0030 (0x0144 - 0x0114)
class ULevelStreamingBlessLobbyCinematic : public ULevelStreaming
{
public:
	TArray<TEnumAsByte<ECERaceType>>                   RaceTypes;                                                // 0x0114(0x0010) (Edit, NeedCtorLink)
	TArray<TEnumAsByte<ECEGenderType>>                 GenderTypes;                                              // 0x0124(0x0010) (Edit, NeedCtorLink)
	TArray<TEnumAsByte<ECEClassType>>                  ClassTypes;                                               // 0x0134(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.LevelStreamingBlessLobbyCinematic");
		return ptr;
	}


	bool CheckTypes(TEnumAsByte<ECERaceType> InRace, TEnumAsByte<ECEGenderType> InGender, TEnumAsByte<ECEClassType> InClass);
};


// Class BLGame.LevelStreamingDirectionLevel
// 0x0028 (0x013C - 0x0114)
class ULevelStreamingDirectionLevel : public ULevelStreaming
{
public:
	TArray<TEnumAsByte<ECEWorldMapType>>               HideWorldTypeList;                                        // 0x0114(0x0010) (Edit, NeedCtorLink)
	TEnumAsByte<EBLDirectionLevelQuality>              Quality;                                                  // 0x0124(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0125(0x0003) MISSED OFFSET
	TArray<class ALevelStreamingVolume*>               EntranceVolumes;                                          // 0x0128(0x0010) (Edit, NeedCtorLink)
	unsigned long                                      bShouldBeLoadedResult : 1;                                // 0x0138(0x0004) (Transient)
	unsigned long                                      bFirstCheck : 1;                                          // 0x0138(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.LevelStreamingDirectionLevel");
		return ptr;
	}

};


// Class BLGame.LevelStreamingPerDivisionContents
// 0x0004 (0x011C - 0x0118)
class ULevelStreamingPerDivisionContents : public ULevelStreamingAlwaysLoaded
{
public:
	unsigned long                                      bIsPMapAlive : 1;                                         // 0x0118(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.LevelStreamingPerDivisionContents");
		return ptr;
	}

};


// Class BLGame.LevelStreamingByPlayerWorld
// 0x0010 (0x012C - 0x011C)
class ULevelStreamingByPlayerWorld : public ULevelStreamingPerDivisionContents
{
public:
	TArray<struct FWorldCondition>                     Conditions;                                               // 0x011C(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.LevelStreamingByPlayerWorld");
		return ptr;
	}

};


// Class BLGame.LevelStreamingOptimizeTestLoading
// 0x0000 (0x011C - 0x011C)
class ULevelStreamingOptimizeTestLoading : public ULevelStreamingPerDivisionContents
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.LevelStreamingOptimizeTestLoading");
		return ptr;
	}

};


// Class BLGame.LevelStreamingPerDivisionTemporary
// 0x0000 (0x0118 - 0x0118)
class ULevelStreamingPerDivisionTemporary : public ULevelStreamingAlwaysLoaded
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.LevelStreamingPerDivisionTemporary");
		return ptr;
	}

};


// Class BLGame.LevelStreamingRectangleDistance
// 0x0018 (0x012C - 0x0114)
class ULevelStreamingRectangleDistance : public ULevelStreaming
{
public:
	float                                              ViewDistance;                                             // 0x0114(0x0004) (Edit, Deprecated)
	float                                              MinX;                                                     // 0x0118(0x0004) (Edit, EditConst)
	float                                              MaxX;                                                     // 0x011C(0x0004) (Edit, EditConst)
	float                                              MinY;                                                     // 0x0120(0x0004) (Edit, EditConst)
	float                                              MaxY;                                                     // 0x0124(0x0004) (Edit, EditConst)
	unsigned long                                      bReCalculation : 1;                                       // 0x0128(0x0004) (Edit)
	unsigned long                                      bIsValid : 1;                                             // 0x0128(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.LevelStreamingRectangleDistance");
		return ptr;
	}

};


// Class BLGame.LevelStreamingSoundActorLevel
// 0x0030 (0x0144 - 0x0114)
class ULevelStreamingSoundActorLevel : public ULevelStreaming
{
public:
	struct FString                                     Division;                                                 // 0x0114(0x0010) (Edit, Transient, EditConst, NeedCtorLink)
	int                                                Division_X;                                               // 0x0124(0x0004) (Transient)
	int                                                Division_Y;                                               // 0x0128(0x0004) (Transient)
	int                                                SectorNumber;                                             // 0x012C(0x0004) (Edit, Transient, EditConst)
	unsigned long                                      bUpdateButton : 1;                                        // 0x0130(0x0004) (Edit)
	float                                              MinX;                                                     // 0x0134(0x0004) (Edit, EditConst)
	float                                              MaxX;                                                     // 0x0138(0x0004) (Edit, EditConst)
	float                                              MinY;                                                     // 0x013C(0x0004) (Edit, EditConst)
	float                                              MaxY;                                                     // 0x0140(0x0004) (Edit, EditConst)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.LevelStreamingSoundActorLevel");
		return ptr;
	}

};


// Class BLGame.LevelStreamingSphereDistance
// 0x0051 (0x0165 - 0x0114)
class ULevelStreamingSphereDistance : public ULevelStreaming
{
public:
	struct FBoxSphereBounds                            Bounding;                                                 // 0x0114(0x001C) (Edit, EditConst)
	float                                              LoadDistance;                                             // 0x0130(0x0004) (Deprecated)
	float                                              ViewDistance;                                             // 0x0134(0x0004) (Deprecated)
	unsigned long                                      bViewDistanceOverride : 1;                                // 0x0138(0x0004) (Edit)
	unsigned long                                      bLoadDistanceOverride : 1;                                // 0x0138(0x0004) (Edit)
	unsigned long                                      OverrideSphereRadius : 1;                                 // 0x0138(0x0004) (Edit)
	unsigned long                                      bUpdateButton : 1;                                        // 0x0138(0x0004) (Edit)
	unsigned long                                      bReCalculation : 1;                                       // 0x0138(0x0004) (Edit)
	float                                              ViewDistanceFactor;                                       // 0x013C(0x0004) (Edit)
	float                                              LoadDistanceFactor;                                       // 0x0140(0x0004) (Edit)
	float                                              OverriddenSphereRadius;                                   // 0x0144(0x0004) (Edit)
	struct FString                                     Division;                                                 // 0x0148(0x0010) (Edit, EditConst, NeedCtorLink)
	int                                                Division_X;                                               // 0x0158(0x0004) (Edit)
	int                                                Division_Y;                                               // 0x015C(0x0004) (Edit)
	int                                                SectorNumber;                                             // 0x0160(0x0004) (Edit)
	TEnumAsByte<ELV_VisibilityGrade>                   VisibilityGrade;                                          // 0x0164(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.LevelStreamingSphereDistance");
		return ptr;
	}

};


// Class BLGame.LevelStreamingTubeDungeonLevel
// 0x0050 (0x0164 - 0x0114)
class ULevelStreamingTubeDungeonLevel : public ULevelStreaming
{
public:
	TArray<struct FBoundsInfo>                         VisibleBounding;                                          // 0x0114(0x0010) (Edit, EditConst, AlwaysInit, NeedCtorLink)
	TArray<class ALevelStreamingVolume*>               EntranceVolumes;                                          // 0x0124(0x0010) (Edit, NeedCtorLink)
	unsigned long                                      bUpdateButton : 1;                                        // 0x0134(0x0004) (Edit, Transient)
	unsigned long                                      bOnlyOneBounding : 1;                                     // 0x0134(0x0004) (Edit, Transient)
	unsigned long                                      bShouldBeLoadedResult : 1;                                // 0x0134(0x0004) (Transient)
	TArray<struct FBox>                                VisibleBoundingBoxes;                                     // 0x0138(0x0010) (NeedCtorLink)
	struct FBox                                        CheckBoxForPlayerIsInLevel;                               // 0x0148(0x001C) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.LevelStreamingTubeDungeonLevel");
		return ptr;
	}

};


// Class BLGame.LobbyGame
// 0x0000 (0x049C - 0x049C)
class ALobbyGame : public AGameInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.LobbyGame");
		return ptr;
	}


	void DestoryLobbyManager();
	void CreateLobbyManager();
	bool AllowCheats(class APlayerController* P);
	bool IsForceAllowCheat();
	void PostLogin(class APlayerController* NewPlayer);
	void PostBeginPlay();
	class UBLGameRes* GetDefaultGameResourceInner();
};


// Class BLGame.LumenaShop
// 0x0070 (0x00D0 - 0x0060)
class ULumenaShop : public UObject
{
public:
	TArray<struct FLumenaShopItemData>                 ServerItemDataList;                                       // 0x0060(0x0010) (NeedCtorLink)
	TArray<int>                                        CategoryList;                                             // 0x0070(0x0010) (NeedCtorLink)
	TArray<struct FLumenaShopCategoryItemInfo>         CategoryItemList;                                         // 0x0080(0x0010) (NeedCtorLink)
	int                                                SelectedCategoryCid;                                      // 0x0090(0x0004)
	int                                                SelectedPage;                                             // 0x0094(0x0004)
	int                                                MaxPage;                                                  // 0x0098(0x0004)
	struct FLumenaShopBuyInfo                          BuyInfo;                                                  // 0x009C(0x0024) (NeedCtorLink)
	struct FLumenaShopResetInfo                        ResetInfo;                                                // 0x00C0(0x000C)
	unsigned long                                      bInitializedUI : 1;                                       // 0x00CC(0x0004)
	unsigned long                                      bOpenedUI : 1;                                            // 0x00CC(0x0004)
	unsigned long                                      bNeedUIUpdateCategoryItemList : 1;                        // 0x00CC(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.LumenaShop");
		return ptr;
	}


	int GetCurrentContentToken(TEnumAsByte<ECEContentTokenType> InContentTokenType);
	int GetCurrentLumena();
	int GetCurrentContentTokenValue(TEnumAsByte<ECEContentTokenType> InContentTokenType);
	int GetProductItemAmount(int InProductCid);
	void OnUpdatedCurrentLumena();
	void OnSelectedPurchaseItemFromDialogUI();
	void OnClickedAddLumenaFromUI();
	void OnClickedPageFromUI(int InPage);
	void OpenPurchaseConfirmDialog(int InItemCount);
	void OnClickedPurchaseAmountFromUI(int InItemCid);
	void OnClickedBuyFromUI(int InItemCid);
	void OnClickedCategoryFromUI(int InCategoryCid);
	void OnClosedFromUI();
	void OnOpenedFromUI();
	void OnFinalizedFromUI();
	void OnInitializedFromUI();
	void UpdateContentTokenToUI();
	void UpdateLumenaToUI();
	void UpdateCategoryPageToUI();
	void UpdateCategoryItemListToUI();
	void UpdateCategoryListToUI();
	void PlayCloseUISound();
	void PlayOpenUISound();
	void UpdateCategoryItemList();
	void UpdateLumenaShopItemList(TArray<struct FLumenaShopItemData>* InItemDataList);
	void UpdateLumenaShopItem(const struct FLumenaShopItemData& InItemData);
	void InitLumenaShopItemList(TArray<struct FLumenaShopItemData>* InItemDataList, struct FLumenaShopResetInfo* InLumenaShopResetInfo);
	void Tick(float InDeltaSeconds);
	void InitCategoryList();
	void Init();
};


// Class BLGame.MissionManager
// 0x0014 (0x0074 - 0x0060)
class UMissionManager : public UObject
{
public:
	TArray<struct FMissionData>                        MissionList;                                              // 0x0060(0x0010) (Native, Transient)
	int                                                SelectedMissionCid;                                       // 0x0070(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MissionManager");
		return ptr;
	}


	void ShowRefreshQueryDialog(int CurrentActingPoint);
	void UpdateMissionExecutableButton();
	bool CheckEnableMissionOpenerByLevel();
	void SetMissionOpenerEnable(bool IsActivateOpenerUI);
	void MissionPushAlarm(int PushCount);
	void UnregisterFellowToMission(int MissionCId, const struct FString& FellowSid);
	void RegisterFellowToMission(int MissionCId, const struct FString& FellowSid);
	void UpdateUI_Mission();
	void ClearMission();
	void RemoveMission(int InKey);
	void UpdateMission(const struct FMissionData& InValue);
	void UpdateMissionList(TArray<struct FMissionData> InList);
};


// Class BLGame.NPCInteractionAsset
// 0x002C (0x008C - 0x0060)
class UNPCInteractionAsset : public UObject
{
public:
	float                                              DistanceTrigger;                                          // 0x0060(0x0004) (Edit)
	float                                              AngleTrigger;                                             // 0x0064(0x0004) (Edit)
	unsigned long                                      bUnsheatheTrigger : 1;                                    // 0x0068(0x0004) (Edit)
	unsigned long                                      bRotation : 1;                                            // 0x0068(0x0004) (Edit)
	unsigned long                                      bLookAt : 1;                                              // 0x0068(0x0004) (Edit)
	struct FName                                       AnimSeqName;                                              // 0x006C(0x0008) (Edit)
	float                                              RestartableTime;                                          // 0x0074(0x0004) (Edit)
	TArray<int>                                        MonologID;                                                // 0x0078(0x0010) (Edit, NeedCtorLink)
	float                                              RemainedRestartableTime;                                  // 0x0088(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.NPCInteractionAsset");
		return ptr;
	}


	void ResetRemainedRestartableTime();
	TEnumAsByte<ENPCInteractionTriggerCheck> TriggerCheck(class ABLNpc* Npc, class ABLPawn* Player);
	void TriggerTick(float DeltaTime);
	int GetMonologID();
};


// Class BLGame.RockClimbHoldMarker
// 0x0004 (0x0254 - 0x0250)
class ARockClimbHoldMarker : public AActor
{
public:
	int                                                ReferenceIndex;                                           // 0x0250(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.RockClimbHoldMarker");
		return ptr;
	}

};


// Class BLGame.RockWallLadderVolume
// 0x0034 (0x0350 - 0x031C)
class ARockWallLadderVolume : public ALadderVolume
{
public:
	float                                              HoldsDensity;                                             // 0x031C(0x0004) (Edit)
	float                                              CheckDensity;                                             // 0x0320(0x0004) (Edit)
	float                                              CheckExtent;                                              // 0x0324(0x0004) (Edit)
	float                                              CheckSlope;                                               // 0x0328(0x0004) (Edit)
	TArray<struct FClimbHold>                          Holds;                                                    // 0x032C(0x0010) (NeedCtorLink)
	int                                                AutoBuiltHoldCount;                                       // 0x033C(0x0004)
	TArray<class ARockClimbHoldMarker*>                HoldMarkers;                                              // 0x0340(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.RockWallLadderVolume");
		return ptr;
	}


	void UpdateHoldMarkers();
};


// Class BLGame.RPProductManager
// 0x0048 (0x00A8 - 0x0060)
class URPProductManager : public UObject
{
public:
	struct FMap_Mirror                                 RPProductList;                                            // 0x0060(0x0048) (Native, Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.RPProductManager");
		return ptr;
	}


	void GetAllProduct(TArray<struct FRPProductInfoData>* OutList);
	void CollectListByCID(int InCid, TArray<struct FRPProductInfoData>* OutList);
	bool GetByProductID(int InProductID, struct FRPProductInfoData* OutData);
	void RemoveByProductIDList(TArray<int> InproductIDList);
	void RemoveByProductID(int InProductID);
	void AddProductList(TArray<struct FRPProductInfoData> InList);
	void AddProduct(const struct FRPProductInfoData& InData);
	void ClearProduct();
	void Initialize();
};


// Class BLGame.SpriteComponentRTT
// 0x0028 (0x0260 - 0x0238)
class USpriteComponentRTT : public UPrimitiveComponent
{
public:
	class UTextureRenderTarget2D*                      Sprite;                                                   // 0x0238(0x0008) (Edit)
	unsigned long                                      bIsScreenSizeScaled : 1;                                  // 0x0240(0x0004) (Edit)
	float                                              ScreenSize;                                               // 0x0244(0x0004) (Edit)
	float                                              U;                                                        // 0x0248(0x0004) (Edit)
	float                                              UL;                                                       // 0x024C(0x0004) (Edit)
	float                                              V;                                                        // 0x0250(0x0004) (Edit)
	float                                              VL;                                                       // 0x0254(0x0004) (Edit)
	struct FName                                       SpriteCategoryName;                                       // 0x0258(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.SpriteComponentRTT");
		return ptr;
	}


	void SetSpriteAndUV(class UTextureRenderTarget2D* NewSprite, int NewU, int NewUL, int NewV, int NewVL);
	void SetUV(int NewU, int NewUL, int NewV, int NewVL);
	void SetSprite(class UTextureRenderTarget2D* NewSprite);
};


// Class BLGame.V2CraftManager
// 0x0080 (0x00E0 - 0x0060)
class UV2CraftManager : public UObject
{
public:
	TArray<int>                                        SmithCategory;                                            // 0x0060(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<int>                                        HandiworkCategory;                                        // 0x0070(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<int>                                        SmeltCategory;                                            // 0x0080(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<int>                                        CookCategory;                                             // 0x0090(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<int>                                        AlchemyCategory;                                          // 0x00A0(0x0010) (AlwaysInit, NeedCtorLink)
	TEnumAsByte<ECraftTabType>                         CurrentCraftTab;                                          // 0x00B0(0x0001) (Transient)
	TEnumAsByte<ECEV2CraftCategoryType>                CurrentRecipeUICraftType;                                 // 0x00B1(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x2];                                       // 0x00B2(0x0002) MISSED OFFSET
	int                                                CategorySelectCid;                                        // 0x00B4(0x0004) (Transient)
	int                                                CraftSelectCid;                                           // 0x00B8(0x0004) (Transient)
	int                                                CraftSelectAmount;                                        // 0x00BC(0x0004) (Transient)
	int                                                PrevMainCategoryCid;                                      // 0x00C0(0x0004) (Transient)
	int                                                PrevSubCategoryCid;                                       // 0x00C4(0x0004) (Transient)
	int                                                PrevMainCraftCid;                                         // 0x00C8(0x0004) (Transient)
	int                                                PrevSubCraftCid;                                          // 0x00CC(0x0004) (Transient)
	unsigned long                                      UseOptionalItem : 1;                                      // 0x00D0(0x0004) (Transient)
	unsigned long                                      ShowRecommandClass : 1;                                   // 0x00D0(0x0004) (Transient)
	unsigned long                                      bNeedUpdatePCCraftListUI : 1;                             // 0x00D0(0x0004) (Transient)
	unsigned long                                      bNeedUpdatePCCraftItemUI : 1;                             // 0x00D0(0x0004) (Transient)
	unsigned long                                      ShowAcquirable : 1;                                       // 0x00D0(0x0004) (Transient)
	unsigned long                                      ShowRecipeRecommandClass : 1;                             // 0x00D0(0x0004) (Transient)
	unsigned long                                      bIsCurrentPossibleCraft : 1;                              // 0x00D0(0x0004)
	unsigned long                                      bIsBeforePossibleCraft : 1;                               // 0x00D0(0x0004)
	int                                                EssencialMaterialCid;                                     // 0x00D4(0x0004) (Transient)
	int                                                CurrentCraftRecipeCid;                                    // 0x00D8(0x0004) (Transient)
	int                                                TargetCraftPropSid;                                       // 0x00DC(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.V2CraftManager");
		return ptr;
	}


	bool HasMySubCraftSpot();
	bool HasMyMainCraftSpot();
	TEnumAsByte<EHasCraftSpot> HasMyCraftSpot();
	int GetPossibleCraftSpotCid(int InServerId);
	int GetPossibleCraftSpotServerID(int InCid);
	bool IsPossibleCraftSpotByServerID(int InServerId);
	bool IsPossibleCraftSpotByCid(int InCid);
	void ClearTargetProp();
	void UpdatePossibleCraftSpot();
	void SendCraft(int InCraftCId, int inAmount);
	int GetCraftCidPossibleCount(int InCraftCId);
	void MakeCraftRecipeSkillLevelTitle(TEnumAsByte<ECEV2CraftCategoryType> InCraftType, class UGFxObject** OutTitle);
	bool MakeCraftRecipeCostObject(int CraftCId, class UGFxObject** OutObject);
	void MakeCraftRecipeItemObject(int CraftCId, class UGFxObject** OutObject);
	void MakeCraftRecipeMaterialList(int CraftCId, class UGFxObject** OutRequire, TArray<class UGFxObject*>* OutMaterialList, class UGFxObject** OutOptionalMaterial);
	void MakeCraftRecipeCategoryUIObject(TEnumAsByte<ECEV2CraftCategoryType> InCraftType, int InUICategoryCid, class UGFxObject** OutRoot);
	void MakeCraftRecipeList(TEnumAsByte<ECEV2CraftCategoryType> InTabType, TArray<class UGFxObject*>* OutList);
	void CloseCraftRecipeLearnUI();
	void OpenCraftRecipeLearnUI(TEnumAsByte<ECEV2CraftCategoryType> InCraftType);
	void OnClickReqQuest();
	void MakeCraftSkillLevelTitle(TEnumAsByte<ECraftTabType> InTabType, class UGFxObject** OutTitle);
	void MakeCraftItemObject(int CraftCId, class UGFxObject** OutObject);
	void MakeCraftMaterialList(int CraftCId, int Amount, class UGFxObject** OutRequire, TArray<class UGFxObject*>* OutMaterialList, class UGFxObject** OutOptionalMaterial, class UGFxObject** OutActingData, class UGFxObject** OutExpData);
	void MakeFavoriteUIObject(TEnumAsByte<ECEV2CraftCategoryType> InCraftType, class UGFxObject** OutFavorite);
	void MakeCategoryUIObject(TEnumAsByte<ECEV2CraftCategoryType> InCraftType, int InUICategoryCid, class UGFxObject** OutRoot);
	void MakeCraftList(TEnumAsByte<ECraftTabType> InTabType, TArray<class UGFxObject*>* OutList);
	void ClearCraftRecipeSelectedItem();
	void UpdateCraftRecipeLevelTitle();
	void UpdateCraftRecipeSelectedItem();
	void UpdateCraftRecipeList();
	void OnCloseCraftRecipeUI();
	void OnOpenCraftRecipeUI();
	void PlayCloseSound();
	void PlayOpenSound();
	void OnClosedPCCraftUI();
	void OnOpenedPCCraftUI();
	void OpenCraftUIByProp(unsigned char InTabType, bool InIsExpend);
	void OpenCraftUI(TEnumAsByte<ECraftTabType> InTabType, bool InIsExpend, int InMaterialItemCid);
	void OnUpdatedCraftItemUI();
	void OnUpdatedPropList();
	void OnUpdatedUseOptionalMaterial();
	void OnUpdatedActingPoint();
	void OnUpdatedContentsToken();
	void OnUpdatedInventoryItem();
	void OnUpdatedCraftExp();
	void OnUpdatedCraftLevel();
	void OnUpdateCraftExpModifier();
	void UpdateCraftLevelTitle();
	void ResetPCCraftList();
	void OpenCraftResultDialog(int InCraftCId, int InItemCid, TEnumAsByte<ECraftResultType> InSuccessType);
	void OpenCraftConfirmDialog(int InCraftCId, int inAmount, bool InUseOptMat);
	void ToggleCraftRecipeRecommandClass(bool InBool);
	void ToggleAcquirable(bool InBool);
	void SetCraftRecipeItemCid(int InCid);
	void ToggleRecommandClass(bool InBool);
	void ToggleCraftTab(int InTabIndex);
	void ToggleUseOptionalMaterial(bool InUse);
	void OnClickCraftMaterialItem(int InCid);
	void SetCraftItemAmount(int inAmount);
	void SetCraftItemCid(int InCategoryCid, int InCraftCId);
	void Tick();
	void Init();
};


// Class BLGame.WebSessionManager
// 0x0040 (0x00A0 - 0x0060)
class UWebSessionManager : public UObject
{
public:
	TEnumAsByte<EWebSessionType>                       CurWebSession;                                            // 0x0060(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	int                                                HelpPageCid;                                              // 0x0064(0x0004)
	struct FString                                     WebSessionURL;                                            // 0x0068(0x0010) (NeedCtorLink)
	int                                                WorldServerId;                                            // 0x0078(0x0004)
	struct FQWord                                      CSN;                                                      // 0x007C(0x0008)
	struct FString                                     TestPageFile;                                             // 0x0084(0x0010) (Config, NeedCtorLink)
	struct FRegisterItemInfo                           ItemInfo;                                                 // 0x0094(0x000C)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.WebSessionManager");
		return ptr;
	}


	void CS_WEB_SESSION_REDIRECT(TEnumAsByte<EWebSessionType> InWebSession);
	void OpenByGameOnLauncher(const struct FString& InURL);
	void SetRegisterItemCid(bool bSuccess, int InCid);
	void RegisterItem(int InSid, int inAmount);
	void LaunchPmangLink(struct FString* InParam);
	void LaunchExternalLink(struct FString* InURL);
	class UBLAweWebViewComponent* GetWebViewComponent();
	void ClearCurrentWebSession();
	void OnCloseWebSession(TEnumAsByte<EWebSessionType> InWebSession);
	void OpenWICHelpPageByCid(int InCid);
	void OpenWebPage(TEnumAsByte<EWebSessionType> InWebSession, const struct FString& InURL);
	void OnOpenWebSessionAck(int InActId, int InWorldServerId, const struct FQWord& InCSN, struct FString* InToken, struct FString* InURL);
	void OpenWebSessionReq(TEnumAsByte<EWebSessionType> InWebSession, const struct FString& URL);
	struct FString GenerateWebURL(int InActId, int InWorldServerId, const struct FQWord& InCSN, struct FString* InToken, struct FString* InURL);
	TEnumAsByte<EWebSessionType> ActIdToWebSessionType(int ActID);
	int WebSessionTypeToActId(TEnumAsByte<EWebSessionType> InWebSession);
};


// Class BLGame.ActionController
// 0x0154 (0x01C4 - 0x0070)
class UActionController : public UComponent
{
public:
	unsigned long                                      bIsTestTalk : 1;                                          // 0x0070(0x0004)
	unsigned long                                      ChargeSkillTrying : 1;                                    // 0x0070(0x0004) (Transient)
	unsigned long                                      bIsInteractionKeyPressedInTalkstate : 1;                  // 0x0070(0x0004) (Transient)
	struct FDialogCamSetting                           DialogCam_DefaultSetting;                                 // 0x0074(0x0018) (Const)
	TArray<struct FMonologAssetAndInfo>                DialogCanceledByPlayerCombat_MonologueInfos;              // 0x008C(0x0010) (NeedCtorLink)
	TArray<struct FMonologAssetAndInfo>                DialogCanceledByTalkerCombat_MonologueInfos;              // 0x009C(0x0010) (NeedCtorLink)
	TArray<int>                                        DialogCanceledByPlayerCombat_MonologIDs;                  // 0x00AC(0x0010) (NeedCtorLink)
	TArray<int>                                        DialogCanceledByTalkerCombat_MonologIDs;                  // 0x00BC(0x0010) (NeedCtorLink)
	struct FTalkerIDInfo                               CurrentTalkerIDInfo;                                      // 0x00CC(0x0030) (Transient, NeedCtorLink)
	struct FPCDialogInfo                               CurrentDialog;                                            // 0x00FC(0x0058) (Transient, NeedCtorLink)
	int                                                ChargeSkillID;                                            // 0x0154(0x0004) (Transient)
	float                                              CarryStateRemainTime;                                     // 0x0158(0x0004) (Transient)
	int                                                CacheingTalkMainNpcId;                                    // 0x015C(0x0004)
	int                                                CacheingTalkSecondNpcId;                                  // 0x0160(0x0004)
	struct FTalkDialogInfo                             CacheingTalkDialogInfo;                                   // 0x0164(0x0040) (NeedCtorLink)
	struct FScriptDelegate                             __OnLoadMonologAsset_CancelByPlayerCombat__Delegate;      // 0x01A4(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x01A4(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY
	struct FScriptDelegate                             __OnLoadMonologAsset_CancelByTalkerCombat__Delegate;      // 0x01B4(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData01[0x4];                                       // 0x01B4(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.ActionController");
		return ptr;
	}


	void EndRuneSynthesize();
	void DoRuneSynthesize();
	void EndCarry();
	void ExpireStateDuration();
	void PutDownCarryObject();
	void DropCarryObject();
	void CarryingCarryObejct();
	void PickUpCarryObject();
	void EndCameraInterp();
	struct FString GetGroupNameByLanguage();
	bool ActionToTarget(bool bPress);
	void PlayTalk(int DInfoCid, TArray<struct FDialogTextInfo> DInfoTextInfoList);
	void EndDialog(int InNpcID);
	void StartDialog(struct FTalkDialogInfo* InDialogInfo);
	void UpdateHideOtherPawn(class ABLPawnBase* inPawn);
	void EndCameraWork();
	void StopTalkCameraWork();
	void StartTalkCameraWork(class ABLPawn* TargetPawn, class ABLPawn* SecondTargetPawn, TEnumAsByte<EDialogCameraType> CameraType, const struct FCustomCameraInfo& CustomCamInfo);
	void EndPlayerTalk();
	void StartPlayerTalk();
	void EndTalk(int InNpcID, TEnumAsByte<ETalkEndType> InEndType);
	void StartTalk(bool InIsTestTalk);
	void SetTalkData(int InMainNpcId, int InSecondNpcId, struct FTalkDialogInfo* InDialogInfo);
	void ClearCurrentDialog();
	void ClearCurrentTalkIDInfo();
	void OnLoadDialogAsset(class UDialogAsset* InAsset);
	bool IsChargingSkill();
	bool IsChannelingSkill();
	bool IsSkillIgnoreMoveInput();
	bool IsSkillCanceledByMoving();
	bool IsInInteractionState();
	bool IsInCastingState();
	bool IsInSkillState();
	void OnUpdateSkillCanceled();
	void InitInteraction();
	void InitLoot();
	void InitCasting();
	void InitFiring();
	void FiringStateEnd();
	void InteractionStateEnd();
	void LootStateEnd();
	void CastingStateEnd();
	void Tick(float DeltaTime);
	void Init();
	void ChargeSkillUnloaded();
	void ChargeSkillLoaded(int SkillID);
	void PlayDialogCancelMonolog(int npcId, int endType);
	void Init_Native();
	void OnLoadMonologAsset_CancelByTalkerCombat(class UMonologAsset* InAsset);
	void OnLoadMonologAsset_CancelByPlayerCombat(class UMonologAsset* InAsset);
};


// Class BLGame.AimController
// 0x01EC (0x025C - 0x0070)
class UAimController : public UComponent
{
public:
	class ABLPawn*                                     BLPawnOwner;                                              // 0x0070(0x0008) (Transient)
	class UBLGameViewportClient*                       ViewportClient;                                           // 0x0078(0x0008) (Transient)
	TArray<struct FAimOffsetInfo>                      AimStep;                                                  // 0x0080(0x0010) (NeedCtorLink)
	TArray<struct FAimOffsetInfo>                      Default_AimStep;                                          // 0x0090(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FAimOffsetInfo>                      Amistad_Male_AimStep;                                     // 0x00A0(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FAimOffsetInfo>                      Amistad_Female_AimStep;                                   // 0x00B0(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FAimOffsetInfo>                      AquaElf_Male_AimStep;                                     // 0x00C0(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FAimOffsetInfo>                      AquaElf_Female_AimStep;                                   // 0x00D0(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FAimOffsetInfo>                      Pantera_Male_AimStep;                                     // 0x00E0(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FAimOffsetInfo>                      Pantera_Female_AimStep;                                   // 0x00F0(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FAimOffsetInfo>                      Iblis_Male_AimStep;                                       // 0x0100(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FAimOffsetInfo>                      Iblis_Female_AimStep;                                     // 0x0110(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FAimOffsetInfo>                      Siren_Male_AimStep;                                       // 0x0120(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FAimOffsetInfo>                      Siren_Female_AimStep;                                     // 0x0130(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FAimOffsetInfo>                      MascuU_Male_AimStep;                                      // 0x0140(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FAimOffsetInfo>                      MascuU_Female_AimStep;                                    // 0x0150(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FAimOffsetInfo>                      Habichts_Male_AimStep;                                    // 0x0160(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FAimOffsetInfo>                      Habichts_Female_AimStep;                                  // 0x0170(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FAimOffsetInfo>                      SylvanElf_Male_AimStep;                                   // 0x0180(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FAimOffsetInfo>                      SylvanElf_Female_AimStep;                                 // 0x0190(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FAimOffsetInfo>                      Lupus_Male_AimStep;                                       // 0x01A0(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FAimOffsetInfo>                      Lupus_Female_AimStep;                                     // 0x01B0(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FAimOffsetInfo>                      Fedayin_Male_AimStep;                                     // 0x01C0(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FAimOffsetInfo>                      Fedayin_Female_AimStep;                                   // 0x01D0(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FAimOffsetInfo>                      MascuH_Male_AimStep;                                      // 0x01E0(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FAimOffsetInfo>                      MascuH_Female_AimStep;                                    // 0x01F0(0x0010) (Edit, Config, NeedCtorLink)
	float                                              AimDist;                                                  // 0x0200(0x0004) (Edit, Config)
	float                                              AimBufferWidth;                                           // 0x0204(0x0004) (Edit, Config)
	float                                              AimBufferLength;                                          // 0x0208(0x0004) (Edit, Config)
	float                                              TargetChangeBuffer;                                       // 0x020C(0x0004) (Edit, Config)
	float                                              AimTargetingCancelTime;                                   // 0x0210(0x0004) (Edit, Config)
	float                                              AimMoveVelocity;                                          // 0x0214(0x0004) (Edit, Config)
	float                                              AimTargetMaxDistance;                                     // 0x0218(0x0004)
	int                                                AimBufferTotalSizeChangeSlideDefault;                     // 0x021C(0x0004) (Edit, Config)
	float                                              AimModifier;                                              // 0x0220(0x0004) (Edit, Config)
	float                                              CustomAimBufferWidth;                                     // 0x0224(0x0004) (Transient)
	float                                              CustomAimBufferLength;                                    // 0x0228(0x0004) (Transient)
	float                                              CustomTargetChangeBuffer;                                 // 0x022C(0x0004) (Transient)
	unsigned long                                      bActivated : 1;                                           // 0x0230(0x0004)
	unsigned long                                      bShowDebugBox : 1;                                        // 0x0230(0x0004)
	struct FAimProjectionInfo                          ProjectionInfo;                                           // 0x0234(0x000C)
	int                                                CurrentAimStep;                                           // 0x0240(0x0004)
	float                                              LastCamDistance;                                          // 0x0244(0x0004)
	float                                              AimScreenPosY;                                            // 0x0248(0x0004)
	float                                              DestAimScreenPosY;                                        // 0x024C(0x0004)
	int                                                AimTargetID;                                              // 0x0250(0x0004)
	float                                              CurrentNearClippingPlane;                                 // 0x0254(0x0004)
	float                                              AimTargetingCancelTimeCount;                              // 0x0258(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.AimController");
		return ptr;
	}


	void ResetAimTargetingCancelTimeCount();
	void SetCustomAimBuffer(int InSliderPosition);
	void DrawDebugBox(float RayExtentWidth, float RayExtentHeight, const struct FColor& BoxColor);
	void CollectAimTargetList(float RayExtentWidth, float RayExtentHeight, TArray<int>* TargetSidList);
	void UpdateAimTarget(float DeltaTime);
	void UpdateAimTarget_UIMode();
	void UpdateAimPos(float DeltaTime);
	float CalcAimScreenPosY();
	int GetAimStep();
	void Tick(float DeltaTime);
	void Activate(class ABLPawn* OwnerPawn, bool InIsActivate);
	void UpdateAimStep(TEnumAsByte<ECERaceType> InRaceType, TEnumAsByte<ECEGenderType> InGenderType);
	void Init(TEnumAsByte<ECERaceType> InRaceType, TEnumAsByte<ECEGenderType> InGenderType);
};


// Class BLGame.BLCameraBase
// 0x00B8 (0x0808 - 0x0750)
class ABLCameraBase : public AGamePlayerCamera
{
public:
	float                                              MaxZoomVelocity;                                          // 0x0750(0x0004) (Edit, Config)
	float                                              ZoomAccelTime;                                            // 0x0754(0x0004) (Edit, Config)
	float                                              ZoomSlowDownTime;                                         // 0x0758(0x0004) (Edit, Config)
	float                                              ReentMaxZoomVelocity;                                     // 0x075C(0x0004) (Edit, Config)
	float                                              ReentZoomAccelTime;                                       // 0x0760(0x0004) (Edit, Config)
	int                                                DefaultZoomStep;                                          // 0x0764(0x0004) (Edit, Config)
	unsigned long                                      bReent : 1;                                               // 0x0768(0x0004)
	unsigned long                                      bDeaccelerate : 1;                                        // 0x0768(0x0004)
	unsigned long                                      bChangedZoom : 1;                                         // 0x0768(0x0004)
	unsigned long                                      bEnableDOF : 1;                                           // 0x0768(0x0004)
	float                                              ZoomVelocity;                                             // 0x076C(0x0004)
	float                                              ZoomAcceleration;                                         // 0x0770(0x0004)
	float                                              ZoomDeacceleration;                                       // 0x0774(0x0004)
	float                                              ZoomReentAcceleration;                                    // 0x0778(0x0004)
	struct FBLCameraInfo                               CameraInfo;                                               // 0x077C(0x0028)
	TArray<struct FZoomStepDistFocus>                  ZoomStep;                                                 // 0x07A4(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  CurZoomStep;                                              // 0x07B4(0x0010) (NeedCtorLink)
	struct FZoomStepDistFocus                          CurrentZoomParam;                                         // 0x07C4(0x0028)
	int                                                ConfigureMaxCamDistance;                                  // 0x07EC(0x0004) (Edit, Config)
	int                                                DestZoomStep;                                             // 0x07F0(0x0004)
	float                                              ElapsedTimeZoomBegin;                                     // 0x07F4(0x0004)
	float                                              DefaultCamDistance;                                       // 0x07F8(0x0004)
	float                                              MaxCamDistance;                                           // 0x07FC(0x0004)
	float                                              MinCamDistance;                                           // 0x0800(0x0004)
	float                                              DesiredFOV;                                               // 0x0804(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLCameraBase");
		return ptr;
	}


	void UpdateFOV(float DeltaTime, struct FTViewTarget* OutVT, float* FOV);
	void UpdateRotation(float DeltaTime, const struct FVector& CameraTarget, const struct FVector& pos, struct FTViewTarget* OutVT, struct FRotator* Rot);
	void UpdatePosition(float DeltaTime, const struct FVector& CameraTarget, const struct FRotator& Rot, struct FTViewTarget* OutVT, struct FVector* pos);
	void UpdateCameraTarget(float DeltaTime, const struct FRotator& Rot, struct FTViewTarget* OutVT, struct FVector* CameraTarget);
	void UpdateBLCamera(float DeltaTime, struct FTViewTarget* OutVT, float* FOV, struct FVector* CameraTarget, struct FRotator* Rot, struct FVector* pos);
	void GetCameraTargetPawnLocation(class ABLPawn* TargetPawn, struct FVector* TargetLocation);
	void UpdateZoomParam(float DeltaTime);
	void UpdateZoomDist(float InDist, float InDeltaTime, float* OutDist);
	void ZoomOut();
	void ZoomIn();
	void ZoomBase(bool bZoomIn);
	bool ReentTest();
	float GetAcceleration();
	void UpdateAccelerationState(float InRemainDist, float InVelocity, float InAcceleration);
	void SetZoomStep(int InStep);
	void InitZoomStepList(TArray<struct FZoomStepDistFocus>* OutZoomStep);
	void UpdateZoom(float DeltaTime);
	void UpdateCamera(float DeltaTime);
	void PostBeginPlay();
	void EnableDoF();
	void DisableDoF();
	void SetDesiredFOV(float InFOV);
};


// Class BLGame.BLCamera
// 0x0544 (0x0D4C - 0x0808)
class ABLCamera : public ABLCameraBase
{
public:
	float                                              ZCompensation;                                            // 0x0808(0x0004)
	unsigned long                                      bCameraBlocked : 1;                                       // 0x080C(0x0004)
	unsigned long                                      bCheckHidePawn : 1;                                       // 0x080C(0x0004) (Transient)
	unsigned long                                      bUseCamOffsetDampingModel : 1;                            // 0x080C(0x0004) (Config)
	unsigned long                                      bUseCachedCylinder : 1;                                   // 0x080C(0x0004) (Transient)
	unsigned long                                      bUseCamInterpolate : 1;                                   // 0x080C(0x0004) (Edit, Config)
	unsigned long                                      bInvCamRotMode : 1;                                       // 0x080C(0x0004)
	unsigned long                                      bControlledMatineeCameraMode : 1;                         // 0x080C(0x0004)
	unsigned long                                      bViewTargetCameraMode : 1;                                // 0x080C(0x0004)
	unsigned long                                      bUseCamBlock : 1;                                         // 0x080C(0x0004)
	unsigned long                                      bOffsetActorCamAndMeshCamInitialized : 1;                 // 0x080C(0x0004) (Transient)
	unsigned long                                      CamUnderWater : 1;                                        // 0x080C(0x0004) (Transient)
	unsigned long                                      bRetCamForGetOffTransport : 1;                            // 0x080C(0x0004)
	float                                              MaxReturnVelocity;                                        // 0x0810(0x0004) (Edit, Config)
	float                                              ReturnDuration;                                           // 0x0814(0x0004) (Edit, Config)
	struct FTDamperModelParam                          DamperModelParam;                                         // 0x0818(0x0008)
	int                                                DefaultZoomStep_ClassicTargeting;                         // 0x0820(0x0004) (Edit, Config)
	int                                                MaxZoomStep_Default_ClassicTargeting;                     // 0x0824(0x0004) (Edit, Config)
	int                                                MaxZoomStep_CustomMin_ClassicTargeting;                   // 0x0828(0x0004) (Edit, Config)
	int                                                MaxZoomStep_CustomMax_ClassicTargeting;                   // 0x082C(0x0004) (Edit, Config)
	int                                                DefaultZoomStep_AimTargeting;                             // 0x0830(0x0004) (Edit, Config)
	int                                                MaxZoomStep_Default_AimTargeting;                         // 0x0834(0x0004) (Edit, Config)
	int                                                MaxZoomStep_CustomMin_AimTargeting;                       // 0x0838(0x0004) (Edit, Config)
	int                                                MaxZoomStep_CustomMax_AimTargeting;                       // 0x083C(0x0004) (Edit, Config)
	int                                                DefaultAim_ZoomStep;                                      // 0x0840(0x0004)
	int                                                DefaultAim_MaxZoomStep;                                   // 0x0844(0x0004)
	int                                                CustomAim_MaxZoomStep;                                    // 0x0848(0x0004)
	int                                                CustomAim_MinZoomStep;                                    // 0x084C(0x0004)
	int                                                DefaultClassic_ZoomStep;                                  // 0x0850(0x0004)
	int                                                DefaultClassic_MaxZoomStep;                               // 0x0854(0x0004)
	int                                                CustomClassic_MaxZoomStep;                                // 0x0858(0x0004)
	int                                                CustomClassic_MinZoomStep;                                // 0x085C(0x0004)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_ClassicTargeting;                                // 0x0860(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_AimTargeting;                                    // 0x0870(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_amistad_male_Classic;                            // 0x0880(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_amistad_female_Classic;                          // 0x0890(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_aquaElf_male_Classic;                            // 0x08A0(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_aquaElf_female_Classic;                          // 0x08B0(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_pantera_male_Classic;                            // 0x08C0(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_pantera_female_Classic;                          // 0x08D0(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_iblis_male_Classic;                              // 0x08E0(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_iblis_female_Classic;                            // 0x08F0(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_siren_male_Classic;                              // 0x0900(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_siren_female_Classic;                            // 0x0910(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_habichts_male_Classic;                           // 0x0920(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_habichts_female_Classic;                         // 0x0930(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_sylvanElf_male_Classic;                          // 0x0940(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_sylvanElf_female_Classic;                        // 0x0950(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_lupus_male_Classic;                              // 0x0960(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_lupus_female_Classic;                            // 0x0970(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_fedayin_male_Classic;                            // 0x0980(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_fedayin_female_Classic;                          // 0x0990(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_mascu_H_male_Classic;                            // 0x09A0(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_mascu_H_female_Classic;                          // 0x09B0(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_mascu_U_male_Classic;                            // 0x09C0(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_mascu_U_female_Classic;                          // 0x09D0(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_amistad_male_AimTarget;                          // 0x09E0(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_amistad_female_AimTarget;                        // 0x09F0(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_aquaElf_male_AimTarget;                          // 0x0A00(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_aquaElf_female_AimTarget;                        // 0x0A10(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_pantera_male_AimTarget;                          // 0x0A20(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_pantera_female_AimTarget;                        // 0x0A30(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_iblis_male_AimTarget;                            // 0x0A40(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_iblis_female_AimTarget;                          // 0x0A50(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_siren_male_AimTarget;                            // 0x0A60(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_siren_female_AimTarget;                          // 0x0A70(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_habichts_male_AimTarget;                         // 0x0A80(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_habichts_female_AimTarget;                       // 0x0A90(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_sylvanElf_male_AimTarget;                        // 0x0AA0(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_sylvanElf_female_AimTarget;                      // 0x0AB0(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_lupus_male_AimTarget;                            // 0x0AC0(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_lupus_female_AimTarget;                          // 0x0AD0(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_fedayin_male_AimTarget;                          // 0x0AE0(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_fedayin_female_AimTarget;                        // 0x0AF0(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_mascu_H_male_AimTarget;                          // 0x0B00(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_mascu_H_female_AimTarget;                        // 0x0B10(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_mascu_U_male_AimTarget;                          // 0x0B20(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_mascu_U_female_AimTarget;                        // 0x0B30(0x0010) (Edit, Config, NeedCtorLink)
	float                                              DampingModelOffsetMaxReturnVelocity;                      // 0x0B40(0x0004) (Config)
	float                                              DampingModelCamOffset;                                    // 0x0B44(0x0004) (Transient)
	float                                              DampingModelOffsetVelocity;                               // 0x0B48(0x0004) (Transient)
	struct FVector                                     CameraExtent;                                             // 0x0B4C(0x000C) (Config)
	float                                              CachedCylinderRadius;                                     // 0x0B58(0x0004) (Transient)
	float                                              CachedCylinderHeight;                                     // 0x0B5C(0x0004) (Transient)
	float                                              CamReturnDelayTime;                                       // 0x0B60(0x0004) (Edit, Config)
	int                                                MaxCamPCPitch;                                            // 0x0B64(0x0004) (Edit, Config)
	int                                                MinCamPCPitch;                                            // 0x0B68(0x0004) (Edit, Config)
	int                                                DefaultCamPCPitch;                                        // 0x0B6C(0x0004) (Edit, Config)
	struct FName                                       FaceBoneName;                                             // 0x0B70(0x0008) (Config)
	float                                              RetCamDelayTime;                                          // 0x0B78(0x0004) (Edit, Config)
	float                                              RetCamDelayTimeCount;                                     // 0x0B7C(0x0004)
	int                                                AutoCamRotNorm;                                           // 0x0B80(0x0004) (Edit, Config)
	int                                                AutoCamRotAccel;                                          // 0x0B84(0x0004) (Edit, Config)
	int                                                AutoCamRotVelocity;                                       // 0x0B88(0x0004)
	float                                              AutoCamRotDir;                                            // 0x0B8C(0x0004)
	int                                                TotalAutoRot;                                             // 0x0B90(0x0004)
	int                                                RemainCamRotDiff;                                         // 0x0B94(0x0004)
	float                                              SprintFOV;                                                // 0x0B98(0x0004) (Edit, Config)
	float                                              SprintFOV_Inc;                                            // 0x0B9C(0x0004) (Edit, Config)
	float                                              SprintFOV_Dec_Stop;                                       // 0x0BA0(0x0004) (Edit, Config)
	float                                              SprintFOV_Dec_Run;                                        // 0x0BA4(0x0004) (Edit, Config)
	float                                              SprintFOV_DelayTime;                                      // 0x0BA8(0x0004) (Edit, Config)
	float                                              NonTarget_SprintFOV;                                      // 0x0BAC(0x0004) (Edit, Config)
	float                                              NonTarget_SprintFOV_Inc;                                  // 0x0BB0(0x0004) (Edit, Config)
	float                                              NonTarget_SprintFOV_Dec_Stop;                             // 0x0BB4(0x0004) (Edit, Config)
	float                                              NonTarget_SprintFOV_Dec_Run;                              // 0x0BB8(0x0004) (Edit, Config)
	float                                              NonTarget_SprintFOV_DelayTime;                            // 0x0BBC(0x0004) (Edit, Config)
	float                                              Mount_MoveFOV;                                            // 0x0BC0(0x0004) (Edit, Config)
	float                                              Mount_MoveFOV_SpeedToFOV_Rate;                            // 0x0BC4(0x0004) (Edit, Config)
	float                                              Mount_MoveFOV_Inc;                                        // 0x0BC8(0x0004) (Edit, Config)
	float                                              Mount_MoveFOV_Dec;                                        // 0x0BCC(0x0004) (Edit, Config)
	float                                              Mount_MoveFOV_DelayTime;                                  // 0x0BD0(0x0004) (Edit, Config)
	float                                              NormalFOV;                                                // 0x0BD4(0x0004) (Edit, Config)
	float                                              CameraBlockedClippingNearPlane;                           // 0x0BD8(0x0004) (Edit, Config)
	float                                              CameraBlockedClippingNearPlaneCheckDist;                  // 0x0BDC(0x0004) (Edit, Config)
	struct FBLFOVChangeInfo                            FOVChangeInfo;                                            // 0x0BE0(0x0014)
	struct FBLCameraInterpInfo                         InterpInfo;                                               // 0x0BF4(0x00C0) (Transient, NeedCtorLink)
	float                                              CamAcceleration;                                          // 0x0CB4(0x0004) (Edit, Config)
	float                                              BlockTime;                                                // 0x0CB8(0x0004) (Transient)
	TEnumAsByte<EMeshOrientedCamMode>                  MeshOrientedCamMode;                                      // 0x0CBC(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0CBD(0x0003) MISSED OFFSET
	struct FVector                                     OffsetActorCamAndMeshCam;                                 // 0x0CC0(0x000C) (Transient)
	struct FBLCamera_WorldMapModeInfo                  WorldMapModeInfo;                                         // 0x0CCC(0x0068) (Transient)
	class UWorldMapManager*                            WorldMapManager;                                          // 0x0D34(0x0008) (Transient)
	float                                              IntersectHidePawnBoundingSize;                            // 0x0D3C(0x0004) (Config)
	float                                              DefaultNearClippingPlane;                                 // 0x0D40(0x0004) (Transient)
	int                                                RetCamZoomStepForGetOffTransport;                         // 0x0D44(0x0004)
	float                                              LookBackAngularSpeed;                                     // 0x0D48(0x0004) (Config)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLCamera");
		return ptr;
	}


	void OutsideWorldBounds();
	void FellOutOfWorld(class UClass* dmgType);
	void UpdateCameraBlockedNearClippingPlane(bool bBlocked, float InCameraDistance);
	void SetDefaultNearClippingPlane();
	float GetSprintFOV_DelayTime();
	float GetSprintFOV_Dec_Run();
	float GetSprintFOV_Dec_Stop();
	float GetSprintFOV_Inc();
	float GetSprintFOV();
	bool IsEnabledCheckHidePawn();
	void SetEnableCheckHidePawn(bool bInEnable);
	void EndWorldMapMode();
	void StartWorldMapMode();
	void SetFadeCameraInfo(const struct FVector& DestTarget, const struct FRotator& DestRotation, float DistFromTarget, float DestFOV);
	void CancelAutoCamRotMode();
	void OnViewInverse();
	void SetInterpDestInfo(float InterpTimeTotal, float DestFOV, const struct FVector& Dest, const struct FRotator& DestRotation);
	void SetInterpStartInfo(const struct FVector& Start, float StartFOV, const struct FRotator& StartRotation);
	void SetCameraMoveWorkInfo(const struct FVector& DestTarget, const struct FRotator& DestRotation, float RotationTime, float MovingTime, float DestFOV, float DistFromTarget);
	void EndCameraFadeState();
	void GoToCameraFadeState();
	void GotoNormalState();
	void GotoCameraInterpState();
	void EndCameraWork_Move();
	void GotoCameraWork_Move();
	void OffFOVAutoChangeMode(float FOVDelta, float DelayTime);
	void OnFOVAutoChangeMode(float EndFOV, float FOVDelta, float DelayTime);
	void DisplayDebug(class AHUD* HUD, float* out_YL, float* out_YPos);
	void DetermineCamPosNRot(float DeltaTime, const struct FVector& PrevCamLoc, struct FTViewTarget* OutVT, struct FVector* DestCamPos, struct FRotator* CamRot, struct FVector* TargetLoc);
	void UpdateViewTarget(float DeltaTime, struct FTViewTarget* OutVT);
	void UpdateBlockedPos(float DeltaTime, const struct FVector& CameraTarget, const struct FRotator& Rot, struct FTViewTarget* OutVT, struct FVector* pos);
	void AdjustCamPosInWater(const struct FVector& CamTarget, struct FVector* CamPos);
	void UpdatePosition(float DeltaTime, const struct FVector& CameraTarget, const struct FRotator& Rot, struct FTViewTarget* OutVT, struct FVector* pos);
	void UpdateRotation(float DeltaTime, const struct FVector& CameraTarget, const struct FVector& pos, struct FTViewTarget* OutVT, struct FRotator* Rot);
	void UpdateZoom(float DeltaTime);
	void UpdateZoomParam(float DeltaTime);
	void UpdateZoomDist(float InDist, float InDeltaTime, float* OutDist);
	void ReturnZoomStepBeforeTransport(float DelayTime);
	void FadeCamera(bool bInFadeOut, float InFadeTime);
	float GetAspectRatio();
	void SetAllowedCameraPosition(class AActor* Target, const struct FVector& Loc, struct FVector* out_Pos);
	void DisableCollisionCylinderCache();
	void EnableCollisionCylinderCache(class APawn* P);
	struct FVector GetBlockedCamPos(const struct FVector& CamPos, const struct FRotator& CamRot, const struct FVector& TargetLoc, class APawn* P);
	void GetPawnBoundingCylinder(class APawn* P, float* Radius, float* Height);
	struct FVector GetCyliderVolumeOutPos(const struct FVector& CircleCenter, float Radius, float Height, const struct FVector& CheckPos);
	struct FVector CalcBlockedCameraPos(float DeltaTime, const struct FVector& CameraPos, const struct FVector& OldCameraPos, const struct FVector& TargetLoc, class APawn* P);
	struct FVector CalcBlockedCameraPosByCamOffset(float DeltaTime, const struct FVector& CameraPos, const struct FRotator& CameraRot, const struct FVector& TargetLoc, class APawn* P);
	float CalcCamOffsetDamperModel(float DeltaTime, float OldOffset);
	struct FVector CalcPosDamperModel(float DeltaTime, const struct FVector& OldPos, const struct FVector& GoalPos);
	void ResetCamera();
	void CollectToHideBLPawnList(TArray<class ABLPawn*>* HideBLPawns);
	void CheckHidePawn(const struct FVector& CameraPos);
	void ZoomOut();
	void ZoomIn();
	void ZoomBase(bool bZoomIn);
	void ChangeZoomStepList(TArray<struct FZoomStepDistFocus>* OutZoomStep);
	void ChangeMaxZoomStepByTargetingMode(TEnumAsByte<ECERaceType> Race, TEnumAsByte<ECEGenderType> Gender, TEnumAsByte<EBLTargetingMode> TargetingMode, int MaxZoomStep);
	void ChangeMaxZoomStep(int MaxZoomStep);
	void InitEnterWorld(TEnumAsByte<ECERaceType> Race, TEnumAsByte<ECEGenderType> Gender, TEnumAsByte<EBLTargetingMode> TargetingMode, int MaxZoomStep);
	void InitDistance(int InitZoomStep, int MaxZoomStep);
	void InitZoomStepAimTargetList();
	void InitZoomStepClassicList();
	void ChangeZoomStepAimTargetListByRaceAndZender(TEnumAsByte<ECERaceType> InRaceType, TEnumAsByte<ECEGenderType> InGenderType);
	void ChangeZoomStepClassicListByRaceAndZender(TEnumAsByte<ECERaceType> InRaceType, TEnumAsByte<ECEGenderType> InGenderType);
	void InitZoomStep();
	void PostBeginPlay();
};


// Class BLGame.BLFlyMountCamera
// 0x0058 (0x0DA4 - 0x0D4C)
class ABLFlyMountCamera : public ABLCamera
{
public:
	float                                              ElasticCoefficient;                                       // 0x0D4C(0x0004) (Edit, Const, Config)
	float                                              CamDistTweak;                                             // 0x0D50(0x0004) (Edit, Const, Config)
	float                                              FlyMountCamDist;                                          // 0x0D54(0x0004) (Edit, Config)
	float                                              FrictionCoefficient;                                      // 0x0D58(0x0004) (Edit, Const, Config)
	float                                              StopFrictionCoefficient;                                  // 0x0D5C(0x0004) (Edit, Const, Config)
	float                                              MinMountCamDist;                                          // 0x0D60(0x0004) (Edit, Const, Config)
	float                                              MaxMountCamDist;                                          // 0x0D64(0x0004) (Edit, Const, Config)
	float                                              ScrollMaxMountCamDist;                                    // 0x0D68(0x0004) (Edit, Const, Config)
	unsigned long                                      CamMoving : 1;                                            // 0x0D6C(0x0004) (Transient)
	float                                              CamVel;                                                   // 0x0D70(0x0004) (Transient)
	float                                              CamAccel;                                                 // 0x0D74(0x0004) (Transient)
	float                                              MountDefaultFOV;                                          // 0x0D78(0x0004) (Edit, Const, Config)
	float                                              FOVTweak;                                                 // 0x0D7C(0x0004) (Edit, Const, Config)
	float                                              FOVElasticCoefficient;                                    // 0x0D80(0x0004) (Edit, Const, Config)
	float                                              MaxFOV;                                                   // 0x0D84(0x0004) (Edit, Const, Config)
	float                                              MinFOV;                                                   // 0x0D88(0x0004) (Edit, Const, Config)
	float                                              FOVFrictionCoefficient;                                   // 0x0D8C(0x0004) (Edit, Const, Config)
	float                                              FOVStopFrictionCoefficient;                               // 0x0D90(0x0004) (Edit, Const, Config)
	float                                              UnitTime;                                                 // 0x0D94(0x0004) (Transient)
	float                                              FOVAccel;                                                 // 0x0D98(0x0004) (Transient)
	float                                              FOVVelocity;                                              // 0x0D9C(0x0004) (Transient)
	float                                              PrevDist;                                                 // 0x0DA0(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLFlyMountCamera");
		return ptr;
	}


	void UpdateViewTarget(float DeltaTime, struct FTViewTarget* OutVT);
	void DisplayDebug(class AHUD* HUD, float* out_YL, float* out_YPos);
	bool DecideCamPos(float CamDistance, float DeltaTime, struct FTViewTarget* OutVT);
	float UpdateCamVelAccelAndGetDist(class APawn* CamTarget, float DeltaTime, struct FVector* FocusLoc);
	float UpdateFOVVelAccelAndGetFOV(class APawn* CamTarget, float DeltaTime);
	void ResetCamera();
	float CalcMinDistance();
};


// Class BLGame.LobbyCamera
// 0x01A0 (0x09A8 - 0x0808)
class ALobbyCamera : public ABLCameraBase
{
public:
	struct FBLCameraInfo                               FixedCameraInfo;                                          // 0x0808(0x0028)
	TEnumAsByte<ECERaceType>                           RaceType;                                                 // 0x0830(0x0001)
	TEnumAsByte<ECEGenderType>                         GenderType;                                               // 0x0831(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x0832(0x0002) MISSED OFFSET
	int                                                CustomizingPitch_Fixed;                                   // 0x0834(0x0004)
	int                                                CustomizingPitch_Flexible;                                // 0x0838(0x0004)
	int                                                maxPitch;                                                 // 0x083C(0x0004)
	int                                                MinPitch;                                                 // 0x0840(0x0004)
	int                                                RotationBtnOFFZoomStep;                                   // 0x0844(0x0004) (Edit, Config)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_amistad_male;                                    // 0x0848(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_amistad_female;                                  // 0x0858(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_aquaElf_male;                                    // 0x0868(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_aquaElf_female;                                  // 0x0878(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_pantera_male;                                    // 0x0888(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_pantera_female;                                  // 0x0898(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_iblis_male;                                      // 0x08A8(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_iblis_female;                                    // 0x08B8(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_siren_male;                                      // 0x08C8(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_siren_female;                                    // 0x08D8(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_mascu_U_male;                                    // 0x08E8(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_mascu_U_female;                                  // 0x08F8(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_habichts_male;                                   // 0x0908(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_habichts_female;                                 // 0x0918(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_sylvanElf_male;                                  // 0x0928(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_sylvanElf_female;                                // 0x0938(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_lupus_male;                                      // 0x0948(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_lupus_female;                                    // 0x0958(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_fedayin_male;                                    // 0x0968(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_fedayin_female;                                  // 0x0978(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_mascu_H_male;                                    // 0x0988(0x0010) (Edit, Config, NeedCtorLink)
	TArray<struct FZoomStepDistFocus>                  ZoomStep_mascu_H_female;                                  // 0x0998(0x0010) (Edit, Config, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.LobbyCamera");
		return ptr;
	}


	void SetCustomizingCamera_Flexible();
	void SetCustomizingCamera_Fixed();
	void RotatePitch(int DeltaPitch);
	void SetLobbyCamera_Fixed();
	void SetLobbyDefaultCamera();
	void SetFixCamera(class ABLPawn* InTargetPawn, const struct FName& TargetBoneName, float InFOV, float InDistance, const struct FVector& CameraViewVector, const struct FVector& WorldLookOffset, int InMaxPitch, int InMinPitch);
	void SetRaceAndGender(TEnumAsByte<ECERaceType> InRaceType, TEnumAsByte<ECEGenderType> InGenderType);
	void InitCustomizingCamera(TEnumAsByte<ECERaceType> InRaceType, TEnumAsByte<ECEGenderType> InGenderType);
};


// Class BLGame.BLCheatManager
// 0x01C4 (0x0244 - 0x0080)
class UBLCheatManager : public UCheatManager
{
public:
	class ABLPawn*                                     TestTargetPawn;                                           // 0x0080(0x0008) (Transient)
	class ABLProjectile*                               TestProjectile;                                           // 0x0088(0x0008) (Transient)
	struct FString                                     PointFunction;                                            // 0x0090(0x0010) (Transient, NeedCtorLink)
	struct FVector                                     MarkedPoint;                                              // 0x00A0(0x000C) (Transient)
	struct FString                                     ScreenClickFunction;                                      // 0x00AC(0x0010) (Transient, NeedCtorLink)
	class UParticleSystemComponent*                    SpawnedFx;                                                // 0x00BC(0x0008) (ExportObject, Transient, Component, EditInline)
	unsigned long                                      SoundSoftMuted : 1;                                       // 0x00C4(0x0004) (Transient)
	unsigned long                                      bFreeCameraMode : 1;                                      // 0x00C4(0x0004) (Transient)
	unsigned long                                      bShowAnimWeights : 1;                                     // 0x00C4(0x0004) (Transient)
	unsigned long                                      bTestTaxi : 1;                                            // 0x00C4(0x0004) (Transient)
	TArray<struct FPCInfoKey>                          NumToPCInfoKey;                                           // 0x00C8(0x0010) (Const, Config, GlobalConfig, NeedCtorLink)
	struct FString                                     PCInfo_F1;                                                // 0x00D8(0x0010) (Const, Config, GlobalConfig, NeedCtorLink)
	struct FString                                     PCInfo_F2;                                                // 0x00E8(0x0010) (Const, Config, GlobalConfig, NeedCtorLink)
	struct FString                                     PCInfo_F3;                                                // 0x00F8(0x0010) (Const, Config, GlobalConfig, NeedCtorLink)
	struct FString                                     PCInfo_F4;                                                // 0x0108(0x0010) (Const, Config, GlobalConfig, NeedCtorLink)
	struct FString                                     PCInfo_F5;                                                // 0x0118(0x0010) (Const, Config, GlobalConfig, NeedCtorLink)
	struct FString                                     PCInfo_F6;                                                // 0x0128(0x0010) (Const, Config, GlobalConfig, NeedCtorLink)
	struct FString                                     PCInfo_F7;                                                // 0x0138(0x0010) (Const, Config, GlobalConfig, NeedCtorLink)
	struct FString                                     PCInfo_F8;                                                // 0x0148(0x0010) (Const, Config, GlobalConfig, NeedCtorLink)
	struct FString                                     PCInfo_Alt_F1;                                            // 0x0158(0x0010) (Const, Config, GlobalConfig, NeedCtorLink)
	struct FString                                     PCInfo_Alt_F2;                                            // 0x0168(0x0010) (Const, Config, GlobalConfig, NeedCtorLink)
	struct FString                                     PCInfo_Alt_F3;                                            // 0x0178(0x0010) (Const, Config, GlobalConfig, NeedCtorLink)
	struct FString                                     PCInfo_Alt_F4;                                            // 0x0188(0x0010) (Const, Config, GlobalConfig, NeedCtorLink)
	struct FString                                     PCInfo_Alt_F5;                                            // 0x0198(0x0010) (Const, Config, GlobalConfig, NeedCtorLink)
	struct FString                                     PCInfo_Alt_F6;                                            // 0x01A8(0x0010) (Const, Config, GlobalConfig, NeedCtorLink)
	struct FString                                     PCInfo_Alt_F7;                                            // 0x01B8(0x0010) (Const, Config, GlobalConfig, NeedCtorLink)
	struct FString                                     PCInfo_Alt_F8;                                            // 0x01C8(0x0010) (Const, Config, GlobalConfig, NeedCtorLink)
	float                                              AnimWeightDisplayBias;                                    // 0x01D8(0x0004) (Const, Config, GlobalConfig)
	class USkeletalMeshComponent*                      WeatherEffectParentComponent;                             // 0x01DC(0x0008) (ExportObject, Component, EditInline)
	TArray<class UGFxUI_NameTagObject*>                NameTagObjects;                                           // 0x01E4(0x0010) (NeedCtorLink)
	struct FMap_Mirror                                 BotNameMap;                                               // 0x01F4(0x0048) (Const, Native)
	class UParticleSystemComponent*                    WeatherPSC;                                               // 0x023C(0x0008) (ExportObject, Transient, Component, EditInline)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLCheatManager");
		return ptr;
	}


	void ClearSkillDeckUI();
	void TestB();
	void TestA();
	void SetGemPiece(const struct FQWord& InCount, const struct FQWord& IncreaseDelta);
	void OpenWithdrawGemDialog(int InStanceGem, int InNonStanceGem, int InParameterGem, const struct FQWord& InGold);
	void SetPlayerTestSkillData();
	void ChallengeTowerTeleport();
	void ChallengeTowerLimitCount(int UseCount, int MaxAdditionalCount, int AdditionalUseCount);
	void ChallengeTowerRanking();
	void ChallengeTowerRankingOpen();
	void ChallengeTowerPartyDeath(int InRemainTime);
	void ChallengeTowerCT(int InTokenCT);
	void ChallengeTowerMonsterCount(int InRemainCount);
	void ChallengeTowerHolyHP(int InHP, int InMaxHP);
	void EndRound();
	void StartRound(int InRound);
	void EndWaitingRound();
	void StartWaitingRound(int InRound);
	void EndChallengeTower();
	void StartChallengeTower();
	void CollectionBookFellowEnable(bool InEnable);
	void TestScoreBoard(bool InbVictory);
	void MissionTabAnimPlay(int InTabIndex);
	void ModifyPlayerLevel(int InModifyLevel);
	void ToggleDebugCharacterLight();
	void ResetCharacterLight();
	void EnableCharacterLight(bool InIsAttachLight, bool InEnableLightEnv, bool InOnPassLightingOnTranslucency);
	void ReceiveUnregistReqAck();
	void ReceiveRegistReqAck();
	void RandomDungeonEquipLock(bool InLock);
	void ToggleChatFocus(bool InEnable);
	void FindRuneSocketItemList(TEnumAsByte<ECERuneType> InRuneType);
	void PlayTamingGame(int InGameCid, int InTotalCount, int InPlayTime, float InBarSpeed, float InBarStopTime, int InSafeZoneIndex, int InSafeZoneSize);
	void OpenCraftRecipeUI(TEnumAsByte<ECEV2CraftCategoryType> InCraftType);
	void OpenCraftResultDialog(int InCraftCId, int InItemCid, TEnumAsByte<ECraftResultType> InSuccessType);
	void OpenLivingGradeUpDialog(TEnumAsByte<ECEV2CraftCategoryType> InCraftType);
	void OpenLivingLevelUpDialog(TEnumAsByte<ECEV2CraftCategoryType> InCraftType, int InFromLevel, int InToLevel);
	void ChoiceSubCraftCategory(TEnumAsByte<ECEV2CraftCategoryType> InCraftType);
	void ChoiceMainCraftCategory(TEnumAsByte<ECEV2CraftCategoryType> InCraftType);
	void ProgressCraft(int InCraftCId);
	void SendWICMessage(int InMessageIndex);
	void TestKeyString(const struct FString& InString);
	void TestCollectionServer();
	void TestCollectionUI3();
	void TestCollectionUI2(int InIndex);
	void TestCollectionUI1(int InIndex, int InSid);
	void TutorialOrderTest();
	void ToggleMountFly(bool InFlyable);
	void SetUseMTGC(bool bTurnOn);
	void SetOptimizeExtreme(bool bTurnOn);
	void SetOptimizeLazyGC(bool bTurnOn);
	void SetOptimizeAnimTreeCache(bool bTurnOn);
	void SetOptimizeOnePassPawnInit(bool bTurnOn);
	void SetOptimizePawnUpdate(bool bTurnOn);
	void SetOptimizePawn(bool bTurnOn);
	void EnableBLCache(bool bEnable);
	void TestCacheAging(int COUNT);
	void GetAllCollectionList();
	void ShowAutoPathNode();
	void AttachFXToSocketInCurrentMount(const struct FName& SocketName);
	void ShowCurrentMountSocketNameList();
	void V2MountNpc(int npcId, unsigned char MountType, unsigned char AnimType);
	void TestBLStatuePC();
	void testInitSeasonHistory();
	void testRegistInstanceRevivalPoint(int InSid, TEnumAsByte<ECEInstantRevivalPointType> InPointType, const struct FString& InSpawnerName);
	void testAddInstanceRevivalPoint(int InSid, TEnumAsByte<ECEInstantRevivalPointType> InPointType, const struct FString& InSpawnerName);
	void testTalk(int Size);
	void TestCitadelOwner(int citadelCid, const struct FString& GuildName, const struct FString& CharacterName, int CrownType, int GuildRankLevel, int BackgroundCid, int SymbolCid, int SymbolColorIndex);
	void TestRealmOwner(const struct FString& GuildName, const struct FString& CharacterName, int CrownType, int GuildRankLevel, int BackgroundCid, int SymbolCid, int SymbolColorIndex);
	void TestNameTagGuildMark(int CrownType, int GuildRankLevel, int BackgroundCid, int SymbolCid, int SymbolColorIndex);
	void TestSetGuildCO_RO(bool bRO, bool bCO);
	void BattleMessageCustomScale(float InScale);
	void BattleMessagePending(bool IsPending);
	void UpdateOrder(int orderId);
	void TestOrder();
	void ShowEmitterPool();
	void SetServiceCode(const struct FString& InServiceCode);
	void SetLanguage(const struct FString& InLanguage);
	void ShowDamageTextConfig();
	void SetFixedCameraControl(bool IsUse);
	void RefreshRevivalDialog();
	void TestDeathSound(int Num);
	void DebugGameStringHtmlTag(bool IsShowInvalidString);
	void TestRevivalDialog(int InType, float InRemainSecond, bool InIsUsePremiumRevival, int InRemainPremiumRevivalCount, bool InIsTutorial);
	void TestDeulTooltip();
	void ToggleHitUpTest();
	void SetChatStressOption(int InSendCountOnTick, float InTerm);
	void ToggleChatStress();
	void ToggleSheathe();
	void ToggleChatOption();
	void MoveParty(int Index, int SlotIndex);
	void LoadUIConfig();
	void SaveUIConfig();
	void SetNPCLocationReviser(bool bEnable);
	void TestPmangLink(const struct FString& InParam);
	void TestExternalLink(const struct FString& InURL);
	void TestInputDialog();
	void TestRejoinTime(int inTime);
	void TestFlashShop(bool bOpen);
	void SetMinimapUpdateConfig(float InIntervalTime, int InIntervalTickCount);
	void ChangeBattleMessageConfig(int InDrawCountOnTick, int InMaxBufferSize, int InIntervalTickCount);
	void ForceUpdateWebView();
	void SetWebShopCount(int COUNT);
	void TestUnequipCostume(int SlotType, int TargetTabId, int TargetSlotId);
	void TestEquipCostume(int SlotType, int Cid);
	void TestAddFriend();
	void TestInitFriendList();
	void WIC_Exchange();
	void WIC_StorageBox();
	void WIC_Blessership();
	void WIC_Item();
	void WIC_Lumena();
	void WIC_VIPService();
	void WIC_FirstShop();
	void WIC_MainShop();
	void OpenLootingDice();
	void TestServerDialog(int InType);
	void ForceUIGC();
	void TestColosseumDialog(int InMode);
	void TestTimeLoop(int InHour, int InMinute);
	void BLCrash();
	void TestLumenaShop();
	void UseTestLoadingValueNPC(bool IsUse, int MaxLoadingCount, int MaxMeshCount, int MaxProxyCount);
	void UseTestLoadingValuePC(bool IsUse, int MaxLoadingCount, int MaxMeshCount, int MaxProxyCount);
	void ToggleTextureStreaming(bool bToggle);
	void TestInvenExpansion_Month(int InExpansionCid);
	void TestInvenExpansion_Week(int InExpansionCid);
	void TestInvenExpansion_Permanent(int InExpansionCid);
	void ChangeLineCheckFrequency(int DestTick);
	void TestItemCoolTime(int InItemCid, float InRemainTime, float InMaxTime);
	void TestHourlyAlarm(int Hour, int Min, float Sec);
	void TestTokenTooltip(TEnumAsByte<ETooltipType> InToolTipType);
	void TestPetTooltip(const struct FString& PetUId);
	void WriteHitch(float Milliseconds);
	void WriteFrame(int Seconds);
	void SpawnBot(int MinLV, int MaxLV, float Radius, int NumOfBots);
	void ToolTipTest(const struct FString& Description);
	void UIHitDebug(bool bVisible);
	void UIDebug(bool bVisible);
	void TestUISound(int TestIndex);
	void SetTargetAdjustLevel(int InAdjustLevel);
	void TestHelp(int Cid);
	void ToggleMEXSize(int Step);
	void ToggleMEXMove();
	void ToggleHelp();
	void ToggleMEX();
	void ChangeAutoTargetType(bool IsOldType);
	void ChangeTabTargetType(bool IsOldType);
	void ToggleAimDebug();
	void TestStartCoIcon(bool IsStart);
	void TestSystemMessage2(const struct FString& InCodeName, const struct FString& paramStr1, const struct FString& paramValue1, const struct FString& paramStr2, const struct FString& paramValue2, const struct FString& paramStr3, const struct FString& paramValue3, const struct FString& paramStr4, const struct FString& paramValue4);
	void TestSystemMessage(int Num);
	void TestROProgress(bool bOn);
	void TestROResult();
	void TestDungeonTimer(bool bVisible);
	void TestScore(bool bVisible);
	void OpenUIEnum(TEnumAsByte<EUIName> UINameEnum);
	void OpenUI(const struct FString& UIName);
	void TestConquestUI_MyInfo();
	void TestConquestUI_Ranking(bool bShowVictory);
	void GetCPTest(const struct FString& Text);
	void FindBlockingActors();
	void SetTargetRankResetTime(float Value);
	void SetTargetListRefreshTime(float Value);
	void SetTargetSelect_ByCamera(bool Value);
	void SetTargetRange_FriendlyRadius(float Value);
	void SetTargetRange_HostileZ(float Value);
	void SetTargetRange_HostileDegree(float Value);
	void SetTargetRange_HostileRadius2(float Value);
	void SetTargetRange_HostileRadius1(float Value);
	void LoadMonsterBookAsset(int Cid);
	void ReloadDialog();
	void RequestMail();
	void TestChangeSkill(int InFromSkill, int InToSkill);
	void CreateGuildQueryDialog(bool isAgree);
	void CheckGuildName(const struct FString& in_name);
	void CloseGuildCreate();
	void OpenGuildCreate(bool In_2, bool In_3, bool In_4, bool In_5, bool In_6, bool In_7, bool In_8);
	void DetachTransportVolume();
	void AttachTransportVolume();
	void ToggleVisionShared(bool bInVisionShared);
	void TestAnimPlay(const struct FName& AnimSeqName);
	void TestDialog(int Step);
	void SetNPCBodyShakeParam(float PlayTime, float Scale);
	void ReloadUIPlayer();
	void CloseUIPlayer();
	void TestHitBy(bool bForward);
	void CaptureSky();
	void ResumeAsync();
	void PauseAsync();
	void SetAvailableMemoryLevel(int Level);
	void VolumeTest(bool isEnable);
	void InitInven();
	void PinFocusing(float X, float Y, float Z);
	void PositionMode();
	void TestZoneNameVector(float X, float Y, float Z);
	void TestZoneName();
	void PrintUI();
	void UnLoadUI(const struct FString& UIName);
	void LoadUI(const struct FString& UIName);
	void execGoToLobby();
	void monCount(int iCount);
	void skilldeckOpen();
	void inventoryOpen();
	void alertTest(int questId, bool bEnable);
	void TestTransferChannel(int channelId);
	void TestDeadlyHP();
	void TestLowHP();
	void TestNormalHP();
	void clearnametagpool();
	void nametagtest(int Test);
	void TurnDoorCollisionOff(const struct FString& DoorName);
	void TurnDoorCollisionOn(const struct FString& DoorName);
	void CloseDoor(const struct FString& DoorName);
	void OpenDoor(const struct FString& DoorName);
	void GetMem();
	void TestToggleSkillOff();
	void TestToggleSkillCancel();
	void TestToggleSkillFired();
	void TestToggleSkill(int SlotIdx);
	void TestPushStop();
	void TestPushBack(float Time);
	void TestLookAtMe(bool bEnable);
	void WeatherEffectFinished(class UParticleSystemComponent* PSC);
	void SetWeatherCount(float COUNT);
	void ChangeWeather(TEnumAsByte<EWeatherType> InWeather);
	void GetCustomCameraInfo();
	void ToggleDisableOutLine();
	void PropTooltip(int iCase);
	void RepurchaseItem(int InIndex);
	void SellItem(int InIndex);
	void BuyItem(int InIndex);
	void WayTest(int Talk);
	void WarpTest(int Warp);
	void TrapVisible(int InTrapCid, bool bVisible);
	void TrapDespawn(int InTrapCid);
	void TrapPhase(int TrapCid, int PhaseIndex);
	void TrapSpawn(int TrapCid);
	void ShowDebugLoadedLevel(bool Toggle);
	void ShowQuestWorldMap(int questId);
	void castingTest2();
	void castingTest();
	void SetTargetScale(float Scale);
	void RevivalClose(int State);
	void IncreaseGuildDummyMember(int COUNT);
	void OpenGuildCreation();
	void OpenPrivateTrade();
	void UACloseLetterInfo();
	void OpenLetterInfo();
	void EnablePacketLogger();
	void ShowUnfilteredLog();
	void HideUnfilteredLog();
	void GetPendingSkillTime();
	void SetPendingSkillTime(float inTime);
	void FlyWaypoint(const struct FString& DepartureName, const struct FString& ArrivalName);
	void TaxiWarp(float warp_end_time);
	void TaxiStopover();
	void TaxiGhost(int start_waypoint, int dest_waypoint);
	void Taxi(int dest_waypoint);
	void ListWaypointAll();
	void ListWaypoint();
	void PlayCinematicAction(const struct FName& CinematicSceneName, int npcId);
	void PIESetEmitterPlayRate(float InPlayRate);
	void ServerLocationBaseCenter();
	void ServerLocationBaseGround();
	void SocialAction(int InCid);
	void GetUp();
	void Down();
	void Pull();
	void Push();
	void HitUpMe();
	void OnTimerHitUpMe();
	void HitUp();
	void OnTimerHitUp();
	class UBSM_RiotControlParameter* GetDefaultRiotControlParameter(TEnumAsByte<ECERiotControlType> RiotControlType, class APawn* InInstigator, class APawn* InTarget);
	void SetMaxNPCPitch(int maxPitch);
	void SetMaxPitchDelta(int PitchDelta);
	void SetFlyMountInterp(bool bInterp, const struct FString& TrackMoveObjName);
	void ShortCutCmd_Fly();
	void ShortCutCmd_ToggleTargetUI();
	void ShortCutCmd_Walk();
	void ShortCutCmd_Ghost();
	void ShortCutCmd_ToggleSoftSoundMute(float InVolume);
	void ShortCutCmd_TogglePlayerHidden();
	void ToggleSetSpeed(bool bUp);
	void ToggleUseCamBlock();
	void ToggleServerLocBox();
	void HideServerLocation();
	void ShowServerLocation();
	void HideServerLocationAll();
	void ShowServerLocationAll(float InLocationBoxLife);
	void PrintIndexedObjectReferenceAll(const struct FString& TargetClass);
	void PrintIndexedObjectReference(const struct FString& TargetClass);
	void SetSpeedInfo_Grid(float InNewWalkBack, float InNewWalkForward, float InNewRunBack, float InNewRunForward, float InFullRunForward);
	void SetSpeedInfo_Meter(float InNewWalkBack, float InNewWalkForward, float InNewRunBack, float InNewRunForward, float InFullRunForward);
	void GetSpeedInfo();
	void SetMaxStepHeight(float InHeight);
	void SpeedDown();
	void SpeedUP();
	void ToggleCamInterpolate();
	void TogglePlayerMeshInterpolate();
	void SetStepUPDownTan(float InTangent);
	void SetCamAccel(float InAccel);
	void UseSkillUpperAnim(bool bUse);
	void NpcDistributedProcessing(bool bUse);
	void NpcSimpleWalkInterval(float interval);
	void NpcSimpleWalk(bool bUse);
	void AddItem(int ItemCid, int NumOfItem);
	void ShowEquipment(TEnumAsByte<ECEEquipSlotType> InConceptEquipSlotType, bool bShow);
	void LogPawnInfos();
	void ToggleSkillCancel(int SkillID);
	void MountAttack();
	void SummoneeToggleEnergySphere(bool Toggle);
	void SummoneeDespawn();
	void SummoneeFollow();
	void SummoneeAIStance(TEnumAsByte<ESummoneeStance> Instance);
	void SummoneeMove();
	void SummoneeAttack();
	void SummoneeSkill(int SkillCid);
	void TurnOnFootPlacementControl();
	void TurnOffFootPlacementControl();
	void SetLootAdjustRotation(bool bAdjust);
	void GetAutoPickUpTime();
	void SetAutoPickUpTime(float Seconds);
	void LootTestItemUpdate();
	void LootTestLeaveAction();
	void LootTestPickupAll();
	void AuraClear();
	void AuraList();
	void AuraDisappear_Finish(int AuraID);
	void AuraAppear(int AuraID);
	void AbnormalClear();
	void AbnormalList();
	void AbnormalPeriodic(int AbnormalStatusID);
	void AbnormalDisappear_Crash(int AbnormalStatusID);
	void AbnormalDisappear_Finish(int AbnormalStatusID);
	void AbnormalOnGoing(int AbnormalStatusID);
	void AbnormalAppear(int AbnormalStatusID);
	void SetTargetMorphWeight(float MorphWeight);
	void BLTeleport(int WorldType, int WorldCid, float X, float Y, float Z);
	void RebuildNpcPickingGeometries(bool IsCheckInSide, bool IsMergeGeometry, bool IsMergeSplitBox);
	void ClearNpcPickingGeometries();
	void DrawPickingGeometries(bool draw);
	void ShowPickingGeometries(bool show);
	void PlayDriverAnim(int DriverID, const struct FName& inSeqName);
	void ShowLegControlTarget();
	void AdjustRightKnee(float X, float Y, float Z);
	void AdjustLeftKnee(float X, float Y, float Z);
	void AdjustRightFoot(float X, float Y, float Z);
	void AdjustLeftFoot(float X, float Y, float Z);
	void TurnOffBoneCtrl();
	void TurnOnBoneCtrl();
	void UnMount();
	void MountNpc(int npcId, unsigned char MountType, unsigned char AnimType);
	void Mount(int MountCId);
	void ShowAnimWeights();
	void SetMITVTimer(float Time, const struct FString& MITVResource);
	void SetMITV(const struct FString& MITVResource);
	void SetMaxJumpHeight(float H);
	void SetSoundListenerType(const struct FString& InListenerType);
	void ShowNpcVolumeActor(bool bShow);
	void TogglePopup();
	void ToggleName();
	void SetColorOnMouseOver(unsigned char R, unsigned char G, unsigned char B);
	void TestDrawGeometryCircularArcCylinder(float nearRadius, float FarRadius, float Height, float Angle, int R, int G, int B, int Seconds);
	void TestDrawGeometrySectorCylinder(float Radius, float Height, float Angle, int R, int G, int B, int Seconds);
	void TestDrawGeometryCircularCylinder(float Radius, float Height, int R, int G, int B, int Seconds);
	void TestDrawGeometrySphere(float Radius, int R, int G, int B, int Seconds);
	void TestDrawSphere(float X, float Y, float Z);
	void TestDrawGeometryBox(float Width, float Depth, float Height, int R, int G, int B, int Seconds);
	void DrawGeometryCircularArcCylinder(const struct FVector& Origin, float nearRadius, float FarRadius, float Height, float Angle, const struct FVector& Direction, const struct FColor& Col, int Seconds);
	void DrawGeometrySectorCylinder(const struct FVector& Origin, float Radius, float Height, float Angle, const struct FVector& Direction, const struct FColor& Col, int Seconds);
	void DrawGeometryCircularCylinder(const struct FVector& Origin, float Radius, float Height, const struct FColor& Col, int Seconds);
	void DrawGeometrySphere(const struct FVector& Origin, float Radius, const struct FColor& Col, int Seconds);
	void DrawGeometryBox(const struct FVector& Origin, const struct FVector& Extends, const struct FVector& Direction, const struct FColor& Col, int Seconds);
	void DrawGeometryOrigin(const struct FVector& InLocation, const struct FVector& Direction, float Length, const struct FColor& Col, int Seconds);
	void LocalPawnList();
	void TakeoffItem(int Slot);
	void EquipItem(int ItemName, int Slot);
	void UndressAllItem();
	void ToggleDumpMoveNative(float a_FPS);
	void ToggleDumpMovie(float a_FPS);
	void SlowMotionNeutral();
	void SlowMotionDown();
	void SlowMotionUp();
	float GetGameSpeed();
	void TestCutIn();
	void TestScreen(float Time);
	void PointHere();
	void UpdateTestUI();
	void TestMoviePlay(int MovieId);
	void HidePropAll(bool bHide);
	void ShowMonologue(const struct FString& Test);
	void DoLineCheckToMark(int Times);
	void DoLineCheckToPathNodesFromPlayerStart(int repeatEachTimes);
	void DoLineCheckInterNpcSpawner(int repeatEachTimes, int Range);
	void DoLineCheckInterPathNodes(int repeatEachTimes, int Range, int IsNonZero);
	void DoLineCheckToPathNodes(int repeatEachTimes);
	void CastLineCheck(const struct FVector& Origin, const struct FVector& Target, int Times);
	void SetScreenClickFunction(const struct FString& FunctionName);
	void SetPointFunction(const struct FString& FunctionName);
	void ChangePawn(int PlayerTypeID);
	void ToggleAutoTarget();
	void SpawnFX(const struct FString& ResPath);
	void SpawnNpc(int NpcCid, int ServerID);
};


// Class BLGame.LobbyPC
// 0x0130 (0x08A8 - 0x0778)
class ALobbyPC : public ABlessPCBase
{
public:
	class AActor*                                      PointingActor;                                            // 0x0778(0x0008) (Transient)
	class AActor*                                      SelectedActor;                                            // 0x0780(0x0008) (Transient)
	class ABLPawn*                                     SelectedPawn;                                             // 0x0788(0x0008)
	class ABLPawn*                                     CreatedPawn;                                              // 0x0790(0x0008)
	struct FPCInfoKey                                  CurrentPCInfoKeyLobbyCC;                                  // 0x0798(0x0004)
	TEnumAsByte<ECERealmType>                          CurrentRealmTypeLobbyCC;                                  // 0x079C(0x0001)
	unsigned char                                      SettingFlag;                                              // 0x079D(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x079E(0x0002) MISSED OFFSET
	class APlayerStart*                                SelectedPawnStart;                                        // 0x07A0(0x0008)
	class ACameraActor*                                CameraLoginExternal;                                      // 0x07A8(0x0008)
	class ACameraActor*                                CameraLogin;                                              // 0x07B0(0x0008)
	class ACameraActor*                                CameraSelectFaction;                                      // 0x07B8(0x0008)
	class ACameraActor*                                CameraSelectCharacter;                                    // 0x07C0(0x0008)
	class ACameraActor*                                CameraLobbyTrans;                                         // 0x07C8(0x0008)
	class ACameraActor*                                CameraLobbyHieron;                                        // 0x07D0(0x0008)
	class ACameraActor*                                CameraLobbyUnion;                                         // 0x07D8(0x0008)
	unsigned long                                      PawnRotation : 1;                                         // 0x07E0(0x0004)
	unsigned long                                      bReserveSpawnLobbyPlayer : 1;                             // 0x07E0(0x0004)
	unsigned long                                      bDragging : 1;                                            // 0x07E0(0x0004)
	int                                                PawnRotationDir;                                          // 0x07E4(0x0004)
	int                                                ZoomLevel;                                                // 0x07E8(0x0004)
	TArray<class UPCAsset*>                            PCAssetCaches;                                            // 0x07EC(0x0010) (NeedCtorLink)
	TArray<class UItemAsset*>                          ItemAssetCaches;                                          // 0x07FC(0x0010) (NeedCtorLink)
	TArray<class UBLEquipmentItemEquipInfo*>           EquipmentAssetCaches;                                     // 0x080C(0x0010) (NeedCtorLink)
	struct FCharacterEnvironmentSetting                CurrentSetting;                                           // 0x081C(0x0030) (NeedCtorLink)
	TArray<struct FCharacterEnvironmentSetting>        CharacterEnvSettings;                                     // 0x084C(0x0010) (NeedCtorLink)
	TArray<struct FName>                               CharacterTags;                                            // 0x085C(0x0010) (NeedCtorLink)
	int                                                UIState;                                                  // 0x086C(0x0004)
	TArray<struct FCustomizeFileInfoStruct>            CustomizeFileInfo;                                        // 0x0870(0x0010) (NeedCtorLink)
	struct FLobbyCCCameraSettingType                   LobbyCCCameraSetting;                                     // 0x0880(0x0018) (Edit, Config)
	class UMaterialInstance*                           CurrentPickedMaterial;                                    // 0x0898(0x0008)
	class UBLCustomizingMouseHandler*                  CustomizingMouseHandler;                                  // 0x08A0(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.LobbyPC");
		return ptr;
	}


	void CustomMatineeIsDeactivated(class USeqAct_Interp* InTarget);
	void SetLobbyDefaultCamera();
	void SpawnLobbyPawn(const struct FVector& InLocation, const struct FRotator& InRotation, class ABLPlayer** OutNewPawn);
	bool FindPlayerStart(const struct FName& InName, class APlayerStart** OutPS);
	void DoRemoteEvent(const struct FName& InName);
	void OnRecvCancelServerChange(bool bSuccess);
	void FlushAsyncLoading();
	TEnumAsByte<EChatMode> GetChatMode();
	void SetChatMode(TEnumAsByte<EChatMode> InChatMode);
	void EnterAction();
	void EscapeAction();
	void RequestOneTimeKey();
	void CancelServerChange();
	void ServerChangeRequest();
	void InitCharacterCustomizingSlider();
	void SetCharacterCustomizingSlider(unsigned char BoneDeformPart, TEnumAsByte<EBoneDeformCategory> BoneDeformCategory, const struct FString& CategoryName, const struct FString& PropertyName, float MinValue, float MaxValue, float BaseValue);
	void SetCharacterCustomizingParameters();
	void RemoveTemoraryCustomizeFile();
	void LoadCustomize(int Index);
	void LoadCustomizeFile();
	void ProcessCustomizeShot();
	void TestLobbyCamera(const struct FName& TargetBone, float CamDistance, float CamFOV, float Shift, float ZOffset);
	void OnMaterialPicked(TArray<class UMaterialInterface*>* OutMaterialList);
	void RotateCustomizingTargetToClockwise();
	void EnableCustomizingPicking(bool bEnable);
	class ABLPawn* GetCustomizingTarget();
	void OnFilterButtonInput(class UBLSeqAct_FilterButtonInput* inAction);
	TEnumAsByte<EKindOfPC> GetKindOfGameMode();
	void SetCharacterEnvironmentSettingEnabled(const struct FCharacterEnvironmentSetting& Setting, bool bEnable);
	void SpawnLobbyPawnForLobbyCC();
	void CopyLightingGroup(class USkeletalMeshComponent* SrcComponent, class USkeletalMeshComponent* DestComponent);
	void SetCameraLobbyTrans();
	void SetCameraSelectCharacter();
	void LobbyMode_CC_NameVoice();
	void LobbyMode_CC_Customizing();
	void LobbyMode_CC_RaceGenderClass();
	void LobbyMode_CC_SelectRealm();
	void LobbyServerSelect();
	bool PlaceOnGround(class AActor* A);
	void SpawnDefaultHUD();
	bool FindActorsOfClass(class UClass* ActorClass, TArray<class AActor*>* out_Actors);
	bool CanRestartPlayer();
	void WorldMapZoom(bool bCursor, bool bZoomIn);
	void ZoomOut();
	void ZoomIn();
	void SetLobbyCamera();
	void UpdateRotation(float DeltaTime);
	void SetPawnRotation(bool InPawnRotation, int InPawnRotationDir);
	int GetCharacterEnvironmentSetting(const struct FName& TagName);
	void PlayerTick(float DeltaTime);
	void Destroyed();
	void PostBeginPlay();
	void InitCharacterTags();
	void OnFinishUIState(int InUIState);
	void OnLoadCompleteUIState(int InUIState);
	void OnStartUIState(int InUIState);
};


// Class BLGame.BLPlayerEnvironment
// 0x0068 (0x00C8 - 0x0060)
class UBLPlayerEnvironment : public UObject
{
public:
	struct FMap_Mirror                                 PlayerEnv;                                                // 0x0060(0x0048) (Native, Transient)
	TArray<struct FPlayerEnvironmentData>              UpdateBuffer;                                             // 0x00A8(0x0010) (Transient, NeedCtorLink)
	TArray<struct FPlayerEnvironmentData>              RemoveBuffer;                                             // 0x00B8(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLPlayerEnvironment");
		return ptr;
	}


	bool IsInAnyKeySetting();
	void Tick();
	void ClearEnv();
	bool RemoveEnv(int InKey, bool IsJustSend);
	void UpdateEnv(const struct FPlayerEnvironmentData& InData, bool IsJustSend);
	bool GetEnv(int InKey, struct FPlayerEnvironmentData* OutData);
	void InitializeEnv(TArray<struct FPlayerEnvironmentData> InDataList);
};


// Class BLGame.BLTargetSelectComponent
// 0x00F0 (0x0160 - 0x0070)
class UBLTargetSelectComponent : public UComponent
{
public:
	float                                              HostileTargetRange_Radius1;                               // 0x0070(0x0004) (Edit, Config)
	float                                              HostileTargetRange_Radius2;                               // 0x0074(0x0004) (Edit, Config)
	float                                              HostileTargetRange_Degree;                                // 0x0078(0x0004) (Edit, Config)
	float                                              HostileTargetRange_Z;                                     // 0x007C(0x0004) (Edit, Config)
	float                                              FriendlyTargetRange_Radius;                               // 0x0080(0x0004) (Edit, Config)
	unsigned long                                      TargetSelectByCamera : 1;                                 // 0x0084(0x0004) (Edit, Config)
	unsigned long                                      IsUseOldTypeAutoSelect : 1;                               // 0x0084(0x0004) (Transient)
	unsigned long                                      IsUseOldTypeTabSelect : 1;                                // 0x0084(0x0004) (Transient)
	float                                              AutoTargetRefreshTime;                                    // 0x0088(0x0004) (Edit, Config)
	float                                              TargetingRankResetTime;                                   // 0x008C(0x0004) (Edit, Config)
	float                                              TargetCanceledRange;                                      // 0x0090(0x0004) (Edit, Config)
	float                                              NearTargetMaxRange;                                       // 0x0094(0x0004) (Edit, Config)
	float                                              DelaySecondOfNextTarget;                                  // 0x0098(0x0004) (Edit, Config)
	float                                              Normal_ConditionDistMin;                                  // 0x009C(0x0004) (Edit, Config)
	float                                              Normal_ConditionFactor_p;                                 // 0x00A0(0x0004) (Edit, Config)
	float                                              Normal_TargetableMaxAngle;                                // 0x00A4(0x0004) (Edit, Config)
	float                                              NonTarget_ConditionDistMin;                               // 0x00A8(0x0004) (Edit, Config)
	float                                              NonTarget_ConditionFactor_p;                              // 0x00AC(0x0004) (Edit, Config)
	float                                              NonTarget_TargetableMaxAngle;                             // 0x00B0(0x0004) (Edit, Config)
	int                                                MaxTargetListSize;                                        // 0x00B4(0x0004) (Edit, Config)
	float                                              TargetingRankResetCount;                                  // 0x00B8(0x0004) (Transient)
	float                                              ConditionDistMin;                                         // 0x00BC(0x0004) (Transient)
	float                                              ConditionFactor_p;                                        // 0x00C0(0x0004) (Transient)
	float                                              TargetableMaxAngle;                                       // 0x00C4(0x0004) (Transient)
	class AActor*                                      ActorOwner;                                               // 0x00C8(0x0008) (Transient)
	class ABLCamera*                                   CameraOwner;                                              // 0x00D0(0x0008) (Transient)
	class ABLPawn*                                     PawnOwner;                                                // 0x00D8(0x0008) (Transient)
	class ABlessPC*                                    PCOwner;                                                  // 0x00E0(0x0008) (Transient)
	float                                              CheckDelaySecond;                                         // 0x00E8(0x0004) (Transient)
	float                                              OnHoldTargetTime;                                         // 0x00EC(0x0004) (Transient)
	TArray<struct FTargetSelectData>                   SortedFriendlyPawnList;                                   // 0x00F0(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<struct FTargetSelectData>                   SortedHostilePawnList;                                    // 0x0100(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<struct FTargetSelectData>                   SortedHostilePawnList_Simple;                             // 0x0110(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<struct FTargetBaseData>                     SortedNearNPCList;                                        // 0x0120(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<struct FTargetBaseData>                     SortedNearPropList;                                       // 0x0130(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<struct FTargetCraftSpotData>                CraftSpotList;                                            // 0x0140(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<struct FTargetBaseData>                     AbleLootingPawnList;                                      // 0x0150(0x0010) (Transient, AlwaysInit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLTargetSelectComponent");
		return ptr;
	}


	int GetFirstHostileTarget();
	int GetNextHostileTarget_Old(bool bForce);
	int GetNextHostileTarget(bool bForce);
	void GetHostileTargetListInRange(float Range, TArray<struct FTargetSelectData>* outTargetData);
	int GetHostileTarget_Old();
	int GetHostileTarget();
	int GetFriendlyTarget(TEnumAsByte<EFriendlyTargetType>* OutTargetType);
	float MakeTabScore(class ABLPawnBase* InSelf, class ABLPawnBase* InTarget);
	float GetRateResult(class ABLPawnBase* InSelf, class ABLPawnBase* InTarget);
	void SortTargetList();
	void ClearTargetList();
	bool UpdateTargetList();
	bool IsFriendlyTarget(class ABLPawnBase* inPawn, TEnumAsByte<EFriendlyTargetType>* OutTargetType);
	bool IsHostileTarget(class ABLPawnBase* inPawn, TEnumAsByte<EHostileTargetType>* OutTargetType);
	void UpdateTime(float DeltaTime);
	void ForceSetDelaySecond(float InDelayTime);
	void ResetDelaySecond(float InAdditionalTime);
	void UpdateComponentOwner(class ABLPawn* inPawn, class ABLCamera* InCamera);
	void ClearTargetingRankResetCount();
	void RefreshTargetingRankResetCount();
	void Initialize(class ABLPawn* inPawn, class ABlessPC* InPCOwner, class ABLCamera* InCamera);
};


// Class BLGame.CombatSoundController
// 0x0014 (0x0074 - 0x0060)
class UCombatSoundController : public UObject
{
public:
	float                                              TimeUntilCombatSoundEnd;                                  // 0x0060(0x0004) (Config)
	struct FName                                       SwitchGroupName;                                          // 0x0064(0x0008) (Const)
	float                                              ElapsedTimeAfterCombatEnd;                                // 0x006C(0x0004)
	unsigned long                                      WillCombatSoundBeEnding : 1;                              // 0x0070(0x0004)
	unsigned long                                      SendStartEvent : 1;                                       // 0x0070(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CombatSoundController");
		return ptr;
	}


	void EndCombatSound();
	void StartCombatSound();
	void CombatEnded();
	void CombatStarted();
	void Tick(float DeltaSeconds);
	void UpdateEnemyList(TArray<int>* InOldEnemyList, TArray<int>* InNewEnemyList);
	void PCDetected(int InSid);
	void CompleteLevelLoading();
};


// Class BLGame.HPAlertController
// 0x0014 (0x0074 - 0x0060)
class UHPAlertController : public UObject
{
public:
	class UMaterialInstanceTimeVarying*                LowHPEffectMaterial;                                      // 0x0060(0x0008) (Transient)
	class UMaterialInstanceTimeVarying*                LowHPBlinkEffectMaterial;                                 // 0x0068(0x0008) (Transient)
	float                                              LowHPBlinkEffectDuration;                                 // 0x0070(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.HPAlertController");
		return ptr;
	}


	void ClearHPAlertEffect();
	void GotoDeadlyHP();
	void GotoLowHP();
	void GotoNormalHP();
	void Tick(float DeltaTime);
	void Init();
	void Init_Native();
};


// Class BLGame.MouseEventDecider
// 0x0070 (0x00D0 - 0x0060)
class UMouseEventDecider : public UObject
{
public:
	class ABlessPCBase*                                Owner;                                                    // 0x0060(0x0008) (Transient)
	class UBLGameViewportClient*                       ViewportClient;                                           // 0x0068(0x0008) (Transient)
	class UBLPlayerInput*                              BLInput;                                                  // 0x0070(0x0008) (Transient)
	unsigned long                                      bHitTestOnUIWhenDisableCursor : 1;                        // 0x0078(0x0004) (Transient)
	unsigned long                                      bWaitingServerDecisionUseItem : 1;                        // 0x0078(0x0004) (Transient)
	unsigned long                                      bValidActionPlayed : 1;                                   // 0x0078(0x0004) (Transient)
	unsigned long                                      bIgnoreUI : 1;                                            // 0x0078(0x0004) (Transient)
	unsigned long                                      bMouseRightClickAttack : 1;                               // 0x0078(0x0004) (Transient)
	unsigned long                                      bMouseLeftClickAttack : 1;                                // 0x0078(0x0004) (Transient)
	unsigned long                                      bMouseLeftDoubleClickAttack : 1;                          // 0x0078(0x0004) (Transient)
	unsigned long                                      bMouseLeftMove : 1;                                       // 0x0078(0x0004) (Transient)
	struct FVector2D                                   ClickPosition;                                            // 0x007C(0x0008) (Transient)
	float                                              ClickStartTime;                                           // 0x0084(0x0004) (Transient)
	TEnumAsByte<EMouseDragState>                       MouseDragState;                                           // 0x0088(0x0001) (Transient)
	TEnumAsByte<EKindOfPC>                             KindOfPC;                                                 // 0x0089(0x0001) (Transient)
	unsigned char                                      MouseDoingClick;                                          // 0x008A(0x0001) (Transient)
	TEnumAsByte<EMouseClickActionMode>                 MouseClickActionMode;                                     // 0x008B(0x0001) (Transient)
	int                                                DragStartedMousePosX;                                     // 0x008C(0x0004) (Transient)
	int                                                DragStartedMousePosY;                                     // 0x0090(0x0004) (Transient)
	int                                                CachePickedServerID;                                      // 0x0094(0x0004) (Native, Transient)
	int                                                CacheDownPickedServerID;                                  // 0x0098(0x0004) (Native, Transient)
	struct FAreaLocationNormal                         CachePickedLocation;                                      // 0x009C(0x001C) (Native, Transient)
	int                                                CachedItemSID;                                            // 0x00B8(0x0004) (Transient)
	int                                                DragStartDisp;                                            // 0x00BC(0x0004) (Config)
	float                                              DragStartTime;                                            // 0x00C0(0x0004) (Config)
	float                                              ButtonDownElapsedTime;                                    // 0x00C4(0x0004) (Transient)
	int                                                PrevMouseX;                                               // 0x00C8(0x0004) (Transient)
	int                                                PrevMouseY;                                               // 0x00CC(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MouseEventDecider");
		return ptr;
	}


	void StopRepairModeHammer();
	void StartRepairModeHammer();
	void StopAllActionMode();
	void StopCustomizingMouseControl();
	void StartCustomizingMouseControl();
	void StopWorldMapControl();
	void StartWorldMapControl();
	void StartNormalClickMode();
	void StopSummoneeControl();
	void StartSummoneeControl();
	void StopInventoryItemSplitMode();
	void StartInventoryItemSplitMode();
	void StopItemPickTargetMode();
	void StartItemPickTargetMode(int Item_s_Id);
	void StopItemAreaMode();
	void StartItemAreaMode();
	void StopSkillAreaMode();
	void StartSkillAreaMode();
	void OnEndRepairModeHammer();
	void OnEndWorldMapControl();
	void OnEndSummoneeControlMode();
	void OnEndItemPickTargetMode();
	void OnEndItemAreaMode();
	void OnEndSkillAreaMode();
	void SetMouseClickActionMode(TEnumAsByte<EMouseClickActionMode> InMouseClickActionMode);
	void UpdateTime(float DeltaTime);
	float GetYawModifier();
	float GetPitchModifier();
	void ClickPositionCheckPoint();
	void DecideCursorType(struct FMouseClientInfo* MouseInfo);
	void TurnOffCursor(TEnumAsByte<ECursorPosCacheType> InCursorPosType);
	void TurnOnCursor();
	bool IsAreaTargetMode();
	bool CheckMouseState(unsigned char CheckFlag, bool bOnly);
	TEnumAsByte<EMouseDoingClick> GetMouseState();
	bool EscapeMouseActionMode();
	void SetMouseClick(TEnumAsByte<EMouseDoingClick> Flag, bool bClick);
	void GetMousePosChangeDelta(int* DeltaX, int* DeltaY);
	void MouseMove(int X, int Y);
	void MiddleUp();
	void MiddleDown();
	void RightUp();
	void RightDown();
	void LeftUp();
	void LeftDown();
	void ClickEventHappen(TEnumAsByte<EMouseGesture> Button, bool bDown);
	void UnPossessed();
	void PossessedBy(class ABlessPCBase* C);
	void PickAreaLocation(struct FAreaLocationNormal* rtn);
	void MouseClickAction(TEnumAsByte<EMouseGesture> Button, bool bDown);
	bool IsHitTestOnUI();
	bool IsClickedOnUI();
	bool IsPickable();
	void SetDragState(TEnumAsByte<EMouseDragState> InState);
	bool IsDragMode();
};


// Class BLGame.MouseEventDecider_AimTargeting
// 0x0018 (0x00E8 - 0x00D0)
class UMouseEventDecider_AimTargeting : public UMouseEventDecider
{
public:
	unsigned long                                      bCursorOn : 1;                                            // 0x00D0(0x0004) (Transient)
	unsigned long                                      UIMode : 1;                                               // 0x00D0(0x0004) (Transient)
	float                                              PitchModifier;                                            // 0x00D4(0x0004) (Config)
	float                                              YawModifier;                                              // 0x00D8(0x0004) (Config)
	float                                              MovingTimeInUIMode;                                       // 0x00DC(0x0004) (Transient)
	struct FVector2D                                   MouseTemporaryPoint;                                      // 0x00E0(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MouseEventDecider_AimTargeting");
		return ptr;
	}


	void StopItemAreaMode();
	void StartItemAreaMode();
	void OnEndSkillAreaMode();
	void StartSkillAreaMode();
	void CursorMoveToTemporaryPoint();
	void ToggleUIMode(bool Toggle, bool bForce);
	void UpdateCursor();
	void MouseButtonRelease();
	float GetYawModifier();
	float GetPitchModifier();
	void StopWorldMapControl();
	void StartWorldMapControl();
	bool EscapeMouseActionMode();
	void MouseMove(int X, int Y);
	void ClickEventHappen(TEnumAsByte<EMouseGesture> Button, bool bDown);
	void PossessedBy(class ABlessPCBase* C);
	bool IsChargeSkillState();
	bool IsHitTestOnUI();
	bool IsClickedOnUI();
};


// Class BLGame.MouseEventDecider_ClassicTargeting
// 0x0000 (0x00D0 - 0x00D0)
class UMouseEventDecider_ClassicTargeting : public UMouseEventDecider
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MouseEventDecider_ClassicTargeting");
		return ptr;
	}

};


// Class BLGame.MoveController
// 0x0154 (0x01C4 - 0x0070)
class UMoveController : public UComponent
{
public:
	TEnumAsByte<EPawnPhysics>                          PawnPhysics;                                              // 0x0070(0x0001) (Transient)
	TEnumAsByte<EMoveState>                            MoveState;                                                // 0x0071(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x2];                                       // 0x0072(0x0002) MISSED OFFSET
	unsigned long                                      bJumping : 1;                                             // 0x0074(0x0004) (Transient)
	float                                              MoveUpdateTime;                                           // 0x0078(0x0004) (Transient)
	float                                              JumpSyncUpdateTime;                                       // 0x007C(0x0004) (Transient)
	struct FActionSyncInfo                             LastMovementSync;                                         // 0x0080(0x0144) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MoveController");
		return ptr;
	}


	void UpdateMoveSync(bool bForceUpdate);
	bool IsPressedMoveButton();
	bool IsMoving();
	TEnumAsByte<EPhysics> GetPhysics();
};


// Class BLGame.MsgCommandDecider
// 0x0080 (0x00F0 - 0x0070)
class UMsgCommandDecider : public UComponent
{
public:
	TArray<struct FMsgCommandData>                     ChatCommandList;                                          // 0x0070(0x0010) (NeedCtorLink)
	TArray<struct FMsgCommandData>                     GMCommandList;                                            // 0x0080(0x0010) (NeedCtorLink)
	TArray<struct FMsgCommandData>                     DevCommandList;                                           // 0x0090(0x0010) (NeedCtorLink)
	TArray<struct FMsgCommandData>                     UIChatChannelCommandList;                                 // 0x00A0(0x0010) (NeedCtorLink)
	TArray<struct FMsgCommandDelegate>                 DelegateList;                                             // 0x00B0(0x0010) (NeedCtorLink)
	TArray<struct FSocialActionCommandData>            SocialActionCommandList;                                  // 0x00C0(0x0010) (NeedCtorLink)
	TArray<struct FSocialActionTriggerData>            SocialActionTriggerList;                                  // 0x00D0(0x0010) (NeedCtorLink)
	struct FScriptDelegate                             __OnMsgCommandDelegate__Delegate;                         // 0x00E0(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x00E0(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MsgCommandDecider");
		return ptr;
	}


	void OnPrivateTrade(struct FMsgCommandArgData* InArgData);
	void OnConsoleCommand(struct FMsgCommandArgData* InArgData);
	void OnMacroCommand(struct FMsgCommandArgData* InArgData);
	void OnServerCommand(struct FMsgCommandArgData* InArgData);
	void SteamActivateGameOverlayToStore(struct FMsgCommandArgData* InArgData);
	void SteamGetStat(struct FMsgCommandArgData* InArgData);
	void SteamClearAchievement(struct FMsgCommandArgData* InArgData);
	void SteamIndicateAchievementProgress(struct FMsgCommandArgData* InArgData);
	void SteamGetAchievement(struct FMsgCommandArgData* InArgData);
	void SteamSetAchievement(struct FMsgCommandArgData* InArgData);
	void OpenTestWeb(struct FMsgCommandArgData* InArgData);
	void SetDialog(struct FMsgCommandArgData* InArgData);
	void SetMonolog(struct FMsgCommandArgData* InArgData);
	void OnSurrenderGuildWar(struct FMsgCommandArgData* InArgData);
	void OnStartGuildWar(struct FMsgCommandArgData* InArgData);
	void OnRequestDuel(struct FMsgCommandArgData* InArgData);
	void OnBotReport(struct FMsgCommandArgData* InArgData);
	void OnDice(struct FMsgCommandArgData* InArgData);
	void OnLeaderParty(struct FMsgCommandArgData* InArgData);
	void OnKickParty(struct FMsgCommandArgData* InArgData);
	void OnLeaveParty(struct FMsgCommandArgData* InArgData);
	void OnInviteParty(struct FMsgCommandArgData* InArgData);
	void OnChatParty(struct FMsgCommandArgData* InArgData);
	void OnChatWhisper(struct FMsgCommandArgData* InArgData);
	bool GetUIChatChannelCommandList(const struct FString& InChatMessageCommand, TArray<struct FString>* OutAliasCommandList, int* OutArgCount);
	void RemoveRightSpace(struct FString* ResultText);
	void RemoveLeftSpace(struct FString* ResultText);
	bool FindSocialActionTrigger(struct FString* InText, int* OutSocialActionCid);
	bool ParseSocialActionCommand(struct FString* InText, int* OutSocialActionCid);
	bool ParseMsgCommandData(struct FString* InText, struct FMsgCommandData* InData, struct FString* OutProcessCmd, struct FMsgCommandArgData* OutArgData);
	bool ParseGMCommand(struct FString* InText, struct FString* OutProcessCmd, struct FMsgCommandArgData* OutArgData);
	bool ParseDevCommand(struct FString* InText, struct FString* OutProcessCmd, struct FMsgCommandArgData* OutArgData);
	bool ParseChatCommnad(struct FString* InText, struct FString* OutProcessCmd, struct FMsgCommandArgData* OutArgData);
	void BuildChatChannelCommad();
	void BuildChattingCommand();
	void BuildSocialCommand();
	void Init();
	void ProcessSocialActionCommand(int InSocialActionCid);
	void ProcessMsgCommand(const struct FString& InProcessCmdName, const struct FMsgCommandArgData& InArgData);
	bool ExecuteMsgCommand(const struct FString& InMsg);
	void OnMsgCommandDelegate(struct FMsgCommandArgData* InArgData);
};


// Class BLGame.BLPlayerInput
// 0x0068 (0x032C - 0x02C4)
class UBLPlayerInput : public UPlayerInput
{
public:
	unsigned char                                      bTurnButton;                                              // 0x02C4(0x0001) (Input)
	unsigned char                                      bDragTurn;                                                // 0x02C5(0x0001) (Input)
	unsigned char                                      bDragging;                                                // 0x02C6(0x0001) (Input)
	unsigned char                                      bWorldMapDragging;                                        // 0x02C7(0x0001) (Input)
	unsigned char                                      bWorldMapRButton;                                         // 0x02C8(0x0001) (Input)
	unsigned char                                      bMoveButton;                                              // 0x02C9(0x0001) (Input)
	TEnumAsByte<EBLTargetingMode>                      TargetingMode;                                            // 0x02CA(0x0001)
	TEnumAsByte<EInputEvent>                           OldestEvent;                                              // 0x02CB(0x0001) (Const)
	float                                              aPawnTurnX;                                               // 0x02CC(0x0004) (Input)
	TArray<struct FButtonInfo>                         ButtonInfoList;                                           // 0x02D0(0x0010) (Transient, NeedCtorLink)
	struct FName                                       CachedReleasedKey;                                        // 0x02E0(0x0008) (Transient)
	float                                              aMouseTurn;                                               // 0x02E8(0x0004) (Transient)
	float                                              aMouseLookUp;                                             // 0x02EC(0x0004) (Transient)
	unsigned long                                      MovementStopped : 1;                                      // 0x02F0(0x0004) (Transient)
	unsigned long                                      bClickedUI : 1;                                           // 0x02F0(0x0004)
	unsigned long                                      bKeepWalkingMode : 1;                                     // 0x02F0(0x0004) (Transient)
	unsigned long                                      bEdgeKeepWalkingMode : 1;                                 // 0x02F0(0x0004) (Transient)
	unsigned long                                      bIgnoreTurnInput : 1;                                     // 0x02F0(0x0004) (Transient)
	unsigned long                                      bWasBack_BackUp : 1;                                      // 0x02F0(0x0004) (Transient)
	unsigned long                                      bPendingMoveInput : 1;                                    // 0x02F0(0x0004) (Transient)
	unsigned long                                      bPendingForward : 1;                                      // 0x02F0(0x0004) (Transient)
	unsigned long                                      bPendingBack : 1;                                         // 0x02F0(0x0004) (Transient)
	unsigned long                                      bPendingLeft : 1;                                         // 0x02F0(0x0004) (Transient)
	unsigned long                                      bPendingRight : 1;                                        // 0x02F0(0x0004) (Transient)
	float                                              aSavedForward;                                            // 0x02F4(0x0004) (Transient)
	int                                                PrevForwardDir;                                           // 0x02F8(0x0004)
	int                                                PrevStrafeDir;                                            // 0x02FC(0x0004)
	int                                                PrevPawnTurnDir;                                          // 0x0300(0x0004)
	float                                              DBLCLKElapsed;                                            // 0x0304(0x0004)
	float                                              DBLCLKLimitTime;                                          // 0x0308(0x0004)
	class UMouseEventDecider*                          MouseEventDecider;                                        // 0x030C(0x0008) (Transient)
	class UOnlineKeyEventBinder*                       KeyBinder;                                                // 0x0314(0x0008) (ExportObject, Transient, NeedCtorLink, EditInline)
	class UMouseEventDecider_ClassicTargeting*         DefaultMouseEventDecider_ClassicTargeting;                // 0x031C(0x0008) (ExportObject, Transient, NeedCtorLink, EditInline)
	class UMouseEventDecider_AimTargeting*             DefaultMouseEventDecider_AimTargeting;                    // 0x0324(0x0008) (ExportObject, Transient, NeedCtorLink, EditInline)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLPlayerInput");
		return ptr;
	}


	bool IsPawnTurningNow();
	void ChangeTargetingMode(TEnumAsByte<EBLTargetingMode> InTargetingMode);
	void SetUIMode(bool UIMode);
	void ReleasePendedMoveInput();
	void PendCurrentMoveInput();
	void CheckPendingInput();
	bool IsMoveInputPended();
	void ToggleUIMode(bool Toggle);
	bool IsPawnRotationCommand(const struct FString& Command);
	bool IsMoveCommand(const struct FString& Command);
	bool IsPressedCommand(const struct FString& Command);
	void ReleasePawnRotationInput();
	void ReleaseMouseButtonInput();
	void ReleaseMoveInput();
	struct FString GetBind(struct FName* Key);
	void SaveInputValue();
	int AxesToDir(float AxesValue);
	void ProcessInputEvent();
	void SetKeepWalkingMode(bool InIsKeepWalkingMode);
	bool IsTurnInputIgnored();
	void IgnoreTurnInput(bool bNewIgnoreTurnInput);
	void PlayerInput(float DeltaTime);
	void PostProcessInput(float DeltaTime);
	void PreProcessInput(float DeltaTime);
	bool IsDragging();
	bool IsPressedButton(const struct FString& ButtonName);
};


// Class BLGame.OnlineKeyEventBinder
// 0x007C (0x00DC - 0x0060)
class UOnlineKeyEventBinder : public UObject
{
public:
	TArray<struct FKeyActionBind>                      KeyEventBindings;                                         // 0x0060(0x0010) (NeedCtorLink)
	TArray<struct FActionFuncBind>                     ActionFuncBindings;                                       // 0x0070(0x0010) (NeedCtorLink)
	float                                              KeyDownPawnTurnSpeed;                                     // 0x0080(0x0004) (Config)
	struct FPlayerEnvironmentData                      ChangedKeyOldData;                                        // 0x0084(0x0008) (Transient)
	struct FPlayerEnvironmentData                      LastChangedKey;                                           // 0x008C(0x0008) (Transient)
	struct FMap_Mirror                                 Temporary_CustomizeKeyList;                               // 0x0094(0x0048) (Native, Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.OnlineKeyEventBinder");
		return ptr;
	}


	void SortKeyBinds();
	void GetShorcutKeyStringByActionName(struct FName* InActionName, struct FString* OutKeyName);
	bool GetSkillDeckUISlotIndexByActionName(const struct FString& InActionName, int* UISlotIndex);
	bool GetActionBarSkillDeckInfoByActionName(const struct FString& InActionName, int* KeyIndex, struct FString* SkillDeckName);
	bool GetActionBarUISlotIndexByActionName(const struct FString& InActionName, int* UISlotIndex);
	void ChangeToDefault();
	void CancelKeyCustomize();
	void SaveChangedKeyCustomize();
	void PostProcess_KeyCustomize(int InActionCID, bool IsMain);
	void RegisterCustomKeyMapping(int ActionID, bool IsMainSet, const struct FName& KeyName, const struct FName& ModName);
	struct FString MakeKeyString(const struct FString& ModName, const struct FString& KeyName, bool IsDouble, bool IsContraction, bool IsNoneString);
	void SetSkillDeckKeyBindingString();
	void SetActionBarKeyBindingString();
	void SetOpenerKeyBindingString();
	void SetKeySettingSubPageData();
	void SetKeySettingUICategory();
	void SetupPostAction();
	void SetupAction();
	void SetKeyActionBind(const struct FName& InName, const struct FName& InActionName, bool InControl, bool InShift, bool InAlt, bool bInLMButton, bool bInRMButton, bool bInDoubleClick, TEnumAsByte<EPC_STATE> InPCState, TEnumAsByte<EWorldMap_State> InEnableInWorldMap);
	void AddKeyActionBind(const struct FKeyActionBind& InKeyActionBind);
	void CollectKeyByActionName(struct FName* InActionName, TArray<struct FName>* OutKey);
	struct FName GetPairKey(struct FName* InOriginKeyName);
	struct FString GetFuncBindAction(struct FName* InActionName);
	bool IsShowCurrentTargetingMode(TEnumAsByte<EBLTargetingMode> InTargetingMode, TEnumAsByte<ECEActionShowType> InActionShowType);
	void PlayConflictSound();
	void AddCheatOrExtraKey(TArray<struct FKeyBind>* ExtraBinds);
	void InitializeActionFuncBind();
	void SetActionFuncBind(const struct FName& ActionName, const struct FString& FuncCommand);
	void SetupFixedAction();
	void Temporary_InitializeKeyActionBind(TEnumAsByte<EBLTargetingMode> InTargetingMode);
};


// Class BLGame.PawnVisibilityController
// 0x0010 (0x0070 - 0x0060)
class UPawnVisibilityController : public UObject
{
public:
	TArray<unsigned long>                              bForceVisblePhase;                                        // 0x0060(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PawnVisibilityController");
		return ptr;
	}


	void CheckAllPawnVisible();
	void CheckPawnVisible(class ABLPawn* CheckPawn);
	void GotoStealthPhase();
	void GotoSpiritPhase();
	void GotoDeadPhase();
	void GotoAlivePhase();
	void OnUpdateConditionalPhase(TEnumAsByte<ECEConditionPhaseType> Type);
	void SetForceVisiblePhase(TEnumAsByte<ECEConditionPhaseType> Type, bool IsVisible);
	void Init();
	void STATIC_UpdatePawnVisible(class ABLPawn* InUpdatePawn);
	void Init_Native();
};


// Class BLGame.BLAvatar
// 0x0000 (0x0060 - 0x0060)
class UBLAvatar : public UObject
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAvatar");
		return ptr;
	}

};


// Class BLGame.BLCharacterLightComponent
// 0x018F (0x0214 - 0x0085)
class UBLCharacterLightComponent : public UActorComponent
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0085(0x0003) MISSED OFFSET
	class USpotLightComponent*                         LT_Main;                                                  // 0x0088(0x0008) (Edit, Const, ExportObject, Transient, Component, EditInline)
	class USpotLightComponent*                         LT_Back;                                                  // 0x0090(0x0008) (Edit, Const, ExportObject, Transient, Component, EditInline)
	class USpotLightComponent*                         LT_Side;                                                  // 0x0098(0x0008) (Edit, Const, ExportObject, Transient, Component, EditInline)
	class UPointLightComponent*                        LT_Fill;                                                  // 0x00A0(0x0008) (Edit, Const, ExportObject, Transient, Component, EditInline)
	unsigned char                                      UnknownData01[0x8];                                       // 0x00A8(0x0008) MISSED OFFSET
	struct FMatrix                                     MatrixMain;                                               // 0x00B0(0x0040) (Const, Native, Transient)
	struct FMatrix                                     MatrixFill;                                               // 0x00F0(0x0040) (Const, Native, Transient)
	struct FMatrix                                     MatrixBack;                                               // 0x0130(0x0040) (Const, Native, Transient)
	struct FMatrix                                     MatrixSide;                                               // 0x0170(0x0040) (Const, Native, Transient)
	struct FVector                                     MainLightLocation;                                        // 0x01B0(0x000C) (Edit, Const, Transient)
	struct FVector                                     BackLightLocation;                                        // 0x01BC(0x000C) (Edit, Const, Transient)
	struct FVector                                     SideLightLocation;                                        // 0x01C8(0x000C) (Edit, Const, Transient)
	struct FVector                                     FillLightLocation;                                        // 0x01D4(0x000C) (Edit, Const, Transient)
	struct FRotator                                    MainLightRotation;                                        // 0x01E0(0x000C) (Const, Transient)
	struct FRotator                                    BackLightRotation;                                        // 0x01EC(0x000C) (Const, Transient)
	struct FRotator                                    SideLightRotation;                                        // 0x01F8(0x000C) (Const, Transient)
	unsigned long                                      bEnable : 1;                                              // 0x0204(0x0004) (Edit)
	unsigned long                                      bEnabled : 1;                                             // 0x0204(0x0004)
	unsigned long                                      bDrawLocationBox : 1;                                     // 0x0204(0x0004) (Edit)
	class UBLCharacterLightProperty*                   LightProperty;                                            // 0x0208(0x0008) (Edit, ExportObject, Transient, NeedCtorLink, EditInline)
	int                                                CharacterLightIndex;                                      // 0x0210(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLCharacterLightComponent");
		return ptr;
	}

};


// Class BLGame.BLCustomizingController
// 0x00B0 (0x0110 - 0x0060)
class UBLCustomizingController : public UObject
{
public:
	TEnumAsByte<ECERaceType>                           RaceType;                                                 // 0x0060(0x0001)
	TEnumAsByte<ECEGenderType>                         GenderType;                                               // 0x0061(0x0001)
	TEnumAsByte<ECEClassType>                          ClassType;                                                // 0x0062(0x0001)
	TEnumAsByte<EEquipmentHelmetType>                  HelmetType;                                               // 0x0063(0x0001)
	TEnumAsByte<ECustomizeActionScriptUIEnum>          CurrentDetailMode;                                        // 0x0064(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET
	class UCharacterizeSkeletalMeshComponent*          BodyMeshComp;                                             // 0x0068(0x0008) (ExportObject, Component, EditInline)
	class UCharacterizeSkeletalMeshComponent*          HeadMeshComp;                                             // 0x0070(0x0008) (ExportObject, Component, EditInline)
	TArray<class UMaterialInterface*>                  Materials;                                                // 0x0078(0x0010) (NeedCtorLink)
	class UBLMeshRenderBufferComponent*                AdditionalRenderComponent;                                // 0x0088(0x0008) (ExportObject, Component, EditInline)
	class ABLPawn*                                     Owner;                                                    // 0x0090(0x0008)
	unsigned long                                      bCustomizingEnabled : 1;                                  // 0x0098(0x0004)
	unsigned long                                      bIsWhispyHair : 1;                                        // 0x0098(0x0004)
	unsigned long                                      bPrevWispyHair : 1;                                       // 0x0098(0x0004)
	unsigned long                                      bIsMatchEyebrowColor : 1;                                 // 0x0098(0x0004)
	unsigned long                                      bIsMatchBeardColor : 1;                                   // 0x0098(0x0004)
	unsigned long                                      bNeedUpdateMesh : 1;                                      // 0x0098(0x0004)
	unsigned long                                      bInitialUpdate : 1;                                       // 0x0098(0x0004)
	class UBLCustomizingData*                          CustomizingData;                                          // 0x009C(0x0008)
	TArray<TEnumAsByte<ECECustomizeType>>              ApplyingQueue;                                            // 0x00A4(0x0010) (NeedCtorLink)
	class UBLCustomizingModule_ChangeMaterialBuffer*   ChangeMaterialBufferModule;                               // 0x00B4(0x0008)
	class UBLCustomizingModule_ChangeMaterialFace*     ChangeMaterialFaceModule;                                 // 0x00BC(0x0008)
	class UBLCustomizingModule_ChangeMaterialFaceFur*  ChangeMaterialFaceFurModule;                              // 0x00C4(0x0008)
	class UBLCustomizingModule_ChangeMaterialBody*     ChangeMaterialBodyModule;                                 // 0x00CC(0x0008)
	class UBLCustomizingModule_ChangeMaterialEyeBall*  ChangeMaterialEyeBallModule;                              // 0x00D4(0x0008)
	class UBLCustomizingModule_ChangeMaterialEyelash*  ChangeMaterialEyelashModule;                              // 0x00DC(0x0008)
	class UBLCustomizingModule_ChangeMaterialBeard*    ChangeMaterialBeardModule;                                // 0x00E4(0x0008)
	class UBLCustomizingModule_ChangeMaterialHair*     ChangeMaterialHairModule;                                 // 0x00EC(0x0008)
	class UBLCustomizingModule_BoneControl*            BoneContolModule;                                         // 0x00F4(0x0008)
	class UBLCustomizingModule_ChangeParts*            ChangePartsModule;                                        // 0x00FC(0x0008)
	class UBLCustomizingModule_MorphTarget*            MorphTargetModule;                                        // 0x0104(0x0008)
	int                                                AutoSaveFileCycleMinute;                                  // 0x010C(0x0004) (Config)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLCustomizingController");
		return ptr;
	}


	void UpdateHelmetType(TEnumAsByte<EEquipmentHelmetType> InHelmetType);
	bool IsExistTemporaryCustomizeFile();
	void RemoveTemporaryCustomizeFile();
	void LoadTemporaryCustomizeFile();
	void SaveTemporaryCustomizeFile();
	struct FString GetTemporaryCustomizeFullPath();
	struct FString GetTemporaryCustomizeFileName();
	void SetCustomizeDataFromArray(TArray<unsigned char>* InData);
	void GetCustomizeDataFromArray(TArray<unsigned char>* OutData);
	bool IsDirtyPresetValue(TEnumAsByte<ECustomizeActionScriptUIEnum> InUIEnum);
	bool IsPresetUI(TEnumAsByte<ECustomizeActionScriptUIEnum> InUIEnum);
	bool GetRawData(TEnumAsByte<ECustomizeActionScriptUIEnum> InUIEnum, int* OutRawData);
	void ResetAllByCustomizeData(struct FCustomizeData* InData);
	void ResetAll();
	struct FString GetECustomizeTypeStringByValue(int s_Value);
	void SaveCustomizeData();
	void LoadPresetFile(const struct FString& InFilename);
	void SavePresetFile(const struct FString& InFilename);
	void SetAppearanceType(TEnumAsByte<ECEAppearanceType> InAppearanceType);
	TEnumAsByte<ECEAppearanceType> GetAppearanceType();
	float GetVoicePitch();
	int GetVoiceType();
	void SetVoicePitch(int Pitch);
	void SetVoiceType(int Cid);
	void MatcLensSetting();
	void MatchColorHair(TEnumAsByte<ECustomizeActionScriptUIEnum> InUIEnum, bool InSelected);
	void SetWhispyHair(bool InIsWispyHair);
	float ConvertRawDataToValue(TEnumAsByte<ECECustomizeType> InType, int InRawData);
	int ConvertValueToRawData(TEnumAsByte<ECECustomizeType> InType, float InValue);
	void UpdateMouseAction(TEnumAsByte<ECECustomizeType> InCMT, int MouseDispValue);
	void OnUpdatedDetailModeValue(TEnumAsByte<ECustomizeActionScriptUIEnum> InUIEnum, int InUIValue);
	void OnUpdatedDetailMode(TEnumAsByte<ECustomizeActionScriptUIEnum> InUIEnum);
	void OnUpdatedUI(TEnumAsByte<ECustomizeActionScriptUIEnum> InUIEnum, int InUIValue);
	void UpdateUI(TEnumAsByte<ECustomizeActionScriptUIEnum> InUIEnum, int InUIValue);
	void ResetUI();
	void InitUI();
	void SetCustomizeData(struct FCustomizeData* InData);
	void GetCustomizeData(struct FCustomizeData* OutData);
	void ApplyAll(bool bImmediatelyApply);
	void RandomCustomizeInSubMenu(TEnumAsByte<ECustomizeActionScriptMenuEnum> InSubMenuUIEnum);
	void ResetCustomizeInSubMenuByCustomizeData(TEnumAsByte<ECustomizeActionScriptMenuEnum> InSubMenuUIEnum, struct FCustomizeData* InData);
	void ResetCustomizeInSubMenu(TEnumAsByte<ECustomizeActionScriptMenuEnum> InSubMenuUIEnum);
	void SetCustomize(class UCustomizeElement** CustomizeElem);
	void ClearModule();
	void Refresh();
	void InitModule();
	void InitDefaultPreset();
	void InitCustomizeElement();
	void InitMaterial(TArray<class UMaterialInterface*> InMaterials);
	void InitNormal(TEnumAsByte<ECERaceType> InRaceType, TEnumAsByte<ECEGenderType> InGenderType, TEnumAsByte<ECEClassType> InClassType, TEnumAsByte<EEquipmentHelmetType> InHelmetType);
	void Init(TEnumAsByte<ECERaceType> InRaceType, TEnumAsByte<ECEGenderType> InGenderType, TEnumAsByte<ECEClassType> InClassType, TEnumAsByte<EEquipmentHelmetType> InHelmetType, TArray<class UMaterialInterface*> InMaterials);
	void SetMaterials(TArray<class UMaterialInterface*> InMaterials);
	void UnPossessed();
	void PossessedBy(class UCharacterizeSkeletalMeshComponent* InBodyMesh, class UCharacterizeSkeletalMeshComponent* InHeadMesh);
	void SetPawnOwner(class ABLPawn* InOwner);
	int ConvertColorIndexToRawData(TEnumAsByte<ECECustomizeType> CustomizeType, int ColorIndex);
	struct FColor STATIC_ConvertRawDataToColor(int RawData);
	int STATIC_ConvertColorToRawData(const struct FColor& ColorValue);
	bool STATIC_ConvertCustomizeDataToPresetData(TEnumAsByte<ECECustomizeType> PresetCustomizeType, TArray<unsigned char>* InCustomizeData, TArray<struct FCustomizeUISettingInfo>* OutPresetData);
	TEnumAsByte<ECustomizeValueType> STATIC_GetValueType(TEnumAsByte<ECECustomizeType> CustomizeType);
};


// Class BLGame.BLCustomizingData
// 0x0718 (0x0778 - 0x0060)
class UBLCustomizingData : public UObject
{
public:
	class UCustomizeElement*                           Elements[0xE3];                                           // 0x0060(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLCustomizingData");
		return ptr;
	}


	void SetCustomizeData(struct FCustomizeData* InData);
	void GetCustomizeData(struct FCustomizeData* OutData);
	class UCustomizeElement* GetElement(TEnumAsByte<ECECustomizeType> InType);
	void SetElement(class UCustomizeElement* Element);
};


// Class BLGame.BLCustomizingModule_BoneControl
// 0x0018 (0x0078 - 0x0060)
class UBLCustomizingModule_BoneControl : public UObject
{
public:
	class UCharacterizeSkeletalMeshComponent*          HeadMeshComp;                                             // 0x0060(0x0008) (ExportObject, Component, EditInline)
	class UCharacterizeSkeletalMeshComponent*          BodyMeshComp;                                             // 0x0068(0x0008) (ExportObject, Component, EditInline)
	class UCustomizeParameters*                        CustomizeParam;                                           // 0x0070(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLCustomizingModule_BoneControl");
		return ptr;
	}


	void ApplyBoneControl(TEnumAsByte<EBoneDeformPart> InBoneDeformPart, float Value);
	void SetCustomize(class UCustomizeElement** CustomizeElem);
	void Clear();
	void Init(class UCharacterizeSkeletalMeshComponent* InHeadMeshComp, class UCharacterizeSkeletalMeshComponent* InBodyMeshComp);
};


// Class BLGame.BLCustomizingModule_ChangeMaterialBase
// 0x0018 (0x0078 - 0x0060)
class UBLCustomizingModule_ChangeMaterialBase : public UObject
{
public:
	TArray<class UMaterialInstance*>                   TargetMIs;                                                // 0x0060(0x0010) (NeedCtorLink)
	class UCustomizeParameters*                        CustomizeParam;                                           // 0x0070(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLCustomizingModule_ChangeMaterialBase");
		return ptr;
	}


	void ApplyColor(const struct FName& InSwitch, const struct FColor& InValue);
	void ApplyScalar(const struct FName& InSwitch, float InValue);
	void ApplySwitch(const struct FName& InSwitch, bool bInValue);
	void ApplyTexture(const struct FName& InSwitch, class UTexture2D* InTexture);
	void SetCustomize(class UCustomizeElement** CustomizeElem);
	void Clear();
	void Initialize(TArray<class UMaterialInstance*> InMIs);
};


// Class BLGame.BLCustomizingModule_ChangeMaterialBeard
// 0x0000 (0x0078 - 0x0078)
class UBLCustomizingModule_ChangeMaterialBeard : public UBLCustomizingModule_ChangeMaterialBase
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLCustomizingModule_ChangeMaterialBeard");
		return ptr;
	}


	void Refresh();
	void Init(TArray<class UMaterialInterface*> InMIs);
};


// Class BLGame.BLCustomizingModule_ChangeMaterialBody
// 0x0000 (0x0078 - 0x0078)
class UBLCustomizingModule_ChangeMaterialBody : public UBLCustomizingModule_ChangeMaterialBase
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLCustomizingModule_ChangeMaterialBody");
		return ptr;
	}


	void Refresh();
	void Init(TArray<class UMaterialInterface*> InMIs);
};


// Class BLGame.BLCustomizingModule_ChangeMaterialBuffer
// 0x0008 (0x0080 - 0x0078)
class UBLCustomizingModule_ChangeMaterialBuffer : public UBLCustomizingModule_ChangeMaterialBase
{
public:
	class UBLMeshRenderBufferComponent*                BufferComponent;                                          // 0x0078(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLCustomizingModule_ChangeMaterialBuffer");
		return ptr;
	}


	void Refresh();
	void SetCustomize(class UCustomizeElement** CustomizeElem);
	void Clear();
	void Init(class UBLMeshRenderBufferComponent* InComponent);
};


// Class BLGame.BLCustomizingModule_ChangeMaterialEyeBall
// 0x0000 (0x0078 - 0x0078)
class UBLCustomizingModule_ChangeMaterialEyeBall : public UBLCustomizingModule_ChangeMaterialBase
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLCustomizingModule_ChangeMaterialEyeBall");
		return ptr;
	}


	void Refresh();
	void Init(TArray<class UMaterialInterface*> InMIs);
};


// Class BLGame.BLCustomizingModule_ChangeMaterialEyelash
// 0x0000 (0x0078 - 0x0078)
class UBLCustomizingModule_ChangeMaterialEyelash : public UBLCustomizingModule_ChangeMaterialBase
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLCustomizingModule_ChangeMaterialEyelash");
		return ptr;
	}


	void Refresh();
	void Init(TArray<class UMaterialInterface*> InMIs);
};


// Class BLGame.BLCustomizingModule_ChangeMaterialFace
// 0x0000 (0x0078 - 0x0078)
class UBLCustomizingModule_ChangeMaterialFace : public UBLCustomizingModule_ChangeMaterialBase
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLCustomizingModule_ChangeMaterialFace");
		return ptr;
	}


	void Refresh();
	void Init(TArray<class UMaterialInterface*> InMIs);
};


// Class BLGame.BLCustomizingModule_ChangeMaterialFaceFur
// 0x0000 (0x0078 - 0x0078)
class UBLCustomizingModule_ChangeMaterialFaceFur : public UBLCustomizingModule_ChangeMaterialBase
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLCustomizingModule_ChangeMaterialFaceFur");
		return ptr;
	}


	void Refresh();
	void Init(TArray<class UMaterialInterface*> InMIs);
};


// Class BLGame.BLCustomizingModule_ChangeMaterialHair
// 0x0000 (0x0078 - 0x0078)
class UBLCustomizingModule_ChangeMaterialHair : public UBLCustomizingModule_ChangeMaterialBase
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLCustomizingModule_ChangeMaterialHair");
		return ptr;
	}


	void Refresh();
	void Init(TArray<class UMaterialInterface*> InMIs);
};


// Class BLGame.BLCustomizingModule_ChangeMorphTargetWeight
// 0x0018 (0x0078 - 0x0060)
class UBLCustomizingModule_ChangeMorphTargetWeight : public UObject
{
public:
	class UCharacterizeSkeletalMeshComponent*          HeadMeshComp;                                             // 0x0060(0x0008) (ExportObject, Component, EditInline)
	class UCharacterizeSkeletalMeshComponent*          BodyMeshComp;                                             // 0x0068(0x0008) (ExportObject, Component, EditInline)
	class UCustomizeParameters*                        CustomizeParam;                                           // 0x0070(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLCustomizingModule_ChangeMorphTargetWeight");
		return ptr;
	}


	void ApplyMorphTarget(const struct FName& InMorphTargetName, float Value);
	void SetCustomize(class UCustomizeElement** CustomizeElem, class UCustomizeElement** PairCustomizeElem);
	void Clear();
	void Init(class UCharacterizeSkeletalMeshComponent* InHeadMeshComp, class UCharacterizeSkeletalMeshComponent* InBodyMeshComp);
};


// Class BLGame.BLCustomizingModule_ChangeParts
// 0x0011 (0x0071 - 0x0060)
class UBLCustomizingModule_ChangeParts : public UObject
{
public:
	class UCharacterizeSkeletalMeshComponent*          BodyMeshComp;                                             // 0x0060(0x0008) (ExportObject, Component, EditInline)
	class UCustomizeParameters*                        CustomizeParam;                                           // 0x0068(0x0008)
	TEnumAsByte<EEquipmentHelmetType>                  HelmetType;                                               // 0x0070(0x0001)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLCustomizingModule_ChangeParts");
		return ptr;
	}


	void ApplyPart(TEnumAsByte<EEquipmentDisplaySlotType> PartID, class USkeletalMesh* SkeletalMesh);
	void SetCustomize(class UCustomizeElement** CustomizeElem);
	void UpdateHelmetType(TEnumAsByte<EEquipmentHelmetType> InHelmetType);
	void Clear();
	void Init(class UCharacterizeSkeletalMeshComponent* InBodyMeshComp);
};


// Class BLGame.BLCustomizingModule_MorphTarget
// 0x0018 (0x0078 - 0x0060)
class UBLCustomizingModule_MorphTarget : public UObject
{
public:
	class UBLCustomizingModule_ChangeMaterialFace*     ChangeMaterialModule;                                     // 0x0060(0x0008)
	class UBLCustomizingModule_ChangeMorphTargetWeight* ChangeMorphTargetModule;                                  // 0x0068(0x0008)
	class UCustomizeParameters*                        CustomizeParam;                                           // 0x0070(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLCustomizingModule_MorphTarget");
		return ptr;
	}


	void ApplyMorphTarget(float Weight, class UCustomizeElement** MorphTargetElem);
	void SetCustomize(class UCustomizeElement** CustomizeElem, class UCustomizeElement** PairCustomizeElem);
	void Clear();
	void Init(class UCharacterizeSkeletalMeshComponent* InHeadMeshComp, class UCharacterizeSkeletalMeshComponent* InBodyMeshComp, TArray<class UMaterialInterface*> InMIs);
};


// Class BLGame.BLCustomizingMouseHandler
// 0x003C (0x009C - 0x0060)
class UBLCustomizingMouseHandler : public UObject
{
public:
	class ABlessPCBase*                                Owner;                                                    // 0x0060(0x0008)
	TEnumAsByte<ECECustomizingUIModeType>              CurrentUIMode;                                            // 0x0068(0x0001)
	TEnumAsByte<ECECustomizingAreaType>                CurrentPickedArea;                                        // 0x0069(0x0001)
	TEnumAsByte<ECECustomizingViewType>                CurrentViewType;                                          // 0x006A(0x0001)
	unsigned char                                      UnknownData00[0x1];                                       // 0x006B(0x0001) MISSED OFFSET
	struct FVector2D                                   MousePickOrigin;                                          // 0x006C(0x0008)
	float                                              XComponentMin;                                            // 0x0074(0x0004)
	float                                              XComponentMax;                                            // 0x0078(0x0004)
	float                                              XComponentOrigin;                                         // 0x007C(0x0004)
	float                                              YComponentMin;                                            // 0x0080(0x0004)
	float                                              YComponentMax;                                            // 0x0084(0x0004)
	float                                              YComponentOrigin;                                         // 0x0088(0x0004)
	float                                              ClickComponentMin;                                        // 0x008C(0x0004)
	float                                              ClickComponentMax;                                        // 0x0090(0x0004)
	float                                              ClickComponentOrigin;                                     // 0x0094(0x0004)
	unsigned long                                      bDragAction : 1;                                          // 0x0098(0x0004)
	unsigned long                                      bMouseActionRangeOver : 1;                                // 0x0098(0x0004)
	unsigned long                                      bPawnTurningMode : 1;                                     // 0x0098(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLCustomizingMouseHandler");
		return ptr;
	}


	void ProcessTranslucencyMaterial(const struct FName& MaterialKey, bool bIsTranslucency);
	void OnMouseClick();
	void UpdateHighlightArea();
	void UpdateMouseAction(const struct FVector2D& MousePos);
	void DecideCursorType(struct FMouseClientInfo* MouseInfo);
	void EndDrag();
	void StartDrag(const struct FVector2D& MousePos);
	void SetPawnTurningMode(bool bInPawnTurningMode);
	void UnPossessed();
	void PossessedBy(class ABlessPCBase* InOwner);
	void OnMaterialPicked(class ABLPawn* InTargetPawn, TArray<class UMaterialInterface*>* OutMaterialList);
};


// Class BLGame.BLMeshRenderBufferComponent
// 0x003B (0x00C0 - 0x0085)
class UBLMeshRenderBufferComponent : public UActorComponent
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0085(0x0003) MISSED OFFSET
	class UTextureRenderTarget2DForMeshRenderBuffer*   BufferRenderTarget;                                       // 0x0088(0x0008) (Const)
	class UCustomizeParameters*                        CustomizeParam;                                           // 0x0090(0x0008)
	class UMaterialInstanceConstant*                   ParentBufferMIC;                                          // 0x0098(0x0008) (Const)
	class UMaterialInstanceTimeVarying*                BufferMITV;                                               // 0x00A0(0x0008)
	unsigned long                                      bBufferMITVChanged : 1;                                   // 0x00A8(0x0004)
	unsigned long                                      bNeedDrawBuffer : 1;                                      // 0x00A8(0x0004)
	unsigned long                                      bPendingDrawBuffer : 1;                                   // 0x00A8(0x0004)
	TArray<class UMaterialInstance*>                   TargetMIs;                                                // 0x00AC(0x0010) (NeedCtorLink)
	float                                              TimeRemianForDrawBuffer;                                  // 0x00BC(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLMeshRenderBufferComponent");
		return ptr;
	}


	class UMaterialInstanceConstant* GetParentBufferMIC(TEnumAsByte<ECERaceType> InRaceType, TEnumAsByte<ECEGenderType> InGenderType);
	void Refresh();
	class UMaterialInstanceTimeVarying* GetBufferMITV();
	bool Initialize(TEnumAsByte<ECERaceType> InRaceType, TEnumAsByte<ECEGenderType> InGenderType, TArray<class UMaterialInterface*> InMIs, bool bReset);
};


// Class BLGame.BLNPCLocationReviser
// 0x006C (0x00CC - 0x0060)
class UBLNPCLocationReviser : public UObject
{
public:
	TArray<struct FNPCLocationReviseInfo>              NPCLocationReviseList;                                    // 0x0060(0x0010) (NeedCtorLink)
	struct FMap_Mirror                                 RegisteredNCPSids;                                        // 0x0070(0x0048) (Native, Transient)
	unsigned long                                      bEnableReviser : 1;                                       // 0x00B8(0x0004) (Config)
	float                                              ReviseRemainMaxTime;                                      // 0x00BC(0x0004) (Config)
	float                                              ReviseDefaultCheckTime;                                   // 0x00C0(0x0004) (Config)
	float                                              ReviseNoiseCheckTime;                                     // 0x00C4(0x0004) (Config)
	int                                                ReviseMaxCountPerTick;                                    // 0x00C8(0x0004) (Config)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLNPCLocationReviser");
		return ptr;
	}


	class UBLNPCLocationReviser* STATIC_GetNPCLocationReviser();
};


// Class BLGame.BLPawnBase
// 0x0100 (0x0674 - 0x0574)
class ABLPawnBase : public AGamePawn
{
public:
	struct FName                                       SpecialMove;                                              // 0x0574(0x0008)
	struct FName                                       PreviousSpecialMove;                                      // 0x057C(0x0008)
	struct FBLSpecialMoveStruct                        PendingSpecialMoveStruct;                                 // 0x0584(0x0024)
	unsigned long                                      bEndingSpecialMove : 1;                                   // 0x05A8(0x0004) (Transient)
	unsigned long                                      ChangedTarget : 1;                                        // 0x05A8(0x0004) (Transient)
	unsigned long                                      bNeedUIUpdateParamStatus : 1;                             // 0x05A8(0x0004) (Transient)
	unsigned long                                      bNeedUIUpdateAbnormalStatus : 1;                          // 0x05A8(0x0004) (Transient)
	unsigned long                                      bNeedUIUpdateAura : 1;                                    // 0x05A8(0x0004) (Transient)
	unsigned long                                      bAssetLoaded : 1;                                         // 0x05A8(0x0004)
	unsigned long                                      bIsPlaySpawnEffect : 1;                                   // 0x05A8(0x0004)
	unsigned long                                      bInitPawn : 1;                                            // 0x05A8(0x0004)
	unsigned long                                      bVisionShared : 1;                                        // 0x05A8(0x0004) (Transient)
	unsigned long                                      bInitPawnResource : 1;                                    // 0x05A8(0x0004)
	TArray<struct FBlessSpecialMoveInfo>               SpecialMoves;                                             // 0x05AC(0x0010) (NeedCtorLink)
	class ABLPawnBase*                                 InteractionPawn;                                          // 0x05BC(0x0008)
	int                                                SpecialMoveFlags;                                         // 0x05C4(0x0004)
	TArray<class UBLMSGProcInterface*>                 MsgProcs;                                                 // 0x05C8(0x0010) (NeedCtorLink)
	int                                                MsgProcId;                                                // 0x05D8(0x0004)
	class UBLEventHandler*                             EventHandler;                                             // 0x05DC(0x0008)
	int                                                ServerID;                                                 // 0x05E4(0x0004) (Transient)
	int                                                TargetID;                                                 // 0x05E8(0x0004) (Transient)
	struct FString                                     PawnName;                                                 // 0x05EC(0x0010) (Transient, NeedCtorLink)
	class UPawnAsset*                                  PawnAsset;                                                // 0x05FC(0x0008) (Transient)
	class UPawnRepInfo*                                PawnRepInfo;                                              // 0x0604(0x0008) (ExportObject, Transient, Component, EditInline)
	int                                                HiddenList;                                               // 0x060C(0x0004) (Transient)
	int                                                HiddenMaskList;                                           // 0x0610(0x0004) (Transient)
	TArray<class UPawnComponent*>                      PawnComponents;                                           // 0x0614(0x0010) (Const, ExportObject, Component, NeedCtorLink, EditInline)
	class UActionApplyResultComponent*                 ActionApplyResultComp;                                    // 0x0624(0x0008) (ExportObject, Component, EditInline)
	class UAbnormalStatusComponent*                    AbnormalStatusComp;                                       // 0x062C(0x0008) (ExportObject, Component, EditInline)
	class UAuraComponent*                              AuraComp;                                                 // 0x0634(0x0008) (ExportObject, Component, EditInline)
	struct FGuid                                       SpawnGuid;                                                // 0x063C(0x0010)
	float                                              DistToLocalPlayerPawn;                                    // 0x064C(0x0004) (Transient)
	class UBLPawnMovementComponent*                    AdditionalMovement;                                       // 0x0650(0x0008) (ExportObject, Transient, Component, EditInline)
	struct FVector                                     AdditionalMovementVelocity;                               // 0x0658(0x000C) (Transient)
	class UPawnOutLineComponent*                       OutLineComponent;                                         // 0x0664(0x0008) (ExportObject, Transient, Component, EditInline)
	class UBLSkillAreaDecalComponent*                  SkillAreaDecal;                                           // 0x066C(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLPawnBase");
		return ptr;
	}


	bool PlaceOnGround(int InTryCount);
	bool IsExistImmuneType(TEnumAsByte<ECEImmuneType> InImmuneType);
	bool IsTargetable();
	bool IsVisionShared();
	void OnChangeVisionShared(bool bInVisionShared);
	void SetVisionShared(bool bInVisionShared);
	void AssetDLEUpdate();
	void LockOnTargetingEffect(bool IsLockOn);
	void SetAutoTargetingEffect(bool bInEnable);
	void SetTargetingEffect(bool bInEnable);
	void PlayBodyShake();
	void SetJumpAbility(float InJumpAbility);
	void SetHillClimbingAbility(float InHillClimbingAbility);
	void DisplayDebug(class AHUD* HUD, float* out_YL, float* out_YPos);
	void AnimFreeze(float InFreezeTime, float InRemainAnimTime);
	void OnHitBy_RiotControl(class UBLEvent_HitBy_RiotControl* Event);
	void OnHitBy(class UBLEvent_HitBy* Event);
	void OnHit(class UBLEvent_Hit* Event);
	void SendEvent(class UBLEvent* Event);
	void ProcessEvent_HitBy_RiotControl(class UBLEvent_HitBy_RiotControl* Event);
	void ProcessEvent_HitBy(class UBLEvent_HitBy* Event);
	void ProcessEvent_Hit(class UBLEvent_Hit* Event);
	void RegisterHandler();
	void Tick(float DeltaTime);
	void PrintDecal(class UMaterialInstanceTimeVarying* a_MaterialInstance, float InDecalLifeSpan, float Width, float Height, float Thickness, const struct FVector& a_vHit, const struct FRotator& a_Rotation, bool a_bRadomRotation, float a_CheckLength);
	void OnAnimEnd(class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime);
	void OnAnimEndInternal(class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime);
	bool IsBodyInTheAnimation();
	void StopBodyStance(float BlendTime);
	void EndFreezeBody();
	void StartFreezeBody(float SecondsToFreeze, float FreezeTime, float InThawBlendTime);
	bool PlayBodyStance(float a_Rate, float a_FadeIn, float a_FadeOut, bool a_bLoop, bool a_bOverride, float a_StartTime, bool bRootMotionAnim, bool bPlayRootMotion, struct FBodyStance* a_BodyStance);
	void DisableRootMotion(bool bKeepVelocity);
	bool IsDoingRiotControl();
	bool IsPendingDeathAction();
	bool IsDoingDeathAction();
	void CancelSpecialMove();
	int ToSMInfo(const struct FName& a_SpecialMove);
	class UClass* ToSMClass(const struct FName& a_SpecialMove);
	struct FName FromSM(class UClass* SpecialMoveClass);
	class UBSM_Base* ToSM(const struct FName& a_SpecialMove);
	void AddSM(const struct FName& a_Name, class UClass* a_Class);
	bool CanChainSpecialMove(const struct FName& NextMove);
	bool IsDoingASpecialMove();
	bool IsDoingSpecialMove(const struct FName& AMove);
	bool CanDoSpecialMove(const struct FName& AMove, bool bForceCheck);
	void DoSpecialMoveFromStruct(const struct FBLSpecialMoveStruct& InSpecialMoveStruct, bool bForceMove);
	void DoSpecialMove(const struct FName& NewMove, bool bForceMove, class ABLPawnBase* InInteractionPawn, int InSpecialMoveFlags, class UBSM_BaseParameter* InSMParam);
	struct FString SpecialMoveToString(const struct FName& InSpecialMove, class AGamePawn* InInteractionPawn, int InSpecialMoveFlags);
	struct FString SpecialMoveStructToString(const struct FBLSpecialMoveStruct& InSpecialMoveStruct);
	struct FBLSpecialMoveStruct FillSpecialMoveStructFromParams(const struct FName& InSpecialMove, class ABLPawnBase* InInteractionPawn, int InSpecialMoveFlags, class UBSM_BaseParameter* InSMParam);
	bool VerifySMHasBeenInstanced(const struct FName& AMove);
	void SpecialMoveEnded(const struct FName& PrevMove, const struct FName& NextMove);
	void SpecialMoveStarted(const struct FName& NewMove, const struct FName& PrevMove, bool bForced);
	void SpecialMoveAssigned(const struct FName& NewMove, const struct FName& PrevMove);
	void LocalEndSpecialMove(const struct FName& SpecialMoveToEnd);
	void EndSpecialMove(const struct FName& SpecialMoveToEnd);
	void UnRegisterMsgProc();
	void RegisterMsgProc();
	void PlaySpawnEffect();
	void Despawned();
	void Spawned(int InInstigatorId);
	void InitEventHandler();
	void PostInitSM();
	void PostInitPawn();
	void InitSpawnGuid();
	void PostBeginPlay();
	struct FString GetPawnNamePrefix();
	TEnumAsByte<ETargetFrameType> GetTargetFrameType();
	void CheckHideSpeechBubble(class ABlessPC* InPC);
	bool GetEnergy(int* outEnergy, int* outEnergyMax);
	bool GetLevelText(class ABlessPC* InPC, struct FString* OutLevelText);
	bool GetLevelColor(class ABlessPC* InPC, struct FColor* OutColor);
	bool GetTargetHPColor(class ABlessPC* InPC, struct FColor* OutColor);
	bool GetTargetNameColor(class ABlessPC* InPC, struct FColor* OutColor);
	bool GetOnHeadRankTitle(class ABlessPC* InPC, struct FString* OutDesc);
	bool GetOnHeadSubTitle(class ABlessPC* InPC, struct FString* OutDesc);
	bool GetOnHeadTitle(class ABlessPC* InPC, struct FString* OutDesc);
	bool GetOnHeadNameColor(class ABlessPC* InPC, bool IgnoreDeath, bool bTargetUI, struct FColor* OutColor);
	bool GetOnHeadHPColor(class ABlessPC* InPC, struct FColor* OutColor);
	bool InitNameTag();
	class UHeadExpressionComponent* GetHeadExpressionComponent();
	class UDebugLocationComponent* GetDebugLocationComponent();
	void UpdateAllAttachmentVisibility();
	class UBLAggregateEquipment* GetAggregateEquipment();
	class UFootStepEffectComponent* GetFootStepEffectComponent();
	class UMorphController* GetMorphController();
	class UMaterialController* GetMaterialController();
	class UDecorationEffectController* GetDecorationEffectController();
	TEnumAsByte<EVisualMaterialDefenceType> GetVisualMaterialDefenceType();
	TEnumAsByte<ESoundMaterialDefenceType> GetSoundMaterialDefenceType();
	void OnUpdateEnergy();
	void OnUpdateMP();
	void OnUpdateHP();
	void OnUpdateMovePhysicsData();
	void OnUpdateConditionalPhase(TEnumAsByte<ECEConditionPhaseType> InPrevType, TEnumAsByte<ECEConditionPhaseType> InNewType);
	void OnPoseActionAck(TEnumAsByte<ECEStatePoseType> InStatePose, bool bSuccess);
	void OnUpdateStateSituation(TEnumAsByte<ECEStateSituationType> InStateSituation);
	void OnUnsheatheWeapon();
	void OnSheatheWeapon();
	void OnUpdateTargetChanged();
	bool IsPawnRotationLocked();
	void HideFriendlyAutoTargetOutLine();
	void ShowFriendlyAutoTargetOutLine();
	void HideQuestOutLine(TEnumAsByte<ECEQuestType> QuestType);
	void ShowQuestOutLine(TEnumAsByte<ECEQuestType> QuestType);
	void OnMouseOut();
	void OnMouseOver();
	bool CompareAnimSeqName(const struct FName& AnimSeqA, const struct FName& AnimSeqB);
	struct FName GetDefaultAnimSeqName(const struct FName& WeaponAnimSeqName);
	struct FName GetWeaponAnimSeqName(const struct FName& DefaultAnimSeqName);
	bool CheckLOS_PawnType(class ABLPawnBase* InDestPawn);
	float GetCollisionRadiusOfPawnInfo();
	float GetCollisionHeightOfPawnInfo();
	float SafetyGetCollisionRadius();
	float SafetyGetCollisionHeight();
	class UDynamicLightEnvironmentComponent* GetLightEnvironmentComp();
	class UCharacterizeSkeletalMeshComponent* GetCharacterizeHeadMeshComp();
	class UCharacterizeSkeletalMeshComponent* GetCharacterizeBodyMeshComp();
	void HideTooltip();
	void ShowTooltip();
	void LeaveWorld();
	bool IsSpiritState();
	bool IsTransportState();
	bool IsDeadPawn();
	void OnSpawned(class ABlessPC* InPC, bool bNeedSpawnEffect);
	void InitPawnCrowdControl();
	void InitPawnAura();
	void InitPawnAbnormalStatus();
	void InitPawn();
	void PostSetData();
	void UpdateHidden();
	void SetHiddenMask(TEnumAsByte<EPawnHidden> HiddenType, bool bMaskOn);
	void ForceShowPawn();
	void InitPawnHidden();
	void SetPawnHidden(TEnumAsByte<EPawnHidden> HiddenType, bool IsHidden);
	bool IsHidePawn(TEnumAsByte<EPawnHidden> HiddenType);
	void UpdateAura(int InAuraCid, bool bInActive, bool bOnGoing);
	void ClearAbnormalStatusData();
	void UpdateAbnormalStatusDuration(struct FAbnormalStatusDurationData* DurationData);
	void UpdateAbnormalStatus(bool bOnGoing, struct FAbnormalStatusData* InData);
	void NativePostRenderFor(class APlayerController* PC, class UCanvas* Canvas, const struct FVector& CameraPosition, const struct FVector& CameraDir);
	class ABLPawnBase* STATIC_GetPawnByID(int InSid);
	void CrushedBy(class APawn* OtherPawn);
	void TakeFallingDamage();
};


// Class BLGame.BLPawn
// 0x0724 (0x0D98 - 0x0674)
class ABLPawn : public ABLPawnBase
{
public:
	unsigned long                                      bIsLocalPawn : 1;                                         // 0x0674(0x0004)
	unsigned long                                      IsUseCharacterizeMesh : 1;                                // 0x0674(0x0004) (Transient)
	unsigned long                                      bIsSprinting : 1;                                         // 0x0674(0x0004) (Transient)
	unsigned long                                      bHasMovementAuthority : 1;                                // 0x0674(0x0004) (Transient)
	unsigned long                                      bStoppedMovementSync : 1;                                 // 0x0674(0x0004) (Transient)
	unsigned long                                      bHasImportantAction : 1;                                  // 0x0674(0x0004) (Transient)
	unsigned long                                      bIsDoingSyncImportantAction : 1;                          // 0x0674(0x0004) (Transient)
	unsigned long                                      bShowForceSyncMessage : 1;                                // 0x0674(0x0004) (Config)
	unsigned long                                      bIsUnsheathed : 1;                                        // 0x0674(0x0004) (Transient)
	unsigned long                                      IsDead : 1;                                               // 0x0674(0x0004) (Transient)
	unsigned long                                      IsDeadBody : 1;                                           // 0x0674(0x0004) (Transient)
	unsigned long                                      IsDeadBodyDespawn : 1;                                    // 0x0674(0x0004) (Transient)
	unsigned long                                      bLookAtTarget : 1;                                        // 0x0674(0x0004) (Transient)
	unsigned long                                      bLookAtForward : 1;                                       // 0x0674(0x0004) (Transient)
	unsigned long                                      bStrafePose : 1;                                          // 0x0674(0x0004) (Transient)
	unsigned long                                      bNoFootPlacementControl : 1;                              // 0x0674(0x0004) (Transient)
	unsigned long                                      IsUsePawnHeadExpression : 1;                              // 0x0674(0x0004) (Edit, Config)
	unsigned long                                      bBackwardMove : 1;                                        // 0x0674(0x0004) (Transient)
	unsigned long                                      bUseRootMotionFalling : 1;                                // 0x0674(0x0004)
	unsigned long                                      bEnableDelaySkillFiring : 1;                              // 0x0674(0x0004)
	unsigned long                                      bLockPhysics : 1;                                         // 0x0674(0x0004)
	unsigned long                                      EnableSetBase : 1;                                        // 0x0674(0x0004)
	unsigned long                                      bEnableCustomizing : 1;                                   // 0x0674(0x0004)
	unsigned long                                      bAdjustRootMotionHeightMode : 1;                          // 0x0674(0x0004)
	unsigned long                                      bBoneDefomationCached : 1;                                // 0x0674(0x0004)
	unsigned long                                      PlayNextBroadWay : 1;                                     // 0x0674(0x0004)
	struct FVector                                     FloorNormal;                                              // 0x0678(0x000C) (Transient)
	float                                              DefWalkableFloorZ;                                        // 0x0684(0x0004) (Transient)
	class USpriteComponentRTT*                         PawnNameSpriteComponent;                                  // 0x0688(0x0008) (ExportObject, Component, EditInline)
	TEnumAsByte<EMoveSpeedType>                        MoveSpeedType;                                            // 0x0690(0x0001) (Transient)
	TEnumAsByte<ECERiotControlType>                    RiotControlState;                                         // 0x0691(0x0001) (Transient)
	TEnumAsByte<EPhysics>                              LastPhysics;                                              // 0x0692(0x0001)
	TEnumAsByte<EPawnMeshRenderState>                  PawnMeshRenderState;                                      // 0x0693(0x0001)
	TEnumAsByte<EPawnMeshRenderState>                  AppliedPawnMeshRenderState;                               // 0x0694(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0695(0x0003) MISSED OFFSET
	TArray<class USkillAsset*>                         SkillAssetCaches;                                         // 0x0698(0x0010) (NeedCtorLink)
	float                                              DistToWallNormalWhenFailSlideSlop;                        // 0x06A8(0x0004) (Config)
	class UDynamicLightEnvironmentComponent*           LightEnvironment;                                         // 0x06AC(0x0008) (Edit, ExportObject, Component, EditInline)
	class UBLCharacterLightComponent*                  CharacterLight;                                           // 0x06B4(0x0008) (Edit, ExportObject, Component, EditInline)
	struct FActionSyncInfo                             CurActionSync;                                            // 0x06BC(0x0144) (Transient, NeedCtorLink)
	struct FActionSyncInfo                             LastestActionSync;                                        // 0x0800(0x0144) (Transient, NeedCtorLink)
	TArray<struct FActionSyncInfo>                     PendingActionSyncList;                                    // 0x0944(0x0010) (Transient, NeedCtorLink)
	float                                              PendingActionSync_TotalDistance;                          // 0x0954(0x0004) (Transient)
	struct FImportantActionSyncInfo                    ImportantAction;                                          // 0x0958(0x001C) (Transient)
	struct FVector                                     TranslationDelta;                                         // 0x0974(0x000C) (Transient)
	float                                              TranslationTimeToGo;                                      // 0x0980(0x0004) (Transient)
	int                                                MaxPendingMovements;                                      // 0x0984(0x0004) (Config)
	float                                              ForceSyncLimitDist;                                       // 0x0988(0x0004) (Config)
	float                                              WalkingUpdateFrequency;                                   // 0x098C(0x0004) (Config)
	float                                              FallingUpdateFrequency;                                   // 0x0990(0x0004) (Config)
	float                                              SpecialMoveUpdateFrequency;                               // 0x0994(0x0004) (Config)
	float                                              MovementTimeOut;                                          // 0x0998(0x0004) (Config)
	int                                                TargetPrevID;                                             // 0x099C(0x0004) (Transient)
	int                                                TargetOfTargetID;                                         // 0x09A0(0x0004) (Transient)
	int                                                TargetOfTargetPrevID;                                     // 0x09A4(0x0004) (Transient)
	int                                                SummoneeID;                                               // 0x09A8(0x0004) (Transient)
	float                                              UnsheatheKeepTimeToRemain;                                // 0x09AC(0x0004) (Transient)
	float                                              UnsheatheKeepingSeconds;                                  // 0x09B0(0x0004) (Edit, Config)
	float                                              TimesFromPeacePostureBroken;                              // 0x09B4(0x0004) (Transient)
	float                                              PeacePostureRecoverySeconds;                              // 0x09B8(0x0004) (Edit, Config)
	float                                              TimesFromPeaceStatus;                                     // 0x09BC(0x0004) (Transient)
	float                                              CombatReadinessKeepingSeconds;                            // 0x09C0(0x0004) (Edit, Config)
	float                                              RCDurationTime;                                           // 0x09C4(0x0004) (Transient)
	struct FSkillRequestInfo                           CurrentSkill;                                             // 0x09C8(0x00A8) (Transient, NeedCtorLink)
	struct FAttackRequestInfo                          CurrentAttack;                                            // 0x0A70(0x0028) (Transient)
	struct FVoluntaryActionRequestInfo                 CurrentVoluntaryAction;                                   // 0x0A98(0x0014) (Transient)
	struct FSocialActionRequestInfo                    CurrentSocialAction;                                      // 0x0AAC(0x000C) (Transient)
	float                                              TimeOfDeath;                                              // 0x0AB8(0x0004) (Transient)
	struct FName                                       DeathAnim;                                                // 0x0ABC(0x0008) (Const)
	struct FName                                       HeadLookAtBoneName;                                       // 0x0AC4(0x0008)
	class UBLAnimBlendLookAt*                          HeadLookNode;                                             // 0x0ACC(0x0008) (Transient)
	class UAnimNodeHumanIKDirectionalProjection*       FootPlacementControl;                                     // 0x0AD4(0x0008) (Transient)
	class UBLSkelControlWeaponSheathe*                 UnsheatheControl_Main;                                    // 0x0ADC(0x0008) (Transient)
	class UBLSkelControlWeaponSheathe*                 UnsheatheControl_Off;                                     // 0x0AE4(0x0008) (Transient)
	TArray<class UAnimNodeBlendBase*>                  IdleMotionParentNodes;                                    // 0x0AEC(0x0010) (Transient, NeedCtorLink)
	class UBLAnimNodeFreeze*                           AnimFreezeNode;                                           // 0x0AFC(0x0008) (Transient)
	class UBLAnimNodeScalePlayRate*                    AnimPlayRateNode;                                         // 0x0B04(0x0008) (Transient)
	class UBLAnimNodeSlot*                             FullBodyNode;                                             // 0x0B0C(0x0008) (Transient)
	class UBLAnimNodeSlot*                             StandBodyNode;                                            // 0x0B14(0x0008) (Transient)
	class UBLAnimBlendByCustomAnim*                    CustomAnimNode;                                           // 0x0B1C(0x0008) (Transient)
	class UAnimNodeSequence*                           IdlePNode;                                                // 0x0B24(0x0008) (Transient)
	class UBLAnimNodeSlot*                             StandUpperBodyNode;                                       // 0x0B2C(0x0008) (Transient)
	class UBLAnimNodeSlot*                             RunUpperBodyNode;                                         // 0x0B34(0x0008) (Transient)
	class UBLAnimNodeSlot*                             UpperBodyAdditiveNode;                                    // 0x0B3C(0x0008) (Transient)
	class UBLAnimNodeSlot*                             JumpUpNode;                                               // 0x0B44(0x0008) (Transient)
	class UBLAnimNodeBlendByBidirectional*             WalkBidirectionNode;                                      // 0x0B4C(0x0008) (Transient)
	class UBLAnimBlendByIdle*                          AnimBlendByIdle;                                          // 0x0B54(0x0008) (Transient)
	TArray<class UAnimNodeBlend*>                      AnimSlightlyTurnBlendList;                                // 0x0B5C(0x0010) (Transient, NeedCtorLink)
	TArray<class UAnimNodeAdditiveBlending*>           AnimSlightlyTurnLeftList;                                 // 0x0B6C(0x0010) (Transient, NeedCtorLink)
	TArray<class UAnimNodeAdditiveBlending*>           AnimSlightlyTurnRightList;                                // 0x0B7C(0x0010) (Transient, NeedCtorLink)
	class UBLAnimNodeRemoveAnimation*                  HairSuppressNode;                                         // 0x0B8C(0x0008) (Transient)
	class UBLAnimNodeSlot*                             FullHeadNode;                                             // 0x0B94(0x0008) (Transient)
	class UBLAnimNodeShakeBone*                        BodyShakeNode;                                            // 0x0B9C(0x0008) (Transient)
	class UBLAnimNodeRotateByDirectional*              RotatorNode;                                              // 0x0BA4(0x0008) (Transient)
	class UMaterialController*                         PawnMaterialController;                                   // 0x0BAC(0x0008) (Const, ExportObject, Component, EditInline)
	class UDecorationEffectController*                 PawnDecorationEffectController;                           // 0x0BB4(0x0008) (Const, ExportObject, Component, EditInline)
	class UMorphController*                            PawnMorphController;                                      // 0x0BBC(0x0008) (Transient)
	class UBLPawnMovementComponent*                    PawnMovementComponent;                                    // 0x0BC4(0x0008) (Const, ExportObject, Component, EditInline)
	class UHeadExpressionComponent*                    PawnHeadExpressionComponent;                              // 0x0BCC(0x0008) (ExportObject, Component, EditInline)
	class UFootStepEffectComponent*                    FootStepEffectComp;                                       // 0x0BD4(0x0008) (ExportObject, Component, EditInline)
	class UBlobShadowComponent*                        BlobShadowComp;                                           // 0x0BDC(0x0008) (ExportObject, Component, EditInline)
	class UCharacterizeSkeletalMeshComponent*          CharacterizeMesh;                                         // 0x0BE4(0x0008) (ExportObject, Component, EditInline)
	class UCharacterizeSkeletalMeshComponent*          CharacterizeHeadMesh;                                     // 0x0BEC(0x0008) (ExportObject, Component, EditInline)
	class UBLAggregateEquipment*                       AggregateEquipment;                                       // 0x0BF4(0x0008) (Const, ExportObject, Component, EditInline)
	class UEquipItemEffectComponent*                   EquipItemEffectComp;                                      // 0x0BFC(0x0008) (ExportObject, Component, EditInline)
	class USkeletalMeshComponent*                      ProxyMesh;                                                // 0x0C04(0x0008) (ExportObject, Component, EditInline)
	class USkeletalMeshComponent*                      ProxyWeaponL;                                             // 0x0C0C(0x0008) (ExportObject, Component, EditInline)
	class USkeletalMeshComponent*                      ProxyWeaponR;                                             // 0x0C14(0x0008) (ExportObject, Component, EditInline)
	int                                                LineCheckAccumTick;                                       // 0x0C1C(0x0004) (Transient)
	int                                                LineCheckTick;                                            // 0x0C20(0x0004) (Transient)
	TArray<class UBLBroadwayPlayer*>                   BroadwayPlayers;                                          // 0x0C24(0x0010) (NeedCtorLink)
	class ULootController*                             PawnLootController;                                       // 0x0C34(0x0008) (Const, ExportObject, Component, EditInline)
	float                                              SecondsAfterLanding;                                      // 0x0C3C(0x0004) (Transient)
	class UDebugLocationComponent*                     DebugLocComp;                                             // 0x0C40(0x0008) (Const, ExportObject, Component, EditInline)
	class UInterpTrackMove*                            PawnTrackMove;                                            // 0x0C48(0x0008) (Transient)
	class UInterpTrackInstMove*                        PawnTrackInstMove;                                        // 0x0C50(0x0008) (Transient)
	float                                              InterpolationElapsedTime;                                 // 0x0C58(0x0004) (Transient)
	class UInterpPlayInstance*                         CurrentOnlineInterp;                                      // 0x0C5C(0x0008) (Transient)
	TArray<struct FAnimSeqWeightInfo>                  TickingAnimSeqWeightInfos;                                // 0x0C64(0x0010) (Transient, NeedCtorLink)
	float                                              RootMotionFallingVelocityZ;                               // 0x0C74(0x0004)
	TArray<class UParticleSystemComponent*>            EffectsInWaterSurface;                                    // 0x0C78(0x0010) (ExportObject, Transient, Component, NeedCtorLink, EditInline)
	TArray<class UParticleSystemComponent*>            EffectsUnderWater;                                        // 0x0C88(0x0010) (ExportObject, Transient, Component, NeedCtorLink, EditInline)
	struct FAnimationFreezeInfo                        AnimFreezeInfo;                                           // 0x0C98(0x000C) (Transient)
	class UPassiveSkillManager*                        PassiveSkillManager;                                      // 0x0CA4(0x0008) (ExportObject, Transient, Component, EditInline)
	TArray<struct FDelaySkillFiringInfo>               DelaySkillFiringInfos;                                    // 0x0CAC(0x0010) (Transient, NeedCtorLink)
	TArray<class AActor*>                              BackupTouching;                                           // 0x0CBC(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	float                                              FluidSurfaceRatio;                                        // 0x0CCC(0x0004) (Const)
	float                                              PhysicsLockUpdateTime;                                    // 0x0CD0(0x0004) (Config)
	float                                              PhysicsLockUpdateTimeCount;                               // 0x0CD4(0x0004) (Transient)
	struct FRotator                                    MeshLookRot;                                              // 0x0CD8(0x000C) (Transient)
	float                                              BodyShakePlayTime;                                        // 0x0CE4(0x0004) (Transient)
	float                                              BodyShakeScale;                                           // 0x0CE8(0x0004) (Transient)
	class UParticleSystemComponent*                    TargetingPSC;                                             // 0x0CEC(0x0008) (ExportObject, Transient, Component, EditInline)
	class UParticleSystemComponent*                    LockOnTargetingPSC;                                       // 0x0CF4(0x0008) (ExportObject, Transient, Component, EditInline)
	class UParticleSystemComponent*                    AutoTargetingPSC;                                         // 0x0CFC(0x0008) (ExportObject, Transient, Component, EditInline)
	float                                              CustomizedBip01Scale;                                     // 0x0D04(0x0004)
	float                                              CustomizedBNHeadScale;                                    // 0x0D08(0x0004)
	class UBLCustomizingController*                    Customizing;                                              // 0x0D0C(0x0008) (Transient)
	struct FBoneDeformationCacheData                   BodyMeshDefomationCache;                                  // 0x0D14(0x0040) (Transient, NeedCtorLink)
	struct FBoneDeformationCacheData                   HeadMeshDefomationCache;                                  // 0x0D54(0x0040) (Transient, NeedCtorLink)
	int                                                PlayNextBroadWaySkillCid;                                 // 0x0D94(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLPawn");
		return ptr;
	}


	void ShowTargetOutline(bool IsShow);
	void OnUpdateCombatState(TEnumAsByte<ECEStateSituationType> InStateSituation);
	bool IsShowOutlineInBattle(bool IsPlayer);
	TEnumAsByte<EBattleTypeForOutline> GetBattleTypeForOutline();
	void OnApplyRenderState(TEnumAsByte<EPawnMeshRenderState> NewRenderState);
	void OnChangeRenderState(TEnumAsByte<EPawnMeshRenderState> NewRenderState);
	void ApplyCharaterizeMeshOptimzation();
	void ApplyProxyMeshOptimzation();
	void InitSync(const struct FVector& InLocation, const struct FRotator& InRotation, TEnumAsByte<EPawnPhysics> InPhysics);
	bool IsDeadBodySpecialMove();
	void ApplyProxyMeshCastDynamicShadow();
	void ApplyForcedLODLevel(bool bApply);
	bool IsLineCheckEnable();
	void LoadAllAssets();
	void UpdateProxyMeshAnimAndPhys(class UAnimTree* InProxyAnimTree, class UAnimSet* InProxyAnimSet, class UAnimSet* InWeaponAnimSet, class UAnimNotifySet* InWeaponAnimNotifySet);
	void InitToDefaultProxyMeshComp(class USkeletalMeshComponent* InProxy);
	void InitToDefaultCharacterizeMeshComp(class UCharacterizeSkeletalMeshComponent* InChar);
	void ReleaseCharacterizeMesh();
	void ReleaseProxyMesh();
	void SetCharacterizeMesh();
	void SetProxyMesh();
	void GetProxyKeyData(TEnumAsByte<ECERaceType>* OutRace, TEnumAsByte<ECEGenderType>* OutGender, TEnumAsByte<ECEClassType>* OutClass);
	void SetMoreFitBounds(bool bUse, bool bRandomUpdate);
	bool IsUsableProxyMesh();
	void ReleasePawnAsset();
	bool FindProxyWeaponData(bool IsLeftHand, int* OutIsFloatingWeapon, struct FName* OutSheatheBoneName, struct FRotator* OutSheatheRotate, struct FVector* OutSheatheLocation);
	void InitProxyMesh();
	void PlayVoice(const struct FName& VoiceKey);
	bool IsExistAbnormalStatusGroup(int InGroupCid);
	TEnumAsByte<EEquipmentHelmetType> GetHelmetType();
	void ClearAutoTargetingEffect();
	void SetAutoTargetingEffect(bool bInEnable);
	void ClearLockOnTargetingEffect();
	void LockOnTargetingEffect(bool IsLockOn);
	void ClearTargetingEffect();
	void TargetingEffect();
	void SetTargetingEffect(bool bInEnable);
	float GetCurrentBackwardSpeed();
	float GetCurrentForwardSpeed();
	float GetBaseBackwardSpeed();
	float GetBaseForwardSpeed();
	void SetJumpAbility(float InJumpAbility);
	void SetHillClimbingAbility(float InHillClimbingAbility);
	void SetWalkableFloorZ(float InWalkableFloorAngle);
	void OutsideWorldBounds();
	void FellOutOfWorld(class UClass* dmgType);
	void StartDelaySkillFiring();
	void RegisterDelaySkillFiring(int InSkillCid, float InServerFiringTime, float InOriginalFiringTime, bool bInChannelingSkill, bool bInIgnoreMoveInput, bool bInCancelByMoving, bool bInIgnoreMoveInputBreakTime);
	void InitLootAnim();
	void InitInteractAnim(TEnumAsByte<EBLPropInteractionState> InPropInteractionState);
	void ShowSpeechBubble(const struct FString& Text, int ShowTimeInSeconds, bool IsEnemy, TEnumAsByte<EChatChannel> Channel);
	void SetPawnCompHidden(TEnumAsByte<EPawnCompHidden> HiddenType, bool IsHidden);
	bool GetLevelColor(class ABlessPC* InPC, struct FColor* OutColor);
	bool GetLevelText(class ABlessPC* InPC, struct FString* OutLevelText);
	void OutOfWaterSpace();
	void EnterWaterSpace();
	void BLPawnOnParticleSystemFinished(class UParticleSystemComponent* PSC);
	bool PlayWaterParticleEffect(class UAnimNotify_PlayWaterParticleEffect* AnimNotifyData);
	class UHeadExpressionComponent* GetHeadExpressionComponent();
	class UDebugLocationComponent* GetDebugLocationComponent();
	void UpdateAllAttachmentVisibility();
	class UBLAggregateEquipment* GetAggregateEquipment();
	class UFootStepEffectComponent* GetFootStepEffectComponent();
	class UMorphController* GetMorphController();
	class UMaterialController* GetMaterialController();
	class UDecorationEffectController* GetDecorationEffectController();
	void OnAnimTick(const struct FName& AnimSeqName, float Weight);
	void OnAnimPlay(class UAnimNodeSequence* SeqNode);
	int FindAnimSeqIndex(struct FName* SeqName);
	void StopTalkAction();
	bool FinishOnlineInterp();
	bool SeekOnlineInterp(class ULevelStreamingBlessCinematic* StreamingLevel, float pos, float BlendTime);
	bool PlayOnlineInterp(class ULevelStreamingBlessCinematic* StreamingLevel, float pos);
	TEnumAsByte<EVisualMaterialDefenceType> GetVisualMaterialDefenceType();
	TEnumAsByte<ESoundMaterialDefenceType> GetSoundMaterialDefenceType();
	void VoluntaryActionTick(float DeltaTime);
	void StopRiotControl();
	void RiotControlTick(float DeltaTime);
	void OnEndRC();
	void OnHitBy_RiotControl(class UBLEvent_HitBy_RiotControl* Event);
	void OnHitBy(class UBLEvent_HitBy* Event);
	void TargetCastingBarUpdate();
	void ChangeTarget(int InTargetID);
	bool IsExistCrowdControlState(TEnumAsByte<ECECrowdControlComponentType> InType, float* OutParam);
	void UpdateCrowdControl(TEnumAsByte<ECECrowdControlComponentType> InType);
	void UpdateCrowdControlState(TEnumAsByte<ECECrowdControlComponentType> InType, bool bInApplied, float InParam);
	void DropItemBagChooseAcquirerReq(int Acquirer);
	void TurnOnFootPlacementControl();
	void TurnOffFootPlacementControl();
	void APEXClothReactTick(const struct FVector& pawnVelocity, bool bFoward);
	bool TraceForGroundDecal(const struct FVector& InTraceStart, const struct FVector& InTraceEnd, struct FVector* OutLocation, struct FVector* OutNormal, struct FTraceHitInfo* OutHitInfo);
	void SetAllMorphTargetWeights(float MorphWeight);
	void SetMorphTargetWeight(const struct FName& MorphTargetName, float MorphWeight);
	bool SetBaseAsTransport(class AActor* InVehiclePawn, class USkeletalMeshComponent* InBaseMesh, TEnumAsByte<EMountVehicleType> VehicleType);
	bool UpdateAnimationsForTransport(TEnumAsByte<EMountVehicleType> VehicleType, class UAnimTree* ForceUseAnimTree);
	bool StopTaxiTransport();
	bool StartTaxiTransport(float Time, TArray<int>* WaypointIds);
	void PlaySpawnEffect();
	bool STATIC_GetDamageLocAndRot_AngleType(const struct FVector& InSrcLocation, class ABLPawn* InTarget, struct FVector* OutDamageLocation, struct FRotator* OutDamageRotator, float* OutAdditionalScale);
	bool STATIC_GetDamageLocAndRot_DistType(const struct FVector& InSrcLocation, class ABLPawn* InTarget, struct FVector* OutDamageLocation, struct FRotator* OutDamageRotator, float* OutAdditionalScale);
	void RemoveBroadwayPlayer(class UBLBroadwayPlayer* InBwPlayer);
	void AddBroadwayPlayer(class UBLBroadwayPlayer* InBwPlayer);
	class UBLBroadwayPlayer* GetBroadwayPlayer();
	void CrushedBy(class APawn* OtherPawn);
	void JumpOffPawn();
	void PlayFootStepSound(int FootDown);
	void OnAnimNotify(class UAnimNodeSequence* SeqNode, class UBLAnimNotify* NotifyObject);
	bool IsPendingUpdateHpEvent();
	void OnUpdateHP();
	void OnUpdateStateSituation(TEnumAsByte<ECEStateSituationType> InStateSituation);
	TEnumAsByte<EBLCombatStatus> GetCombatStatus();
	void OnUnsheatheWeapon();
	void OnSheatheWeapon();
	void OnEndConditionalPhase(TEnumAsByte<ECEConditionPhaseType> InConditionalPhase);
	void OnStartConditionalPhase(TEnumAsByte<ECEConditionPhaseType> InConditionalPhase);
	void OnUpdateConditionalPhase(TEnumAsByte<ECEConditionPhaseType> InPrevType, TEnumAsByte<ECEConditionPhaseType> InNewType);
	void BreakPeacefulPosture(bool bForce);
	void ReleaseCombatReadiness(float KeepingSeconds);
	bool IsCombatState();
	bool IsPeacefulPosture();
	bool SheatheWeaponFromUnEquipWeapon();
	bool SheatheWeapon();
	bool UnsheatheWeapon();
	void OnUnsheathe();
	void OnSheathe();
	void OnPoseActionAck(TEnumAsByte<ECEStatePoseType> InStatePose, bool bSuccess);
	bool IsSitting();
	void OnUpdateGatherLevel();
	void OnUpdateCraftLevel();
	void OnUpdateLevel(const struct FPawnParamData& InPawnParamData);
	struct FParamData MakeParamData(TEnumAsByte<ECEParamType> InType, float InValue);
	void OnUpdateTargetChanged();
	struct FVector GetPawnDirVelocity();
	bool IsStopped();
	void MovementDoJump();
	float GetMoveUpdateFrequency();
	bool DoJump(bool bUpdating);
	bool IsMovingToForward();
	float PlayCustomAnimWithRunUpper(const struct FName& AnimName, const struct FName& RunUpperName, float Rate, bool bFullBody, float BlendInTime, float BlendOutTime, bool bLooping, bool bOverride, float StartTime, bool bRootMotionAnim, bool bPlayRootMotion);
	float PlayCustomAnim(class UBLAnimNodeSlot* SlotNode, const struct FName& AnimName, float Rate, float BlendInTime, float BlendOutTime, bool bLooping, bool bOverride, float StartTime, bool bRootMotion);
	void SetSprinting(bool InIsSprint);
	void StopSprint();
	void StartSprint();
	void Landed(const struct FVector& HitNormal, class AActor* FloorActor);
	void PrintDecal(class UMaterialInstanceTimeVarying* a_MaterialInstance, float InDecalLifeSpan, float Width, float Height, float Thickness, const struct FVector& a_vHit, const struct FRotator& a_Rotation, bool a_bRadomRotation, float a_CheckLength);
	void ForceUpdatePose();
	void SitDown();
	void StandUp(bool a_Immediately);
	void Tick(float a_DeltaTime);
	void SkillTick(float a_DeltaTime);
	void PostSetupData();
	void CancelSocialAction();
	void DoSocialAction(int InSocialActionID);
	void CleanUpCurrentSocialAction();
	bool IsVoluntaryActionMovable();
	void VoluntaryActionEnd(int InVoluntaryActionID);
	void VoluntaryActionStart(int InVoluntaryActionID);
	void CleanUpCurrentVoluntaryAction();
	void ChannelingSkillFinished();
	void DoSkillAction_Canceled();
	void HideSkillAreaDecal();
	void SkillCanceled();
	bool SkillEndedNormally(int InSkillCid);
	void DoSkillAction_Firing();
	bool SkillAction_Firing(int InSkillCid, float InFiringTime, float InOriginalFiringTime, bool bInChanneling, bool bInIgnoreMoveInput, bool bInCanceledByMoving, float InIgnoreMoveInputBreakTime);
	bool DoSkillAction_Prepare(bool bChargeSkill);
	bool SkillAction_Prepare(class USkillAsset* InSkillAsset, TEnumAsByte<ECETargetingType> InTargetingType, int InTargetID, const struct FVector& InTargetLocation, float InServerCastingTime, float InOriginalCastingTime, const struct FVector& InSkillLocation, const struct FRotator& InSkillRotation, bool bInAbleRush, bool bInChanneling, bool bIgnoreMoveInput, bool bCanceledByMoving, bool bChargeSkill, TArray<float>* ChargeTimes);
	void SetPlayNextBroadway(bool InIsPlay, int InSkillID);
	bool GetExtraSkillParameter(class USkillAsset* InSkillAsset, class UBroadwayInfo** OutBroadwayInfo, class UBroadwayInfo** OutCastingBroadwayInfo, class UBroadwayInfo** OutNextBroadwayInfo, class UClass** BSM);
	bool ChargeInvokeSkillLaunched(class USkillAsset* NewSkillAsset, int ChargeInvokeSkillID);
	void SetSkillResultKey(int InResultKey);
	void DoAttackAction_Canceled();
	void AttackCanceled();
	void DoAttackAction();
	void AttackAction(int InTargetSid, TEnumAsByte<ECEAttackChanceType> InAttackChanceType, int InDamage, float InAttackPeriodSec, float InOriginalAttackPeriodSec, float InApplyTimeSec, int InActionIndex, TEnumAsByte<ECENormalAttackEquipType> InEquipType);
	void SetCurrentAttack(int InTargetSid, TEnumAsByte<ECEAttackChanceType> InAttackChanceType, int InDamage, float InAttackPeriodSec, float InOriginalAttackPeriodSec, int InActionIndex, TEnumAsByte<ECENormalAttackEquipType> InEquipType);
	void CleanUpCurrentAttack();
	class UBroadwayInfo* GetNormalAttackBroadway(int InActionIndex, TEnumAsByte<ECENormalAttackEquipType> InEquipType);
	void CleanUpSkillInfo(struct FSkillRequestInfo* SkillInfo);
	bool GetCurrentSkill(struct FSkillRequestInfo* OutInfo);
	bool SetCurrentSkill_Firing(int InSkillCid, float InFiringTime, float InOriginalFiringTime, bool bInChanneling, bool bInIgnoreMoveInput, bool bInCanceledByMoving, float InIgnoreMoveInputBreakTime);
	void SetCurrentSkill_Prepare(class USkillAsset* InAsset, class UBroadwayInfo* Broadway, class UBroadwayInfo* CastingBroadway, class UBroadwayInfo* NextBroadway, class UClass* InBSM, TEnumAsByte<ECETargetingType> InTargetingType, int InTargetID, const struct FVector& InTargetLocation, float InServerCastingTime, float InOriginalCastingTime, bool bAbleRush, bool bInChanneling, bool bInIgnoreMoveInput, bool bInCanceledByMoving, bool bInChargeSkill, TArray<float>* InChargeTimes);
	bool IsRemoteControlled();
	bool IsDoingExclusiveActing();
	bool Died(class AController* Killer, class UClass* DamageType, const struct FVector& HitLocation);
	void PlayReviveAction(bool bRevivalbyOther, bool bRevivalAtDeadbody);
	void PlayDeathAction(const struct FName& InDeathActionName);
	void PlayDeadbodyDespawn();
	void SetDeadBodyDespawn(bool InIsDeadbodyDespawn);
	void SetDeadBody(bool InIsDeadbody);
	void SetDead();
	void OnUpdateStealth(bool bInState);
	void OnUpdateDead(bool bInState);
	void OnUpdateSpirit(bool bInState);
	void OnUpdateAlive(bool bInState);
	void ChangeToRagdoll();
	void ChangeCollisionToPhysics();
	void ManageRagdolls();
	void BreakConstraint(const struct FVector& Impulse, const struct FVector& HitLocation, const struct FName& InBoneName, bool bVelChange);
	void PlayParticleEffectBySocket(const struct FName& SocketName, class UParticleSystem* PS);
	void DisplayDebug(class AHUD* HUD, float* out_YL, float* out_YPos);
	void gibbedBy(class AActor* Other);
	void EncroachedBy(class AActor* Other);
	bool IsOnlineMode();
	bool IsEnableRootMotion();
	void SetSlightlyTurn(float a_Yaw, float a_BlendTime);
	void OnAnimEndInternal(class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime);
	bool FindAnimSequence(const struct FName& AnimSeqName, struct FName* a_ProperAnimSeq);
	void SetFootPlacementControl(bool bOn, float BlendTime);
	void BuildAnimSetList();
	void ClearAnimNodes();
	void SetCurrentPlayAnimScale(const struct FName& BoneName, bool bIsOneOff, bool bUseAbsoluteScale, struct FBodyStance* TargetBodyStance, struct FVector* TranslationScale);
	void StopAdditiveSequence(float BlendTime);
	bool PlayAdditiveSequence(const struct FName& a_Seq, float a_Rate, float a_FadeIn, float a_FadeOut, bool bOverride, bool bFullBody);
	void StopBodyStance(float BlendTime);
	void AnimFreezeTick(float InDeltaSeconds);
	void RestoreAnimFreezePlayRate();
	void AnimFreeze(float InFreezeTime, float InRemainAnimTime);
	void EndFreezeBody();
	void StartFreezeBody(float SecondsToFreeze, float FreezeTime, float ThawBlendTime);
	bool IsBodyInTheAnimation();
	bool PlayBodyStance(float a_Rate, float a_FadeIn, float a_FadeOut, bool a_bLoop, bool a_bOverride, float a_StartTime, bool bRootMotionAnim, bool bPlayRootMotion, struct FBodyStance* a_BodyStance);
	bool PlayBodyStanceWrapper(float a_Rate, float a_FadeIn, float a_FadeOut, bool a_bLoop, struct FBodyStance* a_BodyStance);
	bool PlayBodyAnim(float a_Rate, float a_FadeIn, float a_FadeOut, bool a_bLoop, bool a_bOverride, float a_StartTime, bool bRootMotionAnim, bool bPlayRootMotion, struct FBodyStance* a_BodyStance);
	bool PlayHeadAnim(float a_Rate, float a_FadeIn, float a_FadeOut, bool a_bLoop, bool a_bOverride, float a_StartTime, struct FBodyStance* a_BodyStance);
	void CacheAnimNodes();
	void PostInitAnimTree(class USkeletalMeshComponent* SkelComp);
	void SetMovementPhysics();
	void UpdateCollisionSize();
	void PostInitPawn();
	void SetMaxJumpHeight(float H);
	void Destroyed();
	bool InitNameTag();
	void PostBeginPlay();
	void UpdateMoveSpeedType(TEnumAsByte<EMoveSpeedType> InMoveSpeedType);
	void ProcessViewRotation(float DeltaTime, struct FRotator* out_ViewRotation, struct FRotator* out_DeltaRot);
	float GetHitAnimRate(float fAnimHitTime, float fServerHitTime);
	struct FName GetDefaultCameraMode(class APlayerController* RequestedBy);
	float GetBaseTranslationOffset();
	void InitDefaultCharacter(class UPawnAsset* Asset);
	void EquipItemSetForEditor(struct FEquipSet* InEquipSet);
	void DisableRootMotion(bool bKeepVelocity);
	void CleanupRotation();
	void SetSheatheControlParameter(class UBLSkelControlWeaponSheathe* Control, class UBLEquipmentItemInHandInfo* InHandInfo, bool bLeftHand, bool bUnsheathe);
	void SetAnimNodeChildBlendTime(class UBLAnimBlendBase* Node, int ChildIndex, float BlendTime);
	void SendSyncToServer();
	void UnLockPhysics();
	void LockPhysics();
	void UpdatePhysicsLock();
	void EndAdjustRootMotionHeightMode();
	void StartAdjustRootMotionHeightMode();
	void StopActorFaceFXAnim();
	bool PlayActorFaceFXAnim(class UFaceFXAnimSet* AnimSet, const struct FString& GroupName, const struct FString& SeqName, class USoundCue* SoundCueToPlay, class UAkEvent* AkEventToPlay);
	float GetAnimWeight(const struct FName& AnimName);
	struct FName GetDominantTickingAnimName();
	bool UpdateCharacterizeMesh();
	bool CanUpdateCharacterizeMesh();
	bool IsNeedUpdateCharacterizeMesh();
	void UpdateEquipmentItem(TArray<struct FEquipedItemData>* EquippedItems);
	void UpdateRotation(const struct FRotator& NewRotation, float DeltaTime);
	struct FVector GetCylinderBottomLocation();
	struct FVector GetCylinderCenterLocation();
	struct FVector GetCylinderTopLocation();
	void NewLog(const struct FString& msg);
	void SetPawnHidden(TEnumAsByte<EPawnHidden> HiddenType, bool IsHidden);
	void RestoreTouching();
	void BackUpAndClearTouching();
	bool STATIC_TraceSkeletalMesh(class USkeletalMeshComponent* InTargetSkelMeshComp, const struct FVector& InTraceRayEnd, const struct FVector& InTraceRayStart, const struct FVector& InTraceRayExtent, struct FVector* OutHitLoc, struct FVector* OutHitNorm, struct FTraceHitInfo* OutHitInfo);
	bool GetWaterVolumeSurfaceHeight(float* WaterHeight);
	bool IsEquippedWeaponTypeItem();
	void TakeOffAll();
	void ReStartSyncMovement();
	void StopSyncMovement();
	void CleanUpMovementSync();
	void ForceMoveToLocationByServer(const struct FVector& a_Location, const struct FRotator& a_Rotation);
	void ForceAdjustmentMovement(const struct FVector& a_Location, const struct FRotator& a_Rotation, bool a_bZeroVelocity, bool a_bZeroAcceleration);
	void SetMovementAuthority(bool a_bHasMovementAuthority);
	void CleanupMovementInfo(struct FActionSyncInfo* a_Info);
	float GetHeightBetweenFeetAndRoot(const struct FName& LeftFootBoneName, const struct FName& RightFootBoneName);
	TEnumAsByte<EPhysics> PawnPhysicsToPhysics(TEnumAsByte<EPawnPhysics> PawnPhysics);
	TEnumAsByte<EPawnPhysics> PhysicsToPawnPhysics(TEnumAsByte<EPhysics> InPhysics);
	class ABLPawnBase* GetTargetOfTargetPawn();
	class ABLPawnBase* GetTargetPawn();
	struct FVector ClientLocationToServerLocation(struct FVector* ClientLocation);
	struct FVector ServerLocationToClientLocation(struct FVector* ServerLocation);
	void LeaveWorld();
	TEnumAsByte<ECERiotControlStateType> GetRCStateType();
	bool IsSpiritState();
	bool IsTransportState();
	bool IsDeadPawn();
	class UDynamicLightEnvironmentComponent* GetLightEnvironmentComp();
	class UCharacterizeSkeletalMeshComponent* GetCharacterizeHeadMeshComp();
	class UCharacterizeSkeletalMeshComponent* GetCharacterizeBodyMeshComp();
	void OnSpawned(class ABlessPC* InPC, bool bNeedSpawnEffect);
	void InitPawnCrowdControl();
	void InitPawnAura();
	void InitPawnAbnormalStatus();
	void PostSetData();
	void PostInitMaterialController();
	void InitMaterialController();
	void InitPawnComp();
	void UpdateMeshCompTranslation();
	void PostUpdateMeshAndAttachments();
	void PreUpdateMeshAndAttachments();
	bool UpdateMeshAndAttachmentsInner();
	bool UpdateMeshAndAttachments();
	void InitAnimAndPhys();
	void InitCharacterizeMesh();
	void InitEquipment();
	void InitMorphTargets();
	void InitPawnResource();
	void InitPawnAsset(class UPawnAsset* Asset);
	void InitPawn();
	void ReInitComponents();
	TEnumAsByte<EBLAnimMoveState> GetAnimMoveState();
	TEnumAsByte<EBLAnimWeaponState> GetAnimWeaponState();
};


// Class BLGame.BLNpcBase
// 0x0080 (0x0E18 - 0x0D98)
class ABLNpcBase : public ABLPawn
{
public:
	class UNPCAsset*                                   NPCAsset;                                                 // 0x0D98(0x0008) (Transient)
	int                                                InfoCid;                                                  // 0x0DA0(0x0004)
	float                                              DesiredZ;                                                 // 0x0DA4(0x0004)
	unsigned long                                      bHasGroundZ : 1;                                          // 0x0DA8(0x0004)
	struct FMoveToAction                               CurrentMoveToAction;                                      // 0x0DAC(0x002C)
	float                                              MoveUpdateTime;                                           // 0x0DD8(0x0004) (Transient)
	float                                              MoveUpdateFrequency;                                      // 0x0DDC(0x0004)
	float                                              BaseRunForwardSpeed;                                      // 0x0DE0(0x0004) (Transient)
	float                                              BaseRunBackwardSpeed;                                     // 0x0DE4(0x0004) (Transient)
	float                                              BaseWalkForwardSpeed;                                     // 0x0DE8(0x0004) (Transient)
	float                                              SimpleWalkingAccumTime;                                   // 0x0DEC(0x0004) (Transient)
	class UAnimNodeScaleRateBySpeed*                   WalkFwdAnimSpeedMod;                                      // 0x0DF0(0x0008) (Transient)
	class UAnimNodeScaleRateBySpeed*                   RunBackwardAnimSpeedMod;                                  // 0x0DF8(0x0008) (Transient)
	class UAnimNodeScaleRateBySpeed*                   RunFwdAnimSpeedMod;                                       // 0x0E00(0x0008) (Transient)
	TArray<class UBLEquipmentItemEquipInfo*>           EquipCaches;                                              // 0x0E08(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLNpcBase");
		return ptr;
	}


	void UpdateServerRotation(const struct FRotator& InRotator);
	void CleanupMoveAction(const struct FVector& InLocation, const struct FRotator& InRotator);
	void ReplicatedMove(const struct FVector& InLocation, const struct FRotator& InRotation, bool IsWalking, float InSpeed);
	void StopMove(const struct FVector& StopLocation, const struct FRotator& StopRotation, bool IsWalking);
	bool IsLineCheckEnable();
	void MoveToLocation(const struct FVector& NewLocation, bool IsWalking, float InSpeed);
	void ForceMoveToLocationByServer(const struct FVector& a_Location, const struct FRotator& a_Rotation);
	void PlayBodyShake();
	void CacheAnimNodes();
	void SetGradeFX();
	void PostInitPawn();
	void InitDefaultCharacter(class UPawnAsset* Asset);
	TEnumAsByte<ENPCBodySizeType> GetBodySizeType();
	bool GetLevelText(class ABlessPC* InPC, struct FString* OutLevelText);
	void STATIC_FindGround_AllNPC();
	void InitMaterialController();
	void SetData(struct FNPCInfoData* InNPCInfo, struct FNPCData* InNPCData);
	void UpdateRotation(const struct FRotator& NewRotation, float DeltaTime);
	float GetCollisionRadiusOfPawnInfo();
	float GetCollisionHeightOfPawnInfo();
	bool UpdateMeshAndAttachmentsInner();
	void InitCharacterizeMesh();
	void InitPawnResource();
	void InitPawnAsset(class UPawnAsset* Asset);
};


// Class BLGame.BLNpc
// 0x00EC (0x0F04 - 0x0E18)
class ABLNpc : public ABLNpcBase
{
public:
	class UNPCRepInfo*                                 RepInfo;                                                  // 0x0E18(0x0008) (ExportObject, Component, EditInline)
	int                                                TypeID;                                                   // 0x0E20(0x0004) (Const)
	struct FString                                     Typename;                                                 // 0x0E24(0x0010) (Const, NeedCtorLink)
	struct FString                                     FriendlyName;                                             // 0x0E34(0x0010) (Const, NeedCtorLink)
	int                                                Level;                                                    // 0x0E44(0x0004) (Const)
	struct FString                                     NPCTitle;                                                 // 0x0E48(0x0010) (NeedCtorLink)
	class UParticleSystemComponent*                    AudibleRangePSC;                                          // 0x0E58(0x0008) (ExportObject, Component, EditInline)
	class ABLPawnBase*                                 NPCLookingTarget;                                         // 0x0E60(0x0008) (Transient)
	class UBLAnimNodeSlot*                             OverrideIdlePNode;                                        // 0x0E68(0x0008) (Transient)
	class UBLAnimBlendByMoveType*                      MoveTypeBlendNode;                                        // 0x0E70(0x0008) (Transient)
	TEnumAsByte<ECENPCStateType>                       CurrentNPCState;                                          // 0x0E78(0x0001) (Transient)
	TEnumAsByte<ECEItemGradeType>                      DropItemGradeEffectType;                                  // 0x0E79(0x0001) (Transient)
	TEnumAsByte<EQuestMarker>                          QuestMarker;                                              // 0x0E7A(0x0001) (Transient)
	TEnumAsByte<ENPCFunctionMarker>                    NPCFunctionMarker;                                        // 0x0E7B(0x0001)
	TEnumAsByte<ECEStateSituationType>                 LastStateSituation;                                       // 0x0E7C(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0E7D(0x0003) MISSED OFFSET
	class UParticleSystemComponent*                    DeadBody_EffectPSC;                                       // 0x0E80(0x0008) (ExportObject, Transient, Component, EditInline)
	class UMaterialInstanceTimeVarying*                DeadBody_EffectMITV;                                      // 0x0E88(0x0008) (Transient)
	class ABLSpawnableEmitter*                         QuestMarkEmitter;                                         // 0x0E90(0x0008) (Transient)
	float                                              MaxPhysicsDistance;                                       // 0x0E98(0x0004) (Config)
	class UParticleSystemComponent*                    QuestObjectEffectPSC;                                     // 0x0E9C(0x0008) (ExportObject, Transient, Component, EditInline)
	float                                              HateListUpdateTime;                                       // 0x0EA4(0x0004) (Transient)
	TArray<struct FHateActorData>                      HateList;                                                 // 0x0EA8(0x0010) (Transient, NeedCtorLink)
	float                                              BTListUpdateTime;                                         // 0x0EB8(0x0004) (Transient)
	struct FString                                     BehaviourName;                                            // 0x0EBC(0x0010) (Transient, NeedCtorLink)
	TArray<struct FString>                             BTNodeList;                                               // 0x0ECC(0x0010) (Transient, NeedCtorLink)
	class UBLMerchantInventory*                        MerchantInventory;                                        // 0x0EDC(0x0008) (Transient)
	unsigned long                                      bNpcInteractionPossible : 1;                              // 0x0EE4(0x0004) (Transient)
	unsigned long                                      bNpcInteractionPlaying : 1;                               // 0x0EE4(0x0004) (Transient)
	float                                              AnimForceUpdateDistance;                                  // 0x0EE8(0x0004) (Config)
	float                                              OutofSightGuaranteeSec;                                   // 0x0EEC(0x0004) (Config)
	float                                              OutofSightGuaranteeAccumsec;                              // 0x0EF0(0x0004) (Transient)
	struct FScriptDelegate                             __NPCSpawned__Delegate;                                   // 0x0EF4(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData01[0x4];                                       // 0x0EF4(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLNpc");
		return ptr;
	}


	void ClearOutofSightGuarantee();
	void SetOutofSightGuarantee();
	void RefreshQuestEffect();
	void LoadAllAssets();
	float GetCurrentBackwardSpeed();
	float GetCurrentForwardSpeed();
	float GetBaseBackwardSpeed();
	float GetBaseForwardSpeed();
	struct FName GetDefaultAnimSeqName(const struct FName& WeaponAnimSeqName);
	struct FName GetWeaponAnimSeqName(const struct FName& DefaultAnimSeqName);
	void ReleasePawnAsset();
	bool IsUsableProxyMesh();
	void GetProxyKeyData(TEnumAsByte<ECERaceType>* OutRace, TEnumAsByte<ECEGenderType>* OutGender, TEnumAsByte<ECEClassType>* OutClass);
	void DoPolymorph();
	void OnUpdatePolymorphCid();
	void OverridePolymorphNPCInfo(int InNPCCid);
	void OnChangeVisionShared(bool bInVisionShared);
	void SetMovementPhysics();
	void OnUpdateAlive(bool bInState);
	void OnUpdateDead(bool bInState);
	void OnUpdateStateSituation(TEnumAsByte<ECEStateSituationType> InStateSituation);
	void UpdateNPCAudibleRangeVisible();
	void OnUpdateNPCAudibleRangeVisible();
	void OnUpdateNPCAudibleRange();
	void OnUpdateNPCVisible();
	struct FString GetPawnNamePrefix();
	TEnumAsByte<ETargetFrameType> GetTargetFrameType();
	void CheckHideSpeechBubble(class ABlessPC* InPC);
	bool GetLevelColor(class ABlessPC* InPC, struct FColor* OutColor);
	bool GetTargetHPColor(class ABlessPC* InPC, struct FColor* OutColor);
	bool GetTargetNameColor(class ABlessPC* InPC, struct FColor* OutColor);
	bool GetOnHeadSubTitle(class ABlessPC* InPC, struct FString* OutDesc);
	bool GetOnHeadNameColor(class ABlessPC* InPC, bool IgnoreDeath, bool bTargetUI, struct FColor* OutColor);
	bool GetOnHeadHPColor(class ABlessPC* InPC, struct FColor* OutColor);
	void DisplayDebug(class AHUD* HUD, float* out_YL, float* out_YPos);
	void PlayMonologueSound();
	void LoadAndPlayMonologue(int MonologID, int ShowTimeInSeconds);
	bool LookTargetPawn(class ABLPawn* TargetPawn, bool bForce);
	void StopLookTargetPawn();
	void StopTalkAction();
	void PlayTalkAction(class UAkEvent* TalkSound, const struct FName& TalkAnimSeq);
	void AttackAction(int InTargetSid, TEnumAsByte<ECEAttackChanceType> InAttackChanceType, int InDamage, float InAttackPeriodSec, float InOriginalAttackPeriodSec, float InApplyTimeSec, int InActionIndex, TEnumAsByte<ECENormalAttackEquipType> InEquipType);
	void SetDeadBody(bool InIsDeadbody);
	void Destroyed();
	void NPCSpawned(class ABLNpc* pNPC);
	void StopDeadBodyParticle();
	void StopDeadBodyMITV();
	void StopDeadBodyEffect();
	void PlayDeadBodyEffect(TEnumAsByte<ECEItemGradeType> InNewItemGrade);
	void OnUpdateDropItemGrade();
	TEnumAsByte<EQuestMarker> GetQuestMark(TEnumAsByte<ECEQuestType> QuestType, TEnumAsByte<EQuestStatus> questStatus);
	void OutsideWorldBounds();
	void UpdateHeadTagMark();
	void OnUpdateQuestInfoList();
	void EndNPCInteraction();
	void DoNPCInteractionAction(bool bPlayLoop, const struct FName& AnimSeqName, int MonologID);
	void UpdateNPCFunctionMark();
	void Tick(float DeltaTime);
	void UpdateMoveSpeedType(TEnumAsByte<EMoveSpeedType> InMoveSpeedType);
	void RestartNPCInteraction();
	void StopNPCInteraction();
	void SkillCanceled();
	class UBroadwayInfo* GetNPCNormalAttackBroadway(int InAttackIndex);
	bool CanOverrideAction();
	class UBLMerchantInventory* GetMerchantInventory();
	void PostInitPawn();
	bool OnAssetLoaded();
	void PlayDisposableAnim(const struct FName& AnimSeqName, float PlayTime);
	bool ChangeIdleP(int Index);
	bool OverrideIdlePAnim(const struct FName& idleAnimSeqName);
	bool ClearOverrideIdlePAnim(float BlendOut);
	void UpdateNPCState();
	bool PlayBodyStance(float a_Rate, float a_FadeIn, float a_FadeOut, bool a_bLoop, bool a_bOverride, float a_StartTime, bool bRootMotionAnim, bool bPlayRootMotion, struct FBodyStance* a_BodyStance);
	void ClearAnimNodes();
	void OnEndRC();
	void OnHitBy_RiotControl(class UBLEvent_HitBy_RiotControl* Event);
	void UnFixMoveType();
	void FixMoveType(TEnumAsByte<EMoveSpeedType> MoveType);
	bool StopBodyShake();
	void CacheAnimNodes();
	void OffQuestObjectEffect();
	void OnQuestObjectEffect(bool bIsStory);
	void PCDetected();
	void UpdateQuestObjectiveEffect();
	TEnumAsByte<EQuestMarker> GetQuestMarkerType();
	void ShowFriendlyAutoTargetOutLine();
	void OnMouseOver();
	TEnumAsByte<EPawnOutLineColorType> GetOutLineColorType();
	void ForceShowPawn();
	void SetPawnHidden(TEnumAsByte<EPawnHidden> HiddenType, bool IsHidden);
	void LeaveWorld();
	void BuildAnimSetList();
	void DisappearNpc();
	bool CheckApproach(class ABLPawn* Pawn);
	void OnSpawned(class ABlessPC* InPC, bool bNeedSpawnEffect);
	void SetData(struct FNPCInfoData* InNPCInfo, struct FNPCData* InNPCData);
};


// Class BLGame.BLSummonee
// 0x0010 (0x0F14 - 0x0F04)
class ABLSummonee : public ABLNpc
{
public:
	int                                                SummonerSid;                                              // 0x0F04(0x0004)
	TEnumAsByte<ESummoneeStance>                       AIStance;                                                 // 0x0F08(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0F09(0x0003) MISSED OFFSET
	int                                                NumEnergySphere;                                          // 0x0F0C(0x0004)
	unsigned long                                      ToggleEnergySphere : 1;                                   // 0x0F10(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLSummonee");
		return ptr;
	}


	void SummoneeToggleEnergySphere(bool Toggle);
	void SummoneeDespawn();
	void SummoneeAttack(int TargetSId);
	void SummoneeFollow();
	void SummoneeMove(const struct FVector& DestLocation);
	void SummoneeSkill(int TargetSId, const struct FVector& TargetLocation, int SkillCid);
	void SummoneeChangeAIStance(TEnumAsByte<ESummoneeStance> Instance);
};


// Class BLGame.BLPet
// 0x0048 (0x0E60 - 0x0E18)
class ABLPet : public ABLNpcBase
{
public:
	struct FPetData                                    PetData;                                                  // 0x0E18(0x0028)
	struct FPointer                                    PetInfoData;                                              // 0x0E40(0x0008) (Native)
	struct FPointer                                    LookInfoData;                                             // 0x0E48(0x0008) (Native)
	class UPetLookAsset*                               PetLookAsset;                                             // 0x0E50(0x0008)
	class UPetGradeFXAsset*                            GradeFXAsset;                                             // 0x0E58(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLPet");
		return ptr;
	}


	float GetCurrentBackwardSpeed();
	float GetCurrentForwardSpeed();
	float GetBaseBackwardSpeed();
	float GetBaseForwardSpeed();
	void OnUpdateConditionalPhase(TEnumAsByte<ECEConditionPhaseType> InPrevType, TEnumAsByte<ECEConditionPhaseType> InNewType);
	void PlayDespawnEffect();
	void PlaySpawnEffect();
	bool OnAssetLoaded();
	void SetGradeFX();
	void PostInitPawn();
	void LoadAllAssets();
};


// Class BLGame.BLVehiclePawn
// 0x0114 (0x0F2C - 0x0E18)
class ABLVehiclePawn : public ABLNpcBase
{
public:
	class ABLPlayer*                                   DriverPawn;                                               // 0x0E18(0x0008) (Transient)
	class UMountLookAsset*                             VehicleMountLookAsset;                                    // 0x0E20(0x0008) (Transient)
	class UMountGradeFXAsset*                          GradeFXAsset;                                             // 0x0E28(0x0008) (Transient)
	class UBLAnimNodeSlot*                             MountSpecialNode;                                         // 0x0E30(0x0008) (Transient)
	int                                                MountCId;                                                 // 0x0E38(0x0004) (Transient)
	struct FMountLookInfoData                          LookInfoData;                                             // 0x0E3C(0x0078) (Transient, NeedCtorLink)
	struct FPointer                                    GrowthInfoDataPtr;                                        // 0x0EB4(0x0008) (Native)
	int                                                SkillCid_WW;                                              // 0x0EBC(0x0004) (Transient)
	int                                                SkillCid_C;                                               // 0x0EC0(0x0004) (Transient)
	class UMountSkillAsset*                            SkillAsset_WW;                                            // 0x0EC4(0x0008) (Transient)
	class UMountSkillAsset*                            SkillAsset_C;                                             // 0x0ECC(0x0008) (Transient)
	float                                              AttachedDriverCollisionZ;                                 // 0x0ED4(0x0004) (Transient)
	class UMoveController*                             PCMoveController;                                         // 0x0ED8(0x0008) (ExportObject, Component, EditInline)
	TEnumAsByte<ECECompanionGradeType>                 MountGrade;                                               // 0x0EE0(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0EE1(0x0003) MISSED OFFSET
	TArray<class UParticleSystemComponent*>            MountGradePSCList;                                        // 0x0EE4(0x0010) (ExportObject, Component, NeedCtorLink, EditInline)
	float                                              RestoreFatigueTickTime;                                   // 0x0EF4(0x0004)
	float                                              ConsumeFatigueTickTime;                                   // 0x0EF8(0x0004)
	struct FDriverDataToRestore                        DriverRestoreData;                                        // 0x0EFC(0x0010) (Transient)
	struct FScriptDelegate                             __OnLoadMountSkillAsset_WW__Delegate;                     // 0x0F0C(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData01[0x4];                                       // 0x0F0C(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY
	struct FScriptDelegate                             __OnLoadMountSkillAsset_C__Delegate;                      // 0x0F1C(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData02[0x4];                                       // 0x0F1C(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLVehiclePawn");
		return ptr;
	}


	void UpdateMountGrowthInfo(int InLevel);
	float GetBaseBackwardSpeed();
	float GetBaseForwardSpeed();
	void FlyMountMovementInterpolationStopped();
	void FlyMountMovementInterpolated();
	void SendSyncToServer();
	void OnUpdateMovePhysicsData();
	void UpdatePhysicsLock();
	void StopMountActiveSkill();
	void PlayMountActiveSkill(int SkillCid);
	bool PlayBodyStance(float a_Rate, float a_FadeIn, float a_FadeOut, bool a_bLoop, bool a_bOverride, float a_StartTime, bool bRootMotionAnim, bool bPlayRootMotion, struct FBodyStance* a_BodyStance);
	bool PlayHeadAnim(float a_Rate, float a_FadeIn, float a_FadeOut, bool a_bLoop, bool a_bOverride, float a_StartTime, struct FBodyStance* a_BodyStance);
	void PlayDespawnSound();
	void PlayDespawnEffect();
	void PlaySpawnSound();
	void DetachDriver();
	void AttachDriver(class ABLPlayer* InDriver);
	float GetSaddleHeight();
	void InitMountNPC(class UMountLookAsset* InMountLookAsset, class UNPCAsset* InMountNPCAsset, class UMountGradeFXAsset* InGradeFXAsset);
	bool IsChangedMountAsset(class UMountLookAsset* InMountLookAsset, class UNPCAsset* InMountNPCAsset, class UMountGradeFXAsset* InGradeFXAsset);
	void SetGradeFX();
	void PostInitPawn();
	void SetMountInfo(const struct FMountRepInfo& InMountRepData);
	void OnLoadMountSkillAsset_C(class UMountSkillAsset* InAsset);
	void OnLoadMountSkillAsset_WW(class UMountSkillAsset* InAsset);
	bool DoJump(bool bUpdating);
	void StopSpecial();
	void DoSpecial();
	void PossessedBy(class AController* C, bool bVehicleTransition);
	void OnUpdateConditionalPhase(TEnumAsByte<ECEConditionPhaseType> InPrevType, TEnumAsByte<ECEConditionPhaseType> InNewType);
	bool OnAssetLoaded(class UNPCAsset* InAsset);
	void CacheAnimNodes();
	void Destroyed();
	void UpdateRotation(const struct FRotator& NewRotation, float DeltaTime);
};


// Class BLGame.BLPlayer
// 0x0308 (0x10A0 - 0x0D98)
class ABLPlayer : public ABLPawn
{
public:
	class UPlayerRepInfo*                              RepInfo;                                                  // 0x0D98(0x0008) (ExportObject, Component, EditInline)
	class UPCAsset*                                    PCAsset;                                                  // 0x0DA0(0x0008) (Transient)
	int                                                PCCid;                                                    // 0x0DA8(0x0004) (Transient)
	unsigned long                                      bUnSheatheLastestDeadbody : 1;                            // 0x0DAC(0x0004) (Transient)
	unsigned long                                      bPlayerMeshInterpolate : 1;                               // 0x0DAC(0x0004) (Config)
	unsigned long                                      IsPlayMountSpawnEffect : 1;                               // 0x0DAC(0x0004)
	unsigned long                                      bIsAboard : 1;                                            // 0x0DAC(0x0004)
	struct FName                                       LastDeathActionName;                                      // 0x0DB0(0x0008) (Transient)
	TArray<class UAnimNodeScaleRateBySpeed*>           RunFwdAnimSpeedModList;                                   // 0x0DB8(0x0010) (Transient, NeedCtorLink)
	TArray<class UAnimNodeScaleRateBySpeed*>           RunBackwardAnimSpeedModList;                              // 0x0DC8(0x0010) (Transient, NeedCtorLink)
	TArray<class UAnimNodeScaleRateBySpeed*>           WalkFwdAnimSpeedModList;                                  // 0x0DD8(0x0010) (Transient, NeedCtorLink)
	TArray<class UAnimNodeScaleRateBySpeed*>           WalkBackwardAnimSpeedModList;                             // 0x0DE8(0x0010) (Transient, NeedCtorLink)
	TArray<class UAnimNodeScaleRateBySpeed*>           SprintAnimSpeedModList;                                   // 0x0DF8(0x0010) (Transient, NeedCtorLink)
	TArray<class UBLAnimNodeBlendBySpeed*>             AnimBlendBySpeedJump;                                     // 0x0E08(0x0010) (Transient, NeedCtorLink)
	class UBLAnimNodeBlendBySpeed*                     AnimBlendBySpeedJumpLand;                                 // 0x0E18(0x0008) (Transient)
	class UBLAnimNodeSlot*                             MountJumpUpNode;                                          // 0x0E20(0x0008) (Transient)
	class UAnimNodeHumanIKMarker*                      ClimbWallRHand1;                                          // 0x0E28(0x0008) (Transient)
	class UAnimNodeHumanIKMarker*                      ClimbWallRHand2;                                          // 0x0E30(0x0008) (Transient)
	class UAnimNodeHumanIKMarker*                      ClimbWallLHand1;                                          // 0x0E38(0x0008) (Transient)
	class UAnimNodeHumanIKMarker*                      ClimbWallLHand2;                                          // 0x0E40(0x0008) (Transient)
	class UAnimNodeHumanIKMarker*                      ClimbWallRFoot1;                                          // 0x0E48(0x0008) (Transient)
	class UAnimNodeHumanIKMarker*                      ClimbWallRFoot2;                                          // 0x0E50(0x0008) (Transient)
	class UAnimNodeHumanIKMarker*                      ClimbWallLFoot1;                                          // 0x0E58(0x0008) (Transient)
	class UAnimNodeHumanIKMarker*                      ClimbWallLFoot2;                                          // 0x0E60(0x0008) (Transient)
	class UAnimNodeHumanIKBlend*                       ClimbBlendLHand;                                          // 0x0E68(0x0008) (Transient)
	class UAnimNodeHumanIKBlend*                       ClimbBlendRHand;                                          // 0x0E70(0x0008) (Transient)
	class UAnimNodeHumanIKBlend*                       ClimbBlendRFoot;                                          // 0x0E78(0x0008) (Transient)
	class UAnimNodeHumanIKBlend*                       ClimbBlendLFoot;                                          // 0x0E80(0x0008) (Transient)
	class UBLAnimBlendByClimbing*                      ClimbAnimBlend;                                           // 0x0E88(0x0008) (Transient)
	TEnumAsByte<EClimbMoveType>                        ClimbMoveType;                                            // 0x0E90(0x0001) (Transient)
	TEnumAsByte<EEquipmentLoadState>                   EquipmentLoadState;                                       // 0x0E91(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x0E92(0x0002) MISSED OFFSET
	struct FVector                                     ClimbStartPoint;                                          // 0x0E94(0x000C) (Transient)
	struct FVector                                     ClimbDestPoint;                                           // 0x0EA0(0x000C) (Transient)
	float                                              ClimbRemainTime;                                          // 0x0EAC(0x0004) (Transient)
	TArray<class UAnimNodeHumanIKBlend*>               ClimbNudgeControls;                                       // 0x0EB0(0x0010) (Transient, NeedCtorLink)
	class UBLCostumeHelper*                            CostumeHelper;                                            // 0x0EC0(0x0008) (Transient)
	float                                              MeshInterpTranslationZ;                                   // 0x0EC8(0x0004)
	float                                              MeshInterpVelocity;                                       // 0x0ECC(0x0004)
	float                                              StepUPDownTan;                                            // 0x0ED0(0x0004) (Config)
	float                                              ActualVelocity;                                           // 0x0ED4(0x0004)
	struct FName                                       FallingForwardAnimSeqName;                                // 0x0ED8(0x0008) (Const)
	struct FName                                       FallingBackwardAnimSeqName;                               // 0x0EE0(0x0008) (Const)
	class ABLVehiclePawn*                              VehiclePawn;                                              // 0x0EE8(0x0008) (Transient)
	float                                              PrepareCastingRemainTime;                                 // 0x0EF0(0x0004)
	class USkelControlLimb*                            MountLegControl_R;                                        // 0x0EF4(0x0008) (Transient)
	class USkelControlLimb*                            MountLegControl_L;                                        // 0x0EFC(0x0008) (Transient)
	class UAnimNodeSequence*                           MountRunJumpLoopNode;                                     // 0x0F04(0x0008) (Transient)
	class UAnimNodeSequence*                           MountRunBNode;                                            // 0x0F0C(0x0008) (Transient)
	class UAnimNodeSequence*                           MountRunJumpLandNode;                                     // 0x0F14(0x0008) (Transient)
	class UAnimNodeSequence*                           MountRunFNode;                                            // 0x0F1C(0x0008) (Transient)
	class UAnimNodeSequence*                           MountRunFStartNode;                                       // 0x0F24(0x0008) (Transient)
	class UAnimNodeSequence*                           MountRunFStopNode;                                        // 0x0F2C(0x0008) (Transient)
	class UAnimNodeSequence*                           MountJumpLandNode;                                        // 0x0F34(0x0008) (Transient)
	class UAnimNodeSequence*                           MountIdleNode;                                            // 0x0F3C(0x0008) (Transient)
	class UBLAnimNodeAdditiveAnimPlayWhenMoveDirectionChanging* MountADDRotNode;                                          // 0x0F44(0x0008) (Transient)
	class UBLAnimNodeAdditiveAnimPlayWhenMoveDirectionChanging* MountADDRotPoseNode;                                      // 0x0F4C(0x0008) (Transient)
	class UAnimNodeSequence*                           MountIdleROTLStartNode;                                   // 0x0F54(0x0008) (Transient)
	class UAnimNodeSequence*                           MountIdleROTLLoopNode;                                    // 0x0F5C(0x0008) (Transient)
	class UAnimNodeSequence*                           MountIdleROTRStartNode;                                   // 0x0F64(0x0008) (Transient)
	class UAnimNodeSequence*                           MountIdleROTRLoopNode;                                    // 0x0F6C(0x0008) (Transient)
	class UAnimNodeSequence*                           MountFlyingIdleNode;                                      // 0x0F74(0x0008) (Transient)
	class UAnimNodeSequence*                           MountFlyingFFlutterNode;                                  // 0x0F7C(0x0008) (Transient)
	class UAnimNodeSequence*                           MountFlyingBNode;                                         // 0x0F84(0x0008) (Transient)
	class UAnimNodeSequence*                           MountAddIdleSpineBackwardNode;                            // 0x0F8C(0x0008) (Transient)
	class UAnimNodeSequence*                           MountAddIdleSpineForwardNode;                             // 0x0F94(0x0008) (Transient)
	class UAnimNodeSequence*                           MountAddIdleArmUpwardNode;                                // 0x0F9C(0x0008) (Transient)
	class UAnimNodeSequence*                           MountAddIdleArmDownwardNode;                              // 0x0FA4(0x0008) (Transient)
	class UAnimNodeSequence*                           MountAddIdleArmFoldNode;                                  // 0x0FAC(0x0008) (Transient)
	class UAnimNodeSequence*                           MountAddIdleLegNarrowerNode;                              // 0x0FB4(0x0008) (Transient)
	class UAnimNodeSequence*                           MountAddIdleLegWiderNode;                                 // 0x0FBC(0x0008) (Transient)
	class UAnimNodeSequence*                           MountAddRunFSpineBackwardNode;                            // 0x0FC4(0x0008) (Transient)
	class UAnimNodeSequence*                           MountAddRunFSpineForwardNode;                             // 0x0FCC(0x0008) (Transient)
	class UAnimNodeSequence*                           MountAddRunFArmUpwardNode;                                // 0x0FD4(0x0008) (Transient)
	class UAnimNodeSequence*                           MountAddRunFArmDownwardNode;                              // 0x0FDC(0x0008) (Transient)
	class UAnimNodeSequence*                           MountAddRunFArmFoldNode;                                  // 0x0FE4(0x0008) (Transient)
	class UAnimNodeSequence*                           MountAddRunFLegNarrowerNode;                              // 0x0FEC(0x0008) (Transient)
	class UAnimNodeSequence*                           MountAddRunFLegWiderNode;                                 // 0x0FF4(0x0008) (Transient)
	class UAnimNodeBlend*                              MountIdleSpineBackwardNode;                               // 0x0FFC(0x0008) (Transient)
	class UAnimNodeBlend*                              MountIdleSpineForwardNode;                                // 0x1004(0x0008) (Transient)
	class UAnimNodeBlend*                              MountIdleArmUpwardNode;                                   // 0x100C(0x0008) (Transient)
	class UAnimNodeBlend*                              MountIdleArmDownwardNode;                                 // 0x1014(0x0008) (Transient)
	class UAnimNodeBlend*                              MountIdleArmFoldNode;                                     // 0x101C(0x0008) (Transient)
	class UAnimNodeBlend*                              MountIdleLegNarrowerNode;                                 // 0x1024(0x0008) (Transient)
	class UAnimNodeBlend*                              MountIdleLegWiderNode;                                    // 0x102C(0x0008) (Transient)
	class UAnimNodeBlend*                              MountRunFSpineBackwardNode;                               // 0x1034(0x0008) (Transient)
	class UAnimNodeBlend*                              MountRunFSpineForwardNode;                                // 0x103C(0x0008) (Transient)
	class UAnimNodeBlend*                              MountRunFArmUpwardNode;                                   // 0x1044(0x0008) (Transient)
	class UAnimNodeBlend*                              MountRunFArmDownwardNode;                                 // 0x104C(0x0008) (Transient)
	class UAnimNodeBlend*                              MountRunFArmFoldNode;                                     // 0x1054(0x0008) (Transient)
	class UAnimNodeBlend*                              MountRunFLegNarrowerNode;                                 // 0x105C(0x0008) (Transient)
	class UAnimNodeBlend*                              MountRunFLegWiderNode;                                    // 0x1064(0x0008) (Transient)
	class UAnimNodeBlendList*                          MountNode;                                                // 0x106C(0x0008) (Transient)
	struct FSkillDeckSwapRquestInfo                    SkillDeckSwapInfo;                                        // 0x1074(0x001C) (NeedCtorLink)
	class USkeletalMeshComponent*                      CarryObjMeshComp;                                         // 0x1090(0x0008) (ExportObject, Component, EditInline)
	float                                              MountPrepareCastingRemainTime;                            // 0x1098(0x0004)
	int                                                TamingGameTargetSid;                                      // 0x109C(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLPlayer");
		return ptr;
	}


	void PlayTamingSuccessEffect(const struct FMPFRandomData& InResultMPData);
	void EndTamingGame(TEnumAsByte<ETamingEndState> InEndState);
	void PlayTamingGameHitSuccess();
	void StartTamingGame(int InTargetSid);
	bool IsEmptyWeaponDurability();
	void GetEquipItemsWithoutCostume(TArray<class UBLItem*>* EquipItemList);
	void UpdateEquipItemDurabilityHUD();
	bool SetBaseAsMount(class AActor* InVehiclePawn, class USkeletalMeshComponent* InBaseMesh);
	void UnMountFailed(int ErrorCode);
	void DespawnVehicle();
	void GetOffVehicle();
	void EndMountState();
	void UnMountSucceeded();
	void MountPrepareTick(float DeltaTime);
	void DoMountPrepareCancel();
	void DoMountPrepareComplete();
	void DoMountPrepare();
	void MountFailed(int ErrorCode, unsigned char mount_type);
	void ChangeMountLook(int InLookCid);
	void RideVehicle();
	void InitVehicle();
	bool SpawnVehicle(const struct FVector& InLoc, const struct FRotator& InRot);
	void InitMountState();
	bool NeedMountAssetLoading();
	int GetMountLookInfoCId();
	void ReMount();
	void MountSucceeded(bool InPlaySpawnEffect);
	bool LoadMountAssetAsync(int InMountCid, int InLookCid, int InGradeFXCid);
	void RevertMountAnimSeqNames();
	void ChangeMountAnimSeqNames(unsigned char MountAnimType);
	void ChangeMountAnimNodeWeight(const struct FMountLookInfoData& InMountLookInfoData);
	void OnLoadMountAsset(class UMountLookAsset* InMountLookAsset, class UNPCAsset* InMountNPCAsset, class UMountGradeFXAsset* InGradeFXAsset);
	void UpdateDriverAnimNode(TEnumAsByte<ECEMountType> InMountType);
	bool CalcVehicleLoc(const struct FMountRepInfo& InMountRepData, struct FVector* OutPos);
	void PutDownCarryObject(bool bSuccess);
	void DropCarryObject();
	void PickUpCarryObject();
	void DoAction_PickUp(class UCarryObjectAsset* InAsset);
	void OnLoadCarryAsset(class UCarryObjectAsset* InAsset);
	void DetachCarryObject();
	void AttachCarryObject();
	void OnCarryAnimEnd();
	bool UpdateCharacterizeMesh();
	bool CanUpdateCharacterizeMesh();
	void UpdateMPByEquipmentCostume(TArray<struct FEquipedItemData> EquippedItems);
	bool IsEquippedWeaponTypeItem();
	void LoadEquipmentAsset();
	void UpdateEquipmentItem(TArray<struct FEquipedItemData>* EquippedItems);
	void SetEquipmentLoadState(TEnumAsByte<EEquipmentLoadState> InLoadState);
	void RefreshCostumeVisibilityToUI();
	void UpdateCostumeVisibilityWithSendPacket(TEnumAsByte<ECEEquipSlotType> SlotType, bool IsShow);
	void UpdateCostumeVisibility(int CompressedVal);
	void LoadAllAssets();
	void PlayPartySummonEffect();
	bool IsUsableProxyMesh();
	void GetProxyKeyData(TEnumAsByte<ECERaceType>* OutRace, TEnumAsByte<ECEGenderType>* OutGender, TEnumAsByte<ECEClassType>* OutClass);
	void ReleasePawnAsset();
	void SkillDeckSwapTick(float DeltaTime);
	void DoSkillDeckSwapCancel();
	void DoSkillDeckSwapComplete();
	void DoSkillDeckSwapCasting(float InCastingTime, const struct FString& InCastingText);
	void ShowFriendlyAutoTargetOutLine();
	void OnMouseOver();
	TEnumAsByte<EPawnOutLineColorType> GetOutLineColorType();
	void OnHitBy(class UBLEvent_HitBy* Event);
	void PlayBodyShake();
	float GetBaseBackwardSpeed();
	float GetBaseForwardSpeed();
	void SetJumpAbility(float InJumpAbility);
	void SetHillClimbingAbility(float InHillClimbingAbility);
	void StopMountActiveAbnormalStatus(int InSkillCid);
	void StopMountActiveSkill(int InSkillCid);
	void PlayMountActiveSkill(int SkillCid);
	struct FName GetDefaultAnimSeqName(const struct FName& WeaponAnimSeqName);
	struct FName GetWeaponAnimSeqName(const struct FName& DefaultAnimSeqName);
	bool GetLevelColor(class ABlessPC* InPC, struct FColor* OutColor);
	bool GetLevelText(class ABlessPC* InPC, struct FString* OutLevelText);
	void OutOfWaterSpace();
	void EnterWaterSpace();
	void CheckHideSpeechBubble(class ABlessPC* InPC);
	bool GetEnergy(int* outEnergy, int* outEnergyMax);
	TEnumAsByte<ETargetFrameType> GetTargetFrameType();
	bool GetTargetHPColor(class ABlessPC* InPC, struct FColor* OutColor);
	bool GetTargetNameColor(class ABlessPC* InPC, struct FColor* OutColor);
	bool GetOnHeadRankTitle(class ABlessPC* InPC, struct FString* OutDesc);
	bool GetOnHeadSubTitle(class ABlessPC* InPC, struct FString* OutDesc);
	bool GetOnHeadTitle(class ABlessPC* InPC, struct FString* OutDesc);
	bool GetOnHeadNameColor(class ABlessPC* InPC, bool IgnoreDeath, bool bTargetUI, struct FColor* OutColor);
	bool GetOnHeadHPColor(class ABlessPC* InPC, struct FColor* OutColor);
	void SetOnePassLightingOnTranslucency(bool bUse);
	void PhysicsVolumeChange(class APhysicsVolume* NewVolume);
	void ResetEquipmentsByInventory(class UBLPlayerInventory* Inventory);
	void InitEquipedCharacter(class UPCAsset* InPCAsset, TArray<struct FEquipedItemData>* EquipedItems);
	void InitDefaultCharacter(class UPawnAsset* Asset);
	void OnToggleCinematicModeWithHidingNPC(class UBLSeqAct_ToggleCinematicModeWithHidingNPC* Action);
	void OnUpdateDead(bool bInState);
	void OnUpdateSpirit(bool bInState);
	void Tick(float a_DeltaTime);
	void SetPlayerRepInfo(class UPlayerRepInfo* aRepInfo);
	void DisplayDebug(class AHUD* HUD, float* out_YL, float* out_YPos);
	class UBroadwayInfo* GetPCNormalAttackBroadway(int InActionIndex, TEnumAsByte<ECENormalAttackEquipType> InEquipType);
	void OnUpdateConditionalPhase(TEnumAsByte<ECEConditionPhaseType> InPrevType, TEnumAsByte<ECEConditionPhaseType> InNewType);
	void PostInitPawn();
	bool OnAssetLoaded(class UPCAsset* InAsset);
	void SetOtherPCData(struct FOtherPCData* InOtherPCData);
	void SetData(int InPCCid, struct FPCData* InPCData);
	void PostSetData();
	void UpdateAbnormalStatus(bool bOnGoing, struct FAbnormalStatusData* InData);
	void UnPossessed();
	void Destroyed();
	void PlayReviveAction(bool bRevivalbyOther, bool bRevivalAtDeadbody);
	float TickClimbing(float DeltaTime);
	bool IsDoingClimbing();
	bool StartClimbing(TEnumAsByte<EClimbMoveType> InClimbType, const struct FVector& InClimbStartPoint, const struct FVector& InClimbDestPoint, float InClimbTime);
	void StickToRockWallUsingGraspHolds();
	bool ReadyToRockClimb();
	bool ReleaseRockClimbGrip();
	bool ProjectToClimbingWall(float PrjectDist, struct FVector* ProjectedLocation);
	TEnumAsByte<EClimbMoveType> FindHandAndFootHoldsForNudgePush(const struct FVector& MoveDirection, struct FVector* DestLoc);
	TEnumAsByte<EClimbMoveType> FindHandAndFootHoldsForNudgeCross(const struct FVector& MoveDirection, struct FVector* DestLoc);
	TEnumAsByte<EClimbMoveType> FindHandAndFootHoldsForHopping(const struct FVector& MoveDirection, float MoveScale, struct FVector* DestLoc);
	bool FindHandAndFootHolds();
	bool FindHandAndFootHoldsAt(const struct FVector& TargetLocation);
	void ClimbLadder(class ALadderVolume* L);
	void ForceMoveToLocationByServer(const struct FVector& a_Location, const struct FRotator& a_Rotation);
	void OnUpdateMovePhysicsData();
	void OnUpdateEnergy();
	void OnUpdateMP();
	void OnUpdateHP();
	void ClearAnimNodes();
	void CacheAnimNodes();
	bool CalcCamera(float fDeltaTime, struct FVector* out_CamLoc, struct FRotator* out_CamRot, float* out_FOV);
	void SetWalking(bool bNewIsWalking);
	TEnumAsByte<EBLAnimMoveState> GetAnimMoveState();
	void UpdatePhysicsLock();
	void InitProxyMesh();
	void ChangeTarget(int InTargetID);
	void PostBeginPlay();
	bool IsIncludeEar();
	void SetPawnHidden(TEnumAsByte<EPawnHidden> HiddenType, bool IsHidden);
	TEnumAsByte<ECEAppearanceType> GetAppearanceType();
	float GetCollisionRadiusOfPawnInfo();
	float GetCollisionHeightOfPawnInfo();
	void InitCustomizingControllerMaterial();
	void InitCustomizingControllerNormal();
	void InitOverrideMorphTarget();
	void InitMaterialController();
	void InitMorphTargets();
	void InitPawnComp();
	void PostUpdateMeshAndAttachments();
	bool UpdateMeshAndAttachmentsInner();
	void InitCharacterizeMesh();
	void InitEquipment();
	void InitPawnResource();
	void InitPawnAsset(class UPawnAsset* Asset);
	void UpdateRotation(const struct FRotator& NewRotation, float DeltaTime);
};


// Class BLGame.BLPlayerPreview
// 0x0108 (0x077C - 0x0674)
class ABLPlayerPreview : public ABLPawnBase
{
public:
	struct FPCInfoKey                                  PCInfoKey;                                                // 0x0674(0x0004)
	struct FCustomizeData                              CustomizingData;                                          // 0x0678(0x0010) (NeedCtorLink)
	TArray<struct FEquipedItemData>                    EquipItemDataList;                                        // 0x0688(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<struct FEquipedItemData>                    PlayerPreviewItemDataList;                                // 0x0698(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<struct FEquipedItemData>                    LumenaShopItemDataList;                                   // 0x06A8(0x0010) (AlwaysInit, NeedCtorLink)
	float                                              CustomizedBip01Scale;                                     // 0x06B8(0x0004)
	float                                              CustomizedBNHeadScale;                                    // 0x06BC(0x0004)
	TEnumAsByte<EEquipmentHelmetType>                  HelmetType;                                               // 0x06C0(0x0001)
	TEnumAsByte<ERotateDirectionType>                  RotateType;                                               // 0x06C1(0x0001)
	TEnumAsByte<EItemAssetLoadState>                   ItemAssetLoadState;                                       // 0x06C2(0x0001)
	unsigned char                                      UnknownData00[0x1];                                       // 0x06C3(0x0001) MISSED OFFSET
	unsigned long                                      bIsIncludeEar : 1;                                        // 0x06C4(0x0004)
	unsigned long                                      bWeaponRetrieveAnimSets : 1;                              // 0x06C4(0x0004)
	TArray<class UBLEquipmentItemEquipInfo*>           EquipInfoList;                                            // 0x06C8(0x0010) (AlwaysInit, NeedCtorLink)
	class UDynamicLightEnvironmentComponent*           LightEnvironment;                                         // 0x06D8(0x0008) (ExportObject, Component, EditInline)
	class UBLCharacterLightComponent*                  CharacterLight;                                           // 0x06E0(0x0008) (ExportObject, Component, EditInline)
	class UCharacterizeSkeletalMeshComponent*          CharacterizeMesh;                                         // 0x06E8(0x0008) (ExportObject, Component, EditInline)
	class UCharacterizeSkeletalMeshComponent*          CharacterizeHeadMesh;                                     // 0x06F0(0x0008) (ExportObject, Component, EditInline)
	class UBLCostumeHelper*                            CostumeHelper;                                            // 0x06F8(0x0008)
	class UBLAggregateEquipment*                       AggregateEquipment;                                       // 0x0700(0x0008) (ExportObject, Component, EditInline)
	class UMaterialController*                         PawnMaterialController;                                   // 0x0708(0x0008) (ExportObject, Component, EditInline)
	class UBLCustomizingController*                    Customizing;                                              // 0x0710(0x0008)
	class UBLAnimBlendByCustomAnim*                    CustomAnimNode;                                           // 0x0718(0x0008)
	class UBLSkelControlWeaponSheathe*                 UnsheatheControl_Main;                                    // 0x0720(0x0008)
	class UBLSkelControlWeaponSheathe*                 UnsheatheControl_Off;                                     // 0x0728(0x0008)
	struct FPlayerPreviewCameraInfo                    PreviewCameraInfo;                                        // 0x0730(0x0014) (Config)
	struct FPreviewCompressValInfo                     PreviewCompressVal[0x3];                                  // 0x0744(0x0008)
	float                                              CollisionHeight;                                          // 0x075C(0x0004)
	float                                              CollisionRadius;                                          // 0x0760(0x0004)
	struct FRotator                                    EquipPreviewRotator;                                      // 0x0764(0x000C)
	struct FRotator                                    LumenaShopPreviewRotator;                                 // 0x0770(0x000C)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLPlayerPreview");
		return ptr;
	}


	void LoadItemAsset();
	void SetItemAssetLoadState(TEnumAsByte<EItemAssetLoadState> InItemAssetLoadState);
	TEnumAsByte<ECEAppearanceType> GetAppearanceType();
	struct FVector GetCylinderBottomFocus();
	struct FVector GetCylinderTopFocus();
	void RotateRight_LumenaShop(bool InbStartRotate);
	void RotateLeft_LumenaShop(bool InbStartRotate);
	void RotateRight_Equip(bool InbStartRotate);
	void RotateLeft_Equip(bool InbStartRotate);
	void RotatePlayerPreview(float a_DeltaTime);
	void SetZeroRotate(TEnumAsByte<EUIName> UIName);
	void SetSheatheControlParameter(class UBLSkelControlWeaponSheathe* Control, class UBLEquipmentItemInHandInfo* InHandInfo, bool bLeftHand, bool bUnsheathe);
	void OnUnsheathe();
	void OnSheathe();
	void Destroyed();
	void PostBeginPlay();
	void ClearAnimNodes();
	void CacheAnimNodes();
	bool IsNeedUpdatePreview(TEnumAsByte<EBLPreviewType> InPreviewType);
	bool IsChangeCostumeShow(TEnumAsByte<EBLPreviewType> InPreviewType, int InNewCostumeShowConfig);
	bool IsNeedUpdateCharacterizeMesh();
	bool CanUpdateCharacterizeMesh();
	void SetFellowCostumePreview(int LookCid);
	void SetPetCostumePreview(int LookCid);
	void SetMountCostumePreview(int LookCid);
	void SetPlayerCostumePreivew();
	void SetEquipPreview();
	class UBLAggregateEquipment* GetAggregateEquipment();
	class UDynamicLightEnvironmentComponent* GetLightEnvironmentComp();
	class UCharacterizeSkeletalMeshComponent* GetCharacterizeHeadMeshComp();
	class UCharacterizeSkeletalMeshComponent* GetCharacterizeBodyMeshComp();
	void UpdatePreviewPawn(int InCompressedVal, TEnumAsByte<EBLPreviewType> InPreviewType);
	void UpdateCharacterizeMesh();
	void UpdateEquipItem(TArray<struct FEquipedItemData> InEquipItemInfoList);
	void BuildAnimSetList();
	void UpdateMeshCompTranslation();
	void UpdateCollisionSize();
	void PostInitMaterialController();
	void InitMaterialController();
	void PostUpdateMeshAndAttachments();
	void PreUpdateMeshAndAttachments();
	void UpdateMeshAndAttachments();
	void SetEquipInfo(TArray<class UBLEquipmentItemEquipInfo*> InEquipInfoList);
	void PlayPose();
	void InitToDefaultCharacterizeMeshComp(class UCharacterizeSkeletalMeshComponent* InChar);
	void InitCustomizing(TEnumAsByte<EEquipmentHelmetType> InHelmetType, TArray<class UMaterialInterface*> InMaterials, const struct FCustomizeData& InCustomizeData, struct FPCInfoKey* InPCInfoKey);
	void InitAnimAndPhys(class UAnimTree* InBodyAnimTreeTemplate, class UAnimTree* InHeadAnimTreeTemplate, class UPhysicsAsset* InBodyPhysAsset);
	void InitParts(class UPawnAsset* InPawnAsset, TEnumAsByte<EEquipmentHelmetType> InHelmetType, bool IncludeEar);
	void InitEquipment(class UPawnAsset* InPawnAsset);
	void InitCharacterizeMesh(class UPawnAsset* InPawnAsset);
	void InitPawn();
	void UpdateCostumeVisibility(int InCompressedVal);
	void SetCustomizingData(const struct FCustomizeData& InCustomizingData);
	void EquipItems(TArray<struct FEquipedItemData> InEquipItemInfoList);
	void SetLumenaShopEquipItemDataList(TArray<struct FEquipedItemData> InEquipmentItemDataList);
	void SetEquipItemDataList();
	void SetData(const struct FPCInfoKey& InPCInfoKey);
};


// Class BLGame.BLProp
// 0x009C (0x0710 - 0x0674)
class ABLProp : public ABLPawnBase
{
public:
	TArray<struct FBLPropTriggerHandIeInfo>            TriggerHandler;                                           // 0x0674(0x0010) (Component, NeedCtorLink)
	TArray<struct FBLPropTriggerIgnoreHandIeInfo>      IgnoredTriggerHandler;                                    // 0x0684(0x0010) (NeedCtorLink)
	class UPropRepInfo*                                RepInfo;                                                  // 0x0694(0x0008) (ExportObject, Component, EditInline)
	class UStaticMeshComponent*                        PropStaticMeshComponent;                                  // 0x069C(0x0008) (ExportObject, Component, EditInline)
	class USkeletalMeshComponent*                      PropSkeletalMeshComponent;                                // 0x06A4(0x0008) (ExportObject, Component, EditInline)
	class UMaterialInstanceConstant*                   MeshMIC;                                                  // 0x06AC(0x0008)
	class UAnimNodeSequence*                           PropAnimNodeIdle;                                         // 0x06B4(0x0008) (Transient)
	class UAnimNodeSequence*                           PropAnimNodeCustom;                                       // 0x06BC(0x0008) (Transient)
	class UAnimNodeSlot*                               PropAnimNodeSlot;                                         // 0x06C4(0x0008) (Transient)
	TArray<int>                                        PendingInteractionState;                                  // 0x06CC(0x0010) (NeedCtorLink)
	unsigned long                                      bActivated : 1;                                           // 0x06DC(0x0004) (Transient)
	unsigned long                                      bCompleteDirectly : 1;                                    // 0x06DC(0x0004) (Transient)
	unsigned long                                      bPossNonPossUpdated : 1;                                  // 0x06DC(0x0004) (Transient)
	unsigned long                                      bVisible : 1;                                             // 0x06DC(0x0004)
	class UPropAsset*                                  PropAsset;                                                // 0x06E0(0x0008) (Transient)
	TArray<int>                                        PendingStateIds;                                          // 0x06E8(0x0010) (Transient, NeedCtorLink)
	float                                              DefaultPropCollisionRadius;                               // 0x06F8(0x0004)
	float                                              DefaultPropCollisionHeight;                               // 0x06FC(0x0004)
	int                                                CurrentStateId;                                           // 0x0700(0x0004)
	class UBLPropStateAgent*                           PropStateAgent;                                           // 0x0704(0x0008)
	int                                                PropCid;                                                  // 0x070C(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLProp");
		return ptr;
	}


	bool IsTargetable();
	bool IsInteractable();
	bool GetVisionSharedFromPropInfoData(bool bInVisionShared);
	void OnChangeVisionShared(bool bInVisionShared);
	void SetPropVisible(bool bInVisible);
	bool GetLevelColor(class ABlessPC* InPC, struct FColor* OutColor);
	bool GetLevelText(class ABlessPC* InPC, struct FString* OutLevelText);
	bool GetTargetNameColor(class ABlessPC* InPC, struct FColor* OutColor);
	void OnDespawn();
	void Tick(float a_DeltaTime);
	void InteractionCanceled();
	void Update_Possibility(bool InPossiblity);
	void Update_InteractionState(TEnumAsByte<ECEPropStateType> InStateType);
	bool IsTriggerIgnored(int InStateId, TEnumAsByte<EBLPropCmdType> InCmdType);
	void InitProp();
	void OnAssetLoaded(class UPropAsset* InAsset);
	float GetPropCollisionHeight();
	float GetPropCollisionRadius();
	void LoadAllAssets();
	void PostBeginPlay();
	class UDecalComponent* SpawnDecal(const struct FSpawnDecalTriggerData& InTrigger);
	class UParticleSystemComponent* SpawnEmitter(class UParticleSystem* InPS, const struct FComponentAdjustOffsetData& InOffsetData);
	void HandleTrigger(int InStateId);
	void DespawnDecallAll();
	void FlushPendingTriggerCommand();
	void ExcuteTriggerCommand(int InStateId);
	void SetSkeletalMeshData(const struct FSkeletalMeshTriggerHandleData& InSKMHandleData);
	void StopSkeletalMeshAnim();
	void SetStaticMeshData(const struct FStaticMeshTriggerHandleData& InSMHandleData);
	void UpdateComponentAdjustOffset(class UPrimitiveComponent* InPC, const struct FComponentAdjustOffsetData& InOffset);
	void FillComponentAdjstOffset(const struct FAdjustOffsetData& InOffset, struct FComponentAdjustOffsetData* OutData);
	void DespawnEffectByTargetEventPoint(bool bForceDespawnAll, int InStateId);
	void SetTriggerHandler(class UPropAsset* InAsset);
	void AddSpawnDecalHandleData(int InStateId, const struct FSpawnDecalTrigger& InDecalSpawnData);
	void AddStopSkeletalMeshAnim(int InStateId);
	void AddChangeSkeletalMeshHandleData(int InStateId, const struct FSkeletalMeshChangeTrigger& InSkeletalMeshData);
	void AddChangeStaticMeshHandleData(int InStateId, const struct FStaticMeshChangeTrigger& InStaticMeshData);
	void AddDespawnEffectHandleData(int InStateId, int TargetStateId);
	void AddPlaySoundHandleData(int InStateId, class UAkEvent* InEvent);
	void AddSpawnEffectHandleData(int InStateId, const struct FParticleSystemSpawnTriger& InPS);
	void SetPropLocation(const struct FVector& InDestLocation, const struct FVector& InExtent);
	void ApplyMICToSekeletalMeshComponent(class USkeletalMeshComponent* InComponent, class UMaterialInstanceConstant* InMIC);
	void ApplyMICToStaticMeshComponent(class UStaticMeshComponent* InComponent, class UMaterialInstanceConstant* InMIC);
	void HideTooltip();
	void ShowTooltip();
	int GetPutDownBurdenCid();
	bool IsPropInfoDataAvailable();
	float GetCollisionRadiusOfPawnInfo();
	float GetCollisionHeightOfPawnInfo();
	void OnMouseOver();
	void AddChangeMICHandleData(int InStateId, class UMaterialInstanceConstant* InMIC, const struct FName& InParamType, const struct FName& InParamName, float fParam, const struct FLinearColor& vecParam);
	int GetPossId(TEnumAsByte<EBLPropPossibilityState> InState);
	bool IsCraftSpot();
};


// Class BLGame.BLStatue
// 0x00EC (0x0760 - 0x0674)
class ABLStatue : public ABLPawnBase
{
public:
	TEnumAsByte<ECERealmType>                          RealmType;                                                // 0x0674(0x0001)
	TEnumAsByte<EEquipmentHelmetType>                  HelmetType;                                               // 0x0675(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x2];                                       // 0x0676(0x0002) MISSED OFFSET
	struct FPCInfoKey                                  PCInfoKey;                                                // 0x0678(0x0004)
	int                                                CostumeShowConfig;                                        // 0x067C(0x0004)
	struct FCustomizeData                              CustomizingData;                                          // 0x0680(0x0010) (NeedCtorLink)
	TArray<struct FROGuildStatueItemData>              EquipmentItemList;                                        // 0x0690(0x0010) (NeedCtorLink)
	float                                              CustomizedBip01Scale;                                     // 0x06A0(0x0004)
	float                                              CustomizedBNHeadScale;                                    // 0x06A4(0x0004)
	class UCharacterizeSkeletalMeshComponent*          CharacterizeMesh;                                         // 0x06A8(0x0008) (ExportObject, Component, EditInline)
	class UCharacterizeSkeletalMeshComponent*          CharacterizeHeadMesh;                                     // 0x06B0(0x0008) (ExportObject, Component, EditInline)
	class UBLCostumeHelper*                            CostumeHelper;                                            // 0x06B8(0x0008) (Transient)
	unsigned long                                      bIsIncludeEar : 1;                                        // 0x06C0(0x0004) (Transient)
	unsigned long                                      bIsUnsheathed : 1;                                        // 0x06C0(0x0004) (Transient)
	TArray<class UBLEquipmentItemEquipInfo*>           EquipInfoList;                                            // 0x06C4(0x0010) (Transient, NeedCtorLink)
	class UBLAnimBlendByCustomAnim*                    CustomAnimNode;                                           // 0x06D4(0x0008) (Transient)
	class UBLSkelControlWeaponSheathe*                 UnsheatheControl_Main;                                    // 0x06DC(0x0008) (Transient)
	class UBLSkelControlWeaponSheathe*                 UnsheatheControl_Off;                                     // 0x06E4(0x0008) (Transient)
	class UBLAggregateEquipment*                       AggregateEquipment;                                       // 0x06EC(0x0008) (ExportObject, Component, EditInline)
	class UMaterialController*                         PawnMaterialController;                                   // 0x06F4(0x0008) (ExportObject, Component, EditInline)
	class UBLCustomizingController*                    Customizing;                                              // 0x06FC(0x0008) (Transient)
	class UBLMeshRenderBufferComponent*                AdditionalRenderComponent;                                // 0x0704(0x0008) (ExportObject, Component, EditInline)
	class UHeadExpressionComponent*                    PawnHeadExpressionComponent;                              // 0x070C(0x0008) (ExportObject, Component, EditInline)
	class UDynamicLightEnvironmentComponent*           LightEnvironment;                                         // 0x0714(0x0008) (ExportObject, Component, EditInline)
	class UBLCharacterLightComponent*                  CharacterLight;                                           // 0x071C(0x0008) (ExportObject, Component, EditInline)
	class UMaterialInstanceConstant*                   StatueBaseMIC;                                            // 0x0724(0x0008)
	class UMaterialInstanceConstant*                   StatueEyeballMIC;                                         // 0x072C(0x0008)
	class UMaterialInstanceConstant*                   StatueEyelashMIC;                                         // 0x0734(0x0008)
	class UMaterialInstanceConstant*                   StatueFaceFurMIC;                                         // 0x073C(0x0008)
	class UMaterialInstanceConstant*                   StatueHairMIC;                                            // 0x0744(0x0008)
	struct FFontConfigSizeAndColor                     ROGuildNameFont;                                          // 0x074C(0x0008) (Config)
	struct FFontConfigSizeAndColor                     ROGuildLeaderNameFont;                                    // 0x0754(0x0008) (Config)
	int                                                ROGuildMarkSizePercent;                                   // 0x075C(0x0004) (Config)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLStatue");
		return ptr;
	}


	bool GetOnHeadSubTitle(class ABlessPC* InPC, struct FString* OutDesc);
	bool GetOnHeadTitle(class ABlessPC* InPC, struct FString* OutDesc);
	bool GetOnHeadNameColor(class ABlessPC* InPC, bool IgnoreDeath, bool bTargetUI, struct FColor* OutColor);
	void SetSheatheControlParameter(class UBLSkelControlWeaponSheathe* Control, class UBLEquipmentItemInHandInfo* InHandInfo, bool bLeftHand, bool bUnsheathe);
	void OnUnsheathe();
	void OnSheathe();
	class UHeadExpressionComponent* GetHeadExpressionComponent();
	void Tick(float a_DeltaTime);
	bool InitNameTag();
	void OnAssetLoaded();
	void Destroyed();
	void PostBeginPlay();
	void ClearAnimNodes();
	void CacheAnimNodes();
	void PlayPose();
	void ApplyStatueMaterial();
	class UDynamicLightEnvironmentComponent* GetLightEnvironmentComp();
	class UCharacterizeSkeletalMeshComponent* GetCharacterizeHeadMeshComp();
	class UCharacterizeSkeletalMeshComponent* GetCharacterizeBodyMeshComp();
	void UpdateMeshCompTranslation();
	void UpdateCollisionSize();
	void BuildAnimSetList();
	void EquipItems(TArray<struct FROGuildStatueItemData>* EquippedItems);
	void UpdateCostumeVisibility(int InCompressedVal);
	void PostInitMaterialController();
	void InitMaterialController();
	void PostUpdateMeshAndAttachments();
	void PreUpdateMeshAndAttachments();
	void UpdateMeshAndAttachments();
	void InitCustomizing(TEnumAsByte<EEquipmentHelmetType> InHelmetType, TArray<class UMaterialInterface*> InMaterials, const struct FCustomizeData& InCustomizeData, struct FPCInfoKey* InPCInfoKey);
	void InitAnimAndPhys(class UAnimTree* InBodyAnimTreeTemplate, class UAnimTree* InHeadAnimTreeTemplate, class UPhysicsAsset* InBodyPhysAsset);
	void InitHeadDeformation(class UBoneDeformationTemplate* InBDT, TArray<struct FBoneDeformRelativeParameter> InBoneDeformSet);
	void InitBodyDeformation(class UBoneDeformationTemplate* InBDT, TArray<struct FBoneDeformRelativeParameter> InBoneDeformSet);
	void InitParts(class UPawnAsset* InPawnAsset, TEnumAsByte<EEquipmentHelmetType> InHelmetType, bool IncludeEar);
	void InitEquipment(class UPawnAsset* InPawnAsset);
	void InitCharacterizeMesh(class UPawnAsset* InPawnAsset);
	void InitPawnShapeComp(class UPawnAsset* InPawnAsset, bool InHelmetType, bool InIsIncludeEar, class UBoneDeformationTemplate* InBodyBDT, TArray<struct FBoneDeformRelativeParameter> InBodyBoneDeformSet, class UBoneDeformationTemplate* InHeadBDT, TArray<struct FBoneDeformRelativeParameter> InHeadBoneDeformSet);
	void InitPawn();
	void SetEquipInfo(TArray<class UBLEquipmentItemEquipInfo*> InEquipInfoList);
	void SetCustomizingData(const struct FCustomizeData& InCustomizingData);
	void SetStatueMaterial(class UMaterialInstanceConstant* InBaseMIC, class UMaterialInstanceConstant* InEyeballMIC, class UMaterialInstanceConstant* InEyelashMIC, class UMaterialInstanceConstant* InFaceFurMIC, class UMaterialInstanceConstant* InHairMIC);
	void SetPawnAsset(class UPawnAsset* InPawnAsset);
	void LoadAllAssets();
	void SetData(struct FPCInfoKey* InPCInfoKey, struct FROGuildStatueData* InData);
	float GetCollisionRadiusOfPawnInfo();
	float GetCollisionHeightOfPawnInfo();
};


// Class BLGame.BLTrap
// 0x0064 (0x06D8 - 0x0674)
class ABLTrap : public ABLPawnBase
{
public:
	TArray<struct FBLTrapTriggerHandIeInfo>            TriggerHandler;                                           // 0x0674(0x0010) (Component, NeedCtorLink)
	TArray<struct FBLTrapTriggerIgnoreHandIeInfo>      IgnoredTriggerHandler;                                    // 0x0684(0x0010) (NeedCtorLink)
	class UTrapRepInfo*                                RepInfo;                                                  // 0x0694(0x0008) (ExportObject, Component, EditInline)
	class UStaticMeshComponent*                        TrapStaticMeshComponent;                                  // 0x069C(0x0008) (ExportObject, Component, EditInline)
	class USkeletalMeshComponent*                      TrapSkeletalMeshComponent;                                // 0x06A4(0x0008) (ExportObject, Component, EditInline)
	struct FPointer                                    TrapInfoDataPtr;                                          // 0x06AC(0x0008) (Native, Transient)
	class UTrapAsset*                                  TrapAsset;                                                // 0x06B4(0x0008) (Transient)
	TArray<int>                                        PendingPhases;                                            // 0x06BC(0x0010) (Transient, NeedCtorLink)
	float                                              DefaultTrapCollisionRadius;                               // 0x06CC(0x0004)
	float                                              DefaultTrapCollisionHeight;                               // 0x06D0(0x0004)
	int                                                SummonerPawnSid;                                          // 0x06D4(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLTrap");
		return ptr;
	}


	void OnUpdateHP();
	void SetTrapVisible(bool bVisible);
	void UpdateVisible(class ABLPlayer* InPCPlayer);
	void OnDespawn();
	void Tick(float a_DeltaTime);
	void Update_Phase(TEnumAsByte<ECETrapPhaseType> InPhaseType);
	bool IsTriggerIgnored(int InPhase, TEnumAsByte<EBLTrapCmdType> InCmdType);
	void OnAssetLoaded(class UTrapAsset* InAsset);
	float GetTrapCollisionHeight();
	float GetTrapCollisionRadius();
	void SetData(int InTrapCid, struct FTrapData* InTrapData);
	void PostBeginPlay();
	class UDecalComponent* SpawnDecal(const struct FTrapDecalTriggerData& InTrigger);
	class UParticleSystemComponent* SpawnEmitter(class UParticleSystem* InPS, const struct FTrapAdjustOffsetData& InOffsetData);
	void HandleTrigger(int InPhase);
	void DespawnDecalAll();
	void FlushPendingTriggerCommand();
	void ExcuteTriggerCommand(int InPhase);
	void ChangeSkeletalMesh(const struct FTrapSkeletalMeshTriggerData& InSKMTriggerData);
	void StopSkeletalMeshAnim();
	void ChangeStaticMesh(const struct FTrapStaticMeshTriggerData& InSMTriggerData);
	void UpdateComponentAdjustOffset(class UPrimitiveComponent* InPC, const struct FTrapAdjustOffsetData& InOffset);
	void FillAdjustOffsetData(const struct FTrapAdjustOffset& InOffset, struct FTrapAdjustOffsetData* OutData);
	void DespawnParticle(int InDespawnParticleTargetPhase);
	void SetTriggerHandler(class UTrapAsset* InAsset);
	void RegisterSpawnDecal(int InPhase, const struct FTrapSpawnDecalTrigger& InDecalSpawnData);
	void RegisterStopSkeletalMeshAnim();
	void RegisterChangeSkeletalMesh(int InPhase, const struct FTrapSkeletalMeshChangeTrigger& InSkeletalMeshData);
	void RegisterChangeStaticMesh(int InPhase, const struct FTrapStaticMeshChangeTrigger& InStaticMeshData);
	void RegisterDespawnEffect(int InPhase, int InDespawnTargetPhase);
	void RegisterPlaySound(int InPhase, class UAkEvent* InEvent);
	void RegisterSpawnEffect(int InPhase, const struct FTrapParticleTrigger& InParticleTrigger);
	void OnParticleSystemFinished(class UParticleSystemComponent* InPSC);
	void SetTrapLocation(const struct FVector& InDestLocation, float InOffsetHeight, const struct FVector& InExtent);
};


// Class BLGame.BLPawnMovementComponent
// 0x0020 (0x00A5 - 0x0085)
class UBLPawnMovementComponent : public UActorComponent
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0085(0x0003) MISSED OFFSET
	float                                              DefaultSpeeed;                                            // 0x0088(0x0004)
	float                                              Speed;                                                    // 0x008C(0x0004) (Transient)
	float                                              Duration;                                                 // 0x0090(0x0004) (Transient)
	struct FVector                                     UnitDirection;                                            // 0x0094(0x000C) (Transient)
	float                                              AccumTime;                                                // 0x00A0(0x0004) (Transient)
	TEnumAsByte<EMovementType>                         MovementType;                                             // 0x00A4(0x0001)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLPawnMovementComponent");
		return ptr;
	}


	void PushInTime(const struct FVector& Direction, float Time);
	void PushToLocation(const struct FVector& DestLocation, float Time);
	void PushBack(float Time);
	void Stop();
	void Init();
};


// Class BLGame.BLPropPossibilityHandler
// 0x0060 (0x00C0 - 0x0060)
class UBLPropPossibilityHandler : public UObject
{
public:
	TEnumAsByte<EClientPropPossibilityType>            CurrentState;                                             // 0x0060(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	unsigned long                                      bVisible : 1;                                             // 0x0064(0x0004) (Transient)
	unsigned long                                      bVisionShared : 1;                                        // 0x0064(0x0004) (Transient)
	class UBLPropStateAgent*                           OwnerAgent;                                               // 0x0068(0x0008) (Transient)
	class UBLPropEffectPlayer*                         EffectPlayer;                                             // 0x0070(0x0008) (Transient)
	struct FPropEffectDataSet_Possibility              PossibleEffectDataSet;                                    // 0x0078(0x0014) (Transient, NeedCtorLink)
	struct FPropEffectDataSet_Possibility              ImpossibleEffectDataSet;                                  // 0x008C(0x0014) (Transient, NeedCtorLink)
	TArray<class UParticleSystemComponent*>            PossibleEffectPSCs;                                       // 0x00A0(0x0010) (ExportObject, Transient, Component, NeedCtorLink, EditInline)
	TArray<class UParticleSystemComponent*>            ImpossibleEffectPSCs;                                     // 0x00B0(0x0010) (ExportObject, Transient, Component, NeedCtorLink, EditInline)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLPropPossibilityHandler");
		return ptr;
	}


	void OnChangeVisionShared(bool bInVisionShared);
	void RefreshVisibility();
	void StopEffect(const struct FPropEffectDataSet_Possibility& InEffectDataSet, TArray<class UParticleSystemComponent*>* OutResultPSCs);
	void PlayEffect(const struct FPropEffectDataSet_Possibility& InEffectDataSet, TArray<class UParticleSystemComponent*>* OutResultPSCs);
	void OnEndState(TEnumAsByte<EClientPropPossibilityType> PrevState);
	void OnBeginState(TEnumAsByte<EClientPropPossibilityType> NewState);
	void ChangeState(TEnumAsByte<EClientPropPossibilityType> NewState, bool bForceRefresh);
	bool EffectPlayed(TEnumAsByte<EClientPropPossibilityType> InState);
	bool NeedToRefresh(TEnumAsByte<EClientPropPossibilityType> OldState, TEnumAsByte<EClientPropPossibilityType> NewState);
	void SetVisible(bool bInVisible);
	void SetPossible(bool bPossible);
	bool IsPossible();
	void Refresh(bool bForce);
	void Cleanup();
	void OnAssetLoaded(TArray<struct FPropEffectDataSet_Possibility> InPropEffectDataSets);
	void Init(class UBLPropStateAgent* InAgent, class UBLPropEffectPlayer* InEffectPlayer);
};


// Class BLGame.BLPropStateAgent
// 0x0028 (0x0088 - 0x0060)
class UBLPropStateAgent : public UObject
{
public:
	class ABLProp*                                     OwnerProp;                                                // 0x0060(0x0008) (Transient)
	class UPropAsset*                                  OwnerPropAsset;                                           // 0x0068(0x0008) (Transient)
	class UBLPropEffectPlayer*                         PropEffectPlayer;                                         // 0x0070(0x0008) (Transient)
	class UBLPropStateHandler*                         PropState;                                                // 0x0078(0x0008) (Transient)
	class UBLPropPossibilityHandler*                   PropPossibility;                                          // 0x0080(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLPropStateAgent");
		return ptr;
	}


	bool IsInteractable();
	void OnChangeVisionShared(bool bInVisionShared);
	void SetVisible(bool bInVisible);
	void RefreshPossibility();
	void RefreshState();
	void ChangePossibility(bool bPossible);
	void ChangeState(TEnumAsByte<ECEPropStateType> NewState);
	void Cleanup();
	void OnAssetLoaded(class UPropAsset* InAsset);
	void Init(class ABLProp* InProp);
};


// Class BLGame.BLTargetSign
// 0x0034 (0x0094 - 0x0060)
class UBLTargetSign : public UObject
{
public:
	TArray<struct FDesignatedSignData>                 PrivateSigns;                                             // 0x0060(0x0010) (Transient, NeedCtorLink)
	TArray<struct FDesignatedSignData>                 UnionSigns;                                               // 0x0070(0x0010) (Transient, NeedCtorLink)
	TArray<struct FSignInfo>                           SignInfoList;                                             // 0x0080(0x0010) (Const, NeedCtorLink)
	unsigned long                                      IsAllPermit : 1;                                          // 0x0090(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLTargetSign");
		return ptr;
	}


	int GetSignIndex(int InPawnSID);
	bool IsSignedPawn(int InPawnSID);
	void Request_SetSignAuthority(bool IsAll);
	void Request_ReleaseAll();
	void Request_Release(int TargetSId);
	void Request_Set(int SignType, int TargetSId);
	void Toggle(int SignType, int TargetSId);
	void Release(int SignType, int TargetSId);
	void SetTargetSign(int SignType, int TargetSId);
	struct FString GetActionNameBySignType(int SignType);
	void Set(int SignType, int TargetSId);
	void Update(const struct FSignDataInfo& InSignData);
	void Initialize();
};


// Class BLGame.BoneDeformedSkeletalMeshComponent
// 0x004C (0x07E8 - 0x079C)
class UBoneDeformedSkeletalMeshComponent : public USkeletalMeshComponent
{
public:
	unsigned long                                      bCacheUpdate : 1;                                         // 0x079C(0x0004) (Transient)
	class UCharacterBoneDeformationModule*             BoneDeformation;                                          // 0x07A0(0x0008) (Transient)
	TArray<struct FIndexVectorParameter>               CharacterizeBoneTranslation;                              // 0x07A8(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<struct FIndexRotationParameter>             CharacterizeBoneRotation;                                 // 0x07B8(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<struct FIndexVectorParameter>               CharacterizeBoneScale;                                    // 0x07C8(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<struct FIndexVectorParameter>               CharacterizeBoneScaledTranslationScale;                   // 0x07D8(0x0010) (Transient, AlwaysInit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BoneDeformedSkeletalMeshComponent");
		return ptr;
	}


	void ResetDeforming();
	bool UpdateAttachments();
	void SetDeformedSkeletalMesh(class USkeletalMesh* Mesh, class UBoneDeformationTemplate* DeformTemplate, TArray<struct FBoneDeformRelativeParameter>* DeformParameters);
	class UCharacterBoneDeformationModule* GetBoneDeformationModule();
	void STATIC_AttachHeadToBody(class USkeletalMeshComponent* HeadComponent, class USkeletalMeshComponent* BodyComponent);
	void EqualizeScalingDeformationToOtherSkeletalMeshComponent(const struct FName& SkelMeshBoneName, class UBoneDeformedSkeletalMeshComponent* OtherSkelMesh, const struct FName& OtherSkelMeshBoneName);
};


// Class BLGame.CharacterizeSkeletalMeshComponent
// 0x007C (0x0864 - 0x07E8)
class UCharacterizeSkeletalMeshComponent : public UBoneDeformedSkeletalMeshComponent
{
public:
	class USkeletalMesh*                               BoneReferenceMesh;                                        // 0x07E8(0x0008) (Edit, Const, EditConst)
	class UCharacterPartsModule*                       PartsModule;                                              // 0x07F0(0x0008) (Edit, EditConst)
	class UCharacterPaintingModule*                    FacePainting;                                             // 0x07F8(0x0008) (Edit, EditConst)
	class UBodyInfo*                                   CharacterBodyInfo;                                        // 0x0800(0x0008) (Edit, Const, EditConst)
	TEnumAsByte<ECEClassType>                          CharacterClassType;                                       // 0x0808(0x0001) (Edit, Const, EditConst)
	unsigned char                                      TestDeformPart;                                           // 0x0809(0x0001) (Edit, Transient)
	unsigned char                                      UnknownData00[0x2];                                       // 0x080A(0x0002) MISSED OFFSET
	class UBodyInfo*                                   CachedEquipBodyInfo;                                      // 0x080C(0x0008) (Transient)
	TArray<struct FBasePartInfo>                       CachedBasePartsList;                                      // 0x0814(0x0010) (Transient, NeedCtorLink)
	TArray<class UBLEquipmentItemEquipInfo*>           CachedEquipItems;                                         // 0x0824(0x0010) (Transient, NeedCtorLink)
	TArray<struct FBoneDeformingInfo>                  CachedBoneDeforms;                                        // 0x0834(0x0010) (Transient, NeedCtorLink)
	class USkeletalMesh*                               CachedCharacterizationOwner;                              // 0x0844(0x0008) (Transient)
	class UHIKCharacterization*                        CachedCharacterization;                                   // 0x084C(0x0008) (Transient)
	float                                              TestDeformScale;                                          // 0x0854(0x0004) (Edit, Transient)
	int                                                TestFacePart;                                             // 0x0858(0x0004) (Edit, Transient)
	int                                                TestHairPart;                                             // 0x085C(0x0004) (Edit, Transient)
	unsigned long                                      bUseHumanIK : 1;                                          // 0x0860(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CharacterizeSkeletalMeshComponent");
		return ptr;
	}


	struct FVector GetCustomizedBoneLocationWithRefPose(const struct FName& BoneName, int Space);
	class UHIKCharacterization* CopyHIKCharacterizationOfBoneReference(class USkeletalMesh* OwnerMesh);
	void UpdateFacePaintingModule();
	void InitFacePaintingModule(class UMeshTexturePaintTemplate* Template, int SizeX, int SizeY, TArray<struct FColor>* BulkData);
	void UpdateAnimatedWeaponAndAnimSet(class UBodyInfo* InBodyInfo, TEnumAsByte<ECEClassType> InClassType, class UBLEquipmentItemInfo* AnimatedWeapon, const struct FName& BoneToAttach, bool Flipping);
	class UCharacterPartsModule* GetPartsModule();
	void Undress();
	void MergeAllDeformedPartsTest(bool bNeedMeshRebuild, bool bNeedBoneDeform, TArray<class UBLPickingAsset*> ToMergePickingAssetArray, bool bHead, TArray<class UBLEquipmentItemEquipInfo*>* ItemInfos, TArray<struct FAccessoryInfo>* Accessories);
	void MergeAllDeformedParts(bool bNeedMeshRebuild, bool bNeedBoneDeform, TArray<class UBLPickingAsset*> ToMergePickingAssetArray, bool bHead, TArray<class UBLEquipmentItemInfo*>* ItemInfos, TArray<struct FAccessoryInfo>* Accessories);
	void Equip(bool bNeedMeshRebuild, bool bNeedBoneDeform, class UBLAggregateEquipment* AggEquip, TArray<class UBLPickingAsset*> ToMergePickingAssetArray);
	void InitDefaultCharacterBody(class UPawnAsset* InInfo);
	void InitDefaultCharacterHead(class UPawnAsset* InInfo, bool IncludeEar);
	void InitCharacterBody(class UPawnAsset* InPawnInfo, class UBoneDeformationTemplate* InBDT, class UBLAggregateEquipment* AggregateEquipment);
	void InitCharacterHead(class UPawnAsset* InPawnInfo, class UBoneDeformationTemplate* InBDT, bool IncludeEar);
	void Init(class USkeletalMesh* InReferenceMesh, class UBodyInfo* InBodyInfo, TEnumAsByte<ECEClassType> InClassType);
	void Invalidate();
};


// Class BLGame.CharacterBoneDeformationModule
// 0x0018 (0x0078 - 0x0060)
class UCharacterBoneDeformationModule : public UObject
{
public:
	class UBoneDeformationTemplate*                    DeformTemplate;                                           // 0x0060(0x0008) (Transient)
	TArray<struct FBoneDeformAbsoluteParameter>        DeformParameters;                                         // 0x0068(0x0010) (Edit, EditConst, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CharacterBoneDeformationModule");
		return ptr;
	}


	int COUNT();
	void ResetDeformInfo();
	void GetCustomizedInfo(struct FNewCustomizeData* OutCustomizeData);
	void UpdateBoneTemplate(class UBoneDeformationTemplate* BDT);
	void UpdateCharacterInfoByBoneDeformSet(class UBoneDeformationTemplate* BDT, TArray<struct FBoneDeformRelativeParameter>* BoneDeformSet);
	void UpdateCharacterInfo(class UBoneDeformationTemplate* BDT);
	float GetDeformationScale(TEnumAsByte<EBoneDeformPart> TargetPart);
	float GetDeformationValue(TEnumAsByte<EBoneDeformPart> TargetPart);
	bool SetDeformationByScale(TEnumAsByte<EBoneDeformPart> TargetPart, float Scale);
	bool SetDeformation(TEnumAsByte<EBoneDeformPart> TargetPart, float Value);
};


// Class BLGame.CharacterPaintingModule
// 0x0024 (0x0084 - 0x0060)
class UCharacterPaintingModule : public UObject
{
public:
	class UTexture2D*                                  PaintedTexture;                                           // 0x0060(0x0008) (Const)
	unsigned char                                      UnknownData00[0x8];                                       // 0x0068(0x0008) MISSED OFFSET
	struct FVector4                                    ClippingUVWH;                                             // 0x0070(0x0010) (Const)
	unsigned long                                      bEnabled : 1;                                             // 0x0080(0x0004) (Const)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CharacterPaintingModule");
		return ptr;
	}


	struct FLinearColor GetShaderClippingUV();
	class UTexture2D* GetPaintedTexture();
	void SetTemplate(class UMeshTexturePaintTemplate* InTemplate);
	void InitResource(int SizeX, int SizeY, TArray<struct FColor>* BulkData);
};


// Class BLGame.CharacterPartsModule
// 0x0028 (0x0088 - 0x0060)
class UCharacterPartsModule : public UObject
{
public:
	TArray<struct FBasePartInfo>                       CustomizedPartList;                                       // 0x0060(0x0010) (Edit, Const, EditConst, NeedCtorLink)
	TArray<struct FBasePartInfo>                       BasePartList;                                             // 0x0070(0x0010) (Edit, Const, EditConst, NeedCtorLink)
	class UBodyInfo*                                   BodyInfo;                                                 // 0x0080(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CharacterPartsModule");
		return ptr;
	}


	void Trim();
	int COUNT();
	class UMaterialInterface* GetFaceMaterial();
	void SetHairPart(int HairId);
	void SetFacePart(int FaceId);
	void AddPart(TEnumAsByte<EEquipmentDisplaySlotType> PartID, class USkeletalMesh* SkeletalMesh);
	void SetPart(TEnumAsByte<EEquipmentDisplaySlotType> PartID, class USkeletalMesh* SkeletalMesh);
	void UpdateDefaultCharacterBodyInfo(class UPawnAsset* InPawnInfo, TEnumAsByte<EEquipmentHelmetType> InHelmetType);
	void UpdateDefaultCharacterHeadInfo(class UPawnAsset* InPawnInfo, bool IncludeEar);
	void UpdateHeadBaseParts(class UPawnAsset* InPawnInfo, bool IncludeEar);
	void UpdateBodyBaseParts(class UPawnAsset* InPawnInfo, TEnumAsByte<EEquipmentHelmetType> InHelmetType, bool IncludeEar);
	void InitHeadPartsModule(class UPawnAsset* InPawnInfo, bool IncludeEar);
	void InitBodyPartsModule(class UPawnAsset* InPawnInfo, TEnumAsByte<EEquipmentHelmetType> InHelmetType);
	void InitPartsModule(class UBodyInfo* InBodyInfo, TArray<struct FBasePartInfo> InPartList);
};


// Class BLGame.DebugLocationComponent
// 0x002C (0x009C - 0x0070)
class UDebugLocationComponent : public UComponent
{
public:
	unsigned long                                      bShowBox : 1;                                             // 0x0070(0x0004) (Transient)
	struct FColor                                      ReplicateBoxColor;                                        // 0x0074(0x0004) (Transient)
	struct FColor                                      MoveToLocBoxColor;                                        // 0x0078(0x0004) (Transient)
	struct FColor                                      MoveToTargetBoxColor;                                     // 0x007C(0x0004) (Transient)
	struct FColor                                      StopMoveBoxColor;                                         // 0x0080(0x0004) (Transient)
	struct FColor                                      InsightLocBoxColor;                                       // 0x0084(0x0004) (Transient)
	struct FColor                                      OutofSightLocBoxColor;                                    // 0x0088(0x0004) (Transient)
	struct FColor                                      SkillActionBoxColor;                                      // 0x008C(0x0004) (Transient)
	struct FVector                                     LocBoxExtent;                                             // 0x0090(0x000C) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.DebugLocationComponent");
		return ptr;
	}


	void STATIC_SetGlobalLife(float InLifeSeconds);
	void STATIC_SetGlobalShowBox(bool bShow);
	void DrawGeometryBox(const struct FVector& Origin, const struct FVector& Extends, const struct FVector& Direction, const struct FColor& Col, bool bDrawDirectionLine);
	bool IsEnabled();
	bool IsShowBox();
	void ToggleShowBox();
	void SetShowBox(bool bInShow);
};


// Class BLGame.DecorationEffectController
// 0x0038 (0x00A8 - 0x0070)
class UDecorationEffectController : public UComponent
{
public:
	class UDecorationEffectInfo*                       DefaultInfo;                                              // 0x0070(0x0008) (Transient)
	class UDecorationEffectInfo*                       NowInfo;                                                  // 0x0078(0x0008) (Transient)
	TArray<class UParticleSystemComponent*>            PSCs;                                                     // 0x0080(0x0010) (ExportObject, Transient, Component, NeedCtorLink, EditInline)
	TArray<struct FSoftAttachedDecorationEffectInfo>   SoftAttachedDecoEffectInfos;                              // 0x0090(0x0010) (Transient, Component, NeedCtorLink)
	class ABLPawn*                                     OwnerPawn;                                                // 0x00A0(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.DecorationEffectController");
		return ptr;
	}


	void HideEffect(bool bHide);
	void Tick(float InDeltaTime);
	void OnParticleSystemFinished(class UParticleSystemComponent* InPSC);
	void Cleanup();
	void ForceStop();
	void ActiveDecorationEffect(bool bActive);
	void ActiveDefaultDecorationEffect(bool bActive);
	void SetDecorationEffect(class UDecorationEffectInfo* InEffectInfo, bool bAutoActive);
	void InitDecorationEffect(class ABLPawn* inPawn, class UDecorationEffectInfo* InDefaultInfo);
};


// Class BLGame.LootController
// 0x0074 (0x00E4 - 0x0070)
class ULootController : public UComponent
{
public:
	class ABLPawn*                                     BLPawnOwner;                                              // 0x0070(0x0008) (Transient)
	class ABlessPC*                                    BlessPCOwner;                                             // 0x0078(0x0008) (Transient)
	struct FInteractTargetInfo                         CurrentTargetInfo;                                        // 0x0080(0x0008) (Transient)
	struct FInteractionTimeInfo                        InteractionTime;                                          // 0x0088(0x0008) (Transient)
	float                                              AutoCompletionTime;                                       // 0x0090(0x0004) (Transient)
	float                                              AutoPickUpTime;                                           // 0x0094(0x0004) (Transient)
	TArray<struct FItemData>                           ItemBagItems;                                             // 0x0098(0x0010) (Transient, NeedCtorLink)
	TEnumAsByte<ELOOT_ACTION_STATE>                    LootActionState;                                          // 0x00A8(0x0001) (Transient)
	TEnumAsByte<EINTERACT_TARGET_TYPE>                 InteractTargetType;                                       // 0x00A9(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x2];                                       // 0x00AA(0x0002) MISSED OFFSET
	struct FQWord                                      Gold;                                                     // 0x00AC(0x0008) (Transient)
	unsigned long                                      bEndingCheck : 1;                                         // 0x00B4(0x0004) (Transient)
	unsigned long                                      bMovingCheck : 1;                                         // 0x00B4(0x0004) (Transient)
	unsigned long                                      CachingCanGiveup : 1;                                     // 0x00B4(0x0004)
	unsigned long                                      CachingAddLooting : 1;                                    // 0x00B4(0x0004)
	int                                                CachingOwnerSid;                                          // 0x00B8(0x0004)
	struct FQWord                                      CachingDropGold;                                          // 0x00BC(0x0008)
	TArray<struct FEachDropItemInfo>                   CachingDropItemInfoList;                                  // 0x00C4(0x0010) (NeedCtorLink)
	TArray<struct FEachDropContentTokenInfo>           CachingContentTokenList;                                  // 0x00D4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.LootController");
		return ptr;
	}


	void Tick(float InDeltaTime);
	void STATIC_SetLootAdjustRotation(bool bAdjust);
	bool IsAdjustRotation();
	void AcquireAdditionalLootingItem();
	void PickUpCoin(int CoinType, int OwnerType);
	void PickUpItem(int ItemCid, int OwnerType);
	void PickUpAllOpenedItemBag();
	void ShowLootingUI();
	void UpdateItemBag_Drop(int InOwnerSid, const struct FQWord& DropGold, TArray<struct FEachDropItemInfo> DropItemInfoList, TArray<struct FEachDropContentTokenInfo> ContentTokenList, bool bCanGiveup, bool bAddLooting);
	void SortDropContentTokenList(TArray<struct FEachDropContentTokenInfo>* OutList);
	void SortDropItemList(TArray<struct FEachDropItemInfo>* OutList);
	void GiveupItemBag(int InItemBagID);
	void CloseItemBag(int InItemBagID);
	void OpenItemBag(int InItemBagID);
	bool IsDoingLootActionEnd();
	bool IsDoingLootActionStart();
	void OnLootActionStartFinished();
	void DoLootActionEnd(bool bForceStandUp);
	void DoLootActionStart();
	bool IsPlayingSkill();
	void StopPlayingMotion(bool bForceStandUp);
	bool IsPlayingLootMotion();
	void EndLoot(bool bCancel);
	void StartLoot(const struct FInteractTargetInfo& TargetInfo, float InAutoCompletionTime);
	bool IsJumping();
	bool CheckPCStartCondition(const struct FInteractTargetInfo& TargetInfo);
	bool IsMyPCMoving();
	bool IsMoving();
	bool IsMyPCKeyboardMoving();
	bool IsLooting();
	void Complete();
	void Cancel();
	void StartInteraction(const struct FInteractTargetInfo& TargetInfo, float InAutoCompletionTime);
	void RequestInteraction(TEnumAsByte<EINTERACT_TARGET_TYPE> TargetType, int TargetSId);
	void Init(class ABLPawn* inPawn, class ABlessPC* InPC);
	void TickInternal(float DeltaTime);
};


// Class BLGame.MeshTexturePaintComponent
// 0x00F7 (0x017C - 0x0085)
class UMeshTexturePaintComponent : public UActorComponent
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0085(0x0003) MISSED OFFSET
	class UTextureRenderTarget2D*                      CanvasTexture;                                            // 0x0088(0x0008) (Const)
	class UTextureRenderTarget2D*                      PreDrawTexture;                                           // 0x0090(0x0008) (Const)
	class UTextureRenderTarget2D*                      MaskLayerTexture;                                         // 0x0098(0x0008) (Const)
	class UTextureRenderTarget2D*                      MousePickingTarget;                                       // 0x00A0(0x0008) (Const)
	class UTexture2D*                                  ClearTexture;                                             // 0x00A8(0x0008) (Const)
	class UTexture2D*                                  OriginalTexture;                                          // 0x00B0(0x0008) (Const)
	class USkeletalMeshComponent*                      EditingMeshComponent;                                     // 0x00B8(0x0008) (Const, ExportObject, Component, EditInline)
	class UMaterialInstance*                           EditingMaterialInstance;                                  // 0x00C0(0x0008) (Const)
	int                                                SectionIndex;                                             // 0x00C8(0x0004) (Const)
	float                                              ClippingX;                                                // 0x00CC(0x0004) (Const)
	float                                              ClippingY;                                                // 0x00D0(0x0004) (Const)
	float                                              ClippingWidth;                                            // 0x00D4(0x0004) (Const)
	float                                              ClippingHeight;                                           // 0x00D8(0x0004) (Const)
	unsigned char                                      UnknownData01[0x4];                                       // 0x00DC(0x0004) MISSED OFFSET
	struct FMeshPaintBrush                             PaintingBrush;                                            // 0x00E0(0x0040) (Edit, Const, EditConst)
	struct FPointer                                    PaintingBrushInfo;                                        // 0x0120(0x0008) (Native)
	TEnumAsByte<EnumMeshPaintBrush>                    PaintingBrushId;                                          // 0x0128(0x0001) (Edit, Const)
	unsigned char                                      PickedAreaIndex;                                          // 0x0129(0x0001)
	unsigned char                                      UnknownData02[0x2];                                       // 0x012A(0x0002) MISSED OFFSET
	int                                                PaintingBrushShape;                                       // 0x012C(0x0004) (Edit, Const)
	struct FLinearColor                                PaintingColor;                                            // 0x0130(0x0010) (Edit, Const)
	struct FVector2D                                   PrevPickedUV;                                             // 0x0140(0x0008)
	struct FVector2D                                   PickedUV;                                                 // 0x0148(0x0008)
	struct FIntPoint                                   MousePos;                                                 // 0x0150(0x0008)
	struct FIntPoint                                   MouseTrip;                                                // 0x0158(0x0008)
	unsigned long                                      bMousePressed : 1;                                        // 0x0160(0x0004)
	class ULocalPlayer*                                ControlPlayer;                                            // 0x0164(0x0008)
	struct FPointer                                    PropertyWindow;                                           // 0x016C(0x0008) (Native)
	class UMeshTexturePaintTemplate*                   PaintingTemplate;                                         // 0x0174(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MeshTexturePaintComponent");
		return ptr;
	}


	void PopupPropertyPage();
	class UTexture* GetPaintingTexture();
	bool EndPainting(bool bResolveToOriginalTexture);
	bool BeginPainting(class ULocalPlayer* InControlPlayer, class USkeletalMeshComponent* MeshComp, int InSectionIndex, class UMeshTexturePaintTemplate* Template);
	void PaintMaskLayer(bool bClear);
	void Paint();
	void ResolvePreDraw();
	void PreDraw(bool bClear, bool bClearWholeTexture);
	void Clear(bool bWashoff);
	void UpdateBrushAndMaskOverlay();
	void SelectPaintColor(bool bResetColorMass, struct FLinearColor* InColor);
	void SelectPaintBrush(TEnumAsByte<EnumMeshPaintBrush> InBrush, int ShapeIndex, bool bUpdateImmediate);
};


// Class BLGame.MeshTexturePaintTemplate
// 0x0050 (0x00B0 - 0x0060)
class UMeshTexturePaintTemplate : public UObject
{
public:
	TArray<struct FMeshPaintBrushInfo>                 BrushInfoList;                                            // 0x0060(0x0010) (Edit, NeedCtorLink)
	TArray<struct FMeshPaintBrushMask>                 BrushMaskList;                                            // 0x0070(0x0010) (Edit, NeedCtorLink)
	class UTexture2D*                                  LegendTexture;                                            // 0x0080(0x0008) (Edit)
	struct FVector2D                                   PaintingClipLeftTop;                                      // 0x0088(0x0008) (Edit)
	struct FVector2D                                   PaintingClipRightBottom;                                  // 0x0090(0x0008) (Edit)
	class UTexture2D*                                  ClearTexture;                                             // 0x0098(0x0008) (Edit)
	TArray<struct FMeshPaintBrushInfoAndColor>         BasicPainting;                                            // 0x00A0(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MeshTexturePaintTemplate");
		return ptr;
	}

};


// Class BLGame.PawnComponent
// 0x0000 (0x0070 - 0x0070)
class UPawnComponent : public UComponent
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PawnComponent");
		return ptr;
	}


	void PostLoadAsset();
};


// Class BLGame.AbnormalStatusComponent
// 0x0010 (0x0080 - 0x0070)
class UAbnormalStatusComponent : public UPawnComponent
{
public:
	TArray<class UAbnormalStatusBase*>                 AbnormalStatusList;                                       // 0x0070(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.AbnormalStatusComponent");
		return ptr;
	}


	void TakeStatusDamage(class AController* InstigatedBy, class ABLPawnBase* Assailant, const struct FAbnormalStatusEffectResult& StatusResult, const struct FString& DamageCauseDesc);
	void UpdateAbnormalStatusHitEffect(const struct FAbnormalStatusEffectResult& InEffectResult);
	struct FString GetDescriptionOfAbnormalStatus(int AbnormalStatusCid);
	bool GetAbnormalStatusList(int InCid, int InCasterSid, TArray<class UAbnormalStatusBase*>* OutASList);
	void SetupAbnormalStatusData(TArray<struct FAbnormalStatusData> InDataList, bool bOnGoing);
	void Cleanup();
	void ForceDisappearAbnormalStatusList();
	void DisappearAbnormalStatus(const struct FAbnormalStatusData& InData);
	void OnGoingAbnormalStatus(class UAbnormalStatusAsset* InAsset, struct FAbnormalStatusData* InData);
	void AppearAbnormalStatus(class UAbnormalStatusAsset* InAsset, struct FAbnormalStatusData* InData);
	void UpdatePawnAbnormalStatus(int PawnSid, bool bOnGoing, struct FAbnormalStatusData* AbnormalStatusData);
	void HideEffect(bool bHide);
	void PostLoadAsset();
};


// Class BLGame.ActionApplyResultComponent
// 0x0084 (0x00F4 - 0x0070)
class UActionApplyResultComponent : public UPawnComponent
{
public:
	TArray<struct FActionApplyInfoSet>                 ActionApplyInfoSetStorage;                                // 0x0070(0x0010) (NeedCtorLink)
	TArray<int>                                        CurrentSkillResultKeyList;                                // 0x0080(0x0010) (NeedCtorLink)
	TArray<struct FDamageResultInfo>                   SkillDamageList;                                          // 0x0090(0x0010) (NeedCtorLink)
	TArray<struct FDamageResultInfo>                   NormalAttackDamageList;                                   // 0x00A0(0x0010) (NeedCtorLink)
	TArray<struct FHitEventInfo>                       HitByEventList;                                           // 0x00B0(0x0010) (NeedCtorLink)
	TArray<struct FHitEventInfo>                       HitRCEventList;                                           // 0x00C0(0x0010) (NeedCtorLink)
	TArray<struct FHitServerNotifyEventInfo>           HitServerNotifyEventList;                                 // 0x00D0(0x0010) (NeedCtorLink)
	int                                                HitServerNotifyEventIndex;                                // 0x00E0(0x0004)
	TArray<struct FFiringRateInfo>                     SkillFiringRateList;                                      // 0x00E4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.ActionApplyResultComponent");
		return ptr;
	}


	void DeleteCurrentSkillResultKey(int InKey);
	void AddCurrentSkillResultKey(int InKey);
	int FindActionApplyInfoSetStorageIndex(int InKey);
	void AddNormalAttackDamage(int InTargetID, int InResultKey, TEnumAsByte<ECEAttackChanceType> InAttackChance, float InApplyTime, TArray<struct FSkillDamageInfo>* InDamageList);
	void AddSkillDamage(int InTargetID, int InResultKey, TEnumAsByte<ECEAttackChanceType> InAttackChance, float InApplyTime, TEnumAsByte<ERiotAppliedType> InRiotAppliedType, TArray<struct FSkillDamageInfo>* InDamageList);
	void AddActionApplyInfoSet(struct FActionApplyInfoSet* InNewApplyInfoSet);
	int FindDistanceDivideIndex(int InTargetSid, float InCheckDistance, int InDivideCount);
	int FindAngleDivideIndex(int InTargetSid, float InCheckAngle, int InDivideCount);
	float GetSkillFiringRate(int InSkillCid);
	void UnregisterSkillFiringRate(int InSkillCid);
	void RegisterSkillFiringRate(int InSkillCid, float InFiringTime, float InOriginalFiringTime);
	int GetLastActionApplyInfoIndex(int InResultKey);
	bool IsExistActionApplyResultTarget(int InKey, int InTargetServerID);
	class ABLPawnBase* GetActionApplyResultTarget(int InKey, int InTargetIndex, int InApplyInfoIndex, bool bInMergedResult);
	class ABLPawnBase* GetActionApplyResultPreviousTarget(int InKey, int InApplyInfoIndex);
	bool CollectActionApplyResults(int InKey, int InTargetServerID, int InApplyInfoIndex, TArray<struct FActionApplyResult>* OutResults);
	bool FindActionApplyInfoSet(int InKey, struct FActionApplyInfoSet* OutApplyInfoSet);
	bool IsExistTarget(int InKey, int InTargetSid, int InApplyInfoIndex, bool bInMergedResult);
	bool FindActionApplyResult(int InKey, int InTargetIndex, int InApplyInfoIndex, bool bInMergedResult, struct FActionApplyResult* OutResult);
	bool FindActionApplyResults(int InKey, int InApplyInfoIndex, TArray<struct FActionApplyResult>* OutResults);
	bool SetSendHitByEvent(int InKey, int InApplyInfoIndex, int InActionApplyResultIndex, bool bSendHitByEvent);
	void SetTamingResult(int InTargetSid, bool IsSuccess);
	void UpdateSkillResultTargetInfos(int InKey, int InSkillCid, TArray<struct FSkillResultTargetInfo> InTargetInfos, bool bUpdateResultKeyToSM);
	void UpdateAttackApplyInfos(int InTargetSid, TEnumAsByte<ECEAttackChanceType> InAttackChanceType, int InDamage, float InApplyTimeSec);
	bool IsDoingSkillSpecialMove();
	bool IsDoingAttackSpecialMove();
	void OnSkillEnded();
	void OnSkillCanceled();
	void OnSkillFired();
};


// Class BLGame.AuraComponent
// 0x0010 (0x0080 - 0x0070)
class UAuraComponent : public UPawnComponent
{
public:
	TArray<class UAuraBase*>                           AuraList;                                                 // 0x0070(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.AuraComponent");
		return ptr;
	}


	bool GetAuraList(int InCid, TArray<class UAuraBase*>* OutAuraList);
	void SetupAuraData(TArray<int> InAuraIDs, bool bOnGoing);
	void Cleanup();
	void ForceDisappearAuraList();
	void DisappearAura(int InAuraCid);
	void OnGoingAura(int InAuraCid, class UAuraAsset* InAsset);
	void AppearAura(int InAuraCid, class UAuraAsset* InAsset);
	void UpdatePawnAura(int PawnSid, int InAuraCid, bool bInActive, bool bOnGoing);
	void HideEffect(bool bHide);
	void PostLoadAsset();
};


// Class BLGame.BlobShadowComponent
// 0x0020 (0x0090 - 0x0070)
class UBlobShadowComponent : public UPawnComponent
{
public:
	class ABLPawn*                                     PawnOwner;                                                // 0x0070(0x0008)
	class ABLPlayer*                                   PawnPlayer;                                               // 0x0078(0x0008)
	float                                              DecalDiameter;                                            // 0x0080(0x0004)
	int                                                CenterBoneIndex;                                          // 0x0084(0x0004)
	class ABLDecalActor*                               BlobShadowDecal;                                          // 0x0088(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BlobShadowComponent");
		return ptr;
	}


	void Cleanup();
	void UpdateBlobShadow();
	void SetEnableBlobShadow(bool bEnable);
};


// Class BLGame.EquipItemEffectComponent
// 0x0010 (0x0080 - 0x0070)
class UEquipItemEffectComponent : public UPawnComponent
{
public:
	TArray<class UEquipItemEffectBase*>                EquipItemEffectList;                                      // 0x0070(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.EquipItemEffectComponent");
		return ptr;
	}


	void Cleanup();
	void DisappearAllEquipItemEffect();
	void AppearEquipItemEffect(int InItemCid, class UItemAsset* InItemAsset);
	void UpdateEquipItemEffect(TArray<class UBLItem*> InEquipedItemList);
	void HideEffect(bool bHide);
};


// Class BLGame.HeadExpressionComponent
// 0x0098 (0x0108 - 0x0070)
class UHeadExpressionComponent : public UPawnComponent
{
public:
	int                                                DrawPawnNameOption;                                       // 0x0070(0x0004) (Config)
	unsigned long                                      bShowPawnName : 1;                                        // 0x0074(0x0004) (Transient)
	unsigned long                                      bRenderedPawnName : 1;                                    // 0x0074(0x0004) (Transient)
	unsigned long                                      bHideSpeechBubbleComp : 1;                                // 0x0074(0x0004)
	unsigned long                                      LastTraceCheck : 1;                                       // 0x0074(0x0004)
	class UGFxUI_NameTagObject*                        PawnNameTagMC;                                            // 0x0078(0x0008)
	class UTextureRenderTarget2D*                      PawnNameTextureRenderTarget;                              // 0x0080(0x0008)
	struct FVector                                     PawnNameSpritePosition;                                   // 0x0088(0x000C)
	class USpriteComponentRTT*                         PawnNameSpriteComponent;                                  // 0x0094(0x0008) (ExportObject, Component, EditInline)
	class UStaticMesh*                                 NameMesh;                                                 // 0x009C(0x0008)
	struct FVector                                     TraslationOffset;                                         // 0x00A4(0x000C)
	TArray<class UMaterialInterface*>                  PawnNameMaterials;                                        // 0x00B0(0x0010) (NeedCtorLink)
	class UMaterialInstanceConstant*                   PawnNameMIC;                                              // 0x00C0(0x0008)
	class ANameTagMesh*                                PawnNameTagMesh;                                          // 0x00C8(0x0008)
	class UNameTagUIPlayer*                            NameTagPlayer;                                            // 0x00D0(0x0008)
	class UBLSpeechBubbleComponent*                    SpeechBubbleComp;                                         // 0x00D8(0x0008) (ExportObject, Component, EditInline)
	float                                              LastTraceTime;                                            // 0x00E0(0x0004)
	TEnumAsByte<EHpBarState>                           eHpBarState;                                              // 0x00E4(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x3];                                       // 0x00E5(0x0003) MISSED OFFSET
	float                                              HpUpdateElapsedTime;                                      // 0x00E8(0x0004) (Transient)
	float                                              HpUpdateTime;                                             // 0x00EC(0x0004) (Transient)
	struct FOnHeadTagIconData                          LastApplyOnHeadTagIcon;                                   // 0x00F0(0x0018) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.HeadExpressionComponent");
		return ptr;
	}


	void SetOnHeadTagIcon(const struct FOnHeadTagIconData& InData);
	void UpdateQuestMark(TEnumAsByte<EQuestMarker> InQuestMarker);
	void SetSpeechBubble(const struct FString& Text, const struct FColor& TextColor, int ShowTime, bool IsEnemy);
	void HidePawnName(bool bForce);
	void UpdateScale(float Distance);
	void UpdatePawnNameSpriteComponent();
	void InitPawnNameMIC();
	void InitPawnNameTextureRenderTarget();
	void Finalize();
	bool Initialize(class USpriteComponentRTT* InSpriteComponent);
	void Tick(float InDeltaTime);
	void SetShowPawnName(bool bShow);
	void ProcHpVisible(float DeltaTime);
	void ShowHpBarByOnUpdatedHp();
	bool IsPendingUpdateHpEvent();
	bool IsShowHpBar();
	void DisableProcHp();
	void EnableProcHp(bool IsTimePending);
	void ForcedEnableHpBar();
};


// Class BLGame.PawnDLEManager
// 0x002C (0x008C - 0x0060)
class UPawnDLEManager : public UObject
{
public:
	float                                              DefaultRemoveTime;                                        // 0x0060(0x0004) (Const)
	float                                              ActorDistInstantUpdateRefreshInterval;                    // 0x0064(0x0004) (Const)
	float                                              ActorDistInstantUpdateMaxDist;                            // 0x0068(0x0004)
	int                                                ActorDistInstantUpdateMaxCount;                           // 0x006C(0x0004)
	float                                              ActorDistInstantUpdateRefreshTimer;                       // 0x0070(0x0004)
	int                                                SkillRadiusUpdateMaxCount;                                // 0x0074(0x0004) (Config)
	int                                                DLEInstantUpdatePawnCount;                                // 0x0078(0x0004)
	TArray<struct FDLEInstantUpdateInfo>               InstantUpdateList;                                        // 0x007C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PawnDLEManager");
		return ptr;
	}


	void DisplayDebug(class AHUD* HUD, float* out_YL, float* out_YPos);
	int GetInstantUpdatePawnCount(TEnumAsByte<EDLEInstantUpdateType> InCheckType);
	bool SetEnableInstantUpdate_Pawn(class ABLPawnBase* InPawnBase, bool bInEnable);
	bool AddInstantUpdatePawn(class ABLPawnBase* InPawnBase, TEnumAsByte<EDLEInstantUpdateType> InupdateType, float InRemoveTime);
	void UpdateActorDistInstantUpdate();
	void NotifyRemovedPawn(class ABLPawnBase* InPawnBase);
	void SetInstantUpdate_SkillRadius(const struct FVector& InCenterLocation, float Inradius);
	void SetInstantUpdate_MyPlayer(class ABLPawnBase* InPawnBase);
	void Tick(float InDeltaSeconds);
	void Init();
};


// Class BLGame.PawnLoadingFSM
// 0x002C (0x008C - 0x0060)
class UPawnLoadingFSM : public UObject
{
public:
	float                                              MinLoadedGuaranteeTime;                                   // 0x0060(0x0004) (Const, Config)
	float                                              TargetChangeTime;                                         // 0x0064(0x0004) (Const, Config)
	float                                              ProcessTime;                                              // 0x0068(0x0004) (Const, Transient)
	float                                              AccumTime;                                                // 0x006C(0x0004) (Transient)
	unsigned long                                      IsUseTestValue_PC : 1;                                    // 0x0070(0x0004) (Transient)
	unsigned long                                      IsUseTestValue_NPC : 1;                                   // 0x0070(0x0004) (Transient)
	int                                                MaxLoadingCount_PC;                                       // 0x0074(0x0004) (Transient)
	int                                                MaxMeshCount_PC;                                          // 0x0078(0x0004) (Transient)
	int                                                MaxProxyCount_PC;                                         // 0x007C(0x0004) (Transient)
	int                                                MaxLoadingCount_NPC;                                      // 0x0080(0x0004) (Transient)
	int                                                MaxMeshCount_NPC;                                         // 0x0084(0x0004) (Transient)
	int                                                MaxProxyCount_NPC;                                        // 0x0088(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PawnLoadingFSM");
		return ptr;
	}


	void Remove(int PawnSid);
	void Add(int PawnSid);
	void Tick(float DeltaTime);
};


// Class BLGame.PawnRepInfo
// 0x01C4 (0x0234 - 0x0070)
class UPawnRepInfo : public UComponent
{
public:
	class ABLPawnBase*                                 OwnerPawn;                                                // 0x0070(0x0008)
	int                                                Sid;                                                      // 0x0078(0x0004)
	struct FVector                                     Location;                                                 // 0x007C(0x000C)
	struct FRotator                                    Rotation;                                                 // 0x0088(0x000C)
	struct FPawnStateData                              StateData;                                                // 0x0094(0x0014)
	struct FBLPawnParamData                            ParamData;                                                // 0x00A8(0x0040) (NeedCtorLink)
	struct FPawnMovePhysicsData                        MovePhysicsData;                                          // 0x00E8(0x0024)
	TArray<struct FAbnormalStatusData>                 AbnormalStatusDataList;                                   // 0x010C(0x0010) (NeedCtorLink)
	TArray<int>                                        AbnormalStatusGroupList;                                  // 0x011C(0x0010) (NeedCtorLink)
	struct FMap_Mirror                                 AbnormalStatusImmuneTypeMap;                              // 0x012C(0x0048) (Native)
	TArray<int>                                        AuraList;                                                 // 0x0174(0x0010) (NeedCtorLink)
	struct FMap_Mirror                                 CrowdControlStateMap;                                     // 0x0184(0x0048) (Native)
	int                                                CrowdControlStateFlag;                                    // 0x01CC(0x0004)
	int                                                PrevExp;                                                  // 0x01D0(0x0004)
	int                                                SPExp;                                                    // 0x01D4(0x0004)
	int                                                PrevSPExp;                                                // 0x01D8(0x0004)
	int                                                SPLevel;                                                  // 0x01DC(0x0004)
	int                                                SPExpRangeMin;                                            // 0x01E0(0x0004)
	int                                                SPExpRangeMax;                                            // 0x01E4(0x0004)
	int                                                TamingExp;                                                // 0x01E8(0x0004)
	unsigned long                                      bIsEnemy : 1;                                             // 0x01EC(0x0004)
	unsigned long                                      bIsDetected : 1;                                          // 0x01EC(0x0004)
	TEnumAsByte<ECEConditionPhaseType>                 PrevConditionalPhase;                                     // 0x01F0(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x01F1(0x0003) MISSED OFFSET
	TArray<struct FScriptDelegate>                     PendingUpdateDelegateList;                                // 0x01F4(0x0010) (NeedCtorLink)
	TArray<struct FUpdateParamInfo>                    UpdateParamInfoList;                                      // 0x0204(0x0010) (NeedCtorLink)
	class UProperty*                                   ParamProp;                                                // 0x0214(0x0008) (Const)
	class UProperty*                                   MovePhysicsProp;                                          // 0x021C(0x0008) (Const)
	struct FScriptDelegate                             __OnUpdateData__Delegate;                                 // 0x0224(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData01[0x4];                                       // 0x0224(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PawnRepInfo");
		return ptr;
	}


	void UpdateAllParam();
	void UpdateAdjustLevel(int InLevel);
	bool IsUseAdjustLevel();
	int GetLevel();
	int GetSPExpRangeMax();
	int GetSPExpRangeMin();
	int GetSPExp();
	int GetSPLevel();
	void UpdateStatePose(TEnumAsByte<ECEStatePoseType> InPose);
	void UpdateStateSituation(TEnumAsByte<ECEStateSituationType> InSituationType);
	bool UpdateParams(bool IsForced, TArray<struct FParamData>* InParamDatas);
	bool UpdateParam(bool IsForced, struct FParamData* InParamData);
	void SetSPLevel(int InSPLevel);
	void UpdateParamStatus(TEnumAsByte<EParamStatusUpdateType> InType, int InValue);
	void OnUpdateTamingExp();
	void OnSingleUpdateParam(struct FParamData* InParamData);
	void OnUpdateConditionPhase();
	void UpdatePawnVisibility();
	void OnPoseActionAck();
	void OnUpdateStateSituation();
	void OnUpdateSPLevel();
	void OnUpdateLevel();
	void OnUpdateSPExp();
	void OnUpdateExp();
	void OnUpdateMovePhysicsData();
	void OnUpdateEnergy();
	void OnUpdateMP();
	void OnUpdateHP();
	bool SetSingleParamData(class UProperty* MemberProperty, class UProperty* InnerProperty, float InNewValue, bool IsForced, float* OutOldValue);
	void Tick(float DeltaTime);
	bool FindAbnormalSkillParamOverrideMobilityType(int InSkillCid, TEnumAsByte<ECESkillMobilityType>* OutMobilityType);
	void AddPendingUpdateDelegateList(const struct FScriptDelegate& InDelegate);
	void ClearCrowdControlState();
	void UpdateCrowdControlState(TEnumAsByte<ECECrowdControlComponentType> InType, bool bInApplied, float InParam);
	void RemoveAbnormalStatusImmuneType(int InAbnormalStatusID);
	void AddAbnormalStatusImmuneType(int InAbnormalStatusID);
	void SetAuraList(TArray<int>* InList);
	void UpdateAura(int AuraCid, bool bActive);
	void SetAbnormalStatusDataList(TArray<struct FAbnormalStatusData>* InList);
	void ClearAbnormalStatusData();
	void UpdateAbnormalStatusDataDuration(struct FAbnormalStatusDurationData* DurationData);
	void UpdateAbnormalStatusData(struct FAbnormalStatusData* InData);
	void SetConditionPhase(TEnumAsByte<ECEConditionPhaseType> InType);
	void SetIsDetected(bool InIsDetected);
	void SetEnemy(bool InIsEnemy);
	void SetMovePhysicsData(struct FPawnMovePhysicsData* InData);
	void SetStateData(struct FPawnStateData* InData);
	void SetParamData(struct FPawnParamData* InData);
	void SetRotation(struct FRotator* InData);
	void SetLocation(struct FVector* InData);
	void OnUpdateData();
	void Clear();
	void SetOwnerPawn(class ABLPawnBase* inPawn);
};


// Class BLGame.NPCRepInfo
// 0x0030 (0x0264 - 0x0234)
class UNPCRepInfo : public UPawnRepInfo
{
public:
	class ABLNpc*                                      NPCOwner;                                                 // 0x0234(0x0008)
	int                                                Cid;                                                      // 0x023C(0x0004)
	unsigned long                                      bNPCVisible : 1;                                          // 0x0240(0x0004)
	unsigned long                                      bNPCVisibleAudibleRange : 1;                              // 0x0240(0x0004)
	unsigned long                                      bIsTalkable : 1;                                          // 0x0240(0x0004)
	float                                              NPCAudibleRange;                                          // 0x0244(0x0004)
	TEnumAsByte<ECEItemGradeType>                      DropItemGrade;                                            // 0x0248(0x0001)
	TEnumAsByte<ECENPCStateType>                       NPCState;                                                 // 0x0249(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x024A(0x0002) MISSED OFFSET
	TArray<struct FNPCQuestInfo>                       QuestInfoList;                                            // 0x024C(0x0010) (NeedCtorLink)
	int                                                OccupierID;                                               // 0x025C(0x0004)
	int                                                PolymorphCid;                                             // 0x0260(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.NPCRepInfo");
		return ptr;
	}


	int GetLevel();
	void OnUpdatePolymorphCid();
	void OnUpdateQuestInfoList();
	void OnUpdateDropItemGrade();
	void OnUpdateNPCVisibleAudibleRange();
	void OnUpdateNPCAudibleRange();
	void OnUpdateNPCVisible();
	void SetPolymorphCid(int InpolymorphCId);
	void SetOccupierID(int InOccupierID);
	void SetNPCState(TEnumAsByte<ECENPCStateType> InNPCState);
	void SetQuestInfoList(TArray<struct FNPCQuestInfo>* InQuestInfoList);
	void SetIsTalkable(bool bInIsTalkable);
	void SetDropItemGrade(TEnumAsByte<ECEItemGradeType> InItemGrade);
	void SetNPCVisibleAudibleRange(bool bInVisibleAudibleRange);
	void SetNPCAudibleRange(float InaudibleRange);
	void SetNPCVisible(bool bInIsVisible);
	void SetData(struct FNPCData* InData);
	void SetOwnerPawn(class ABLPawnBase* inPawn);
};


// Class BLGame.PlayerRepInfo
// 0x0358 (0x058C - 0x0234)
class UPlayerRepInfo : public UPawnRepInfo
{
public:
	TArray<struct FEnumRedirectInfo>                   EnumRedirectInfos;                                        // 0x0234(0x0010) (Const, NeedCtorLink)
	int                                                WorldType;                                                // 0x0244(0x0004)
	int                                                WorldCid;                                                 // 0x0248(0x0004)
	struct FPawnParam1st                               Param1st;                                                 // 0x024C(0x0020)
	struct FPawnParam2nd                               Param2nd;                                                 // 0x026C(0x004C)
	struct FPawnParam3rd                               Param3rd;                                                 // 0x02B8(0x0054)
	struct FPCAbilityData                              AbilityParam;                                             // 0x030C(0x0008)
	TEnumAsByte<EPlayerPartnerType>                    PartnerType;                                              // 0x0314(0x0001)
	TEnumAsByte<ELookChangeType>                       AppearanceChangeType;                                     // 0x0315(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x0316(0x0002) MISSED OFFSET
	TArray<struct FCombatFlairData>                    CombatFlairs;                                             // 0x0318(0x0010) (NeedCtorLink)
	TArray<struct FCombatFlairActivateData>            CombatFlairActivateList;                                  // 0x0328(0x0010) (NeedCtorLink)
	TArray<struct FClassResourceInfo>                  SkillResources;                                           // 0x0338(0x0010) (NeedCtorLink)
	struct FCustomizeData                              CustomizeData;                                            // 0x0348(0x0010) (NeedCtorLink)
	struct FNewCustomizeData                           BodyCustomizeData;                                        // 0x0358(0x0010) (NeedCtorLink)
	struct FNewCustomizeData                           HeadCustomizeData;                                        // 0x0368(0x0010) (NeedCtorLink)
	struct FFaceMorphData                              FaceMorphCustomizeData;                                   // 0x0378(0x0038)
	TArray<struct FEquipedItemData>                    EquipmentItemDataList;                                    // 0x03B0(0x0010) (NeedCtorLink)
	TArray<struct FQuestProgressInfo>                  QuestProgressInfoList;                                    // 0x03C0(0x0010) (NeedCtorLink)
	struct FWaypointProgressInfo                       WaypointProgressInfo;                                     // 0x03D0(0x0014) (NeedCtorLink)
	TArray<int>                                        completeQuestLocationList;                                // 0x03E4(0x0010) (NeedCtorLink)
	struct FMountRepInfo                               MountRepData;                                             // 0x03F4(0x0038)
	unsigned long                                      bIsDriver : 1;                                            // 0x042C(0x0004)
	unsigned long                                      AllowChannelTransferInCombatState : 1;                    // 0x042C(0x0004)
	int                                                DestinationCid;                                           // 0x0430(0x0004)
	TArray<struct FScriptDelegate>                     SingleUpdateHandlers;                                     // 0x0434(0x0010) (NeedCtorLink)
	TArray<struct FScriptDelegate>                     UpdateCompleteHandlers;                                   // 0x0444(0x0010) (NeedCtorLink)
	struct FString                                     DestinationName;                                          // 0x0454(0x0010) (NeedCtorLink)
	TArray<int>                                        CustomizeDataFormat;                                      // 0x0464(0x0010) (Const, NeedCtorLink)
	struct FPlayerRankData                             RankData;                                                 // 0x0474(0x0068) (NeedCtorLink)
	int                                                CostumeShowConfig;                                        // 0x04DC(0x0004)
	struct FPCGuildData                                GuildData;                                                // 0x04E0(0x0038) (NeedCtorLink)
	struct FBLGuildMarkData                            GuildMarkData;                                            // 0x0518(0x0014)
	int                                                PetSId;                                                   // 0x052C(0x0004)
	int                                                AppliedPetLookCID;                                        // 0x0530(0x0004)
	int                                                CarryObjectCID;                                           // 0x0534(0x0004)
	TArray<struct FDuelResultData>                     duelResultDataList;                                       // 0x0538(0x0010) (NeedCtorLink)
	float                                              EquipUpgradeMileage;                                      // 0x0548(0x0004)
	struct FQWord                                      AppearanceExpireTime;                                     // 0x054C(0x0008)
	int                                                StanceGem;                                                // 0x0554(0x0004)
	int                                                NonStanceGem;                                             // 0x0558(0x0004)
	int                                                ParameterGem;                                             // 0x055C(0x0004)
	int                                                UseExchangableCount;                                      // 0x0560(0x0004)
	float                                              StanceChangeCooltime;                                     // 0x0564(0x0004)
	struct FPartyEffectCraftModifier                   CraftExpModifier;                                         // 0x0568(0x0014)
	struct FScriptDelegate                             __OnSingleUpdateParams__Delegate;                         // 0x057C(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData01[0x4];                                       // 0x057C(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PlayerRepInfo");
		return ptr;
	}


	void SetStanceChangeCoolTime_Reduce(float InReduceTime);
	void SetStanceChangeCoolTime(float InStanceChangeCoolTime);
	float GetStanceChangeCoolTime();
	void TickStanceChangeCoolTime(float InDeltaTime);
	float GetCraftExpModifier(unsigned char InCraftType);
	void OnUpateCraftExpParamData();
	void OnUpdateUseExchangableCount();
	void OnUpdateSkillGem();
	void OnUpdateSPLevel();
	void OnUpdateLevel();
	void OnUpdateSPExp();
	void OnUpdateExp();
	int GetLevel();
	int GetUseExchangableCount();
	int GetParameterGem();
	int GetNonStanceGem();
	int GetStanceGem();
	void UpdateUseExchangableCount(int InCount);
	void UpdateSkillGem(int InStanceGem, int InNonStanceGem, int InParameterGem);
	void UpdateEquipUpgradeMileage(float Mileage);
	void UpdateEquipItemDurabilityHUD();
	void OnUpdateConditionPhase();
	void UpdateAllParam();
	void OnUpdateCostumeShowConfig();
	void UpdateNeedUIUpdateParamStatus();
	void OnUpdateEquipmentList();
	void OnUpdatePrepareCastingTotalTime();
	void OnUpdateStateSituation();
	void OnUpdateParam3rd();
	void OnUpdateParam2nd();
	void OnUpdateParam1st();
	void UpdateParamStatus(TEnumAsByte<EParamStatusUpdateType> InType, int InValue);
	bool UpdateParams(bool IsForced, TArray<struct FParamData>* InParamDatas);
	bool UpdateParam(bool IsForced, struct FParamData* InParamData);
	void OnSingleUpdateParam(struct FParamData* InParamData);
	void NotifyUpdateCompleteToHandler();
	void Clear();
	void UpdateCombatFlair(struct FCombatFlairData* InData);
	void UpdateCombatFlairs(TArray<struct FCombatFlairData>* InDataList);
	void AddOnUpdateComplete(const struct FScriptDelegate& InHandler);
	void AddOnSingleUpdateHandler(const struct FScriptDelegate& InHandler);
	bool IsAllowChannelTransferInCombat();
	void SetAppearanceChangeExpireTime(const struct FQWord& inAppearanceChangeTime);
	void SetAppearaceChangeType(TEnumAsByte<ELookChangeType> inAppearanceChangeType);
	struct FPCInfoKey MakePCInfoKey();
	bool IsItemEquipped(int InItemCid);
	void ClearMountData();
	int GetTotalDuelWinCount();
	void GetDuelResultDataList(TArray<struct FDuelResultData>* outDataList);
	TEnumAsByte<ECETargetStateWidgetType> GetTargetStateWidgetType();
	struct FString GetRankName();
	void SetROCOData(bool InIsRO, bool InIsCO);
	void SetLastSeasonWinCount(int InCount);
	void SetGuildMarkData(struct FGuildMarkData* InData);
	void RemovePCGuildData();
	void SetPCGuildData(struct FPCGuildData* InguildData);
	void SetCostumeShowConfig(int InShowFlage);
	void SetDuelData(struct FDuelResultData* InduelResultData);
	void ToggleMountFly(bool InFlyable);
	void SetPrepareMountData(int InPrepareMountCid, float InPrepareCastingTotalTime);
	void SetMountLevel(int InLevel);
	void SetMountFatigue(int InMountFatigue);
	void SetMountMaxFatigue(int InMountMaxFatigue);
	void SetMountData(int InMountCid, int InMountSkillCid_WW, int InMountSkillCid_C, int InMountFatigue, int InMountMaxFatigue, TEnumAsByte<ECECompanionGradeType> InMountGrade, int InMountLevel);
	void SetCarryObjectCID(int InCarryObjectCID);
	void SetPetSID(int InPetSId);
	void SetLimitedRank(int InCid);
	void SetCurrentRXP(int InRXP);
	void SetSettleRXP(int InRXP);
	void SetDestinationCid(int InCid);
	TEnumAsByte<ECEClassType> GetClassType();
	int GetWorldType();
	void SetWorldType(int InWorldType);
	void SetEquipmentItemDataList(TArray<struct FEquipedItemData>* InEquipmentItemDataList);
	void SetCustomizeData(const struct FCustomizeData& Data);
	void SetPartnerType(TEnumAsByte<EPlayerPartnerType>* InPartnerType);
	void SetAbilityParam(struct FPCAbilityData* InAbilityParam);
	void SetParam3rd(struct FPawnParam3rd* InParam3rd);
	void SetParam2nd(struct FPawnParam2nd* InParam2nd);
	void SetParam1st(struct FPawnParam1st* InParam1st);
	void SetData(struct FPCData* InData);
	void OnSingleUpdateParams(struct FParamData* InParamData);
};


// Class BLGame.PropRepInfo
// 0x0010 (0x0244 - 0x0234)
class UPropRepInfo : public UPawnRepInfo
{
public:
	int                                                Cid;                                                      // 0x0234(0x0004)
	struct FAuraData                                   AuraData;                                                 // 0x0238(0x000C)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PropRepInfo");
		return ptr;
	}


	void SetData(struct FPropData* InData);
};


// Class BLGame.TrapRepInfo
// 0x0018 (0x024C - 0x0234)
class UTrapRepInfo : public UPawnRepInfo
{
public:
	int                                                Cid;                                                      // 0x0234(0x0004)
	int                                                SummonerPawnSid;                                          // 0x0238(0x0004)
	struct FAuraData                                   AuraData;                                                 // 0x023C(0x000C)
	int                                                Phase;                                                    // 0x0248(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.TrapRepInfo");
		return ptr;
	}


	void SetData(struct FTrapData* InData);
};


// Class BLGame.SpawnEffectInfo
// 0x003C (0x009C - 0x0060)
class USpawnEffectInfo : public UObject
{
public:
	struct FSpawnEffectData                            Effect;                                                   // 0x0060(0x003C) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.SpawnEffectInfo");
		return ptr;
	}


	void PlaySpawnEffect(class ABLPawn* inPawn);
};


// Class BLGame.BLAreaDecalActor
// 0x0010 (0x0260 - 0x0250)
class ABLAreaDecalActor : public AActor
{
public:
	class ABLDecalActor*                               outerDecal;                                               // 0x0250(0x0008)
	class ABLDecalActor*                               innerDecal;                                               // 0x0258(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAreaDecalActor");
		return ptr;
	}


	void PostBeginPlay();
};


// Class BLGame.BLAssetCache
// 0x003C (0x009C - 0x0060)
class UBLAssetCache : public UObject
{
public:
	int                                                MaxMountLookAssetCacheCount;                              // 0x0060(0x0004)
	int                                                MaxMountNpcAssetCacheCount;                               // 0x0064(0x0004)
	int                                                MaxMountGradeFXAssetCacheCount;                           // 0x0068(0x0004)
	TArray<class UMountLookAsset*>                     MountLookAssetCaches;                                     // 0x006C(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<class UNPCAsset*>                           MountNpcAssetCaches;                                      // 0x007C(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<class UMountGradeFXAsset*>                  MountGradeFXAssetCaches;                                  // 0x008C(0x0010) (AlwaysInit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAssetCache");
		return ptr;
	}

};


// Class BLGame.BLBodyHeadSkeletalMeshActor
// 0x003C (0x030C - 0x02D0)
class ABLBodyHeadSkeletalMeshActor : public ASkeletalMeshActorMAT
{
public:
	class UCharacterizeSkeletalMeshComponent*          HeadSkeletalMeshComponent;                                // 0x02D0(0x0008) (Edit, ExportObject, Component, EditInline)
	class UNPCAsset*                                   SrcAsset;                                                 // 0x02D8(0x0008) (Edit, Const, EditConst)
	TArray<class UAnimNodeSlot*>                       HeadSlotNodes;                                            // 0x02E0(0x0010) (Transient, NeedCtorLink)
	unsigned long                                      HeadAdjusted : 1;                                         // 0x02F0(0x0004) (Transient)
	unsigned long                                      bIsPlayer : 1;                                            // 0x02F0(0x0004) (Transient)
	unsigned long                                      bSheathed : 1;                                            // 0x02F0(0x0004) (Transient)
	class UBLCustomizingController*                    Customizing;                                              // 0x02F4(0x0008)
	class UBLMeshRenderBufferComponent*                AdditionalRenderComponent;                                // 0x02FC(0x0008) (ExportObject, Component, EditInline)
	class UMaterialController*                         MaterialController;                                       // 0x0304(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLBodyHeadSkeletalMeshActor");
		return ptr;
	}


	void OnAdjustSkelControlWeaponSheathe(class UBLSeqAct_AdjustSkelControlWeaponSheathe* Action);
	void BeginAnimControl(class UInterpGroup* InInterpGroup);
	void SetAnimPosition(const struct FName& SlotName, int ChannelIndex, const struct FName& InAnimSeqName, float InPosition, bool bFireNotifies, bool bLooping, bool bEnableRootMotion, TEnumAsByte<EInterpTrackAnimRootMotionControl> RootMotionOption);
	void AddBoneNameToAnimTree(class UBLSeqAct_AdjustSkelControlWeaponSheathe* Action);
	void AdjustSkelControlWeaponSheathe(class UBLSeqAct_AdjustSkelControlWeaponSheathe* Action);
	void RefreshActorFrom(class UPCAsset* InPCAsset);
	void RefreshActor();
	void SetHeadBodySlotNodes();
	void MAT_SetAnimWeights(TArray<struct FAnimSlotInfo> SlotInfos);
	void MAT_FaceSetAnimPosition(const struct FName& SlotName, int ChannelIndex, const struct FName& InAnimSeqName, float InPosition, bool bFireNotifies, bool bLooping, bool bEnableRootMotion, TEnumAsByte<EInterpTrackAnimRootMotionControl> RootMotionOption);
	void UpdateAnimSetList();
};


// Class BLGame.BLDecalActor
// 0x000C (0x026C - 0x0260)
class ABLDecalActor : public ADecalActorMovable
{
public:
	struct FVector2D                                   DefaultSize;                                              // 0x0260(0x0008) (Transient)
	unsigned long                                      bCanChangeMaterialParameter : 1;                          // 0x0268(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLDecalActor");
		return ptr;
	}


	void SetPawnFloorLocation(class ABLPawnBase* TargetPawn, bool bRootMoveTargetDecal, const struct FName& TargetDecalOriginBoneName);
	void GetSizeOfTargetDecal(class ABLPawnBase* a_PawnBase, float* OutWidth, float* OutHeight);
	void SetDecalColor(const struct FLinearColor& InColor);
	void Init(class UMaterialInterface* NewDecalMaterial);
};


// Class BLGame.BLEnvironmentPreloadManager
// 0x0044 (0x00B4 - 0x0070)
class UBLEnvironmentPreloadManager : public UComponent
{
public:
	TArray<struct FNPCCacheData>                       NPCCacheList;                                             // 0x0070(0x0010) (Transient, NeedCtorLink)
	TArray<class UPropAsset*>                          PropCacheList;                                            // 0x0080(0x0010) (Transient, NeedCtorLink)
	int                                                ToLoadPropNum;                                            // 0x0090(0x0004) (Transient)
	TArray<class UTrapAsset*>                          TrapCacheList;                                            // 0x0094(0x0010) (Transient, NeedCtorLink)
	int                                                ToLoadTrapNum;                                            // 0x00A4(0x0004) (Transient)
	float                                              MaxCachingTime;                                           // 0x00A8(0x0004) (Config)
	float                                              RemainCachingTime;                                        // 0x00AC(0x0004) (Transient)
	unsigned long                                      bCompletedLoading : 1;                                    // 0x00B0(0x0004)
	unsigned long                                      bPause : 1;                                               // 0x00B0(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLEnvironmentPreloadManager");
		return ptr;
	}

};


// Class BLGame.BLEvent
// 0x0014 (0x0074 - 0x0060)
class UBLEvent : public UObject
{
public:
	TEnumAsByte<EBLEventType>                          EventType;                                                // 0x0060(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	struct FName                                       EventName;                                                // 0x0064(0x0008)
	class ABLPawnBase*                                 Instigator;                                               // 0x006C(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLEvent");
		return ptr;
	}


	bool CanTrigger();
	void SetInstigator(class ABLPawnBase* InInstigator);
	class ABLPawnBase* GetInstigator();
	struct FName GetName();
	TEnumAsByte<EBLEventType> GetType();
};


// Class BLGame.BLEvent_Hit
// 0x0020 (0x0094 - 0x0074)
class UBLEvent_Hit : public UBLEvent
{
public:
	int                                                TargetSId;                                                // 0x0074(0x0004)
	TEnumAsByte<ECEAttackChanceType>                   AttackChance;                                             // 0x0078(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0079(0x0003) MISSED OFFSET
	TArray<struct FSkillDamageInfo>                    DamageList;                                               // 0x007C(0x0010) (AlwaysInit, NeedCtorLink)
	int                                                ReservedApplyInfoIndex;                                   // 0x008C(0x0004)
	int                                                ReservedApplyInfoSetKey;                                  // 0x0090(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLEvent_Hit");
		return ptr;
	}


	void SetDamage(TEnumAsByte<ECEAttackChanceType> InAttackChance, TArray<struct FSkillDamageInfo>* InDamageList);
};


// Class BLGame.BLEvent_HitBy
// 0x0014 (0x0088 - 0x0074)
class UBLEvent_HitBy : public UBLEvent
{
public:
	TEnumAsByte<ECEAttackChanceType>                   AttackChance;                                             // 0x0074(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0075(0x0003) MISSED OFFSET
	TArray<struct FSkillDamageInfo>                    DamageList;                                               // 0x0078(0x0010) (AlwaysInit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLEvent_HitBy");
		return ptr;
	}


	bool IsDamaged();
	void FromHitEvent(class UBLEvent_Hit** HitEvent);
	void SetDamage(TEnumAsByte<ECEAttackChanceType> InAttackChance, TArray<struct FSkillDamageInfo>* InDamageList);
};


// Class BLGame.BLEvent_HitBy_RiotControl
// 0x0028 (0x009C - 0x0074)
class UBLEvent_HitBy_RiotControl : public UBLEvent
{
public:
	struct FRiotControlData                            RiotControl;                                              // 0x0074(0x0018) (NeedCtorLink)
	struct FRCApplyInfo                                RiotControlInfo;                                          // 0x008C(0x0010)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLEvent_HitBy_RiotControl");
		return ptr;
	}


	void SetRiotControlData(const struct FRiotControlData& InRiotControl, const struct FRCApplyInfo& InRiotControlInfo);
};


// Class BLGame.BLEventHandler
// 0x0018 (0x0078 - 0x0060)
class UBLEventHandler : public UObject
{
public:
	TArray<struct FPointer>                            Handlers;                                                 // 0x0060(0x0010) (Native)
	class UObject*                                     Listener;                                                 // 0x0070(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLEventHandler");
		return ptr;
	}


	void HandleEvent(class UBLEvent* Event);
	void Init(class UObject* InListener, class UBLEventHandler* InNextHandler, bool bInUseDynamicLink);
};


// Class BLGame.BLGameEngine
// 0x01A4 (0x0DBC - 0x0C18)
class UBLGameEngine : public UGameEngine
{
public:
	TEnumAsByte<EBLLevelState>                         levelstate;                                               // 0x0C18(0x0001)
	unsigned char                                      LoadingLevelStep;                                         // 0x0C19(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x2];                                       // 0x0C1A(0x0002) MISSED OFFSET
	unsigned long                                      bNpcSimpleWalk : 1;                                       // 0x0C1C(0x0004) (Config)
	unsigned long                                      bShowServerPrimitives : 1;                                // 0x0C1C(0x0004) (Config)
	unsigned long                                      bTempSaved : 1;                                           // 0x0C1C(0x0004) (Transient)
	unsigned long                                      bUsingFirstMinimapTextureArray : 1;                       // 0x0C1C(0x0004) (Transient)
	unsigned long                                      bChangingMinimapTextures : 1;                             // 0x0C1C(0x0004) (Transient)
	unsigned long                                      bUseStaticComponentsDynamicAttaching : 1;                 // 0x0C1C(0x0004) (Config)
	unsigned long                                      bUseSkillUpperAnim : 1;                                   // 0x0C1C(0x0004) (Transient)
	unsigned long                                      bPacketLoggerInitialized : 1;                             // 0x0C1C(0x0004) (Transient)
	unsigned long                                      bUseBLScreenShot : 1;                                     // 0x0C1C(0x0004) (Config)
	float                                              NpcSimpleWalkInterval;                                    // 0x0C20(0x0004) (Config)
	int                                                MaxNPCPitch;                                              // 0x0C24(0x0004) (Edit, Config)
	int                                                MaxDeltaPitch;                                            // 0x0C28(0x0004) (Edit, Config)
	int                                                NPCInitCountPerTick;                                      // 0x0C2C(0x0004) (Config)
	float                                              LimitRatioMaxVelocity;                                    // 0x0C30(0x0004) (Config)
	TArray<struct FName>                               MinimapTextures1;                                         // 0x0C34(0x0010) (Transient, NeedCtorLink)
	TArray<struct FName>                               MinimapTextures2;                                         // 0x0C44(0x0010) (Transient, NeedCtorLink)
	class USkillRadialBlurManager*                     SkillRBManager;                                           // 0x0C54(0x0008) (ExportObject, Transient, Component, EditInline)
	class UBLCinematicMovieManager*                    CinematicMovieManager;                                    // 0x0C5C(0x0008) (Transient)
	class UPawnDLEManager*                             PawnDLEManager;                                           // 0x0C64(0x0008) (Transient)
	class AActor*                                      AttachedStreamingActor;                                   // 0x0C6C(0x0008) (Transient)
	float                                              StaticComponentsDynamicAttachHandlingTimeLimit;           // 0x0C74(0x0004) (Config)
	int                                                StaticComponentsDynamicAttachHandlingCountLimit;          // 0x0C78(0x0004) (Config)
	int                                                PrevTickDynamicAttachStaticActorIndex;                    // 0x0C7C(0x0004) (Transient)
	int                                                PrevTickDynamicAttachStaticComponentIndex;                // 0x0C80(0x0004) (Transient)
	TArray<class UClass*>                              SupportedTranslator;                                      // 0x0C84(0x0010) (Const, NeedCtorLink)
	class UDesignParameters*                           DesignParam;                                              // 0x0C94(0x0008)
	class UDevelopmentDesign*                          DevDesign;                                                // 0x0C9C(0x0008)
	float                                              TODClockTimeScale;                                        // 0x0CA4(0x0004) (Transient)
	float                                              ExitTimer;                                                // 0x0CA8(0x0004) (Transient)
	class UCustomizeParameters*                        CustomizeParam;                                           // 0x0CAC(0x0008)
	TArray<struct FString>                             SystemSettingItemNames_WorldDetail;                       // 0x0CB4(0x0010) (Config, NeedCtorLink)
	TArray<struct FString>                             SystemSettingItemNames_WorldTerrainDetail;                // 0x0CC4(0x0010) (Config, NeedCtorLink)
	TArray<struct FString>                             SystemSettingItemNames_WorldSkyDetail;                    // 0x0CD4(0x0010) (Config, NeedCtorLink)
	TArray<struct FString>                             SystemSettingItemNames_WorldViewDistance;                 // 0x0CE4(0x0010) (Config, NeedCtorLink)
	TArray<struct FString>                             SystemSettingItemNames_CharacterDetail;                   // 0x0CF4(0x0010) (Config, NeedCtorLink)
	TArray<struct FString>                             SystemSettingItemNames_CharacterViewDistance;             // 0x0D04(0x0010) (Config, NeedCtorLink)
	TArray<struct FString>                             SystemSettingItemNames_EffectDetail;                      // 0x0D14(0x0010) (Config, NeedCtorLink)
	TArray<struct FString>                             SystemSettingItemNames_GameEffectViewDistance;            // 0x0D24(0x0010) (Config, NeedCtorLink)
	TArray<struct FString>                             SystemSettingItemNames_ShadowDetail;                      // 0x0D34(0x0010) (Config, NeedCtorLink)
	TArray<struct FString>                             SystemSettingItemNames_TextureDetail;                     // 0x0D44(0x0010) (Config, NeedCtorLink)
	TArray<struct FString>                             SystemSettingItemNames_MotionBlur;                        // 0x0D54(0x0010) (Config, NeedCtorLink)
	TArray<struct FString>                             SystemSettingItemNames_LightShaft;                        // 0x0D64(0x0010) (Config, NeedCtorLink)
	struct FString                                     SystemSettingItemName_PostProcessAA;                      // 0x0D74(0x0010) (Config, NeedCtorLink)
	struct FString                                     BlessGameVersion;                                         // 0x0D84(0x0010) (NeedCtorLink)
	int                                                IMECompositingStringFlag;                                 // 0x0D94(0x0004) (Native)
	class UBLUIPlayer*                                 BLUIPlayer;                                               // 0x0D98(0x0008) (Transient)
	class UBLAssetCache*                               AssetCache;                                               // 0x0DA0(0x0008) (Transient)
	int                                                LastLoadingLevelPercentage;                               // 0x0DA8(0x0004) (Transient)
	TArray<class UBLBroadwayPlayer*>                   BroadwayPlayerPool;                                       // 0x0DAC(0x0010) (Native, Transient, AlwaysInit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLGameEngine");
		return ptr;
	}


	void DoExitProcess();
	void InitForbidString();
	void CYClientStatusNotify(TEnumAsByte<ECY_NOTI_ClientStatus> ParamType);
	void SetOptionWithServiceCode();
	void ProcessBLCrash();
	void RunBLCrash();
	void ReserveSafeExit(float InReserveSeconds);
	class UBlessLocalPlayer* GetLP();
	class UBLBroadwayPlayer* GetBroadwayPlayerFromPool();
	void SetDeviceRestore();
	void ResetSpecialKey();
	void ConfirmIMEComposition(const struct FString& ConfirmString);
	void CancelIMEComposition_WIC();
	void SetIMEComposition_WIC(const struct FString& CompositionString, int CursorPos, int target_start, int target_end);
	struct FString ScaleformTranslate(const struct FString& KeyWordString);
	struct FString GetStringGameStringContentInfoWithCodeName(const struct FString& CodeName);
	struct FString GetStringGameStringContentInfo(int Cid);
	bool IsIMECompositingStringFlag(int Flag, const struct FString& CompositionString);
	void SetIMECompositingStringFlag(int Flag, const struct FString& CompositionString);
	class UBLUIPlayer* STATIC_GetUIPlayer();
	void ReloadUIPlayer();
	void CloseUIPlayer();
	void InitUIPlayer();
	void InitializePacketLogger();
};


// Class BLGame.BLHourlyAlarm
// 0x000C (0x006C - 0x0060)
class UBLHourlyAlarm : public UObject
{
public:
	float                                              Second;                                                   // 0x0060(0x0004) (Transient)
	int                                                Minute;                                                   // 0x0064(0x0004) (Transient)
	int                                                Hour;                                                     // 0x0068(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLHourlyAlarm");
		return ptr;
	}


	void STATIC_SetTime(int InHour, int InMin, float InSec);
	void Initialize();
	void Tick(float Delta);
};


// Class BLGame.BLInterpTrackCinematicScript
// 0x0014 (0x00D4 - 0x00C0)
class UBLInterpTrackCinematicScript : public UInterpTrack
{
public:
	TArray<struct FCinematicScriptTrackKey>            CinematicScriptTrack;                                     // 0x00C0(0x0010) (Edit, NeedCtorLink)
	int                                                ActiveTrackIndex;                                         // 0x00D0(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLInterpTrackCinematicScript");
		return ptr;
	}

};


// Class BLGame.BLInterpTrackFloatMaterialParam
// 0x0018 (0x00F0 - 0x00D8)
class UBLInterpTrackFloatMaterialParam : public UInterpTrackFloatBase
{
public:
	TArray<struct FMaterialReferenceList>              Materials;                                                // 0x00D8(0x0010) (Edit, EditConst, Component, NeedCtorLink)
	struct FName                                       ParamName;                                                // 0x00E8(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLInterpTrackFloatMaterialParam");
		return ptr;
	}

};


// Class BLGame.BLInterpTrackInstCinematicScript
// 0x0004 (0x0064 - 0x0060)
class UBLInterpTrackInstCinematicScript : public UInterpTrackInst
{
public:
	float                                              LastUpdatePosition;                                       // 0x0060(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLInterpTrackInstCinematicScript");
		return ptr;
	}

};


// Class BLGame.BLInterpTrackInstFloatMaterialParam
// 0x0018 (0x0078 - 0x0060)
class UBLInterpTrackInstFloatMaterialParam : public UInterpTrackInst
{
public:
	TArray<struct FFloatMaterialParamData>             MICInfos;                                                 // 0x0060(0x0010) (NeedCtorLink)
	class UBLInterpTrackFloatMaterialParam*            InstancedTrack;                                           // 0x0070(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLInterpTrackInstFloatMaterialParam");
		return ptr;
	}

};


// Class BLGame.BLInterpTrackInstWorldPostProcessParam
// 0x0008 (0x0068 - 0x0060)
class UBLInterpTrackInstWorldPostProcessParam : public UInterpTrackInst
{
public:
	class UBLInterpTrackWorldPostProcessParam*         InstancedTrack;                                           // 0x0060(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLInterpTrackInstWorldPostProcessParam");
		return ptr;
	}

};


// Class BLGame.BLInterpTrackWorldPostProcessParam
// 0x001C (0x00F4 - 0x00D8)
class UBLInterpTrackWorldPostProcessParam : public UInterpTrackFloatBase
{
public:
	struct FName                                       EffectName;                                               // 0x00D8(0x0008) (Edit)
	struct FName                                       ParamName;                                                // 0x00E0(0x0008) (Edit)
	unsigned long                                      MaintainParamValue : 1;                                   // 0x00E8(0x0004) (Edit)
	class UMaterialInstanceConstant*                   MaintainMtrl;                                             // 0x00EC(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLInterpTrackWorldPostProcessParam");
		return ptr;
	}

};


// Class BLGame.BLMsgKernel
// 0x0010 (0x0070 - 0x0060)
class UBLMsgKernel : public UObject
{
public:
	TArray<struct FProcInterfaceGroup>                 MsgProcGroup;                                             // 0x0060(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLMsgKernel");
		return ptr;
	}


	void SendMessage(int InMsg, class UBLMsgProcArgBase* InArg, int inGroupId);
	void UpdateGlobalState(TEnumAsByte<EBLGlobalState> InState);
	void UnResisterMsgProc(int inGroupId);
	void ResisterMsgProc(class UBLMSGProcInterface* InMsgProc, int inGroupId);
	void GetMsgProcGroup(int inGroupId, struct FProcInterfaceGroup* OutGroup);
};


// Class BLGame.BLMsgProcArgBase
// 0x0000 (0x0060 - 0x0060)
class UBLMsgProcArgBase : public UObject
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLMsgProcArgBase");
		return ptr;
	}

};


// Class BLGame.BLMsgProcArg_IteractionInstigator
// 0x0000 (0x0060 - 0x0060)
class UBLMsgProcArg_IteractionInstigator : public UBLMsgProcArgBase
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLMsgProcArg_IteractionInstigator");
		return ptr;
	}

};


// Class BLGame.BLMsgProcArg_IteractionTarget
// 0x0010 (0x0070 - 0x0060)
class UBLMsgProcArg_IteractionTarget : public UBLMsgProcArgBase
{
public:
	class ABLPawnBase*                                 Target;                                                   // 0x0060(0x0008)
	class UPropAsset*                                  TargetAsset;                                              // 0x0068(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLMsgProcArg_IteractionTarget");
		return ptr;
	}

};


// Class BLGame.BLMSGProcInterface
// 0x0010 (0x0070 - 0x0060)
class UBLMSGProcInterface : public UObject
{
public:
	struct FScriptDelegate                             __UpdateGlobalStateCallBack__Delegate;                    // 0x0060(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x0060(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLMSGProcInterface");
		return ptr;
	}


	void HandleMessage(int InMsg, class UBLMsgProcArgBase* InArg);
	void UpdateGlobalState(int State);
	void UpdateGlobalStateCallBack(TEnumAsByte<EBLGlobalState> InState);
};


// Class BLGame.BLMsgProc_InteractionBase
// 0x0000 (0x0070 - 0x0070)
class UBLMsgProc_InteractionBase : public UBLMSGProcInterface
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLMsgProc_InteractionBase");
		return ptr;
	}

};


// Class BLGame.BLMsgProc_InteractionInstigator
// 0x0008 (0x0078 - 0x0070)
class UBLMsgProc_InteractionInstigator : public UBLMsgProc_InteractionBase
{
public:
	class UParticleSystemComponent*                    PropEffect;                                               // 0x0070(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLMsgProc_InteractionInstigator");
		return ptr;
	}


	void HandleMessage(int InMsg, class UBLMsgProcArgBase* InArg);
};


// Class BLGame.BLMsgProc_InteractionTarget
// 0x0010 (0x0080 - 0x0070)
class UBLMsgProc_InteractionTarget : public UBLMsgProc_InteractionBase
{
public:
	class UParticleSystemComponent*                    PersistentPSC;                                            // 0x0070(0x0008) (ExportObject, Component, EditInline)
	class UParticleSystemComponent*                    ProgressivePSC;                                           // 0x0078(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLMsgProc_InteractionTarget");
		return ptr;
	}


	void HandleMessage(int InMsg, class UBLMsgProcArgBase* InArg);
	void OnParticleSystemFinished_CallBack(class UParticleSystemComponent* InPSC);
};


// Class BLGame.BLPortraitView
// 0x00F0 (0x0150 - 0x0060)
class UBLPortraitView : public UObject
{
public:
	class UTextureRenderTarget2DForPortraitView*       PortraitRenderTargetTexture;                              // 0x0060(0x0008) (Native)
	struct FIndirectArray_Mirror                       PortraitViewSceneRef;                                     // 0x0068(0x0010) (Const, Native)
	class UBoneDeformedSkeletalMeshComponent*          MainMesh;                                                 // 0x0078(0x0008) (ExportObject, Native, Component, EditInline)
	class UBoneDeformedSkeletalMeshComponent*          SubMesh;                                                  // 0x0080(0x0008) (ExportObject, Native, Component, EditInline)
	TArray<class UParticleSystemComponent*>            PSCs;                                                     // 0x0088(0x0010) (ExportObject, Native, Component, EditInline)
	TArray<struct FSoftAttachedDecorationEffectInfo>   SoftAttachedInfos;                                        // 0x0098(0x0010) (Native, Component)
	class UAnimNodeSequence*                           AnimSeq;                                                  // 0x00A8(0x0008) (Native)
	unsigned long                                      bNeedSetPortraitCollectionAsset : 1;                      // 0x00B0(0x0004) (Native)
	unsigned long                                      bInitialized : 1;                                         // 0x00B0(0x0004)
	struct FPointer                                    PortraitViewScene;                                        // 0x00B4(0x0008) (Native)
	struct FExportShowFlags_Mirror                     ShowFlags;                                                // 0x00BC(0x0010) (Const)
	unsigned char                                      UI_Enum;                                                  // 0x00CC(0x0001) (Native)
	TEnumAsByte<ERenderTargetName>                     RenderTargetNameIndex;                                    // 0x00CD(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x00CE(0x0002) MISSED OFFSET
	int                                                PortraitCounter;                                          // 0x00D0(0x0004)
	struct FPortraitCollectionInfo                     CollectionInfo;                                           // 0x00D4(0x006C) (NeedCtorLink)
	class UCharacterizeSkeletalMeshComponent*          PreviewBodyMesh;                                          // 0x0140(0x0008) (ExportObject, Native, Component, EditInline)
	class UCharacterizeSkeletalMeshComponent*          PreviewHeadMesh;                                          // 0x0148(0x0008) (ExportObject, Native, Component, EditInline)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLPortraitView");
		return ptr;
	}

};


// Class BLGame.BLSkeletalMeshActor
// 0x0048 (0x0318 - 0x02D0)
class ABLSkeletalMeshActor : public ASkeletalMeshActorMAT
{
public:
	int                                                CharIndex;                                                // 0x02D0(0x0004)
	TArray<struct FBLAttachInfo>                       AttachObject;                                             // 0x02D4(0x0010) (Edit, NeedCtorLink)
	TArray<class USkeletalMeshComponent*>              AttachedComponents;                                       // 0x02E4(0x0010) (Edit, ExportObject, Component, NeedCtorLink, EditInline)
	unsigned long                                      bAnimateAttachments : 1;                                  // 0x02F4(0x0004) (Edit)
	unsigned long                                      bFireAnimNotifies : 1;                                    // 0x02F4(0x0004) (Transient)
	unsigned long                                      bIsReadyToPhysics : 1;                                    // 0x02F4(0x0004)
	unsigned long                                      bCollideWithCylinder : 1;                                 // 0x02F4(0x0004) (Edit)
	unsigned long                                      bUsedWithAnimTree : 1;                                    // 0x02F4(0x0004) (Edit)
	unsigned long                                      bIsMeshDirty : 1;                                         // 0x02F4(0x0004) (Transient)
	class USkeletalMesh*                               GoreSkeletalMesh;                                         // 0x02F8(0x0008) (Edit)
	class UCylinderComponent*                          CollisionCylinderComponent;                               // 0x0300(0x0008) (ExportObject, Component, EditInline)
	class UBLAggregateEquipment*                       AggregateEquipment;                                       // 0x0308(0x0008) (Edit, ExportObject, Transient, Component, EditInline)
	class UPawnAsset*                                  PawnInfo;                                                 // 0x0310(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLSkeletalMeshActor");
		return ptr;
	}


	void SetAnimPosition(const struct FName& SlotName, int ChannelIndex, const struct FName& InAnimSeqName, float InPosition, bool bFireNotifies, bool bLooping, bool bEnableRootMotion, TEnumAsByte<EInterpTrackAnimRootMotionControl> RootMotionOption);
	void OnToggle(class USeqAct_Toggle* Action);
	void OnMakeRagdoll(class UBLSeqAct_MakeRagdoll* Action);
	void OnBreakBone(class UBLSeqAct_BreakBone* Action);
	void BreakConstraint(const struct FVector& Impulse, const struct FVector& HitLocation, const struct FName& InBoneName, bool bVelChange);
	void ChangeCollisionToPhysics();
	void UpdateMeshAndAttachments(bool bForce);
	void SetPawnInfo(class UPawnAsset* Info);
	float GetBaseTranslationOffset();
	void ReleaseAttachObject();
	void CreateAttachObject();
	void ResetAttachObject();
};


// Class BLGame.BLTODInterpolator
// 0x02D4 (0x0334 - 0x0060)
class UBLTODInterpolator : public UTODInterpolator
{
public:
	TArray<struct FMaterialInstanceWrapped>            TODApplyMaterialList;                                     // 0x0060(0x0010) (Transient, NeedCtorLink)
	struct FPostProcessSettings                        LastInterpolatedSetting;                                  // 0x0070(0x0298) (Transient, NeedCtorLink)
	TEnumAsByte<ETODTimePhase>                         CurrentTimePhase;                                         // 0x0308(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0309(0x0003) MISSED OFFSET
	float                                              CurrentPhaseInterpolationValue;                           // 0x030C(0x0004) (Transient)
	float                                              PreviousPhaseInterpolationValue;                          // 0x0310(0x0004) (Transient)
	struct FName                                       CurrentPhaseParamName;                                    // 0x0314(0x0008) (Transient)
	struct FName                                       PreviousPhaseParamName;                                   // 0x031C(0x0008) (Transient)
	TArray<struct FName>                               OffPhaseParamName;                                        // 0x0324(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLTODInterpolator");
		return ptr;
	}

};


// Class BLGame.BLWorldClock
// 0x0054 (0x00B4 - 0x0060)
class UBLWorldClock : public UObject
{
public:
	float                                              RawSecondsInADay;                                         // 0x0060(0x0004) (Transient)
	unsigned char                                      Hours;                                                    // 0x0064(0x0001) (Transient)
	unsigned char                                      Minutes;                                                  // 0x0065(0x0001) (Transient)
	TEnumAsByte<ETODTimePhase>                         CurrentWorldTimePhase;                                    // 0x0066(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x1];                                       // 0x0067(0x0001) MISSED OFFSET
	float                                              Seconds;                                                  // 0x0068(0x0004) (Transient)
	int                                                LastSoundNotifiedMinutes;                                 // 0x006C(0x0004) (Transient)
	int                                                LastUINotifiedMinutes;                                    // 0x0070(0x0004) (Transient)
	float                                              LastSyncTime;                                             // 0x0074(0x0004) (Transient)
	float                                              CurrentRawSecondsInADay;                                  // 0x0078(0x0004) (Transient)
	float                                              TimeRatioInCurrentPhase;                                  // 0x007C(0x0004) (Transient)
	float                                              PassedSecondsInCurrentPhase;                              // 0x0080(0x0004) (Transient)
	float                                              BLWC_SECONDS_IN_A_DAY;                                    // 0x0084(0x0004) (Transient)
	float                                              BLWC_DAWN_START_SECONDS;                                  // 0x0088(0x0004) (Transient)
	float                                              BLWC_DAY_START_SECONDS;                                   // 0x008C(0x0004) (Transient)
	float                                              BLWC_DUSK_START_SECONDS;                                  // 0x0090(0x0004) (Transient)
	float                                              BLWC_NIGHT_START_SECONDS;                                 // 0x0094(0x0004) (Transient)
	float                                              BLWC_DAWN_TOTAL_SECONDS;                                  // 0x0098(0x0004) (Transient)
	float                                              BLWC_DAY_TOTAL_SECONDS;                                   // 0x009C(0x0004) (Transient)
	float                                              BLWC_DUSK_TOTAL_SECONDS;                                  // 0x00A0(0x0004) (Transient)
	float                                              BLWC_NIGHT_TOTAL_SECONDS;                                 // 0x00A4(0x0004) (Transient)
	unsigned long                                      bFreeze : 1;                                              // 0x00A8(0x0004) (Transient)
	unsigned long                                      bTimeLoop : 1;                                            // 0x00A8(0x0004) (Transient)
	unsigned long                                      bFixedTime : 1;                                           // 0x00A8(0x0004) (Transient)
	float                                              TimeLoopRawSecondsInADay;                                 // 0x00AC(0x0004) (Transient)
	float                                              FixedRawSecondsInADay;                                    // 0x00B0(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLWorldClock");
		return ptr;
	}

};


// Class BLGame.BLWorldManager
// 0x01EC (0x024C - 0x0060)
class UBLWorldManager : public UObject
{
public:
	struct FPointer                                    VfTable_FCallbackEventDevice;                             // 0x0060(0x0008) (Const, Native, NoExport)
	struct FMap_Mirror                                 WorldInfos;                                               // 0x0068(0x0048) (Native, Transient)
	struct FMap_Mirror                                 DivisionNameIndexMap;                                     // 0x00B0(0x0048) (Native, Transient)
	int                                                CurrentWorldCid;                                          // 0x00F8(0x0004) (Native, Transient)
	int                                                CurrentWorldType;                                         // 0x00FC(0x0004) (Native, Transient)
	int                                                CurrentWorldWrapperCid;                                   // 0x0100(0x0004) (Transient)
	unsigned long                                      bIsDungeon : 1;                                           // 0x0104(0x0004) (Transient)
	unsigned long                                      bWarpHiddenWorld : 1;                                     // 0x0104(0x0004) (Transient)
	unsigned long                                      bIsWaypointMoving : 1;                                    // 0x0104(0x0004) (Transient)
	unsigned long                                      bFrozeLevelStreaming : 1;                                 // 0x0104(0x0004) (Transient)
	unsigned long                                      bInitialize : 1;                                          // 0x0104(0x0004) (Transient)
	unsigned long                                      bPlayingLoadingScreen : 1;                                // 0x0104(0x0004) (Transient)
	unsigned long                                      bAckSurroundingEnvironments : 1;                          // 0x0104(0x0004) (Transient)
	unsigned long                                      bBeganLoadPersistent : 1;                                 // 0x0104(0x0004) (Transient)
	unsigned long                                      bDestroyedWorld : 1;                                      // 0x0104(0x0004) (Transient)
	unsigned long                                      bSpawnedPlayActor : 1;                                    // 0x0104(0x0004) (Transient)
	TArray<class ULevelStreaming*>                     LevelsBelongArriveWaypoint;                               // 0x0108(0x0010) (Native, Transient, AlwaysInit)
	struct FSet_Mirror                                 HighPriorityLevels;                                       // 0x0118(0x0048) (Const, Native, Transient)
	class UMaterialInstanceTimeVarying*                TransitionEffectMaterial;                                 // 0x0160(0x0008) (Transient)
	TEnumAsByte<ELoadingType>                          CurrentLoading;                                           // 0x0168(0x0001) (Transient)
	TEnumAsByte<ELoadingState>                         CurrentState;                                             // 0x0169(0x0001) (Transient)
	TEnumAsByte<EnterWorldState>                       CurEnterWorldState;                                       // 0x016A(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x1];                                       // 0x016B(0x0001) MISSED OFFSET
	int                                                LoadingPercentage_P;                                      // 0x016C(0x0004) (Transient)
	int                                                LoadingPercentage_D;                                      // 0x0170(0x0004) (Transient)
	int                                                LoadingPercentage_S;                                      // 0x0174(0x0004) (Transient)
	int                                                LoadingPercentage_E;                                      // 0x0178(0x0004) (Transient)
	int                                                LoadingPercentage_Total;                                  // 0x017C(0x0004) (Transient)
	TArray<class ULevelStreaming*>                     MarkedToLoadLevels;                                       // 0x0180(0x0010) (Transient, NeedCtorLink)
	struct FVector                                     CurrentPCLocation;                                        // 0x0190(0x000C) (Transient)
	struct FURL                                        ToLoadMapURL;                                             // 0x019C(0x0058) (Transient, NeedCtorLink)
	class UBLEnvironmentPreloadManager*                EnviornmentPreloadManager;                                // 0x01F4(0x0008) (ExportObject, Transient, Component, EditInline)
	struct FSet_Mirror                                 ToProjectOtherLevelDecalComps;                            // 0x01FC(0x0048) (Native, Transient)
	int                                                LoadingWorldType;                                         // 0x0244(0x0004) (Transient)
	int                                                LoadingWorldMapCId;                                       // 0x0248(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLWorldManager");
		return ptr;
	}


	void OnEnterWorldComplete();
	bool IsLoadingComplete();
	bool GetDungeonMapCenterLocation(struct FVector* OutCenterLocation);
	float GetDungeonMapMaxSize();
	int GetCurrentWorldWrapperCID();
	void SetCurrentWorldWrapperCID(int WorldCid);
	class UBLWorldManager* STATIC_GetWorldManager();
};


// Class BLGame.CinematicPointLightMovable
// 0x0000 (0x025C - 0x025C)
class ACinematicPointLightMovable : public APointLightMovable
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CinematicPointLightMovable");
		return ptr;
	}

};


// Class BLGame.CinematicSpotLightMovable
// 0x0000 (0x025C - 0x025C)
class ACinematicSpotLightMovable : public ASpotLightMovable
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CinematicSpotLightMovable");
		return ptr;
	}

};


// Class BLGame.CustomizeParameters
// 0x0F10 (0x0F70 - 0x0060)
class UCustomizeParameters : public UObject
{
public:
	struct FName                                       FaceMatKey;                                               // 0x0060(0x0008) (Const)
	struct FName                                       FaceFurMatKey;                                            // 0x0068(0x0008) (Const)
	struct FName                                       BodyMatKey;                                               // 0x0070(0x0008) (Const)
	struct FName                                       EyeBallMatKey;                                            // 0x0078(0x0008) (Const)
	struct FName                                       EyelashMatKey;                                            // 0x0080(0x0008) (Const)
	struct FName                                       BeardMatKey;                                              // 0x0088(0x0008) (Const)
	struct FName                                       HairMatKey;                                               // 0x0090(0x0008) (Const)
	struct FName                                       BufferRenderTargetSwitchName;                             // 0x0098(0x0008) (Const)
	struct FName                                       EyelinerSwitchName;                                       // 0x00A0(0x0008) (Const)
	struct FName                                       EyelinerUnderSwitchName;                                  // 0x00A8(0x0008) (Const)
	struct FName                                       EyelinerDensitySwitchName;                                // 0x00B0(0x0008) (Const)
	struct FName                                       EyelinerStartRangeSwitchName;                             // 0x00B8(0x0008) (Const)
	struct FName                                       EyelinerEndRotationSwitchName;                            // 0x00C0(0x0008) (Const)
	struct FName                                       EyeshadowSwitchName;                                      // 0x00C8(0x0008) (Const)
	struct FName                                       EyeshadowColorDensitySwitchName;                          // 0x00D0(0x0008) (Const)
	struct FName                                       EyeshadowBaseColorSwitchName;                             // 0x00D8(0x0008) (Const)
	struct FName                                       EyeshadowBaseSizeSwitchName;                              // 0x00E0(0x0008) (Const)
	struct FName                                       EyeshadowBaseColorDensitySwitchName;                      // 0x00E8(0x0008) (Const)
	struct FName                                       EyeshadowDoubleEyelidColorSwitchName;                     // 0x00F0(0x0008) (Const)
	struct FName                                       EyeshadowDoubleEyelidSizeSwitchName;                      // 0x00F8(0x0008) (Const)
	struct FName                                       EyeshadowDoubleEyelidColorDensitySwitchName;              // 0x0100(0x0008) (Const)
	struct FName                                       EyeshadowUnderColorSwitchName;                            // 0x0108(0x0008) (Const)
	struct FName                                       EyeshadowUnderSizeSwitchName;                             // 0x0110(0x0008) (Const)
	struct FName                                       EyeshadowUnderColorDensitySwitchName;                     // 0x0118(0x0008) (Const)
	TArray<struct FName>                               TranslucencyMaterialKey;                                  // 0x0120(0x0010) (NeedCtorLink)
	struct FCustomizeModuleDefElem                     CustomizeModuleDefs[0xE3];                                // 0x0130(0x0010)
	TArray<struct FCustomizeSubMenuDefElem>            CustomizeSubMenuDefs;                                     // 0x0F60(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CustomizeParameters");
		return ptr;
	}


	int STATIC_Get_CMT_HasCM_AS_UI(int InCM_AS_UI);
	bool STATIC_Get_CM_AS_UI_List_HasCMT(int InCMT, TArray<TEnumAsByte<ECustomizeActionScriptUIEnum>>* outCM_AS_UI_List);
	bool STATIC_IsWhispyHairUI(int InUIEnum);
	bool STATIC_IsCloseEyeUI(int InUIEnum);
	bool STATIC_IsHasWhispyHairCheckBoxInSubMenu(int InSubMenuEnum);
	bool STATIC_GetSubMenuRandomAndResetList(int InSubMenuEnum, TArray<TEnumAsByte<ECECustomizeType>>* outCMTList);
	int STATIC_GetSubMenuLargeCategory(int InSubMenuEnum);
	int STATIC_GetSubMenuCameraMode(int InSubMenuEnum);
	bool STATIC_FindHairMat(TArray<class UMaterialInterface*> InBaseMIs, TArray<class UMaterialInstance*>* OutMIs);
	bool STATIC_FindBeardMat(TArray<class UMaterialInterface*> InBaseMIs, TArray<class UMaterialInstance*>* OutMIs);
	bool STATIC_FindEyelashMat(TArray<class UMaterialInterface*> InBaseMIs, TArray<class UMaterialInstance*>* OutMIs);
	bool STATIC_FindEyeBallMat(TArray<class UMaterialInterface*> InBaseMIs, TArray<class UMaterialInstance*>* OutMIs);
	bool STATIC_FindBodyMat(TArray<class UMaterialInterface*> InBaseMIs, TArray<class UMaterialInstance*>* OutMIs);
	bool STATIC_FindFaceFurMat(TArray<class UMaterialInterface*> InBaseMIs, TArray<class UMaterialInstance*>* OutMIs);
	bool STATIC_FindFaceMat(TArray<class UMaterialInterface*> InBaseMIs, TArray<class UMaterialInstance*>* OutMIs);
	class UCustomizeParameters* STATIC_CustomizeParameters();
	TEnumAsByte<ECECustomizeType> FindPairCustomizeType(TEnumAsByte<ECECustomizeType> InType);
	TEnumAsByte<EEquipmentDisplaySlotType> FindPartID(TEnumAsByte<ECECustomizeType> InType);
	TEnumAsByte<EBoneDeformPart> FindBoneDeformPart(TEnumAsByte<ECECustomizeType> InType);
	TEnumAsByte<ECustomizeValueType> FindValueType(TEnumAsByte<ECECustomizeType> InType);
	struct FName FindMaterialParameterName(TEnumAsByte<ECECustomizeType> InType);
	bool CheatMakeElement(TEnumAsByte<ECECustomizeType> InType, float Value, class UCustomizeElement** Element);
	bool MakeElement(TEnumAsByte<ECECustomizeType> InType, int Value, class UCustomizeElement** Element);
};


// Class BLGame.CutInCameraActor
// 0x00A4 (0x05AC - 0x0508)
class ACutInCameraActor : public ACameraActor
{
public:
	class UCutInCaptureComponent*                      SceneCapture;                                             // 0x0508(0x0008) (Edit, Const, ExportObject, Component, EditInline)
	struct FTPOV                                       POV;                                                      // 0x0510(0x001C) (Transient)
	struct FTPOV                                       InitialPOV;                                               // 0x052C(0x001C) (Transient)
	unsigned long                                      bCaptureScene : 1;                                        // 0x0548(0x0004) (Transient)
	class UCameraAnimInst*                             AnimInstPool[0x8];                                        // 0x054C(0x0008)
	TArray<class UCameraAnimInst*>                     ActiveAnims;                                              // 0x058C(0x0010) (NeedCtorLink)
	TArray<class UCameraAnimInst*>                     FreeAnims;                                                // 0x059C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CutInCameraActor");
		return ptr;
	}


	void StopCameraAnim(class UCameraAnimInst* AnimInst, bool bImmediate);
	void StopAllCameraAnimsByType(class UCameraAnim* Anim, bool bImmediate);
	void StopAllCameraAnims(bool bImmediate);
	class UCameraAnimInst* PlayCameraAnim(class UCameraAnim* Anim, float Rate, float Scale, float BlendInTime, float BlendOutTime, bool bLoop, bool bRandomStartTime, float Duration, bool bSingleInstance);
	void UpdateAnimCamera(float DeltaTime, struct FTPOV* OutPOV);
	void Tick(float DeltaTime);
	void Stop();
	class UCameraAnimInst* Play(const struct FCameraAnimInfo& AnimInfo, float Rate, float Scale, float BlendInTime, float BlendOutTime, bool bLoop, bool bRandomStartTime, float Duration, bool bSingleInstance);
	void PostBeginPlay();
};


// Class BLGame.DesignParameters
// 0x0288 (0x02E8 - 0x0060)
class UDesignParameters : public UObject
{
public:
	float                                              DialogTextPlayTime;                                       // 0x0060(0x0004) (Edit, Config)
	float                                              DialogActionIgnoreTime;                                   // 0x0064(0x0004) (Edit, Config)
	struct FDialogCancel_MonologueIDs                  DialogCancelMonologueIDs;                                 // 0x0068(0x0020) (Config, NeedCtorLink)
	unsigned long                                      DisableUnEquipWeapon : 1;                                 // 0x0088(0x0004) (Config)
	unsigned long                                      DisableUnEquipDress : 1;                                  // 0x0088(0x0004) (Config)
	unsigned long                                      bDisableOutLine : 1;                                      // 0x0088(0x0004) (Edit, Config)
	unsigned long                                      LoadingPriority_Boss : 1;                                 // 0x0088(0x0004) (Config)
	TArray<TEnumAsByte<ECEEquipSlotType>>              DisableUnEquipSlot;                                       // 0x008C(0x0010) (Config, NeedCtorLink)
	struct FColor                                      TargetNameColorOfMyPlayer;                                // 0x009C(0x0004) (Edit, Config)
	struct FColor                                      TargetNameColorOfHostilePC;                               // 0x00A0(0x0004) (Edit, Config)
	struct FColor                                      TargetNameColorOfFriendlyPC;                              // 0x00A4(0x0004) (Edit, Config)
	struct FColor                                      TargetNameColorOfFriendlyNPC;                             // 0x00A8(0x0004) (Edit, Config)
	struct FColor                                      TargetNameColorOfHostileAggressiveNPC;                    // 0x00AC(0x0004) (Edit, Config)
	struct FColor                                      TargetNameColorOfHostileDefensiveNPC;                     // 0x00B0(0x0004) (Edit, Config)
	struct FColor                                      TargetNameColorOfCombat;                                  // 0x00B4(0x0004) (Edit, Config)
	struct FColor                                      TargetNameColorOfDead;                                    // 0x00B8(0x0004) (Edit, Config)
	struct FColor                                      TargetNameColorOfProp;                                    // 0x00BC(0x0004) (Edit, Config)
	struct FColor                                      TargetNameColorOfOccupiedByOther;                         // 0x00C0(0x0004) (Edit, Config)
	struct FColor                                      OnHeadNameColorOfNPC_Type1;                               // 0x00C4(0x0004) (Edit, Config)
	struct FColor                                      OnHeadNameColorOfNPC_Type2;                               // 0x00C8(0x0004) (Edit, Config)
	struct FColor                                      OnHeadNameColorOfNPC_Type3;                               // 0x00CC(0x0004) (Edit, Config)
	struct FColor                                      OnHeadNameColorOfNPC_Type4;                               // 0x00D0(0x0004) (Edit, Config)
	struct FColor                                      OnHeadNameColorOfNPC_Type5;                               // 0x00D4(0x0004) (Edit, Config)
	struct FColor                                      OnHeadNameColorOfPlayer_Type1;                            // 0x00D8(0x0004) (Edit, Config)
	struct FColor                                      OnHeadNameColorOfPlayer_Type2;                            // 0x00DC(0x0004) (Edit, Config)
	struct FColor                                      OnHeadNameColorOfPlayer_Type3;                            // 0x00E0(0x0004) (Edit, Config)
	struct FColor                                      OnHeadNameColorOfPlayer_Type4;                            // 0x00E4(0x0004) (Edit, Config)
	struct FColor                                      OnHeadNameColorOfPlayer_Type5;                            // 0x00E8(0x0004) (Edit, Config)
	struct FColor                                      OnHeadNameColorOfPlayer_Type6;                            // 0x00EC(0x0004) (Edit, Config)
	struct FColor                                      OnHeadNameColorOfPlayer_Type7;                            // 0x00F0(0x0004) (Edit, Config)
	struct FColor                                      OnHeadNameColorOfPlayer_Type8;                            // 0x00F4(0x0004) (Edit, Config)
	struct FColor                                      OnHeadNameColorOfPlayer_Type9;                            // 0x00F8(0x0004) (Edit, Config)
	struct FColor                                      OnHeadNameColorOfPlayer_Type10;                           // 0x00FC(0x0004) (Edit, Config)
	struct FColor                                      OnHeadNameColorOfCombat;                                  // 0x0100(0x0004) (Edit, Config)
	struct FColor                                      OnHeadNameColorOfCombatToggle;                            // 0x0104(0x0004) (Edit, Config)
	struct FColor                                      HPColorOfRed;                                             // 0x0108(0x0004) (Edit, Config)
	struct FColor                                      HPColorOfOrange;                                          // 0x010C(0x0004) (Edit, Config)
	struct FColor                                      HPColorOfGrey;                                            // 0x0110(0x0004) (Edit, Config)
	struct FColor                                      HPColorOfParty;                                           // 0x0114(0x0004) (Edit, Config)
	struct FColor                                      HPColorOfPCParty;                                         // 0x0118(0x0004) (Edit, Config)
	struct FColor                                      HPColorOfRaid;                                            // 0x011C(0x0004) (Edit, Config)
	struct FColor                                      LevelColorOfOver3rdLevel;                                 // 0x0120(0x0004) (Edit, Config)
	struct FColor                                      LevelColorOfOver2ndLevel;                                 // 0x0124(0x0004) (Edit, Config)
	struct FColor                                      LevelColorOfOver1stLevel;                                 // 0x0128(0x0004) (Edit, Config)
	struct FColor                                      LevelColorOfInsideLevel;                                  // 0x012C(0x0004) (Edit, Config)
	struct FColor                                      LevelColorOfUnder1stLevel;                                // 0x0130(0x0004) (Edit, Config)
	struct FColor                                      LevelColorOfUnder2ndLevel;                                // 0x0134(0x0004) (Edit, Config)
	struct FColor                                      LevelColorOfProp;                                         // 0x0138(0x0004) (Edit, Config)
	struct FColor                                      LevelColorOfMyPlayer;                                     // 0x013C(0x0004) (Edit, Config)
	struct FColor                                      LevelColorOfFriendlyPC;                                   // 0x0140(0x0004) (Edit, Config)
	struct FColor                                      LevelColorOfFriendlyNPC;                                  // 0x0144(0x0004) (Edit, Config)
	struct FColor                                      InventorySlotUnderColor;                                  // 0x0148(0x0004) (Config)
	struct FColor                                      InventorySlotOverColor;                                   // 0x014C(0x0004) (Config)
	int                                                BubbleSpeechVisibleTime;                                  // 0x0150(0x0004) (Edit, Config)
	float                                              MonologueSpeechBubbleDistance;                            // 0x0154(0x0004) (Edit, Config)
	float                                              MonologueChattingDistance;                                // 0x0158(0x0004) (Edit, Config)
	float                                              carry_object_standard_value_for_rescale;                  // 0x015C(0x0004) (Edit, Config)
	float                                              HPBarTweenFullTime;                                       // 0x0160(0x0004) (Config)
	struct FName                                       LowInteractStartAnim;                                     // 0x0164(0x0008) (Config)
	struct FName                                       LowInteractingAnim;                                       // 0x016C(0x0008) (Config)
	struct FName                                       LowInteractEndAnim;                                       // 0x0174(0x0008) (Config)
	struct FName                                       MidInteractStartAnim;                                     // 0x017C(0x0008) (Config)
	struct FName                                       MidInteractingAnim;                                       // 0x0184(0x0008) (Config)
	struct FName                                       MidInteractEndAnim;                                       // 0x018C(0x0008) (Config)
	struct FName                                       HighInteractStartAnim;                                    // 0x0194(0x0008) (Config)
	struct FName                                       HighInteractingAnim;                                      // 0x019C(0x0008) (Config)
	struct FName                                       HighInteractEndAnim;                                      // 0x01A4(0x0008) (Config)
	struct FName                                       LootStartAnim;                                            // 0x01AC(0x0008) (Config)
	struct FName                                       LootingAnim;                                              // 0x01B4(0x0008) (Config)
	struct FName                                       LootEndAnim;                                              // 0x01BC(0x0008) (Config)
	float                                              LowHPAlertRate;                                           // 0x01C4(0x0004) (Edit, Config)
	float                                              LowHPBlinkAlertRate;                                      // 0x01C8(0x0004) (Edit, Config)
	struct FColor                                      ToolTipDescColorOfUnlearnedSkill;                         // 0x01CC(0x0004) (Edit, Config)
	int                                                TargetPrefix;                                             // 0x01D0(0x0004) (Edit, Config)
	int                                                TargetPostfix;                                            // 0x01D4(0x0004) (Edit, Config)
	int                                                TargetNotInteractablePrePostfix;                          // 0x01D8(0x0004) (Edit, Config)
	struct FColor                                      ItemGradeColorPoor;                                       // 0x01DC(0x0004) (Config)
	struct FColor                                      ItemGradeColorCommon;                                     // 0x01E0(0x0004) (Config)
	struct FColor                                      ItemGradeColorUncommon;                                   // 0x01E4(0x0004) (Config)
	struct FColor                                      ItemGradeColorRare;                                       // 0x01E8(0x0004) (Config)
	struct FColor                                      ItemGradeColorEpic;                                       // 0x01EC(0x0004) (Config)
	struct FColor                                      ItemGradeColorLegendary;                                  // 0x01F0(0x0004) (Config)
	struct FColor                                      QuestItemColor;                                           // 0x01F4(0x0004) (Config)
	struct FColor                                      SkillGradeColorPoor;                                      // 0x01F8(0x0004) (Config)
	struct FColor                                      SkillGradeColorCommon;                                    // 0x01FC(0x0004) (Config)
	struct FColor                                      SkillGradeColorUncommon;                                  // 0x0200(0x0004) (Config)
	struct FColor                                      SkillGradeColorRare;                                      // 0x0204(0x0004) (Config)
	struct FColor                                      SkillGradeColorEpic;                                      // 0x0208(0x0004) (Config)
	struct FColor                                      SkillGradeColorLegendary;                                 // 0x020C(0x0004) (Config)
	struct FColor                                      CompanionGradeColorCommon;                                // 0x0210(0x0004) (Config)
	struct FColor                                      CompanionGradeColorUncommon;                              // 0x0214(0x0004) (Config)
	struct FColor                                      CompanionGradeColorRare;                                  // 0x0218(0x0004) (Config)
	struct FColor                                      CompanionGradeColorEpic;                                  // 0x021C(0x0004) (Config)
	struct FColor                                      CompanionGradeColorLegendary;                             // 0x0220(0x0004) (Config)
	float                                              NPCSize_Small;                                            // 0x0224(0x0004) (Edit, Config)
	float                                              NPCSize_Medium;                                           // 0x0228(0x0004) (Edit, Config)
	float                                              NPCSize_Large;                                            // 0x022C(0x0004) (Edit, Config)
	float                                              BodyShakeScale_Small;                                     // 0x0230(0x0004) (Edit, Config)
	float                                              BodyShakeScale_Medium;                                    // 0x0234(0x0004) (Edit, Config)
	float                                              BodyShakeScale_Large;                                     // 0x0238(0x0004) (Edit, Config)
	float                                              BodyShakePlayTime_Small;                                  // 0x023C(0x0004) (Edit, Config)
	float                                              BodyShakePlayTime_Medium;                                 // 0x0240(0x0004) (Edit, Config)
	float                                              BodyShakePlayTime_Large;                                  // 0x0244(0x0004) (Edit, Config)
	float                                              BodyShakeScale_Player;                                    // 0x0248(0x0004) (Edit, Config)
	float                                              BodyShakePlayTime_Player;                                 // 0x024C(0x0004) (Edit, Config)
	float                                              FlyMountRollC;                                            // 0x0250(0x0004) (Edit, Config)
	float                                              FlyMountRollK;                                            // 0x0254(0x0004) (Edit, Config)
	float                                              FlyMountRollTweakValue;                                   // 0x0258(0x0004) (Edit, Config)
	int                                                RollTarget;                                               // 0x025C(0x0004) (Edit, Config)
	float                                              RootMotionApproachTargetCheckDistance;                    // 0x0260(0x0004) (Edit, Config)
	int                                                BeginnersGuideLevel;                                      // 0x0264(0x0004) (Edit, Config)
	float                                              TooltipDelayTime;                                         // 0x0268(0x0004) (Config)
	struct FColor                                      ColorOfAutotargetMark;                                    // 0x026C(0x0004) (Config)
	int                                                MaxTrackingDistance;                                      // 0x0270(0x0004) (Config)
	struct FColor                                      BPtextColor;                                              // 0x0274(0x0004) (Config)
	struct FColor                                      DPtextColor;                                              // 0x0278(0x0004) (Config)
	struct FColor                                      CPtextColor;                                              // 0x027C(0x0004) (Config)
	struct FColor                                      RPtextColor;                                              // 0x0280(0x0004) (Config)
	struct FColor                                      CTtextColor;                                              // 0x0284(0x0004) (Config)
	struct FColor                                      LumenatextColor;                                          // 0x0288(0x0004) (Config)
	struct FColor                                      CinistextColor;                                           // 0x028C(0x0004) (Config)
	struct FColor                                      ShortageTextColor;                                        // 0x0290(0x0004) (Config)
	struct FColor                                      DisableTextColor;                                         // 0x0294(0x0004) (Config)
	struct FColor                                      UnwareableTextColor;                                      // 0x0298(0x0004) (Config)
	struct FColor                                      AddDungeonLimitTextColor;                                 // 0x029C(0x0004) (Config)
	struct FColor                                      ActingPointTextColor_Under;                               // 0x02A0(0x0004) (Config)
	struct FColor                                      ActingPointTextColor_Over;                                // 0x02A4(0x0004) (Config)
	int                                                DropdownScroll_voice;                                     // 0x02A8(0x0004) (Config)
	int                                                DropdownScroll_molph;                                     // 0x02AC(0x0004) (Config)
	struct FColor                                      SelectionTextColor;                                       // 0x02B0(0x0004) (Config)
	struct FColor                                      OutTextColor;                                             // 0x02B4(0x0004) (Config)
	float                                              PartyReceiveDamageFloaterTime;                            // 0x02B8(0x0004) (Config)
	float                                              PartyReceiveHealFloaterTime;                              // 0x02BC(0x0004) (Config)
	float                                              RaidReceiveDamageFloaterTime;                             // 0x02C0(0x0004) (Config)
	float                                              RaidReceiveHealFloaterTime;                               // 0x02C4(0x0004) (Config)
	struct FString                                     SaveDirectoryPath;                                        // 0x02C8(0x0010) (Config, NeedCtorLink)
	float                                              ForwardAngle;                                             // 0x02D8(0x0004) (Config)
	float                                              MinimumMonsterBookAreaRadius;                             // 0x02DC(0x0004) (Config)
	int                                                WebPageSizeX;                                             // 0x02E0(0x0004) (Config)
	int                                                WebPageSizeY;                                             // 0x02E4(0x0004) (Config)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.DesignParameters");
		return ptr;
	}


	class UDesignParameters* STATIC_GetDesignParameters();
	bool STATIC_GetStateEnableUnEquip();
	bool STATIC_GetStateEnableUndress(int Slot);
};


// Class BLGame.DevelopmentDesign
// 0x0010 (0x0070 - 0x0060)
class UDevelopmentDesign : public UObject
{
public:
	TArray<struct FMacroCommand>                       MacroCommands;                                            // 0x0060(0x0010) (AlwaysInit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.DevelopmentDesign");
		return ptr;
	}


	class UDevelopmentDesign* STATIC_GetDevDesign();
	void Init();
};


// Class BLGame.LevelStreamingTemporaryFakeLevel
// 0x0000 (0x0118 - 0x0118)
class ULevelStreamingTemporaryFakeLevel : public ULevelStreamingAlwaysLoaded
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.LevelStreamingTemporaryFakeLevel");
		return ptr;
	}

};


// Class BLGame.NirvanicPointLightComponent
// 0x0020 (0x0260 - 0x0240)
class UNirvanicPointLightComponent : public UPointLightComponent
{
public:
	struct FColor                                      IndirectLightColor;                                       // 0x0240(0x0004) (Edit)
	float                                              IndirectLightBrightness;                                  // 0x0244(0x0004) (Edit)
	unsigned long                                      SkipLightmapGenerate : 1;                                 // 0x0248(0x0004) (Edit)
	unsigned long                                      bReallyEnabledInRenderThread : 1;                         // 0x0248(0x0004) (Transient)
	struct FColor                                      CachedTODInterpolatedLightColor;                          // 0x024C(0x0004) (Transient)
	TArray<struct FNirvanicLightSettings_ForTOD>       LightSettings_ForTOD;                                     // 0x0250(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.NirvanicPointLightComponent");
		return ptr;
	}

};


// Class BLGame.NirvanicPointLightToggleable
// 0x0000 (0x025C - 0x025C)
class ANirvanicPointLightToggleable : public APointLightToggleable
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.NirvanicPointLightToggleable");
		return ptr;
	}

};


// Class BLGame.NirvanicSpotLightComponent
// 0x0018 (0x0280 - 0x0268)
class UNirvanicSpotLightComponent : public USpotLightComponent
{
public:
	unsigned long                                      bReallyEnabledInRenderThread : 1;                         // 0x0268(0x0004) (Transient)
	unsigned long                                      SkipLightmapGenerate : 1;                                 // 0x0268(0x0004) (Edit)
	struct FColor                                      CachedTODInterpolatedLightColor;                          // 0x026C(0x0004) (Transient)
	TArray<struct FNirvanicLightSettings_ForTOD>       LightSettings_ForTOD;                                     // 0x0270(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.NirvanicSpotLightComponent");
		return ptr;
	}

};


// Class BLGame.NirvanicSpotLightToggleable
// 0x0000 (0x025C - 0x025C)
class ANirvanicSpotLightToggleable : public ASpotLightToggleable
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.NirvanicSpotLightToggleable");
		return ptr;
	}

};


// Class BLGame.ParticleModuleExternalFadeInOut
// 0x0008 (0x0074 - 0x006C)
class UParticleModuleExternalFadeInOut : public UParticleModuleColorBase
{
public:
	float                                              DurationFadeIn;                                           // 0x006C(0x0004) (Edit)
	float                                              DurationFadeOut;                                          // 0x0070(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.ParticleModuleExternalFadeInOut");
		return ptr;
	}

};


// Class BLGame.ParticleModuleLocationSocket
// 0x007C (0x00E8 - 0x006C)
class UParticleModuleLocationSocket : public UParticleModuleLocationBase
{
public:
	struct FName                                       EmitterName;                                              // 0x006C(0x0008)
	struct FName                                       SocketName;                                               // 0x0074(0x0008)
	struct FRawDistributionVector                      LocationOffset;                                           // 0x007C(0x0024) (Component, NeedCtorLink)
	struct FRawDistributionVector                      WorldLocationOffset;                                      // 0x00A0(0x0024) (Component, NeedCtorLink)
	unsigned long                                      bUseSocketSpaceRotation : 1;                              // 0x00C4(0x0004) (Edit)
	unsigned long                                      bTracking : 1;                                            // 0x00C4(0x0004) (Edit)
	float                                              SocketVelocityIntensity;                                  // 0x00C8(0x0004) (Edit)
	int                                                SkelEmitterInstanceIndex;                                 // 0x00CC(0x0004)
	struct FVector                                     LastTickPosition;                                         // 0x00D0(0x000C)
	struct FVector                                     SocketSpeed;                                              // 0x00DC(0x000C)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.ParticleModuleLocationSocket");
		return ptr;
	}

};


// Class BLGame.ParticleModuleTypeDataSkelMesh
// 0x0030 (0x00B8 - 0x0088)
class UParticleModuleTypeDataSkelMesh : public UParticleModuleTypeDataMesh
{
public:
	class USkeletalMesh*                               SkelMesh;                                                 // 0x0088(0x0008)
	TArray<class UAnimSet*>                            AnimSets;                                                 // 0x0090(0x0010) (NeedCtorLink)
	class UAnimNode*                                   Animations;                                               // 0x00A0(0x0008) (Const, ExportObject, NeedCtorLink, EditInline)
	unsigned long                                      bKillWhenEndOfPlay : 1;                                   // 0x00A8(0x0004)
	unsigned long                                      bUseAdjustHeight : 1;                                     // 0x00A8(0x0004)
	unsigned long                                      bDrawDebugLine : 1;                                       // 0x00A8(0x0004) (Edit)
	TEnumAsByte<EAdjustHeightSrcType>                  AdjustHeightSrcType;                                      // 0x00AC(0x0001)
	TEnumAsByte<EAdjustHeightTargetType>               AdjustHeightTargetType;                                   // 0x00AD(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x00AE(0x0002) MISSED OFFSET
	struct FName                                       AdjustHeightSrcSocketBone;                                // 0x00B0(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.ParticleModuleTypeDataSkelMesh");
		return ptr;
	}

};


// Class BLGame.TextureRenderTarget2DForMeshRenderBuffer
// 0x0004 (0x0168 - 0x0164)
class UTextureRenderTarget2DForMeshRenderBuffer : public UTextureRenderTarget2D
{
public:
	unsigned long                                      bNeedUpdate : 1;                                          // 0x0164(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.TextureRenderTarget2DForMeshRenderBuffer");
		return ptr;
	}

};


// Class BLGame.TextureRenderTarget2DForPortraitView
// 0x0004 (0x0168 - 0x0164)
class UTextureRenderTarget2DForPortraitView : public UTextureRenderTarget2D
{
public:
	int                                                PortraitViewIndex;                                        // 0x0164(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.TextureRenderTarget2DForPortraitView");
		return ptr;
	}

};


// Class BLGame.BLAnim_TurnInPlace
// 0x0074 (0x01C4 - 0x0150)
class UBLAnim_TurnInPlace : public UAnimNodeBlend
{
public:
	unsigned long                                      bInitialized : 1;                                         // 0x0150(0x0004) (Const, Transient)
	unsigned long                                      bRootRotInitialized : 1;                                  // 0x0150(0x0004) (Const, Transient)
	unsigned long                                      bDelayBlendOutToPlayAnim : 1;                             // 0x0150(0x0004) (Edit)
	unsigned long                                      bPlayingTurnTransition : 1;                               // 0x0150(0x0004) (Const)
	int                                                LastPawnYaw;                                              // 0x0154(0x0004) (Const, Transient)
	float                                              PawnRotationRate;                                         // 0x0158(0x0004) (Const, Transient)
	int                                                LastRootBoneYaw;                                          // 0x015C(0x0004) (Const, Transient)
	int                                                YawOffset;                                                // 0x0160(0x0004) (Edit, Const, Transient)
	int                                                YawOffsetStamp;                                           // 0x0164(0x0004) (Transient)
	int                                                YawOffsetCounter;                                         // 0x0168(0x0004) (Transient)
	unsigned char                                      UnknownData00[0x4];                                       // 0x016C(0x0004) MISSED OFFSET
	struct FQuat                                       RootBoneRotation;                                         // 0x0170(0x0010) (Transient)
	float                                              RelativeOffset;                                           // 0x0180(0x0004) (Const, Transient)
	class ABLPawn*                                     BLPawnOwner;                                              // 0x0184(0x0008) (Const, Transient)
	class ABLPawn*                                     CachedBaseBLPawn;                                         // 0x018C(0x0008) (Const, Transient)
	TArray<struct FRotTransitionInfo>                  RotTransitions;                                           // 0x0194(0x0010) (Edit, NeedCtorLink)
	float                                              TransitionBlendInTime;                                    // 0x01A4(0x0004) (Edit)
	float                                              TransitionBlendOutTime;                                   // 0x01A8(0x0004) (Edit)
	int                                                CurrentTransitionIndex;                                   // 0x01AC(0x0004) (Const)
	float                                              TransitionThresholdAngle;                                 // 0x01B0(0x0004) (Edit)
	TArray<class UBLAnim_TurnInPlace_Player*>          PlayerNodes;                                              // 0x01B4(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnim_TurnInPlace");
		return ptr;
	}

};


// Class BLGame.BLAnim_TurnInPlace_Player
// 0x0024 (0x01E0 - 0x01BC)
class UBLAnim_TurnInPlace_Player : public UAnimNodeSequenceBlendBase
{
public:
	TArray<struct FTIP_Transition>                     TIP_Transitions;                                          // 0x01BC(0x0010) (Edit, NeedCtorLink)
	float                                              TransitionBlendTime;                                      // 0x01CC(0x0004) (Edit)
	int                                                ActiveChildIndex;                                         // 0x01D0(0x0004) (Transient)
	float                                              BlendTimeToGo;                                            // 0x01D4(0x0004) (Transient)
	class UBLAnim_TurnInPlace*                         TurnInPlace;                                              // 0x01D8(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnim_TurnInPlace_Player");
		return ptr;
	}

};


// Class BLGame.BLAnim_TurnInPlace_Rotator
// 0x0013 (0x0150 - 0x013D)
class UBLAnim_TurnInPlace_Rotator : public UAnimNodeBlendBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x013D(0x0003) MISSED OFFSET
	class ABLPawn*                                     BLPawnOwner;                                              // 0x0140(0x0008) (Const, Transient)
	class UBLAnim_TurnInPlace*                         TurnInPlaceNode;                                          // 0x0148(0x0008) (Const, Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnim_TurnInPlace_Rotator");
		return ptr;
	}

};


// Class BLGame.BLAnimBlendLookAt
// 0x00B7 (0x01F4 - 0x013D)
class UBLAnimBlendLookAt : public UAnimNodeBlendBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x013D(0x0003) MISSED OFFSET
	struct FVector                                     LookAtOffset;                                             // 0x0140(0x000C) (Edit)
	struct FName                                       LookAtOriginBoneName;                                     // 0x014C(0x0008) (Edit)
	struct FName                                       RotatorNodeName;                                          // 0x0154(0x0008) (Edit)
	int                                                LookAtNodeLookUpDepth;                                    // 0x015C(0x0004) (Edit)
	unsigned long                                      bSkipProcess : 1;                                         // 0x0160(0x0004) (Edit)
	class UAnimNodeHumanIKLookAt*                      LookAtNode;                                               // 0x0164(0x0008) (Transient)
	class UBLAnimNodeRotateByDirectional*              RotatorNode;                                              // 0x016C(0x0008) (Transient)
	TEnumAsByte<ELookAtFocus>                          LookFocus;                                                // 0x0174(0x0001) (Transient)
	TEnumAsByte<ELookingTarget>                        LookedTarget;                                             // 0x0175(0x0001) (Transient)
	unsigned char                                      UnknownData01[0x2];                                       // 0x0176(0x0002) MISSED OFFSET
	class APawn*                                       LookFocusPawn;                                            // 0x0178(0x0008) (Transient)
	struct FName                                       LookFocusBone;                                            // 0x0180(0x0008) (Transient)
	class AActor*                                      LookFocusActor;                                           // 0x0188(0x0008) (Transient)
	struct FVector                                     LookFocusLocation;                                        // 0x0190(0x000C) (Transient)
	class ABLPawn*                                     OwnerPawn;                                                // 0x019C(0x0008) (Transient)
	struct FName                                       LookAtTargetBoneName;                                     // 0x01A4(0x0008) (Edit)
	float                                              TargetLookDistraction;                                    // 0x01AC(0x0004) (Edit)
	float                                              ForwardLookDistraction;                                   // 0x01B0(0x0004) (Edit)
	int                                                UpperPitchLimit;                                          // 0x01B4(0x0004) (Edit)
	float                                              UpperPitchLimitTangent;                                   // 0x01B8(0x0004) (Edit, EditConst)
	int                                                LowerPitchLimit;                                          // 0x01BC(0x0004) (Edit)
	float                                              LowerPitchLimitTangent;                                   // 0x01C0(0x0004) (Edit, EditConst)
	float                                              LookBackDistance;                                         // 0x01C4(0x0004) (Edit)
	float                                              AngleConsideredAsBehind;                                  // 0x01C8(0x0004) (Edit)
	float                                              LookOffBlendTime;                                         // 0x01CC(0x0004) (Edit)
	float                                              TargetLookBlendSpeed;                                     // 0x01D0(0x0004) (Edit)
	float                                              ForwardLookBlendSpeed;                                    // 0x01D4(0x0004) (Edit)
	float                                              BlendSpeed;                                               // 0x01D8(0x0004) (Transient)
	TArray<float>                                      TargetWeight;                                             // 0x01DC(0x0010) (Transient, NeedCtorLink)
	int                                                ActiveChildIndex;                                         // 0x01EC(0x0004) (Transient)
	float                                              BlendTimeToGo;                                            // 0x01F0(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimBlendLookAt");
		return ptr;
	}


	void LookAtLocation(const struct FVector& FocusLocation, float BlendTime);
	void LookAtActor(class AActor* Actor, float BlendTime);
	void LookAtPawn(class APawn* Pawn, const struct FName& FocusBone, float BlendTime);
	void ForgetFocus(float BlendTime);
	void EnableLookAt(bool bEnable);
};


// Class BLGame.BLAnimCopycatOfBaseMesh
// 0x008C (0x01B4 - 0x0128)
class UBLAnimCopycatOfBaseMesh : public UAnimNode
{
public:
	unsigned char                                      UnknownData00[0x48];                                      // 0x0128(0x0048) UNKNOWN PROPERTY: MapProperty BLGame.BLAnimCopycatOfBaseMesh.SequenceCache
	unsigned long                                      bUseSlotChildAsDominantNode : 1;                          // 0x0170(0x0004)
	unsigned long                                      bInvalidAnimSets : 1;                                     // 0x0170(0x0004) (Transient)
	TArray<struct FAnimSequenceBlendInfo>              BlendLists;                                               // 0x0174(0x0010) (Transient, NeedCtorLink)
	TArray<struct FAnimSequenceBlendInfo>              DominantBlendLists;                                       // 0x0184(0x0010) (Transient, NeedCtorLink)
	float                                              OriginalTotalWeight;                                      // 0x0194(0x0004) (Transient)
	float                                              DominantTotalWeight;                                      // 0x0198(0x0004) (Transient)
	class USkeletalMeshComponent*                      SourceSkelMesh;                                           // 0x019C(0x0008) (ExportObject, Transient, Component, EditInline)
	struct FString                                     PrefixAnimName;                                           // 0x01A4(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimCopycatOfBaseMesh");
		return ptr;
	}


	void SetPrefixAnimName(const struct FString& InPrefixAnimName);
	void SetSourceSkelMeshComp(class USkeletalMeshComponent* InSrcSkelMesh);
};


// Class BLGame.BLAnimNodeAdditiveConstant
// 0x0037 (0x0174 - 0x013D)
class UBLAnimNodeAdditiveConstant : public UAnimNodeBlendBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x013D(0x0003) MISSED OFFSET
	struct FName                                       BoneName;                                                 // 0x0140(0x0008) (Edit)
	int                                                BoneIndex;                                                // 0x0148(0x0004) (Transient)
	unsigned long                                      bUseOtherBoneSpace : 1;                                   // 0x014C(0x0004) (Edit)
	unsigned long                                      bApplyTranslation : 1;                                    // 0x014C(0x0004) (Edit)
	unsigned long                                      bApplyRotation : 1;                                       // 0x014C(0x0004) (Edit)
	struct FName                                       TargetBoneName;                                           // 0x0150(0x0008) (Edit)
	int                                                TargetBoneIndex;                                          // 0x0158(0x0004) (Transient)
	struct FVector                                     BoneTranslation;                                          // 0x015C(0x000C) (Edit)
	struct FRotator                                    BoneRotation;                                             // 0x0168(0x000C) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNodeAdditiveConstant");
		return ptr;
	}

};


// Class BLGame.BLAnimNodeBlendByBidirectional
// 0x004F (0x018C - 0x013D)
class UBLAnimNodeBlendByBidirectional : public UAnimNodeBlendBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x013D(0x0003) MISSED OFFSET
	int                                                ForwardThreshold;                                         // 0x0140(0x0004) (Edit)
	float                                              ForwardThresholdRadian;                                   // 0x0144(0x0004) (Edit, Transient, EditConst)
	unsigned long                                      bUsingAccelForMoveDirection : 1;                          // 0x0148(0x0004) (Edit)
	unsigned long                                      bUsingPawnFlagForForwardJudge : 1;                        // 0x0148(0x0004) (Edit)
	unsigned long                                      bUsingBasePawnIfExist : 1;                                // 0x0148(0x0004) (Edit)
	unsigned long                                      bIsMoving : 1;                                            // 0x0148(0x0004) (Transient)
	unsigned long                                      bGoingForward : 1;                                        // 0x0148(0x0004) (Transient)
	float                                              LastLookYaw;                                              // 0x014C(0x0004) (Transient)
	float                                              LastMoveYaw;                                              // 0x0150(0x0004) (Transient)
	float                                              LastYawDiff;                                              // 0x0154(0x0004) (Transient)
	float                                              LastLookYawInMove;                                        // 0x0158(0x0004) (Transient)
	float                                              LastMoveYawInMove;                                        // 0x015C(0x0004) (Transient)
	float                                              LastYawDiffInMove;                                        // 0x0160(0x0004) (Transient)
	float                                              MoveYawHoldTimeToGo;                                      // 0x0164(0x0004) (Transient)
	float                                              BlendTime;                                                // 0x0168(0x0004) (Edit)
	TArray<float>                                      TargetWeight;                                             // 0x016C(0x0010) (Transient, NeedCtorLink)
	float                                              BlendTimeToGo;                                            // 0x017C(0x0004) (Transient)
	int                                                ActiveChildIndex;                                         // 0x0180(0x0004) (Transient)
	class ABLPawn*                                     OwnerPawn;                                                // 0x0184(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNodeBlendByBidirectional");
		return ptr;
	}

};


// Class BLGame.BLAnimNodeBlendBySpeed
// 0x0004 (0x019C - 0x0198)
class UBLAnimNodeBlendBySpeed : public UAnimNodeBlendBySpeed
{
public:
	unsigned long                                      bIgnoreZAxisWhenCalcSpeed : 1;                            // 0x0198(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNodeBlendBySpeed");
		return ptr;
	}

};


// Class BLGame.BLAnimNodeBlendByStatus
// 0x0014 (0x0178 - 0x0164)
class UBLAnimNodeBlendByStatus : public UAnimNodeBlendList
{
public:
	class ABLPawn*                                     BLPawnOwner;                                              // 0x0164(0x0008) (Transient)
	float                                              BlendTime;                                                // 0x016C(0x0004) (Edit)
	int                                                PeaceChildIndex;                                          // 0x0170(0x0004) (Transient)
	int                                                CombatChildIndex;                                         // 0x0174(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNodeBlendByStatus");
		return ptr;
	}

};


// Class BLGame.BLAnimNodeBlendDirectional
// 0x0028 (0x01E4 - 0x01BC)
class UBLAnimNodeBlendDirectional : public UAnimNodeSequenceBlendBase
{
public:
	unsigned long                                      bAddRotationRate : 1;                                     // 0x01BC(0x0004) (Edit)
	float                                              BlendSpeed;                                               // 0x01C0(0x0004) (Edit)
	float                                              DirAngle;                                                 // 0x01C4(0x0004)
	struct FVector                                     MoveDir;                                                  // 0x01C8(0x000C)
	int                                                LastYaw;                                                  // 0x01D4(0x0004) (Transient)
	float                                              YawRotationRate;                                          // 0x01D8(0x0004) (Transient)
	class ABLPawn*                                     BLPawnOwner;                                              // 0x01DC(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNodeBlendDirectional");
		return ptr;
	}

};


// Class BLGame.BLAnimNodeBlendEightDirectional
// 0x001B (0x0158 - 0x013D)
class UBLAnimNodeBlendEightDirectional : public UAnimNodeBlendBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x013D(0x0003) MISSED OFFSET
	float                                              BlendTime;                                                // 0x0140(0x0004) (Edit)
	unsigned long                                      bUseAcceleration : 1;                                     // 0x0144(0x0004) (Edit)
	int                                                SingleAnimAtOrAboveLOD;                                   // 0x0148(0x0004) (Edit)
	float                                              DirAngle;                                                 // 0x014C(0x0004) (Transient)
	float                                              EditorTargetDirAngle;                                     // 0x0150(0x0004) (Transient)
	float                                              BlendTimeToGo;                                            // 0x0154(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNodeBlendEightDirectional");
		return ptr;
	}

};


// Class BLGame.BLAnimNodePeacefulPostureBreaker
// 0x0013 (0x0150 - 0x013D)
class UBLAnimNodePeacefulPostureBreaker : public UAnimNodeBlendBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x013D(0x0003) MISSED OFFSET
	class ABLPawn*                                     OwnerBLPawn;                                              // 0x0140(0x0008) (Transient)
	float                                              LastNodeWeight;                                           // 0x0148(0x0004) (Transient)
	unsigned long                                      bForceBreak : 1;                                          // 0x014C(0x0004) (Edit)
	unsigned long                                      bBreakWhenUnsheatedStatusOnly : 1;                        // 0x014C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNodePeacefulPostureBreaker");
		return ptr;
	}

};


// Class BLGame.BLAnimNodeRotateByDirection
// 0x002C (0x0169 - 0x013D)
class UBLAnimNodeRotateByDirection : public UAnimNodeBlendBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x013D(0x0003) MISSED OFFSET
	struct FName                                       BoneName;                                                 // 0x0140(0x0008) (Edit)
	int                                                BoneIndex;                                                // 0x0148(0x0004) (Transient)
	unsigned char                                      UnknownData01[0x4];                                       // 0x014C(0x0004) MISSED OFFSET
	struct FQuat                                       DeltaQuat;                                                // 0x0150(0x0010) (Transient)
	unsigned long                                      bUseAcceleration : 1;                                     // 0x0160(0x0004) (Edit)
	unsigned long                                      bFlipDirection : 1;                                       // 0x0160(0x0004) (Edit)
	unsigned long                                      bFixedDirection : 1;                                      // 0x0160(0x0004) (Edit)
	unsigned long                                      bUsePlayerControllerDirection : 1;                        // 0x0160(0x0004) (Edit)
	unsigned long                                      bConsiderHorizontalRotationOnly : 1;                      // 0x0160(0x0004) (Edit)
	float                                              MaxDegreeWithVerticalAxis;                                // 0x0164(0x0004) (Edit)
	TEnumAsByte<EDirection>                            FixedDirection;                                           // 0x0168(0x0001) (Edit, Const)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNodeRotateByDirection");
		return ptr;
	}

};


// Class BLGame.BLAnimNodeRotateByDirectional
// 0x008F (0x01CC - 0x013D)
class UBLAnimNodeRotateByDirectional : public UAnimNodeBlendBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x013D(0x0003) MISSED OFFSET
	struct FName                                       BoneName;                                                 // 0x0140(0x0008) (Edit)
	int                                                BoneIndex;                                                // 0x0148(0x0004) (Transient)
	unsigned long                                      bFlipDirectionWhenBack : 1;                               // 0x014C(0x0004) (Edit)
	unsigned long                                      bNeedRotate : 1;                                          // 0x014C(0x0004) (Transient)
	unsigned long                                      bUseAccelerating : 1;                                     // 0x014C(0x0004) (Edit)
	unsigned long                                      bWorkForwardMove : 1;                                     // 0x014C(0x0004) (Edit)
	unsigned long                                      bBlendToTarget : 1;                                       // 0x014C(0x0004) (Transient)
	unsigned long                                      bActivate : 1;                                            // 0x014C(0x0004) (Transient)
	struct FQuat                                       DirRot;                                                   // 0x0150(0x0010) (Transient)
	TArray<class UBLAnimNodeBlendByBidirectional*>     BidirectionalBlendNodes;                                  // 0x0160(0x0010) (Transient, NeedCtorLink)
	class UBLAnimNodeBlendByBidirectional*             CurrentDirectionalNode;                                   // 0x0170(0x0008) (Transient)
	int                                                YawAngularVelocity;                                       // 0x0178(0x0004) (Edit)
	float                                              NotWorkAngle;                                             // 0x017C(0x0004) (Edit)
	int                                                NotWorkYawMin;                                            // 0x0180(0x0004) (Transient)
	int                                                NotWorkYawMax;                                            // 0x0184(0x0004) (Transient)
	int                                                PrevYawDiff;                                              // 0x0188(0x0004) (Transient)
	int                                                PrevYawDiffBase;                                          // 0x018C(0x0004) (Transient)
	struct FRotator                                    PrevPawnRot;                                              // 0x0190(0x000C) (Transient)
	struct FRotator                                    PrevPawnRotDiff;                                          // 0x019C(0x000C) (Transient)
	int                                                TargetYaw;                                                // 0x01A8(0x0004) (Transient)
	struct FRotator                                    TargetRot;                                                // 0x01AC(0x000C) (Transient)
	float                                              YawBlendTime;                                             // 0x01B8(0x0004) (Transient)
	float                                              BodyTurnThreashold;                                       // 0x01BC(0x0004) (Edit)
	float                                              YawDiffClearBlendTime;                                    // 0x01C0(0x0004) (Edit)
	float                                              TimeToYawDiffClear;                                       // 0x01C4(0x0004) (Transient)
	float                                              DeadZoneYawRadian;                                        // 0x01C8(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNodeRotateByDirectional");
		return ptr;
	}


	void Deactivate();
	void Activate();
	void ForceLookForward();
	class UBLAnimNodeBlendByBidirectional* GetDominantDirectionalNode();
};


// Class BLGame.BLAnimNodeScalePlayRate
// 0x000B (0x0148 - 0x013D)
class UBLAnimNodeScalePlayRate : public UAnimNodeBlendBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x013D(0x0003) MISSED OFFSET
	float                                              ScaleByValue;                                             // 0x0140(0x0004) (Edit)
	unsigned long                                      bActivate : 1;                                            // 0x0144(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNodeScalePlayRate");
		return ptr;
	}


	void Deactivate(float InScaleByValue);
	void Activate(float InScaleByValue);
};


// Class BLGame.BLAnimNodeScaleRateBySpeed
// 0x0004 (0x014C - 0x0148)
class UBLAnimNodeScaleRateBySpeed : public UAnimNodeScaleRateBySpeed
{
public:
	unsigned long                                      ScaleRateByMeshScale : 1;                                 // 0x0148(0x0004) (Edit)
	unsigned long                                      bUsingBasePawnIfExist : 1;                                // 0x0148(0x0004) (Edit)
	unsigned long                                      bScaleRateByCustomizingHeight : 1;                        // 0x0148(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNodeScaleRateBySpeed");
		return ptr;
	}

};


// Class BLGame.BLAnimNodeSequenceStatus
// 0x001C (0x01C8 - 0x01AC)
class UBLAnimNodeSequenceStatus : public UAnimNodeSequence
{
public:
	class ABLPawn*                                     BLPawnOwner;                                              // 0x01AC(0x0008) (Transient)
	TEnumAsByte<EBLCombatStatus>                       CurrentStatus;                                            // 0x01B4(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x3];                                       // 0x01B5(0x0003) MISSED OFFSET
	TArray<struct FCharacterStatusSequence>            StatusSequence;                                           // 0x01B8(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNodeSequenceStatus");
		return ptr;
	}

};


// Class BLGame.BLAnimNodeSmoothTurning
// 0x003B (0x0178 - 0x013D)
class UBLAnimNodeSmoothTurning : public UAnimNodeBlendBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x013D(0x0003) MISSED OFFSET
	struct FName                                       BoneName;                                                 // 0x0140(0x0008) (Edit)
	int                                                BoneIndex;                                                // 0x0148(0x0004) (Transient)
	unsigned char                                      UnknownData01[0x4];                                       // 0x014C(0x0004) MISSED OFFSET
	struct FQuat                                       DirRot;                                                   // 0x0150(0x0010) (Transient)
	unsigned long                                      bNeedRotate : 1;                                          // 0x0160(0x0004) (Transient)
	float                                              PrevYawDiff;                                              // 0x0164(0x0004) (Transient)
	int                                                PrevYawDiffBase;                                          // 0x0168(0x0004) (Transient)
	float                                              TimeToYawDiffClear;                                       // 0x016C(0x0004) (Transient)
	float                                              YawDiffClearBlendTime;                                    // 0x0170(0x0004) (Transient)
	float                                              BodySmoothTurnThreshold;                                  // 0x0174(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNodeSmoothTurning");
		return ptr;
	}

};


// Class BLGame.BLAnimNotify
// 0x0000 (0x0064 - 0x0064)
class UBLAnimNotify : public UAnimNotify
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNotify");
		return ptr;
	}


	class UBLEvent* ToEvent(class AActor* InOuter);
};


// Class BLGame.BLAnimNotify_HitTime
// 0x0008 (0x006C - 0x0064)
class UBLAnimNotify_HitTime : public UBLAnimNotify
{
public:
	struct FName                                       HitName;                                                  // 0x0064(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNotify_HitTime");
		return ptr;
	}


	class UBLEvent* ToEvent(class AActor* InOuter);
};


// Class BLGame.BLAnimNotify_EffectiveJudgment
// 0x0024 (0x0088 - 0x0064)
class UBLAnimNotify_EffectiveJudgment : public UAnimNotify
{
public:
	TEnumAsByte<EBLImpactType>                         ImpactType;                                               // 0x0064(0x0001) (Edit)
	TEnumAsByte<EEffectiveJudgment>                    JudgmentCondition;                                        // 0x0065(0x0001) (Edit)
	TEnumAsByte<EBleedCauseType>                       BleedCause;                                               // 0x0066(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x1];                                       // 0x0067(0x0001) MISSED OFFSET
	struct FName                                       HittingBoneName;                                          // 0x0068(0x0008) (Edit)
	unsigned long                                      bTargetOnlyEffective : 1;                                 // 0x0070(0x0004) (Edit)
	unsigned long                                      bBlockHitTimeEffect : 1;                                  // 0x0070(0x0004) (Edit)
	unsigned long                                      bSubstituteHitTime : 1;                                   // 0x0070(0x0004) (Edit)
	struct FName                                       MatchingHitNotify;                                        // 0x0074(0x0008) (Edit)
	class UBLAnimNotify_HitTime*                       HitTimeNotify;                                            // 0x007C(0x0008) (Edit, EditConst)
	unsigned long                                      UpdateHitTimeNotify : 1;                                  // 0x0084(0x0004) (Edit, NoExport)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNotify_EffectiveJudgment");
		return ptr;
	}

};


// Class BLGame.BLAnimNotify_HIKMarkerChange
// 0x0024 (0x0088 - 0x0064)
class UBLAnimNotify_HIKMarkerChange : public UAnimNotify
{
public:
	struct FName                                       PrevMarkerName;                                           // 0x0064(0x0008) (Edit)
	struct FName                                       NextMarkerName;                                           // 0x006C(0x0008) (Edit)
	struct FName                                       BlenderName;                                              // 0x0074(0x0008) (Edit)
	TEnumAsByte<EHIKMarkerPreset>                      SelectPreset;                                             // 0x007C(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x007D(0x0003) MISSED OFFSET
	float                                              HandOffBlendTime;                                         // 0x0080(0x0004) (Edit)
	float                                              GripBlendTime;                                            // 0x0084(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNotify_HIKMarkerChange");
		return ptr;
	}

};


// Class BLGame.BLAnimNotify_PickUp
// 0x0000 (0x0064 - 0x0064)
class UBLAnimNotify_PickUp : public UAnimNotify_Scripted
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNotify_PickUp");
		return ptr;
	}


	void Notify(class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator);
};


// Class BLGame.BLAnimNotify_PutDown
// 0x0000 (0x0064 - 0x0064)
class UBLAnimNotify_PutDown : public UAnimNotify_Scripted
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNotify_PutDown");
		return ptr;
	}


	void Notify(class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator);
};


// Class BLGame.BLAnimNotify_Sheathe
// 0x0002 (0x0066 - 0x0064)
class UBLAnimNotify_Sheathe : public UAnimNotify_Scripted
{
public:
	TEnumAsByte<EnumSheatheAction>                     LeftHandAction;                                           // 0x0064(0x0001) (Edit)
	TEnumAsByte<EnumSheatheAction>                     RightHandAction;                                          // 0x0065(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNotify_Sheathe");
		return ptr;
	}


	void Notify(class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator);
};


// Class BLGame.BLAnimNotify_ToggleActiveReaction
// 0x0008 (0x006C - 0x0064)
class UBLAnimNotify_ToggleActiveReaction : public UAnimNotify_Scripted
{
public:
	unsigned long                                      bTurnOffFootPlacement : 1;                                // 0x0064(0x0004) (Edit)
	unsigned long                                      bTurnOffLookAtTarget : 1;                                 // 0x0064(0x0004) (Edit)
	unsigned long                                      bTurnOffTorsoAiming : 1;                                  // 0x0064(0x0004) (Edit)
	float                                              BlendTime;                                                // 0x0068(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNotify_ToggleActiveReaction");
		return ptr;
	}


	void NotifyEnd(class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator);
	void Notify(class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator);
};


// Class BLGame.BLAnimNotify_Trigger
// 0x0008 (0x006C - 0x0064)
class UBLAnimNotify_Trigger : public UAnimNotify_Scripted
{
public:
	struct FName                                       TriggerName;                                              // 0x0064(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNotify_Trigger");
		return ptr;
	}


	void Notify(class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator);
};


// Class BLGame.BLAnimNotify_Voice
// 0x0008 (0x006C - 0x0064)
class UBLAnimNotify_Voice : public UAnimNotify
{
public:
	struct FName                                       Key;                                                      // 0x0064(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNotify_Voice");
		return ptr;
	}

};


// Class BLGame.BLAnimTransportRoute
// 0x005C (0x0184 - 0x0128)
class UBLAnimTransportRoute : public UAnimNode
{
public:
	TArray<struct FBLTransportRouteAnimBlendInfo>      BlendList;                                                // 0x0128(0x0010) (Transient, NeedCtorLink)
	unsigned long                                      bForceUseInAnimTree : 1;                                  // 0x0138(0x0004) (Edit)
	unsigned char                                      UnknownData00[0x48];                                      // 0x013C(0x0048) UNKNOWN PROPERTY: MapProperty BLGame.BLAnimTransportRoute.SequenceCache

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimTransportRoute");
		return ptr;
	}

};


// Class BLGame.BLSkelControlSingleBone
// 0x0000 (0x0130 - 0x0130)
class UBLSkelControlSingleBone : public USkelControlSingleBone
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLSkelControlSingleBone");
		return ptr;
	}

};


// Class BLGame.BLSkelControlWeaponSheathe
// 0x0008 (0x0138 - 0x0130)
class UBLSkelControlWeaponSheathe : public USkelControlSingleBone
{
public:
	float                                              SheatheTargetWeight;                                      // 0x0130(0x0004) (Transient)
	float                                              UnsheatheTargetWeight;                                    // 0x0134(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLSkelControlWeaponSheathe");
		return ptr;
	}


	void SetSkelControlUnsheatheFromSeqAction(class UBLSeqAct_AdjustSkelControlWeaponSheathe* Action);
	void SetSkelControlUnsheathe(bool bUnsheathe, float BlendTime);
};


// Class BLGame.BLDummyInfo
// 0x001C (0x026C - 0x0250)
class ABLDummyInfo : public AInfo
{
public:
	class UPawnAsset*                                  CharInfo;                                                 // 0x0250(0x0008) (Edit)
	class USkeletalMeshComponent*                      SkelComp;                                                 // 0x0258(0x0008) (ExportObject, Transient, Component, EditInline)
	class USpriteComponent*                            IndicatorSpriteComponent;                                 // 0x0260(0x0008) (ExportObject, Transient, Component, EditInline)
	unsigned long                                      bNeedSetUpSkelComp : 1;                                   // 0x0268(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLDummyInfo");
		return ptr;
	}


	void SetUpSkelComp();
};


// Class BLGame.BLDummyNPC
// 0x0038 (0x02A4 - 0x026C)
class ABLDummyNPC : public ABLDummyInfo
{
public:
	int                                                ServerID;                                                 // 0x026C(0x0004) (Edit)
	class UNPCAsset*                                   NPCAsset;                                                 // 0x0270(0x0008)
	unsigned long                                      bDoCounterAttack : 1;                                     // 0x0278(0x0004) (Edit)
	TArray<struct FDummyNPCAttackInfo>                 AttackList;                                               // 0x027C(0x0010) (Edit, NeedCtorLink)
	float                                              SkillInterval;                                            // 0x028C(0x0004) (Edit)
	float                                              ChaseDistance;                                            // 0x0290(0x0004) (Edit)
	int                                                DeadAfterHits;                                            // 0x0294(0x0004) (Edit)
	int                                                DeadSeconds;                                              // 0x0298(0x0004) (Edit)
	class ABLDummyServer*                              ServerActor;                                              // 0x029C(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLDummyNPC");
		return ptr;
	}


	struct FDummyNPCAttackInfo GetAttackInfo();
};


// Class BLGame.BLDummyServer
// 0x0164 (0x03D0 - 0x026C)
class ABLDummyServer : public ABLDummyInfo
{
public:
	int                                                ServerID;                                                 // 0x026C(0x0004) (Edit)
	TArray<struct FClientSkillData>                    SkillList;                                                // 0x0270(0x0010) (Edit, NeedCtorLink)
	unsigned long                                      bShutdown : 1;                                            // 0x0280(0x0004) (Edit)
	unsigned long                                      bSkillAutoFire : 1;                                       // 0x0280(0x0004) (Edit)
	unsigned long                                      bRefreshSkillList : 1;                                    // 0x0280(0x0004) (Edit, Transient)
	unsigned long                                      bChainSkillAutoFire : 1;                                  // 0x0280(0x0004) (Edit)
	unsigned long                                      bEnableSkillAutoFire : 1;                                 // 0x0280(0x0004) (Transient)
	unsigned long                                      bEnableChainSkillAutoFire : 1;                            // 0x0280(0x0004) (Transient)
	TArray<struct FClientSkillData>                    ChainSkillList;                                           // 0x0284(0x0010) (Edit, NeedCtorLink)
	int                                                AbnormalStatusCid;                                        // 0x0294(0x0004) (Edit)
	int                                                AuraCid;                                                  // 0x0298(0x0004) (Edit)
	float                                              TimeAfterLastChainSkill;                                  // 0x029C(0x0004) (Transient)
	int                                                LastChainSkillArrayIndex;                                 // 0x02A0(0x0004) (Transient)
	class UTexture2D*                                  SpriteTexture;                                            // 0x02A4(0x0008) (Edit)
	struct FMap_Mirror                                 PawnNameMap;                                              // 0x02AC(0x0048) (Const, Native)
	struct FMap_Mirror                                 ItemBagNameMap;                                           // 0x02F4(0x0048) (Const, Native)
	class USpriteComponent*                            LiveServerSpriteComponent;                                // 0x033C(0x0008) (ExportObject, Transient, Component, EditInline)
	TArray<int>                                        CacheTargetList;                                          // 0x0344(0x0010) (NeedCtorLink)
	class UPawnAsset*                                  PendingChangePawnInfo;                                    // 0x0354(0x0008) (Transient)
	class USkillRadialBlurManager*                     SkillRBManager;                                           // 0x035C(0x0008) (ExportObject, Transient, Component, EditInline)
	class UPawnDLEManager*                             PawnDLEManager;                                           // 0x0364(0x0008) (Transient)
	float                                              PIECustomPlayRate;                                        // 0x036C(0x0004) (Transient)
	struct FDummyServerSkillActionInfo                 SkillActionInfo;                                          // 0x0370(0x0058) (Transient, NeedCtorLink)
	class UBLPlayerPostProcessController*              PPPController;                                            // 0x03C8(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLDummyServer");
		return ptr;
	}


	void CS_MOUNT_ACTIVE_SKILL_ACTION_REQUEST_END_REP(int SkillCid);
	void CS_MOUNT_ACTIVE_SKILL_ACTION_REQUEST_REP(int SkillCid);
	class ABLPawnBase* GetPawnByID(int Sid);
	void OnVoluntaryActionEnd();
	void ReserveVoluntaryActionEnd(float inTime);
	void OnShoot();
	void DoSkill(class ABLPawnBase* a_Owner);
	void CS_SKILL_ACTION_REQ(int a_SkillCid, const struct FVector& a_TargetLocation);
	void CS_CHAIN_SKILL_ACTION_REQ(const struct FVector& a_TargetLocation);
	void CS_SKILL_ACTION_CANCEL_REQ();
	void CS_SPRINT_START_REQ();
	void UpdateCacheTargetList(float InAttackRange);
	int SortTargetListByDistance(TArray<class ABLPawnBase*> a_SourceList, TArray<int>* a_SortedList);
	TArray<struct FSkillResult> GenerateSkillResultList(class ABLPawnBase* InTargetPawn, TArray<int> InTargetList);
	class ABLPawnBase* GetTargetPawn();
	float CalcProjApplyTime(float InDistance, float InVelocity);
	float GetCastingTime(float InCustomCastingTime);
	struct FClientSkillData GetChainSkillData();
	struct FClientSkillData GetSkillData(int InSkillCid);
	void Tick(float DeltaTime);
	void UpdatePawnInfo();
	int ConvertSkillData(const struct FClientSkillData& InClientSkillData);
	bool IsEnableAutoFire();
};


// Class BLGame.BLNpcDummy
// 0x0014 (0x0F18 - 0x0F04)
class ABLNpcDummy : public ABLNpc
{
public:
	class ABLDummyNPC*                                 DummyOnlineInfo;                                          // 0x0F04(0x0008) (Transient)
	float                                              RemainTimeToAction;                                       // 0x0F0C(0x0004) (Transient)
	int                                                HitCount;                                                 // 0x0F10(0x0004) (Transient)
	unsigned long                                      bAllowAcceleration : 1;                                   // 0x0F14(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLNpcDummy");
		return ptr;
	}


	int GenerateSkillResult(TArray<struct FSkillResult>* SkillResultList);
	void PlayReviveAction(bool bRevivalbyOther, bool bRevivalAtDeadbody);
	void DoSkillAction();
};


// Class BLGame.BLSkillDataManager
// 0x0074 (0x00D4 - 0x0060)
class UBLSkillDataManager : public UObject
{
public:
	TEnumAsByte<ECEClassType>                          LocalPawnClassType;                                       // 0x0060(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	int                                                CurrentUseTacticsIndex;                                   // 0x0064(0x0004)
	TArray<struct FPointer>                            StanceSkill;                                              // 0x0068(0x0010) (Native, AlwaysInit)
	TArray<struct FPointer>                            NonStanceSkill;                                           // 0x0078(0x0010) (Native, AlwaysInit)
	TArray<struct FBLParameterNode>                    ParameterNodeGroupList;                                   // 0x0088(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<struct FBLSkillTreeData>                    CombatSkillTreeDataList;                                  // 0x0098(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<struct FBLSkillDeckInfo>                    CombatSkillDeckDataList;                                  // 0x00A8(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<struct FCombatSkillTreeData>                NodeDataList;                                             // 0x00B8(0x0010) (AlwaysInit, NeedCtorLink)
	struct FBLSkillDeckSizeInfo                        SkillDeckUnlockData;                                      // 0x00C8(0x000C)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLSkillDataManager");
		return ptr;
	}


	void SysMsg_TacticsSave_Fail(struct FSkillDeckData* InSkillDeckData);
	void SysMsg_TacticsSave_Success(struct FSkillDeckData* InSkillDeckData);
	int GetCandidateStanceCid();
	int GetCurrentUseStanceCid();
	void GetSkillDeckSizeInfo(struct FBLSkillDeckSizeInfo* OutSizeInfo);
	bool GetSkillTreeData(int InTreeIndex, struct FBLSkillTreeData* OutTreeData);
	bool GetSkillDeckInfo(int InDeckIndex, struct FBLSkillDeckInfo* OutDeckInfo);
	void GetCurrentSkillDeckInfo(struct FBLSkillDeckInfo* outSkillDeckInfo);
	void GetGemNodeList(int InStartNodeCid, TArray<struct FBLSkillGemInfo>* outGemNodeList);
	void GetParameterNodeList(TArray<struct FBLParameterNode>* OutParameterNodeList);
	void GetNonStanceSkillNodeList(TArray<struct FPointer>* OutNonStanceSkillList);
	void GetChildNodeList(const struct FPointer& InStanceSkillNode, TArray<struct FPointer>* OutStanceSkillList);
	void GetStanceSkillNodeListByStanceCid(int InStanceCid, TArray<struct FPointer>* OutStanceSkillList);
	void GetStanceNodeList(TArray<struct FPointer>* OutStanceSkillList);
	int GetCurrentUseTacticsIndex();
	bool IsActivatedGemNode(int InTacticsIndex, int InNodeCid);
	bool IsEmptySkillDeckTactic(struct FBLSkillDeckInfo* InSkillDeckInfo);
	bool IsLockSkillDeckTactic(int InTacticsIndex);
	int FindParameterStartNodeCid(int InPage);
	void MakeParameter();
	void RemoveNonStanceSkill();
	void MakeNonStanceSkill();
	void RemoveQTESkill(TArray<struct FPointer>* InChildSkillNodes);
	void RemoveStanceSkill(TArray<struct FPointer>* InChildSkillNodes);
	void RemoveStance();
	void MakeQTESkill(int InStanceCid, TArray<struct FBLStanceSkillQTEInfo> InNextQTEList, const struct FPointer& InParents, TArray<struct FPointer>* outChildSkillNodes);
	void MakeStanceSkill(int InStanceCid, TArray<int> InStanceSkillCidList, const struct FPointer& InParents, TArray<struct FPointer>* outChildSkillNodes);
	void MakeStance();
	void UpdateSkillDeckSlotLock();
	void UpdateSkillDeckUnlockData(struct FSkillDeckUnlockData* InSkillDeckSizeData);
	void MakeSkillDeckSlotInfo(TEnumAsByte<ESkillDeckTacticSlotType> InSlotType, int InCombatCid, int InTacticsIndex, struct FBLSkillDeckSlotInfo* outSkillDeckSlotInfo);
	TEnumAsByte<ESkillDeckTacticSlotType> ConvertSlotTypeServerToClient(int InSkillDecDataListIndex);
	void UpdateSkillDeckData(struct FSkillDeckData* InSkillDeckData);
	void UpdateSkillDeckDataList(TArray<struct FSkillDeckData> InSkillDeckDataList);
	void ApplyServerSkillDeckNodeList();
	void UpdateServerSkillDeckNodeList(TArray<struct FCombatSkillTreeData> InDeckDataList);
	bool ChangeSkillDeck(int InTacticsIndex);
	void ClearRemovedNodeData(int InTreeIndex);
	void ClearSkillTreeData();
	void UpdateParameterSkillNodeData(struct FBLSkillNodeData* InNodeData);
	void UpdateNonStanceSkillNodeData(struct FBLSkillNodeData* InNodeData);
	void UpdateStanceSkillNodeData(struct FBLSkillNodeData* InNodeData);
	void UpdateStanceNodeData(struct FBLSkillNodeData* InNodeData);
	void UpdateSkillTreeDataByCombatSkillTreeData(struct FBLSkillTreeData* InSkillTreeData);
	void UpdateServerSkillTreeDataList(TArray<struct FBLSkillTreeData> InTreeDataList);
	bool ChangeSkillTree(int InTreeIndex);
	void ChangeToCurrentSkillTree();
	void ChangeStance();
	void RequestChangeSkillTactics(int InTacticsIndex);
	void ChangeSkillTactics(int InTacticsIndex);
	void Release();
	void Init();
};


// Class BLGame.BLSkillDeckManager
// 0x0174 (0x01D4 - 0x0060)
class UBLSkillDeckManager : public UObject
{
public:
	int                                                UsedStanceGem;                                            // 0x0060(0x0004)
	int                                                UsedNonStanceGem;                                         // 0x0064(0x0004)
	int                                                UsedParameterGem;                                         // 0x0068(0x0004)
	TArray<struct FBLChangedNodeData>                  ChangedStanceNodeList;                                    // 0x006C(0x0010) (NeedCtorLink)
	TArray<struct FBLChangedNodeData>                  ChangedNonStanceNodeList;                                 // 0x007C(0x0010) (NeedCtorLink)
	TArray<struct FBLChangedNodeData>                  ChangedParameterNodeList;                                 // 0x008C(0x0010) (NeedCtorLink)
	struct FBLSkillDeckInfo                            CurrentSkillDeckInfo;                                     // 0x009C(0x009C) (NeedCtorLink)
	struct FBLSkillDeckInfo                            ModifiedSkillDeckInfo;                                    // 0x0138(0x009C) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLSkillDeckManager");
		return ptr;
	}


	int GetUsedParameterGem();
	int GetUsedNonStanceGem();
	int GetUsedStanceGem();
	int GetChangedSkillCidByNonStanceChangedNodeList(int InNonStanceSkillCid);
	int GetChangedSkillCidByStanceChangedNodeList(int InStanceSkillCid);
	bool GetChangedParameterGemNodeData(int InNodeCid, struct FBLChangedNodeData* OutNodeData);
	bool GetChangedNonStanceGemNodeData(int InNodeCid, struct FBLChangedNodeData* OutNodeData);
	bool GetChangedStanceGemNodeData(int InNodeCid, struct FBLChangedNodeData* OutNodeData);
	void GetChangedParameterNodeList(TArray<struct FBLChangedNodeData>* OutList);
	bool IsSelectiveNodeTemporallyActivated(struct FBLSkillGemInfo* InGemInfo);
	bool IsSelectiveNodeActivated(struct FBLSkillGemInfo* InGemInfo);
	bool IsUseSkillGem();
	bool IsSkillNodeDataChanged();
	bool IsSkillDeckDataChanged();
	bool CheckWithdrawGem();
	void ClearChangedDataList();
	void ResetModifiedSkillDeckInfo();
	void AddToChangedParameterNodeList(const struct FBLChangedNodeData& InNodeData);
	void AddToChangedNonStanceNodeList(const struct FBLChangedNodeData& InNodeData);
	void AddToChangedStanceNodeList(const struct FBLChangedNodeData& InNodeData);
	void ModifyRemoveParameterNode(int InTacticsIndex, int InNodeCid, int InPageIndex, int InNodeIndex, bool RemoveByOtherSelectNodeData, bool NeedUpdateSelectiveUI);
	void ModifyRemoveChildSelectiveNode(const struct FBLSkillGemInfo& InChildNodeINfo, int InTacticsIndex, int InNodeCid, int InPageIndex, int InNodeIndex, bool RemoveByOtherSelectNodeData, bool NeedUpdateSelectiveUI);
	void ModifyAddParameterNode(int InTacticsIndex, int InNodeCid, int InPageIndex, int InNodeIndex);
	void ModifyRemoveNonStanceSkillNode(int InTacticsIndex, int InNonStanceCid, int InNodeCid);
	void ModifyAddNonStanceSkillNode(int InTacticsIndex, int InNonStanceCid, int InNodeCid);
	void ModifyRemoveStanceSkillNode(int InTacticsIndex, int InStanceCid, int InNodeCid);
	void ModifyAddStanceSkillNode(int InTacticsIndex, int InStanceCid, int InNodeCid);
	void ModifyParameterNode(int InTacticsIndex, int InNodeCid, int InPageIndex, int InNodeIndex);
	void ModifyNonStanceSkillNode(int InTacticsIndex, int InNonStanceCid, int InNodeCid);
	void ModifyStanceSkillNode(int InTacticsIndex, int InStanceCid, int InNodeCid);
	void ModifyNonStanceSkillSlot(int InNonStanceSkillCid, TEnumAsByte<EBLSkillShortCutUISlotIndex> InUIIndex, bool InAdd);
	void ModifyStanceSlot(int InStanceCid, TEnumAsByte<EBLSkillShortCutUISlotIndex> InUIIndex, bool InAdd);
	bool GetModifiedSkillDeckInfo(int InTacticsPageIndex, struct FBLSkillDeckInfo* OutDeckInfo);
	class UPlayerRepInfo* GetPlayerRepInfo();
	class UBLSkillGemManager* GetSkillGemManager();
	class UBLSkillDataManager* GetSkillDataManager();
	void RequestUpdateModifyTactics(int InTacticsIndex);
	void RequestResetTactics(int InPageIndex);
	void UpdateCurrentSkillDeckInfo();
	void UpdateTacticPageData(int InPageIndex);
	void Init();
};


// Class BLGame.BLSkillGemManager
// 0x0008 (0x0068 - 0x0060)
class UBLSkillGemManager : public UObject
{
public:
	TEnumAsByte<EBLGemExchangeUIPageType>              CurrentPageType;                                          // 0x0060(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	int                                                GemExchangeCount;                                         // 0x0064(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLSkillGemManager");
		return ptr;
	}


	void RequestGemPieceExchange();
	void OnClickExchangeResultButton();
	void OnClickExchangeGemPieceStepper(int InGemCount);
	void OnClickExchangeCancelButton();
	void OnClickExchangeSubmitButton();
	void OpenCautionDialog();
	void OnUpdatePCExchangeCount();
	void OnUpdateGemPiece();
	void UpdateGemExchangeResultUI(int InStanceGem, int InNonStanceGem, int InParameterGem, TArray<struct FGemExchangedItemData> InResultItemList);
	void UpdateGemExchangeCountUI();
	void UpdateGemExchangeUI();
	void CloseGemExchangeUI();
	void OpenGemExchangeUI();
	void Init();
};


// Class BLGame.BLSkillQTEHUDManager
// 0x008C (0x00EC - 0x0060)
class UBLSkillQTEHUDManager : public UObject
{
public:
	float                                              FinishEffectDurationTime;                                 // 0x0060(0x0004) (Config)
	struct FMap_Mirror                                 StanceSkillChainList;                                     // 0x0064(0x0048) (Native)
	TArray<struct FBLQTEHUDInfo>                       NextStanceSkillHUDInfoList;                               // 0x00AC(0x0010) (AlwaysInit, NeedCtorLink)
	struct FBLGaugeInfo                                GaugeInfo;                                                // 0x00BC(0x000C)
	struct FBLGaugeInfo                                PreGaugeInfo;                                             // 0x00C8(0x000C)
	TEnumAsByte<EBLStanceStep>                         StanceStep;                                               // 0x00D4(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x00D5(0x0003) MISSED OFFSET
	float                                              FinishAniTime;                                            // 0x00D8(0x0004)
	int                                                UseCombatCid;                                             // 0x00DC(0x0004)
	float                                              ChainStateTick;                                           // 0x00E0(0x0004)
	float                                              QTEInputTick;                                             // 0x00E4(0x0004)
	float                                              SkillCastingTick;                                         // 0x00E8(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLSkillQTEHUDManager");
		return ptr;
	}


	void ClearSkillCastingTick();
	void PlayStanceActionSound(TEnumAsByte<EBLStanceStep> InStanceStep);
	void ChangeStance();
	void UseQTESkillChain(TEnumAsByte<ECEQTEKeyType> InQTEKeyType, bool bPress);
	void NotifyQTESkillChain(int InPreCombatSkillCid, int InChainCount, float InChainStateTime, float InQTEInputTime);
	void MakeQTESkillChain(TArray<struct FPointer> InChildSkillNodeList, int InStanceSkillCid);
	void UpdateStanceSkillChainList();
	void SetQTEInputGaugeData(float InGaugeTime, TEnumAsByte<EBLGaugeUseType> InGaugeUseType);
	void SetSkillGaugeData(int InSkillCid, bool bAutoHide, float inTime, float InTotalTime);
	void HoldGaugeUI();
	bool CheckHideGauge();
	void HideGaugeUI(bool bForce);
	void ShowGaugeUI(bool bAutoHide);
	void ShowFinishUI();
	void HideChangeStanceStateEffect();
	void ShowChangeStanceStateEffect();
	void HideChainCountUI();
	void ShowChainCountUI(int InChainCount, float InChainStateTick);
	void SetUsingStanceSkill(int InIconIndex, bool bHold);
	bool CheckHideUsingStanceSkill();
	void HideUsingStanceSkillUI(bool bForce);
	void ShowUsingStanceSkillUI();
	void ShowStanceSkillEquip();
	void ShowStanceSkillCoolDown();
	void HideQTEChainLineUI();
	void ShowQTEChainLineUI(TEnumAsByte<EBLQTESlotAniType> InQTESlotAniType);
	void ClearQTEStanceSkill();
	void SetNextStanceSkillChain(int InCombatCid);
	void HideStanceSkillChainUI();
	void ShowStanceSkillChainUI();
	void SetUseCombatCid();
	void ProcessStanceStep();
	void ChangeStanceStep();
	void SetStanceStep(TEnumAsByte<EBLStanceStep> InStanceStep);
	class UBLSkillQTEHUDUIManager* GetSkillQTEHUDUIManager();
	class UBLSkillDataManager* GetSkillDataManager();
	void Tick(float InDeltaTime);
	void Init();
};


// Class BLGame.BLSkillTacticsDeckManager
// 0x0074 (0x00D4 - 0x0060)
class UBLSkillTacticsDeckManager : public UObject
{
public:
	int                                                TacticsDeckCountMax;                                      // 0x0060(0x0004) (Const)
	int                                                CashSkillDeckIndex;                                       // 0x0064(0x0004) (Const)
	int                                                ActionBarCountMax;                                        // 0x0068(0x0004) (Const)
	struct FSkillDeckUnlockData                        UnlockSkillTacticsDeckData;                               // 0x006C(0x000C)
	int                                                UseTaticsNumber;                                          // 0x0078(0x0004)
	int                                                MyTotalSkillPoint;                                        // 0x007C(0x0004) (Transient)
	int                                                SPLevel;                                                  // 0x0080(0x0004) (Transient)
	int                                                SPExp;                                                    // 0x0084(0x0004) (Transient)
	int                                                SPExpCurrentLevel;                                        // 0x0088(0x0004) (Transient)
	int                                                SPExpPrevLevel;                                           // 0x008C(0x0004) (Transient)
	int                                                SPExpMaxLevel;                                            // 0x0090(0x0004) (Transient)
	TArray<struct FSkillTreeData>                      SkillTreeDataList;                                        // 0x0094(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<struct FSkillDeckData>                      SkillDeckDataList;                                        // 0x00A4(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<class UBLSkillTacticsTreeDeck*>             TacticsTreeDeckList;                                      // 0x00B4(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<int>                                        SkillResetItemCidList;                                    // 0x00C4(0x0010) (AlwaysInit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLSkillTacticsDeckManager");
		return ptr;
	}


	int GetSPExpPercent();
	int GetCurrentLevelExpMax();
	int GetCurrentLevelExp();
	bool IsSPExpMaxLevel();
	void UpdateSPExpBar();
	void SetSPExp(int InSPExp);
	void SetSPLevel(int InSPLevel);
	void SetSPLevelUp(int InSPLevel);
	void SetExpRangeByLevel();
	void AllTacticsCancle();
	void ConfirmChange(int InTacticsNumber);
	void UseTactics(int InTacticsNumber);
	bool IsUseSelectTactics(int InTacticsNumber);
	int RemainSkillPoint(int InTacticsNumber);
	class UBLSkillTacticsSkill* GetTreeSkill(int InTacticsNumber, int InSkillTreeCid);
	class UBLSkillTacticsTreeDeck* GetTactics(int InTacticsNumber);
	bool HaveResetItem();
	void InitSkillResetItem();
	void Init();
};


// Class BLGame.BLSkillTacticsTreeDeck
// 0x0050 (0x00B0 - 0x0060)
class UBLSkillTacticsTreeDeck : public UObject
{
public:
	int                                                UsedSP;                                                   // 0x0060(0x0004)
	int                                                ChangeUsedSP;                                             // 0x0064(0x0004)
	int                                                TacticsNumber;                                            // 0x0068(0x0004)
	TArray<class UBLSkillTacticsSkill*>                SkillTacticsTreeSkillList;                                // 0x006C(0x0010) (NeedCtorLink)
	struct FString                                     DeckName;                                                 // 0x007C(0x0010) (NeedCtorLink)
	int                                                SkillAutoFiringCid;                                       // 0x008C(0x0004)
	TArray<int>                                        ActionSkillCidList;                                       // 0x0090(0x0010) (NeedCtorLink)
	TArray<int>                                        ChangeActionSkillCidList;                                 // 0x00A0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLSkillTacticsTreeDeck");
		return ptr;
	}


	void RemoveActionbar(int InIndex);
	void AddActionbar(int InIndex, int InSkillCid, bool InIsActionBar);
	bool DecreaseSkill(int InSkillTreeCid);
	bool IncreaseSkill(int InSkillTreeCid);
	class UBLSkillTacticsSkill* GetTreeSkill(int InSkillTreeCid);
	void CancleTactics();
	void ResetTactics();
	TEnumAsByte<ETacticsTreeSkillLevelState> GetSkillLevelState(int InSkillTreeCid);
	TEnumAsByte<ETacticsTreeSkillState> GetSkillState(int InSkillTreeCid);
	bool IsDefaultSkill(int InSkillTreeCid);
	bool IsSkillMax(int InSkillTreeCid);
	bool IsSkillPointZero();
	bool IsSkillOtherPrecedeSkill(int InSkillTreeCid);
	bool IsLearnSkillBySkillTreeCid(int InSkillTreeCid, int InLevel);
	bool IsOrignalLearnSkillBySkillTreeCid(int InSkillTreeCid, int InLevel);
	bool IsLearnPrecedeSkill(int InSkillTreeCid);
	bool IsRegisterActionSkillDeck(int InSkillTreeCid);
	bool IsChangeTacticsSkillAndActionBar();
	bool IsChangeTacticsSkill();
	void SetActionSkillCidList(TArray<int>* InSkillCidList);
	void SetTreeSkillList(TArray<struct FSkillTreeNodeData>* InTreeSkillList);
	void SetChangeActionSkillDeckData(struct FSkillDeckData* InSkillDeckData);
	void GetChangeActionSkillDeckData(struct FSkillDeckData* InSkillCidList);
	void SetSkillTreeData(struct FSkillTreeData* InSkillTreeData);
	void GetChangeTreeSkillList(TArray<struct FSkillTreeNodeData>* InTreeSkillList);
};


// Class BLGame.BLSkillTacticsSkill
// 0x000C (0x006C - 0x0060)
class UBLSkillTacticsSkill : public UObject
{
public:
	int                                                SkillTreeCid;                                             // 0x0060(0x0004)
	int                                                SkillLevel;                                               // 0x0064(0x0004)
	int                                                ChangeSkillLevel;                                         // 0x0068(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLSkillTacticsSkill");
		return ptr;
	}


	bool GetSkillCidOrStatCid(int* OutCid);
	int GetSkillLevelMax();
	int GetPCLevelLimit();
	void Reset();
	void Cancle();
	bool IsChanged();
	int GetCurrentSkillLevel();
};


// Class BLGame.BLUIPlayer
// 0x00D4 (0x02B8 - 0x01E4)
class UBLUIPlayer : public UGFxMoviePlayer
{
public:
	class UGFxObject*                                  UIMain;                                                   // 0x01E4(0x0008)
	class UGFxObject*                                  UICursor;                                                 // 0x01EC(0x0008)
	class UGFxUI_Minimap*                              Minimap;                                                  // 0x01F4(0x0008)
	class UGFxUI_MinimapExtension*                     MinimapExtension;                                         // 0x01FC(0x0008)
	class UGFxUI_CharInfo*                             CharInfo;                                                 // 0x0204(0x0008)
	class UGFxUI_PopupMenu*                            PopupMenuUI;                                              // 0x020C(0x0008)
	class UGFxWidget_Dialog*                           DialogUI;                                                 // 0x0214(0x0008)
	class UGFxWidget_RevivalDialog*                    RevivalDialogUI;                                          // 0x021C(0x0008)
	class UGFxStream*                                  stream;                                                   // 0x0224(0x0008)
	unsigned long                                      bClosing : 1;                                             // 0x022C(0x0004)
	unsigned long                                      Initialized : 1;                                          // 0x022C(0x0004)
	unsigned long                                      bHitOnUI : 1;                                             // 0x022C(0x0004)
	unsigned long                                      bClientTickSend : 1;                                      // 0x022C(0x0004)
	float                                              HitOnUICheckTime;                                         // 0x0230(0x0004)
	TArray<struct FName>                               FilterInputNames;                                         // 0x0234(0x0010) (NeedCtorLink)
	struct FColor                                      LatestTargetHPColor;                                      // 0x0244(0x0004)
	struct FColor                                      LatestTargetNameColor;                                    // 0x0248(0x0004)
	struct FColor                                      LatestTargetLevelColor;                                   // 0x024C(0x0004)
	struct FString                                     LastestPawnTitle;                                         // 0x0250(0x0010) (NeedCtorLink)
	float                                              OnGoingQuestCountDownUpdateTimer;                         // 0x0260(0x0004)
	float                                              OnGoingQuestCountDownUpdateInterval;                      // 0x0264(0x0004) (Const)
	class UBLSkillTacticsUIManager*                    SkillTacticsUIManager;                                    // 0x0268(0x0008)
	struct FString                                     CurrentOpenedTabNameOfJournal;                            // 0x0270(0x0010) (NeedCtorLink)
	int                                                AppearanceTypeUI_Appearance;                              // 0x0280(0x0004) (Const)
	int                                                AppearanceTypeUI_Gender;                                  // 0x0284(0x0004) (Const)
	struct FString                                     LetterInfoString;                                         // 0x0288(0x0010) (NeedCtorLink)
	TArray<int>                                        ClientTokenTypeToUITokenType;                             // 0x0298(0x0010) (NeedCtorLink)
	TArray<TEnumAsByte<ECEContentTokenType>>           UITokenTypeToClientTokenType;                             // 0x02A8(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLUIPlayer");
		return ptr;
	}


	void AU_Credit_Click_Next();
	void AU_Credit_Click_Prev();
	void AU_Credit_Close();
	void AU_Credit_Open();
	void UA_Credit_Set_Player(const struct FString& InImagePath, const struct FString& InTitle);
	void UA_Credit_Set_Data(class UGFxObject* InCreditData);
	void UA_Credit_Close();
	void UA_Credit_Open();
	void UpdateLumenaByTokenType(const struct FString& InCoin);
	void UpdateContentTokenByTokenType(unsigned char InTokenType, const struct FString& InCoin);
	void UpdateContentTokenData();
	void UpdateExchangeableLumenaData();
	void UpdateLumenaData();
	void UpdateContentTokenExchangeData(int ExchangeableLumena);
	int GetMinExchangeableLumena();
	int GetMaxExchangeableLumena();
	void OpenTokenExchange(int InDPtoLumenaRate, int InCPtoLumenaRate, int InExchangeableLumena, int InMaxExchangeCTtoLumena, int InAdditionalExchangeableLumena, int InLumenaExchangeResetTime);
	void AU_TokenExchange_Click_Min();
	void AU_TokenExchange_Click_Max();
	void AU_TokenExchange_Click_Confirm();
	void AU_TokenExchange_Change_Value(const struct FString& InLumenaValue);
	void AU_TokenExchange_Change_Type(TEnumAsByte<ECoinType> InCoinType);
	void AU_TokenExchange_UI_Open();
	void UA_TokenExchange_Set_Lumena_Data(class UGFxObject* inObj);
	void UA_TokenExchange_Set_My_Token(int InTokenType, const struct FString& InTokenValue);
	void UA_TokenExchange_Set_Exchange_Data(class UGFxObject* inObj);
	void UA_TokenExchange_Set_Rate_Data(class UGFxObject* inObj);
	void AU_DialogGem_ExchangeResult_Submit();
	void AU_DialogGem_ExchangeRequest_Amount(int InGemCount);
	void AU_DialogGem_ExchangeRequest_Submit(bool InSubmit);
	void UA_DialogGem_Close();
	void UA_DialogGem_Open();
	void UA_DialogGem_ExchangeResult(class UGFxObject* inObj);
	void UA_DialogGem_ExchangeRequest(class UGFxObject* inObj);
	void AU_SkillDeck_SubmitDeletePop();
	void AU_SkillDeck_SetShortcut(int InSlotIndex, int InCid, bool InAdd);
	void AU_SkillDeck_ExchangeGem();
	void AU_SkillDeck_Cancel();
	void AU_SkillDeck_Submit();
	void AU_SkillDeck_Open_SelectiveParnmeterPop(int InCid, int InPageIndex, int InNodeIndex);
	void AU_SkillDeck_AddGem_Parameter(int InCid, int InPageIndex, int InNodeIndex);
	void AU_SkillDeck_AddGem_NonStance(int InNonStanceCid, int InNodeCid);
	void AU_SkillDeck_AddGem_Stance(int InStanceCid, int InNodeCid);
	void AU_SkillDeck_SetNonStanceTop(int InCid);
	void AU_SkillDeck_SelectNonStanceTop(int InCid);
	void AU_SkillDeck_SetStanceTop(int InCid);
	void AU_SkillDeck_SelectStanceTop(int InCid);
	void AU_SkillDeck_SelectTab(int InTabIndex);
	void AU_SkillDeck_ClearTactics();
	void AU_SkillDeck_SetTactics();
	void AU_SkillDeck_ShowTactics(int InPageIndex);
	void AU_SkillDeck_UI_Close();
	void AU_SkillDeck_UI_Open();
	void UA_SkillDeck_Activate_Btns(bool InEnableResetButton, bool InEnableCancelButton, bool InEnableSaveButton);
	void UA_SkillDeck_ShowShortcut(bool InShow);
	void UA_SkillDeck_SetGemNum(const struct FString& InGemPiece, const struct FString& InStanceGem, const struct FString& InNonStanceGem, const struct FString& InParameterGem);
	void UA_SkillDeck_SetTab(int InTabIndex);
	void UA_SkillDeck_SetClass(int InClassCid);
	void UA_SkillDeck_SetTactics(int InPageIndex, const struct FString& InTacticsName, const struct FString& InTacticsUseBtnText, const struct FString& InTacticsResetBtnText);
	void UA_SkillDeck_SetTactic_Lock(TArray<int> InLockTabIndexList);
	void UA_SkillDeck_SetParamList(TArray<class UGFxObject*> InObjList);
	void UA_SkillDeck_UpdateParameterParam(class UGFxObject* inObj);
	void UA_SkillDeck_SelectiveParam(class UGFxObject* InLeftObj, class UGFxObject* InRightObj);
	void UA_SkillDeck_SetParmaterTree(TArray<class UGFxObject*> InObjList);
	void UA_SkillDeck_UpdateNonStanceParam(class UGFxObject* inObj);
	void UA_SkillDeck_NonStanceSkill(class UGFxObject* InSkillObj, TArray<class UGFxObject*> InNodeTop, TArray<class UGFxObject*> InNodeMiddle, TArray<class UGFxObject*> InNodeBottom);
	void UA_SkillDeck_SelectNonStanceTop(class UGFxObject* inObj);
	void UA_SkillDeck_SetNonStanceTopList(TArray<class UGFxObject*> InObjList);
	void UA_SkillDeck_UpdateStanceParam(class UGFxObject* inObj);
	void UA_SkillDeck_SetStanceSkillTree(TArray<class UGFxObject*> InObjList);
	void UA_SkillDeck_StanceSkillList(TArray<class UGFxObject*> InObjList);
	void UA_SkillDeck_SelectStanceTop(class UGFxObject* inObj);
	void UA_SkillDeck_SetStanceTopList(TArray<class UGFxObject*> InObjList);
	void UA_SkillDeck_SetShortcut(TArray<class UGFxObject*> InObjList);
	void AU_PartyEffect_Click_Type_Deactive(int InCategoryType);
	void AU_Click_Party_Effect();
	void AU_PartyEffect_Click_Effect_List_Item(int InSelectedPartyEffectCid);
	void AU_PartyEffect_Click_Apply();
	void AU_PartyEffect_Select_Type(int InSelectedType);
	void AU_PartyEffect_Select_Tab(int InSelectedIndex);
	void AU_PartyEffect_UI_Close();
	void AU_PartyEffect_UI_Open();
	void UA_PartyEffect_Active_Effect_List(int InCategoryCid, int InEffectCid, int InFold);
	void UA_PartyEffect_Select_Effect_List(int InCategoryCid, int InEffectCid, int InFold);
	void UA_PartyEffect_Disable_Tab(int InPartyIndex, bool IsDisable);
	void UA_PartyEffect_Set_Apply_Button(bool IsApply, bool IsDisable);
	void UA_PartyEffect_Select_Tab(int InSelectecTab);
	void UA_PartyEffect_Select_Type(int InSelectedType);
	void UA_PartyEffect_Set_Living_Data(class UGFxObject* InLivingEffectInfo);
	void UA_PartyEffect_Set_Combat_Data(class UGFxObject* InCombatEffectInfo);
	void UA_RaidFrame_Set_PartyEffect_Living(int InIndex, class UGFxObject* InLivingEffect);
	void UA_RaidFrame_Set_PartyEffect_Combat(int InIndex, class UGFxObject* InCombatEffect);
	void UA_Party_Set_PartyEffect_Living(class UGFxObject* InLivingEffect);
	void UA_Party_Set_PartyEffect_Combat(class UGFxObject* InCombatEffect);
	void UA_PartyEffect_Set_Effect_Info_Data(class UGFxObject* InEffectInfoData);
	void UA_PartyEffect_Set_Effect_Condition_Data(class UGFxObject* InConditionData);
	void UA_PartyEffect_Set_Effect_List_Data(class UGFxObject* InPartyEffectDataList);
	void UA_PartyEffect_Set_Member_Data(class UGFxObject* InPartyMemeberDataList);
	void InputQTEChainKey(int InCombatCid, int InSkillCid, bool bPress);
	void AU_QTEActionBar_QTE2Slot_ValueRequest(int InCid, int InUISlotType);
	void UA_QTEActionBar_SetQTE2SlotVisible(int InUISlotType, bool bVisible);
	void UA_QTEActionBar_SetQTE2Slot(int InUISlotType, class UGFxObject* InData);
	void UA_QTEActionBar_SetGageHold();
	void UA_QTEActionBar_SetQTESlotInput(int InSlotIndex, bool bPress);
	void UA_QTEActionBar_SetQTESlotChainLevel(int InSlotIndex, int inCurrentLevel, int InMaxLevel);
	void UA_QTEActionBar_SetQTEChainLineAction(int InAniType);
	void UA_QTEActionBar_SetQTESlotCoolTime(int InSlotIndex, float InRemainTime, float InTotalTime);
	void UA_QTEActionBar_SetQTEChainSlotActionClear();
	void UA_QTEActionBar_SetQTEChainSlotAction(int InSlotSequenceType, class UGFxObject* InQTEChainSlotObject);
	void UA_QTEActionBar_SetQTESlotActionClear();
	void UA_QTEActionBar_SetQTESlotAction(class UGFxObject* InQTESlotObject);
	void UA_QTEActionBar_SetQTEChainFinishActionClear();
	void UA_QTEActionBar_SetQTEChainFinishAction();
	void UA_QTEActionBar_SetQTEChainActionClear();
	void UA_QTEActionBar_SetQTEChainAction(int InChainCount);
	void UA_QTEActionBar_SetGage(class UGFxObject* InGaugeObject);
	void UA_QTEActionBar_SetGageVisible(bool IsVisible);
	void AU_Mission_Click_List(int InIndex);
	void AU_Mission_Click_BtnOperation();
	void AU_Mission_Swap_Fellow(int InFromStage, int InFromSlot, int InToStage, int InToSlot);
	void AU_Mission_Set_Fellow(int InStageIndex, int InSlotIndex, const struct FString& InUid);
	void AU_Mission_UI_Close();
	void AU_Mission_UI_Open();
	void UA_Mission_Set_UseContract(const struct FString& InTicketText);
	void UA_Mission_Set_ButtonState(const struct FString& InText, bool InEnable);
	void UA_Mission_Select_SecondDefficulty(int InStageIndex);
	void UA_Mission_Add_Fellow(const struct FString& InSid);
	void UA_Mission_Set_ContractTimer(const struct FString& inTime);
	void UA_Mission_Set_ContractCount(const struct FString& InCount);
	void UA_Mission_Update_Fellow(int InIndex, int InSlotIndex, class UGFxObject* InFellowObj, const struct FString& InSuccessPercent);
	void UA_Mission_Update_Details(int InIndex, class UGFxObject* inObj);
	void UA_Mission_Set_Details(TArray<class UGFxObject*> InObjList);
	void UA_Mission_Update_DifficultyList(class UGFxObject* inObj);
	void UA_Mission_Set_DifficultyList(TArray<class UGFxObject*> InObjList);
	void AU_WarConquestList_List_Index(int InListIndex);
	void AU_WarConquestList_Selected_Tab(int InTabIndex);
	void AU_WarConquestList_Click_Button(int InBtnType);
	void AU_WarConquestList_UI_Close();
	void AU_Open_WarConquestList();
	void UA_WarConquestList_Select_Tab(int InTabIndex);
	void UA_WarConquestList_Set_ListData(TArray<class UGFxObject*> InWarConquestDataList, int InSelectIndex);
	void UA_WarConquestList_Set_Info(class UGFxObject* InInfoObject);
	void UA_WarConquestList_Set_Btn(class UGFxObject* InBtnObject);
	void UA_Private_Trade_Locked_By_Confirm_Other(bool bTrue);
	void UA_Private_Trade_Locked_By_Confirm_My(bool bTrue);
	void UA_Private_Trade_Set_Other_Item(class UGFxObject* ItemData);
	void UA_Private_Trade_Set_My_Item(class UGFxObject* ItemData);
	void UA_Private_Trade_Set_Other_Title(const struct FString& InTitle);
	void UA_Private_Trade_Set_My_Title(const struct FString& InTitle);
	void UA_Private_Trade_Set_OtherName(const struct FString& InName);
	void UA_Private_Trade_Clear_Other_Items();
	void UA_Private_Trade_Clear_My_Items();
	void UA_Private_Trade_Set_MyName(const struct FString& InName);
	void UA_Private_Trade_Set_OtherGold(const struct FString& Gold);
	void UA_Private_Trade_Set_MyGold(const struct FString& Gold);
	void UA_Private_Trade_Set_Title(const struct FString& TitleString);
	void UA_Private_Trade_Lock(bool bLock);
	void UA_Private_Trade_Close();
	void UA_Open_Private_Trade();
	void UA_Journal_Set_Guide_Quest_Summary(const struct FString& Summary);
	void UA_Journal_Remove_Guide_Stage_Info(int StageID);
	void UA_Journal_Add_Guide_Stage_Info(int StageID, const struct FString& StageName, bool extension, int Primary);
	void UA_Journal_Complete_Guide_List(int StageID, TArray<class UGFxObject*> CompleteGuideList);
	void UA_Journal_Remove_Guide_Quest(int questId, int StageID);
	void UA_Journal_Add_Guide_Quest(int questId, int StageID, int QuestLevel, const struct FString& QuestTitle, bool isCompleted, bool isFailed, bool isActive, float QuestTimeLimit, bool IsDisable);
	void UA_Journal_Complete_Guide_Quest_Detail_Info(int questId, class UGFxObject* QuestInfo, int StageID, bool QuestAbandon, const struct FString& QuestContent, int QuestObjectiveType, int SelectiveCount, TArray<class UGFxObject*> Objectives, TArray<class UGFxObject*> BonusObjectives);
	void UA_Journal_Set_Guide_Quest_Detail_Info(int questId, int StageID, const struct FString& QuestTitle, bool QuestAbandon, bool PositioningCheckDisabled, const struct FString& QuestContent, int TimeLimit, int QuestObjectiveType, int SelectiveCount, TArray<class UGFxObject*> Objectives, TArray<class UGFxObject*> BonusObjectives, TArray<class UGFxObject*> UsableItems);
	void UA_Journal_Init_Guide_Quest_List(TArray<class UGFxObject*> Lists, int CurrnetActiveQuest, int MaxActiveQuest);
	void AU_Journal_Set_MonsterAlert_OnHeadIcon(bool IsChecked);
	void SetJournalTabOpenLevel();
	void AU_Journal_RenderTarget();
	void AU_Journal_Register(class UGFxObject* mc);
	void UA_Journal_Set_Open_Level(int InIndex, int InOpenLevel);
	void UA_Journal_SetRender();
	void UA_Journal_Set_Active_Alert_Count(int CurrentCount, int MaxCount);
	void UA_Journal_Set_Disable_RewardButton_Monster(bool InDisabled);
	void UA_Journal_Set_Tab_Count(int TabIndex, int COUNT);
	void UA_Journal_Set_New_Royal_Quest(int COUNT);
	void UA_Journal_Update_Monster_Data_By_LocationID(class UGFxObject* InLocationObject);
	void UA_Journal_Update_Monster_Data_By_BookID(int InLocationId, class UGFxObject* InMonsterInfo);
	void UA_Journal_Set_Monster_Objective(TArray<class UGFxObject*> ObjectiveList, bool AllObjectivesCompleted, bool Visible, bool Enable, const struct FString& Label);
	void UA_Journal_Set_Monster_Info(class UGFxObject* MonsterInfo, TArray<class UGFxObject*> Skills);
	void UA_Journal_Init_Monster_List(TArray<class UGFxObject*> MonsterLists, int CurrnetActiveQuest, int MaxActiveQuest, bool IsOnHeadIcon);
	void UA_Journal_Set_Quest_Summary(const struct FString& Summary);
	void UA_Journal_Init_Quest_Reward();
	void UA_Journal_Story_Refresh();
	void UA_Journal_Update_Story_Quest(int StoryID, int PlotIndex);
	void UA_Journal_Add_Story_Plot(int StoryID, class UGFxObject* StoryObject);
	void UA_Journal_Add_Story(class UGFxObject* StoryObject);
	void UA_Journal_Complete_Episode_List(int LocationID, TArray<class UGFxObject*> CompleteEpisodeList);
	void UA_Journal_List_Refresh();
	void UA_Journal_Update_Quest(int questId, TEnumAsByte<EActionScript_QuestType> QuestType, int LocationID, int QuestLevel, const struct FString& QuestTitle, bool isCompleted, bool isFailed, bool isActive, bool IsDisable);
	void UA_Journal_Remove_Quest(int questId, int LocationID);
	void UA_Journal_Add_Quest(int questId, int LocationID, int QuestLevel, const struct FString& QuestTitle, bool isCompleted, bool isFailed, bool isActive, float QuestTimeLimit);
	void UA_Journal_Remove_Location_Info(int LocationID);
	void UA_Journal_Add_Location_Info(int LocationID, const struct FString& LocationName, bool extension, int Primary);
	void UA_Journal_Show_Select_Quest(TEnumAsByte<EActionScript_QuestType> QuestType, int questId, int LocationID);
	void UA_Journal_LockUI(bool bLock, bool bHaveCloseAction);
	void UA_Journal_Set_Plot_History(const struct FString& PlotHistory);
	void UA_Journal_Set_Quest_Reward2(int QuestType, TArray<class UGFxObject*> rewards);
	void UA_Journal_Set_Quest_Reward(int questId, TEnumAsByte<ECEQuestType> QuestType, int RewardMoney, int RewardExp, bool isBonus, int BonusRewardMoney, int BonusRewardExp, TArray<class UGFxObject*> FixedRewards, TArray<class UGFxObject*> SeletiveRewards, class UGFxObject* tokenObject, bool IsShowReceiveRewardButton, bool IsGuideVisible, bool IsGuideDisable);
	void UA_Journal_Set_Quest_DetailInfo(int questId, int QuestType, const struct FString& Title, const struct FString& Content, bool isCompleted, bool isFailed, bool onGoingLevel, bool abandon, int TimeLimit, int ObjectiveType, int SelectiveCount, TArray<class UGFxObject*> Objectives, TArray<class UGFxObject*> useItems, bool positioning);
	void UA_Journal_Set_Royal_Quest_Summary(const struct FString& Summary);
	void UA_Journal_Complete_Quest_Detail_Info(int questId, class UGFxObject* QuestInfo, int LocationID, bool QuestAbandon, const struct FString& QuestContent, int QuestObjectiveType, int SelectiveCount, TArray<class UGFxObject*> Objectives, TArray<class UGFxObject*> BonusObjectives);
	void UA_Journal_Set_Quest_Detail_Info(int questId, int LocationID, const struct FString& QuestTitle, bool QuestAbandon, bool PositioningCheckDisabled, const struct FString& QuestContent, int TimeLimit, int QuestObjectiveType, int SelectiveCount, TArray<class UGFxObject*> Objectives, TArray<class UGFxObject*> BonusObjectives, TArray<class UGFxObject*> UsableItems);
	void UA_Journal_Set_Plot_Info(class UGFxObject* PlotInfo, TArray<class UGFxObject*> Objectives, TArray<class UGFxObject*> UsableItems);
	void UA_Journal_Init_Royal_Quest(TArray<class UGFxObject*> Quests);
	void UA_Journal_Init_Story_Info(TArray<class UGFxObject*> Lists);
	void UA_Journal_Init_Quest_List(TArray<class UGFxObject*> Lists, int CurrnetActiveQuest, int MaxActiveQuest);
	void UA_Journal_Select_Tab(int TabIndex);
	void AU_Inventory_Add_Succeed_Item(const struct FString& Sid);
	void AU_Succeed_Click_Chk_Option2(bool Selected);
	void AU_Succeed_Click_Chk_Option1(bool Selected);
	void AU_Succeed_Clear_OptionItem(int Index);
	void AU_Succeed_Clear_MaterialItem();
	void AU_Succeed_Clear_ConsumeItem();
	void AU_Succeed_Clear_TargetItem();
	void AU_Succeed_Drop_ConsumeItem_FromInventory(const struct FString& Sid);
	void AU_Succeed_Drop_TargetItem_FromInventory(const struct FString& Sid);
	void AU_Succeed_Click_SucceedButton();
	void AU_Succeed_Closed();
	void AU_Succeed_Click_CloseButton();
	void UA_Succeed_Set_Disable_SucceedButton(bool Disable);
	void UA_Succeed_Clear_ConsumeItem();
	void UA_Succeed_InitContent();
	void UA_Succeed_Set_Expectation(class UGFxObject* ItemData, const struct FString& ItemInfo);
	void UA_Succeed_Set_HelperGuide(bool IsShow, int Mode, const struct FString& Guide);
	void UA_Succeed_Set_OptionItem(TArray<class UGFxObject*> ItemDataList);
	void UA_Succeed_Set_MaterialItem(class UGFxObject* ItemData);
	void UA_Succeed_Set_ConsumeItem(class UGFxObject* ItemData);
	void UA_Succeed_Set_TargetItem(class UGFxObject* ItemData);
	TEnumAsByte<ECB_CompanionType> GetMPFTypeFromNPCCid(int InNPCCid);
	void AU_InterfaceSettingUI_Set_Beginner_Guide_Off(bool InIsOn);
	void AU_BegginersGuide_Click_Close();
	void UA_BeginnersGuide_Close();
	void UA_BeginnersGuide_Open();
	void UA_BeginnersGuide_Set_Data(TArray<class UGFxObject*> GuideDataList);
	void AU_EquipEvolution_Clear_TargetItem();
	void AU_Equip_Add_EquipEvolution_Item(const struct FString& ItemSid);
	void AU_Inventory_Add_EquipEvolution_Item(const struct FString& ItemSid);
	void AU_EquipEvolution_Drop_TargetItem_FromEquip(const struct FString& ItemSid);
	void AU_EquipEvolution_Drop_TargetItem_FromInventory(const struct FString& ItemSid);
	void AU_EquipEvolution_Confirm();
	void AU_EquipEvolution_Clicked_CloseButton();
	void AU_EquipEvolution_Closed();
	void UA_EquipEvolution_Show_MaxGuide();
	void UA_EquipEvolution_SetDisable_Confirm(bool bDisable);
	void UA_EquipEvolution_InitContent();
	void UA_EquipEvolution_Set_Requirement_Second(class UGFxObject* EvolutionItemData, const struct FString& ItemStatInfomation);
	void UA_EquipEvolution_Set_Requirement_First(class UGFxObject* EvolutionItemData, const struct FString& ItemStatInfomation);
	void UA_EquipEvolution_Set_Expectation(class UGFxObject* EvolutionItemData, const struct FString& ItemStatInfomation);
	void UA_EquipEvolution_Set_TargetItem(class UGFxObject* EvolutionItemData, const struct FString& ItemStatInfomation);
	void AU_Disassemble_Enable_Confirm();
	void AU_Disassemble_Clear_Target_Item();
	void AU_Disassemble_Click_Close();
	void AU_Disassemble_Closed();
	void AU_Disassemble_Click_Cancel(const struct FString& Sid);
	void AU_Disassemble_Click_Confirm(int ItemCount);
	void AU_Inventory_Add_Disassemble_Item(const struct FString& Sid);
	void AU_Disassemble_Drop_TargetItem_FromInventory(const struct FString& Sid);
	void AU_Disassemble_Drop_TargetItem_FromEquip(const struct FString& Sid);
	void UA_EquipUpgrade_InitContent();
	void UA_Disassemble_Set_Disable_Confirm(bool Disabled);
	void UA_Disassemble_Complete(int ResultType);
	void UA_Disassemble_Start(int ItemCount, float Time, const struct FString& Guide);
	void UA_Disassemble_Set_ItemCount(int CurItemCount, int MaxItemCount);
	void UA_Disassemble_Clear_TargetItem();
	void UA_Disassemble_Set_TargetItem(class UGFxObject* TargetItemData);
	void AU_EquipConvertResult_Closed(int ConvertMode);
	void AU_EquipConvertResult_Click_OK();
	void UA_EquipConvertResult_InitContent();
	void UA_EquipConvertResult_SetResult_Succeed(int ResultType, class UGFxObject* ItemData, class UGFxObject* ItemInfoData);
	void UA_EquipConvertResult_SetResult_Evolution(int ResultType, class UGFxObject* ItemData, const struct FString& GuideString);
	void UA_EquipConvertResult_SetResult_Upgrade(int ResultValue, class UGFxObject* ItemData, TArray<class UGFxObject*> StatDataList);
	void AU_EquipUpgrade_Selected_SubMaterial(const struct FString& Cid, bool bCheck);
	void AU_Inventory_Add_EquipUpgrade_Item(const struct FString& Sid);
	void AU_EquipUpgrade_Closed();
	void AU_EquipUpgrade_Click_Cancel();
	void AU_EquipUpgrade_Click_Confirm();
	void AU_EquipUpgrade_Clear_TargetItem();
	void AU_EquipUpgrade_Drop_TargetItem_FromInventory(const struct FString& Sid);
	void UA_EquipUpgrade_Show_Failed_Guide(bool Visible);
	void UA_EquipUpgrade_StopUpgradeEffect();
	void UA_EquipUpgrade_PlayUpgradeEffect();
	void UA_EquipUpgrade_Set_RequiredGold(int RequireGold);
	void UA_EquipUpgrade_Set_Disable_Confirm(bool Disable);
	void UA_EquipUpgrade_Set_SuccessRateString(const struct FString& SuccessRate);
	void UA_EquipUpgrade_Set_SuccessRateProgreess(int CurrentRate, int AdditionalRate);
	void UA_EquipUpgrade_Clear_SubMaterialItem(bool IsAll, int Index);
	void UA_EquipUpgrade_Set_SubMaterialItem(int SlotIndex, class UGFxObject* SubMaterialItemList);
	void UA_EquipUpgrade_Clear_MaterialItem();
	void UA_EquipUpgrade_Set_MaterialItem(class UGFxObject* materialItem);
	void UA_EquipUpgrade_Clear_TargetItem();
	void UA_EquipUpgrade_Set_TargetItem(class UGFxObject* TargetItemData);
	void AU_RMD_Swap_MaterialItem(int SrcSlotIndex, const struct FString& SrcSid, int DestSlotIndex, const struct FString& DestSid);
	void AU_RMD_Closed();
	void AU_RMD_Click_Close();
	void AU_RMD_Click_Confirm();
	void AU_RMD_Clear_MaterialItem(int SlotIndex);
	void AU_RMD_Clear_TargetItem();
	void AU_RMD_Drop_MaterialItem_FromInventory(const struct FString& Sid, int SlotIndex);
	void AU_RMD_Drop_MaterialItem_FromEquip(const struct FString& Sid, int SlotIndex);
	void AU_Inventory_Add_RMD_Item(const struct FString& Sid);
	void AU_Equip_Add_RMD_Item(const struct FString& Sid);
	void AU_RMD_Drop_TargetItem_FromInventory(const struct FString& Sid);
	void AU_RMD_Drop_TargetItem_FromEquip(const struct FString& Sid);
	void UA_RMD_Start_Progress();
	void UA_RMD_Set_Disable_Confirm(bool Disabled);
	void UA_RMD_Set_RecoverStep(int RecoverStep);
	void UA_RMD_Set_Progress(int CurrentValue, int NextValue, int MaxValue);
	void UA_RMD_Clear_Materialtem(bool IsAll, int SlotIndex);
	void UA_RMD_Set_MaterialItem(int SlotIndex, class UGFxObject* MaterialItemData);
	void UA_RMD_Clear_TargetItem();
	void UA_RMD_Set_TargetItem(class UGFxObject* TargetItemData);
	void AU_Equip_Closed_OnRepairMode();
	void AU_Inventory_Open_Divide_On_Item_Repair(const struct FString& ItemSid);
	void AU_Inventory_RepairItem(const struct FString& ItemSid);
	void AU_Equip_RepairItem(const struct FString& ItemSid);
	void AU_Equip_Click_RepairEquipedItems();
	void UA_Equip_Set_RepairAll_String(const struct FString& ReapairString);
	void UA_Equip_KeyDown_F();
	void UA_Set_Repairmode(bool IsRepairMode);
	void UA_Durability_Update_Armor(int ArmorType, int ConditionGrade);
	void UA_Durability_Update_Weapon(int WeaponType, int ConditionGrade);
	void UA_Durability_InitAllCondition(int ClassType);
	void UA_Durability_Close();
	void UA_Durability_Open();
	void AU_Anima_Click_Shaping_Button(int InCount);
	void AU_Anima_Click_Result_Item(int InSlotIndex);
	void AU_Anima_Complete_Shaping();
	void AU_Anima_Remove_Target_Item(const struct FString& InSid);
	void AU_Anima_Add_Target_Item(int InCategoryType, const struct FString& InSid);
	void AU_Anima_UI_Close();
	void UA_Anima_Close_UI();
	void UA_Anima_Set_Disable_Button(bool InDisableOne, bool InDisableTen);
	void UA_Anima_Start_Shaping();
	void UA_Anima_Set_Result_Effect(int InGrade);
	void UA_Anima_Clear_Result_Item();
	void UA_Anima_Clear_Target_Item();
	void UA_Anima_SetRender();
	void UA_Anima_Set_Result_Item_Data(int InCount, class UGFxObject* InObjArray);
	void UA_Anima_Set_Target_Item_Data(class UGFxObject* inObj);
	struct FString AU_ExpBar_Request_TooltipString_SPExp();
	void AU_QuestAlert_PlaySound_QuestRewardReceive();
	void AU_Receive_Quest_Reward_Cancel();
	void AU_Receive_Quest_Reward_Confirm(int questId, int SelectedRewardIndex);
	void AU_Receive_Quest_Reward(int questId);
	void UA_Set_ReceiveReward_Info(int questId, int QuestType, const struct FString& Title, int RewardMoney, int RewardExp, TArray<class UGFxObject*> FixedRewards, TArray<class UGFxObject*> SelectiveRewards, class UGFxObject* ObjToken);
	void AU_Order_Click_Tutorial_Reward(const struct FString& Cid);
	void AU_Order_Click_Tutorial_Detail(const struct FString& Cid);
	void AU_Tutorial_Click_QuestAlert(int Index);
	void UA_Order_Set_Tutorial_Data(TArray<class UGFxObject*> Datas);
	void UA_Order_Set_Tutorial_Purpose(class UGFxObject* Data);
	void UA_Order_Update_Tutorial_Data(const struct FString& Cid, int State);
	void UA_Order_Set_Tutorial_Information(const struct FString& FirstInfomation, const struct FString& SecondInfomation);
	void UA_Tutorial_Set_Image(const struct FString& ImageLink);
	void UA_Tutorial_Set_Text(const struct FString& Title, const struct FString& Description);
	void UA_QuestAlert_Set_Tutorial_Data(class UGFxObject* Data);
	void AU_Order_Click_Order_Reward(const struct FString& Cid);
	void AU_Order_Click_Weekly_Reward();
	void AU_Order_Click_Daily_Reward();
	void AU_Order_Get_Order_Data(int TabIndex);
	void UA_Order_Set_Daily_And_Weekly_Information(const struct FString& DailyInformatio, const struct FString& WeeklyInformation);
	void UA_Order_Update_Order_Data(const struct FString& Cid, int COUNT, int iState);
	void UA_Order_Remove_Order(const struct FString& Cid);
	void UA_Order_Set_Order_Datas(TArray<class UGFxObject*> Datas);
	void UA_Order_Set_Weekly_Info(class UGFxObject* Data);
	void UA_Order_Set_Daily_Info(class UGFxObject* Data);
	void AU_Order_Click_Sort_Category(int TabIndex);
	void UA_Order_Disable_Tab(TEnumAsByte<EOrderType> TabIndex, bool Disable);
	void UA_Order_Set_SortType(int TabIndex, int SortType);
	void UA_Order_Set_New_Order_Count(TEnumAsByte<EOrderType> TabIndex, int COUNT);
	void UA_Order_Select_Tab(int TabIndex);
	void AU_RuneCustom_Slate_Full_Meterial_Slot();
	void AU_RuneCustom_Slate_Swap_Item(int IndexA, int IndexB);
	void AU_RuneCustom_Click_Meterial_Page_Button(int CurrentPage);
	void AU_RuneCustom_Click_Synthesis_Button();
	void AU_RuneCustom_Slate_Drop_Item(int Index, const struct FString& Sid);
	void AU_RuneCustom_Remove_Slate_Meterial_Item(int Index);
	void AU_RuneCustom_Click_Reset_Button();
	void AU_RuneCustom_Drop_Rune_From_Inventory(int Index, const struct FString& RuneItemSid);
	void AU_RuneCustom_Remove_Rune_Item(int Index);
	void AU_RuneCustom_Change_Tab(int Type);
	void UA_RuneCustom_Select_Tab(int Type);
	void UA_RuneCustom_Set_Slate_Effect(int EffectType);
	void UA_RuneCustom_Set_Slate_Recipe_Page(int InCurrentPage, int InMaxPage);
	void UA_RuneCustom_Set_Slate_Recipe_Data(const struct FString& Title, const struct FString& Description, TArray<class UGFxObject*> RecipeDataList);
	void UA_RuneCustom_Set_Disable_Synthesis_Button(bool IsDisable);
	void UA_RuneCustom_Set_Slate_Meterial_Data(TArray<class UGFxObject*> MeterialDataList);
	void UA_RuneCustom_Set_Slate_Item_Data(class UGFxObject* ResultDataList);
	void AU_RuneCustom_UsableRuneList_ClickCloseButton();
	void AU_RuneCustom_Click_RuneButton(const struct FString& InSid);
	void AU_RuneCustom_Click_SocketButton(int InIndex);
	void AU_RuneCustom_Drop_Item(const struct FString& Sid);
	void AU_RuneCustom_Remove_Item(const struct FString& Sid);
	void AU_RuneCustom_UI_Close();
	void AU_RuneCustom_UI_Open();
	void UA_RuneCustom_PlayEffect_RuneEnable(int InIndex);
	void UA_RuneCustom_Show_UsableRuneList(bool InShow);
	void UA_RuneCustom_Set_UsableRuneList(TArray<class UGFxObject*> InObjList);
	void UA_RuneCustom_Set_Rune_Data(TArray<class UGFxObject*> InObjList);
	void UA_RuneCustom_Set_Item_Data(class UGFxObject* inObj);
	void AU_Minimap_Click_Web_Event();
	void AU_Call_Helper(const struct FString& InEUIName);
	void UA_Minimap_Set_Visible_Event_Button(bool IsShow);
	void AddExchangeItem(const struct FString& InSid, const struct FString& InCid);
	void AU_WebPage_Drop_Item_In_UI(const struct FString& InSid, const struct FString& InCid);
	void AU_WebPage_Set_RenderTarget_Texture_Position(int InOpenType, int InXPos, int InYPos);
	void AU_WebPage_Close(int InCloseShopType);
	void AU_WebPage_Open(int InOpenShopType);
	void UA_WebPage_Set_OpenType(int InOpenType, int InWidth, int InHeight);
	TArray<class UGFxObject*> AU_RaidFrame_Get_Setting();
	void AU_RaidFrame_Move_Member(const struct FString& MemberSid, int OldMemberIndex, int NewMemberIndex);
	void AU_RaidFrame_Changed_Target(int partyId, int MemberIndex, const struct FString& MemberSid);
	void AU_RaidFrame_Show_Member_ContextMenu(int partyId, int MemberIndex, const struct FString& MemberSid);
	void AU_RaidFrame_Extension_PartyFrame(int partyId, bool extension);
	void AU_RaidFrame_Move_PartyFrame(int partyId, float ScaleX, float ScaleY);
	void AU_RaidFrame_Show_PartyFrame_ContextMenu(int partyId);
	void UA_RaidFrame_Set_Setting(TArray<class UGFxObject*> SettingDatas);
	void UA_RaidFrame_Set_HP_Text_Visible(bool bVisible);
	void UA_RaidFrame_Set_Frame_Move(bool bMove);
	void UA_RaidFrame_Selected_Raid_Member(int partyId, int MemberIndex, const struct FString& MemberSid, bool Selected);
	void UA_RaidFrame_Set_Combat_Flair(int partyId, int MemberIndex, const struct FString& MemberSid, TArray<class UGFxObject*> CombatFlairDatas);
	void UA_RaidFrame_Toggle_AbnormalStatusList_SelfStack(bool IsFalse);
	void UA_RaidFrame_Set_AbnormalStatusList(int partyId, int MemberIndex, const struct FString& MemberSid, int Type, TArray<class UGFxObject*> Datas);
	void UA_RaidFrame_Set_Death(int partyId, int MemberIndex, const struct FString& MemberSid, bool IsDeath);
	void UA_RaidFrame_Set_Login(int partyId, int MemberIndex, const struct FString& MemberOldSID, const struct FString& MemberSid);
	void UA_RaidFrame_Set_Logout(int partyId, int MemberIndex, const struct FString& MemberSid, bool IsLogout);
	void UA_RaidFrame_Set_In_Dungeon(int partyId, int MemberIndex, const struct FString& MemberSid, bool InDungeon);
	void UA_RaidFrame_Set_Other_Space(int partyId, int MemberIndex, const struct FString& MemberSid, bool IsOtherSpace);
	void UA_RaidFrame_Set_Other_Channel(int partyId, int MemberIndex, const struct FString& MemberSid, bool IsOtherChannel);
	void UA_RaidFrame_Set_Leader_Info(int LeaderPartyID, int LeaderIndex, const struct FString& leaderSid);
	void UA_RaidFrame_Set_Raid_Info(TEnumAsByte<EPartyType> InRaidType, const struct FString& MySID);
	void UA_RaidFrame_Update_Raid_Member(int partyId, int MemberIndex, const struct FString& MemberSid, const struct FString& MemberName, int HP, int MaxHP, int SR, int MaxSR, TEnumAsByte<ECEClassType> ClassType);
	void UA_RaidFrame_Remove_Raid_Member(int partyId, int MemberIndex, const struct FString& MemberSid);
	void UA_RaidFrame_Add_Raid_Member(class UGFxObject* MemberData);
	void UA_RaidFrame_Set_Raid_Member(int partyId, TArray<class UGFxObject*> MemberDatas);
	void UA_RaidFrame_Initialize();
	void AU_Warehouse_Closed();
	bool AU_Warehouse_Item_Destruction_Dialog(const struct FString& SidTarget);
	void AU_Warehouse_Move_Item(const struct FString& Sid, int SlotIndex);
	void AU_Warehouse_Cancel_Divide(int Reason);
	void AU_Warehouse_MoveItem_Inventory(int SlotIndex);
	void AU_Warehouse_Open_Divide(const struct FString& Sid);
	void AU_Warehouse_Divide_Item();
	void AU_Warehouse_Auto_Sort();
	void UA_Warehouse_Set_Split_Mode(int Mode);
	void UA_Warehouse_Set_Slot_Count(const struct FString& CountString);
	void UA_Warehouse_Set_Item_Cooldown(int SlotIndex, int RemainingDuration, int Duration);
	void UA_Warehouse_AutoSort_StartCooldown(int Time);
	void UA_Warehouse_Locked_Item(const struct FString& Sid, int SlotIndex, bool Lock);
	void UA_Warehouse_Lock(bool bLock);
	void UA_Warehouse_Open();
	void UA_Warehouse_Clear();
	void UA_Warehouse_Cancel_Item_Destruction(const struct FString& Sid);
	void UA_Warehouse_Remove_Item(const struct FString& Sid);
	void UA_Warehouse_Set_Item(const struct FString& Sid, const struct FString& Cid, int Amount, int SlotIndex, bool ItemUsable, int ItemGrade, int ItemEquipType, int IconIndex, bool QuestGrade, bool QuestStart, int UpdateFlag, bool Registable);
	void AU_Journal_Opened_Tab(const struct FString& openedTab);
	TArray<class UGFxObject*> AU_Journal_Get_Tab_Button_State();
	void AU_Journal_Royal_Quest_Info(int questId);
	class UGFxObject* AU_Journal_Get_Royal_Initialization_Remaining_Time();
	void AU_Equip_Click_Equip_Toggle(int EquipSlotType, bool Selected);
	void UA_Equip_Slot_Toggle_Set_Visible(int EquipSlotType, bool Visible);
	void UA_Equip_Slot_Toggle_Set_Selection(int EquipSlotType, bool Selected);
	void UA_CSC_Set_Charge_Info(const struct FString& InChargeName, const struct FString& InChargePeriod);
	void UA_HUDIconsLT_Set_Icon(int InSlotIndex, class UGFxObject* InData);
	void UA_Enable_ChangeGender(bool Disabled);
	void UA_Disable_ChangeAppearance(bool Disabled);
	void UA_Set_Expired_LookChangeItem(int InIndex);
	void UA_AppearanceChange_Info(const struct FString& InName, const struct FString& InLeftPeriod);
	void AU_Friend_Click_Show_Block_Popup(const struct FString& InUniqueID);
	void AU_Friend_Click_Add_Block_Button();
	void UA_Friend_Set_Block_Info(TArray<class UGFxObject*> InData);
	void AU_Friend_Click_Show_Friend_Popup(const struct FString& Cid);
	void AU_Friend_Click_Add_Friend_Button();
	void AU_Freind_UI_Close();
	void AU_Freind_UI_Open();
	void UA_Friend_Set_Player_Info(TArray<class UGFxObject*> InFriendList);
	void AU_PartyMatchingRole_Click_Cancel();
	void AU_PartyMatchingRole_Click_Start();
	void AU_PartyMatchingRole_UI_Close();
	void AU_PartyMatchingRole_UI_Open();
	void UA_PartyMatchingRole_Set_Disable_Button(bool InDisable);
	void UA_PartyMatchingRole_Set_Data(TArray<class UGFxObject*> InDataList, int stateIndex, const struct FString& dungeonName);
	void AU_PARTYMATCHING_CLICK_ENTER_RANDOMDUNGEON(int InDungeonIndex);
	void AU_PARTYMATCHING_RANDOMPARTY_DUNGEONAPPLY_CANCEL_REQUEST();
	void AU_PARTYMATCHING_RANDOMPARTY_DUNGEONAPPLY_REQUEST();
	void AU_PARTYMATCHING_RANDOMPARTY_REWARD_REQUEST();
	void AU_PartyMatching_Click_Enter_Dungeon();
	void AU_PartyMatching_Click_Cancel();
	void AU_PartyMatching_Click_Request();
	void AU_PartyMatching_Click_Init();
	void AU_PartyMatching_Click_Dungeon_Type(int InDungeonIndex, int InTypeIndex);
	void AU_PartyMatching_Click_Role_Type(int InRoleIndex);
	void AU_PartyMatching_UI_Close();
	void AU_PartyMatching_UI_Open();
	void UA_PartyMatching_Set_RandomPartyMatching_ApplyState(bool InApply);
	void UA_PartyMatching_Set_RandomPartyMatching_ListBlind(bool InBlind);
	void UA_PartyMatching_Set_Disable_Cancel_Button(bool InDisabled);
	void UA_PartyMatching_Set_Visible_Cancel_Button(bool Invisible);
	void UA_PartyMatching_Set_Disable_Request_Button(bool InDisabled);
	void UA_PartyMatching_Set_RandomPartyMatchingBtn(int InButtonIndex, int InButtonEnable, int Invisible);
	void UA_PartyMatching_Set_NewItemCount(int InTabIndex, int InCount);
	void UA_PartyMatching_Enable_Tab(int InTabIndex, bool InIsActivate);
	void UA_PartyMatching_Set_RandomPartyMatchingData(TArray<class UGFxObject*> InItemList, int InSelectIndex);
	void UA_PartyMatching_Set_RandomPartyMatchingGuideData(class UGFxObject* InGuideData, TArray<class UGFxObject*> InItemList);
	void UA_PartyMatching_Set_Disable_Role_Button(class UGFxObject* InData);
	void UA_PartyMatching_Set_Data(TArray<class UGFxObject*> InDataList, int InSelectIndex);
	void AU_Dungeon_Click_WaitingList(int Index);
	void AU_Dungeon_Click_Registration(int Index);
	void AU_Dungeon_Click_Dungeon_Type(int Index, int DungeonType);
	void AU_Dungeon_Click_Init_Button();
	void AU_Dungeon_UI_Open();
	void UA_Dungeon_Update_Data(class UGFxObject* InUpdatedData);
	void UA_Dungeon_Set_Data(class UGFxObject* InDataList);
	void UA_WarpLoading_Close();
	void UA_WarpLoading_Open();
	void AU_Taming_Hit_Fail();
	void AU_Taming_Hit_Success(int InIndex);
	void UA_Taming_Close();
	void UA_Taming_Open();
	void UA_Taming_Cancel();
	void UA_Taming_Show_Result(int InresultType);
	void UA_Taming_Pressed_SpaceBar();
	void UA_Taming_StartSession();
	void UA_Taming_StartGame();
	void UA_Taming_SetTimeLimit(int InTimeLimit);
	void UA_Taming_InitGame(int InGoalIndex, int InGoalSize, float InStopTime, float InBarSpeed, int InTotalCount, int InCurrentCount, int InIconIndex);
	void AU_Refresh_Mission_Accept(bool IsOk);
	void AU_Select_Mission(int InMissionCID);
	void AU_Accept_Reward(int InMissionCID);
	void AU_Removed_Fellow(int InMissionCID, const struct FString& InFellowSid);
	void AU_Inserted_Fellow(int InMissionCID, const struct FString& InFellowSid);
	void AU_Request_ExecuteMission(int MissionCId);
	void AU_Request_RefreshMissions();
	void AU_Closed_MissionView();
	void AU_Opened_MissionView();
	void UA_Accept_Reward(int InMissionCID, bool IsSucceed);
	void UA_Update_ExecuteButton(bool isEnable, const struct FString& InLabel, int InMissionCID);
	void UA_Update_Mission(TArray<class UGFxObject*> InMissionList);
	void AU_CustomizingFileManager_Click_Load_File(int SelectedIndex);
	void AU_CustomizingFileManager_Click_Save_File(const struct FString& Filename);
	void AU_CustomizingFileManager_Close_Contents();
	void AU_CustomizingFileManager_UI_Close();
	void AU_CustomizingFileManager_UI_Open();
	void AU_Customizing_Open_File();
	void AU_Customizing_Save_File();
	void AU_Customizing_RotateRight_Released();
	void AU_Customizing_RotateRight_Pressed();
	void AU_Customizing_RotateLeft_Released();
	void AU_Customizing_RotateLeft_Pressed();
	void AU_Customizing_DetailMode_ChangedDropdown(int Index);
	void AU_Customizing_RequestDetailModeDropdownMenuData(int controllerType);
	void AU_Customizing_ToggleDetailedModifying(bool bDetailedModifying);
	void AU_Customizing_PutOnCloth(bool bPutonCloth, int openedController);
	void AU_Customizing_ChangeChameraView(int nCurrentChameraView);
	void AU_Customizing_TODChange(int currentTOD);
	void AU_Customizing_Random(int controllerType);
	void AU_Customizing_Reset(int controllerType);
	void AU_Customizing_ResetAll();
	void AU_Customizing_ChangedRadioGroupSelection(int controllerType, int Value);
	void AU_Customizing_ChangedCheckBoxSelction(int controllerType, bool Selected);
	void AU_Customizing_ChangedSliderValue(int controllerType, int Value);
	void AU_Customizing_ChangedListSelection(int controllerType, int Index);
	void AU_Selected_Customizing_SubMenu(int controllerType);
	void AU_Customizing_RequestInitSliderControllers();
	void AU_Open_Create_Customizing();
	void UA_Customizing_SetSelectedAppearanceType(int AppearanceType);
	void UA_CustomizingFileManager_Set_LoadFile_Data(TArray<class UGFxObject*> ImageList);
	void UA_CustomizingFileManager_Set_SaveFile_Data(const struct FString& ImageLink);
	void UA_CustomizingFileManager_Close();
	void UA_CustomizingFileManager_Open_Type(int Type);
	void UA_Disable_OpenFileButton(bool Disabled);
	void UA_Disable_SaveFileButton(bool Disabled);
	void UA_CustomizingRotateButtons_SetVisible(bool bVisible);
	void UA_Customizing_SelectItem_DetailModeDropdownMenu(int SelectedIndex);
	void UA_CustomizingSetDetailModeTitle(const struct FString& strTitle);
	void UA_Customizing_SetDetailModeDropdownMenuData(TArray<struct FString> arrData);
	void UA_Customizing_SetValueRadioButtons(int controllerKey, int Value);
	void UA_Customizing_SetValueSlidersWithArray(TArray<class UGFxObject*> arrSliderDatas);
	void UA_Customizing_InitSlidersWithArray(TArray<class UGFxObject*> arrValues);
	void UA_Customizing_SetSliderValue(int controllerKey, int Value);
	void UA_Customizing_InitSlider(int controllerKey, int Value, int Min, int Max);
	void UA_Customizing_SetValueCheckBox(int controllerKey, bool Value);
	void UA_Customizing_SetValueList(int controllerKey, int SelectedIndex);
	void UA_Customizing_InitList(int controllerKey, int SelectedIndex, class UGFxObject* arrData);
	void AU_CollectionBook_Add_To_GradeUpAdd(const struct FString& InSid);
	void AU_CollectionBook_Add_To_SkillChange(const struct FString& InSid);
	void AU_CollectionBook_Add_To_FatigueRecovery(const struct FString& InSid);
	void AU_CollectionBook_Add_To_MonsterBall(const struct FString& InSid);
	void AU_CollectionBook_Add_To_GradeUp(const struct FString& InSid);
	void AU_CollectionBook_Add_To_ExpUp(const struct FString& InSid);
	void AU_CollectionBook_Make_Fellow_Mission(const struct FString& Sid);
	void AU_CollectionBook_Pet_Summon(const struct FString& Sid);
	void AU_CollectionBook_Mount_Boarding(const struct FString& Sid);
	void AU_CollectionBook_Excute_Collection(const struct FString& Sid);
	void AU_CollectionBook_Click_New_Collection(const struct FString& Sid);
	void AU_CollectionBook_Select_Tab(int TabIndex);
	void UA_CollectionBook_Open_With_Mission();
	void UA_CollectionBook_Set_Holding_List_Flag(bool Holding);
	void UA_CollectionBook_Set_Collection_Count(const struct FString& COUNT);
	void UA_CollectionBook_Set_NewCount(int TabIndex, int COUNT);
	void AU_CollectionBook_Confirm_Filter(int InTabIndex, int InFilterType, int InSortingType, bool InIsUncommon, bool InIsRare, bool InIsEpic, bool InIsLegend, bool InIsHuman, bool InIsBarbarian, bool InIsCreature, bool InIsUndead);
	void AU_CollectionBook_Open_Filter(int InTabIndex);
	void UA_CollectionBook_Set_Filter_Data(int InTabIndex, int InFilterType, int InSortingType, bool InIsUncommon, bool InIsRare, bool InIsEpic, bool InIsLegend, bool InIsHuman, bool InIsBarbarian, bool InIsCreature, bool InIsUndead);
	void AU_ActionBar_Click_Favorite_Slot_GO_MP(const struct FString& InUid);
	void AU_ActionBar_Remove_Favorite_Slot(const struct FString& InUid, int InSlotIndex);
	void AU_ActionBar_Add_Favorite_Slot(const struct FString& InUid, int InSlotIndex);
	void AU_ActionBar_Swap_Favorite_Slot(int InTargetIndex, int IndraggedSlotIndex);
	void AU_CollectionBook_Extraction_Click_Confirm();
	void AU_CollectionBook_FatigueRecovery_Click_Use_Button(int InIndex);
	void AU_CollectionBook_SkillChange_Click_Help_Button(int InIndex);
	void AU_CollectionBook_SkillChange_Click_Confirm();
	void AU_CollectionBook_GradeToAdd_Click_Use_Button(int InIndex);
	void AU_CollectionBook_GradeUp_Click_Confirm();
	void AU_CollectionBook_GradeUp_Click_Amount(int InIndex);
	void AU_CollectionBook_GradeUp_Click_Probability(bool IsCheck);
	void AU_CollectionBook_GradeUp_Click_Protection(bool IsCheck);
	void AU_CollectionBook_GradeUp_Remove_Material(const struct FString& Sid);
	void AU_CollectionBook_GradeUp_Add_Material(const struct FString& Sid);
	void AU_CollectionBook_ExpUp_Complete_Progress();
	void AU_CollectionBook_ExpUp_Click_Confirm();
	void AU_CollectionBook_ExpUp_Click_Amount(int InIndex);
	void AU_CollectionBook_ExpUp_Click_SubMaterial(bool IsCheck);
	void AU_CollectionBook_ExpUp_Remove_Material(const struct FString& Sid, int InSlotIndex);
	void AU_CollectionBook_ExpUp_Swap_Material(int InTargetIndex, int IndraggedSlotIndex);
	void AU_CollectionBook_ExpUp_Add_Material(const struct FString& InSid, int SlotIndex);
	void UA_CollectionBook_Extraction_Disable_Button(bool IsDisable);
	void UA_CollectionBook_Extraction_Set_Result_Data(class UGFxObject* InUIData);
	void UA_CollectionBook_Extraction_Set_SubMaterial_Data(class UGFxObject* InUIData);
	void UA_CollectionBook_FatigueRecovery_Set_SubMaterial_Data(int Index, class UGFxObject* InUIData);
	void UA_CollectionBook_SkillChange_Disable_Button(bool IsDisable);
	void UA_CollectionBook_SkillChange_Set_SubMaterial_Data(class UGFxObject* InUIData);
	void UA_CollectionBook_SkillChange_Set_Skill_Data(int Index, class UGFxObject* InUIData);
	void UA_CollectionBook_GradeUpAdd_Set_SubMaterial_Data(int Index, class UGFxObject* InUIData);
	void UA_CollectionBook_GradeUp_Disable_Button(bool IsDisable);
	void UA_CollectionBook_GradeUp_Set_Result_Data(class UGFxObject* InUIData);
	void UA_CollectionBook_GradeUp_Set_Probability_Data(class UGFxObject* InUIData);
	void UA_CollectionBook_GradeUp_Set_Protection_Data(class UGFxObject* InUIData);
	void UA_CollectionBook_GradeUp_Remove_Material_Data();
	void UA_CollectionBook_GradeUp_Set_Material_Data(class UGFxObject* InUIData);
	void UA_CollectionBook_ExpUp_Clear_ProgressBar();
	void UA_CollectionBook_ExpUp_Start_ProgressBar();
	void UA_CollectionBook_ExpUp_Set_ProgressBar(int InNextValue, int InMaxValue, const struct FString& InExpect);
	void UA_CollectionBook_ExpUp_Disable_Button(bool IsDisable);
	void UA_CollectionBook_ExpUp_Set_SubMaterial_Data(class UGFxObject* InUIData);
	void UA_CollectionBook_ExpUp_Remove_Material_Data(int Index);
	void UA_CollectionBook_ExpUp_Set_Material_Data(int Index, class UGFxObject* InUIData);
	void UA_CollectionBook_Select_Collection_Item(const struct FString& InSid);
	void UA_CollectionBook_Clear_Contents();
	void UA_CollectionBook_Set_Detail_Disable_Button(int InIndex, bool InbIsDisable);
	void UA_CollectionBook_Set_Description(bool IsVisible, const struct FString& Description);
	void AU_CollectionBook_Click_Grade_Up_Add();
	void AU_CollectionBook_Click_Skill_Change();
	void AU_CollectionBook_Click_Fatigue_Recovery();
	void AU_CollectionBook_Click_Extraction();
	void AU_CollectionBook_Click_Exp_Up();
	void AU_CollectionBook_Click_Grade_Up();
	void AU_CollectionBook_Click_Location();
	void AU_CollectionBook_Click_Lock(bool InIsLock);
	void AU_CollectionBook_Click_Preview();
	void AU_CollectionBook_Use_Favorite_Slot(int InSlotIndex);
	void AU_CollectionBook_Select_Favorite_Slot(int InSlotIndex);
	void AU_CollectionBook_Move_Favorite_Slot(int InFromNumber, int InToNumber);
	void AU_CollectionBook_Remove_Favorite_Slot(int InSlotIndex);
	void AU_CollectionBook_Add_Favorite_Slot(int InSlotIndex, const struct FString& InSid);
	void AU_CollectionBook_Change_Favorite_Page(int InPageNumber);
	void AU_CollectionBook_Select_Collection_Item(const struct FString& InSid);
	void UA_CollectionBook_Set_Open_Level(int InIndex, int InOpenLevel);
	void UA_CollectionBook_Show_Fellow(bool InEnable);
	void UA_CollectionBook_Open_Mission(bool InMissionUIOpen);
	void UA_CollectionBook_Clear_Detail_Info_Data();
	void UA_CollectionBook_Set_Tab_Count(int InTabIndex, int InCount);
	void UA_CollectionBook_Clear_Favorite(int InIndex);
	void UA_CollectionBook_Update_Favorite_Fatigue(int InIndex, int InFatigue);
	void UA_CollectionBook_SetRender();
	void UA_CollectionBook_SkillChange_Set_Skill_Pool_List_Data(TArray<class UGFxObject*> InSkillPoolDataList);
	void UA_CollectionBook_Update_Collection_Data(int InTableIndex, int InSlotIndex, class UGFxObject* InUIData);
	void UA_CollectionBook_Update_Favorite(int InIndex, class UGFxObject* InData);
	void UA_CollectionBook_Set_Favorite(TArray<class UGFxObject*> InUIDataList);
	void UA_CollectionBook_Update_Detail_Info_Data(class UGFxObject* InData);
	void UA_CollectionBook_Set_Detail_Info_Data(class UGFxObject* InData);
	void UA_CollectionBook_Set_Collection_Data(int InTableIndex, const struct FString& InCount, TArray<class UGFxObject*> InUIDataList);
	void UA_CollectionBook_Select_Tab(int InTabIndex);
	void AU_EquipCustom_Click_Return();
	void AU_EquipCustom_Complete_Potential_Disjoint();
	void AU_EquipCustom_Click_Disjoint();
	void AU_EquipCustom_Click_Potential_Disjoint_Button();
	void AU_EquipCustom_Click_Potential_Increase();
	void AU_EquipCustom_Click_Potential_Button();
	void AU_EquipCustom_Complete_Roulette();
	void AU_EquipCustom_Click_Special_Change();
	void AU_EquipCustom_Click_Normal_New();
	void AU_EquipCustom_Click_Normal_Now();
	void AU_EquipCustom_Click_Normal_CT();
	void AU_EquipCustom_Click_Normal_Lumena();
	void AU_EquipCustom_Click_Special_Button();
	void AU_EquipCustom_Click_Normal_Button();
	void AU_EquipCustom_Remove_Item(const struct FString& InItemSid);
	void AU_EquipCustom_Regist_Item_After_Potential_Disjoint(const struct FString& InItemSid);
	void AU_EquipCustom_Drop_From_Inventory(const struct FString& InItemSid);
	void UA_EquipCustom_Set_Potential_Disjoint_Data(class UGFxObject* InObject);
	void UA_EquipCustom_Start_Potential_Disjoint();
	void UA_EquipCustom_Init();
	void UA_EquipCustom_Update_Potential_Data(class UGFxObject* InUpdateResult);
	void UA_EquipCustom_Set_Potential_Data(TArray<class UGFxObject*> InCurrentStat, class UGFxObject* InMaterial);
	void UA_EquipCustom_Start_Special_Roulette(class UGFxObject* InObject);
	void UA_EquipCustom_Set_Special_Data(class UGFxObject* InObject);
	void UA_EquipCustom_Set_Normal_Stat_Data(TArray<class UGFxObject*> InNowObjectArray, TArray<class UGFxObject*> InNewObjectArray);
	void UA_EquipCustom_Set_Normal_Gold_Data(class UGFxObject* InObject);
	void UA_EquipCustom_Set_Popup_Data(class UGFxObject* InObject);
	void UA_EquipCustom_Clear_Item();
	void UA_EquipCustom_Set_Item_Data(class UGFxObject* InObject);
	void AU_CraftNPC_Click_OK_Button(int Cid, int Amount);
	void AU_Craft_Choice_Over_Choice_Button(int InType);
	void AU_Craft_Choice_Click_Choice_Button(int InType);
	void AU_Craft_Choice_UI_Close();
	void AU_Craft_Choice_UI_Open();
	void UA_Craft_Choice_Set_Title(const struct FString& InTitle);
	void UA_Craft_Choice_Set_Choice_Data(TArray<class UGFxObject*> InList);
	void AU_Craft_Recipe_Click_Acquisition_Button(int InCraftCId);
	void AU_Craft_Recipe_Click_List_Craft_Item(int InCraftCId);
	void AU_Craft_Recipe_Click_Class_Recommend(bool InBool);
	void AU_Craft_Recipe_Click_Acquirable(bool InBool);
	void AU_Craft_Recipe_UI_Close();
	void AU_Craft_Recipe_UI_Open();
	void UA_Craft_Recipe_Set_List_Selected(int InCategoryCid, int InCraftCId);
	void UA_Craft_Recipe_Set_Recipe_Data(class UGFxObject* InSelectedData, class UGFxObject* InRequireData, TArray<class UGFxObject*> InMaterialData, class UGFxObject* InCostData, bool InIsAcquisition);
	void UA_Craft_Recipe_Set_List_All_Data(TArray<class UGFxObject*> InCategoryList);
	void UA_Craft_Recipe_Set_CraftLevel_Data(class UGFxObject* InLevelData);
	void UA_Craft_Recipe_Set_ClassType_Data(const struct FString& InClassName);
	void UA_Craft_Recipe_Set_CraftType_Data(int InType);
	void AU_DialogPurchase_Click_Craft_Success_Answer();
	void AU_Craft_Click_SubMaterial(bool InUseOptional);
	void AU_Craft_Click_Craft_Close_Button();
	void AU_Craft_Click_Craft_Cancel_Button();
	void AU_Craft_Click_Craft_Start_Button(int InCraftCId, int InCraftAmount, bool IsSubMaterial);
	void AU_Craft_Change_Selected_Item_Amount(int InCraftCId, int InCraftAmount);
	void AU_Craft_Click_List_Favorite(int InCraftCId);
	void AU_Craft_Click_List_Craft_Item(int InCategoryCid, int InCraftCId);
	void AU_Craft_Click_Class_Recommend(bool InBool);
	void AU_Craft_Click_Promotion_Quest();
	void AU_Craft_Click_Tab(int InTabIndex);
	void AU_Craft_Click_Craft_Skill_Title(int InCraftType);
	void AU_Craft_Click_OK_Button(int InCid, int inAmount);
	void AU_Craft_UI_Close();
	void AU_Craft_UI_Open();
	void UA_Craft_Set_Open_Level(int InIndex, int InOpenLevel);
	void UA_Craft_Set_List_Selected(int InTabIndex, int InCategoryCid, int InCraftCId);
	void UA_Craft_Set_Craft_Button(bool InIsEnable);
	void UA_Craft_Set_List_Expansion(int InTabIndex, bool IsExpandAll);
	void UA_Craft_Set_Selected_Item_Amount(int inAmount);
	void UA_Craft_Set_Tab(int InTabIndex);
	void UA_Craft_Set_ClassType_Data(const struct FString& InClassRecommend);
	void UA_Craft_Set_CraftType_Data(int InMainType, int InSubType);
	void UA_Craft_Set_CraftLevel_Data(class UGFxObject* InData);
	void UA_Craft_Set_Material_Data(class UGFxObject* InRequireMat, TArray<class UGFxObject*> InMatList, class UGFxObject* InSubMat);
	void UA_Craft_Set_Selected_Data(class UGFxObject* InData);
	void UA_Craft_Set_List_All_Data(int InTabIndex, TArray<class UGFxObject*> InDataList);
	void AU_Acting_Point_Click_Charge();
	bool GetMinimapExtensionDefaultValue();
	void AU_Exchange_Confirm();
	void AU_Changed_Exchange_DealTokenValue2_Value(const struct FString& Value);
	void AU_Changed_Exchange_DealTokenValue2_Type(int TargetType);
	void AU_Changed_Exchange_DealTokenVale1(int SourceType, const struct FString& SourceValue);
	void AU_Request_Open_TokenExchange();
	void UA_TokenExchange_Update_OwnTokenValue(int CoinType, const struct FString& Value);
	void UA_TokenExchange_Update_Values(const struct FString& exchangeRate_Value1, const struct FString& exchangeDealTokenVaue1, const struct FString& exchangeDealTokenValue2, const struct FString& commisionValue);
	void UA_TokenExchange_Close();
	void UA_TokenExchange_Open(class UGFxObject* updatedData);
	void AU_DIALOGPURCHASE_CLICK_CONQUEST_POPUP_CONFIRM(int Value, int DialogOpenType, int DialogOptionType);
	void AU_DialogPurchase_Click_GoldUnit_Answer(int Value, int DialogOpenType, int DialogOptionType, const struct FString& Gold);
	void AU_DialogPurchase_Click_Naming_Answer(int Value, int DialogOpenType, int DialogOptionType, const struct FString& strName);
	void AU_DialogPurchase_Click_Recycle_Time_out(int DialogOpenType, int CurrentSec);
	void AU_DialogPurchase_Click_Slot_Answer(int Value, int DialogOpenType, int DialogOptionType);
	void AU_DialogPurchase_Click_Amount_Answer(int Value, int DialogOpenType, int DialogOptionType, int StepperValue);
	void AU_DialogPurchase_Click_NumberStepper_Answer(int Value, int DialogOpenType, int DialogOptionType, int StepperValue);
	void AU_DialogPurchase_Click_Token_Answer(int Value, int DialogOpenType, int DialogOptionType);
	void AU_DialogPurchase_Click_Period_Answer(int Value, int DialogOpenType, int DialogOptionType, int SelectedPeriod);
	void UA_DialogPurchase_Set_Button_Disable(int dialogId, bool Disabled, int Flag);
	int UA_DialogPurchase_Close(int DialogOpenType, int DialogOptionType);
	int UA_DialogPurchase_Open(int DialogOpenType, int DialogOptionType, TArray<class UGFxObject*> TextDatas, TArray<class UGFxObject*> ObjectDatas, TArray<class UGFxObject*> ButtonDatas, float TimeOut, bool IsModal, int DialogAlign, int OffsetX, int OffsetY, const struct FString& DialogOwner, class UGFxObject* RecycleData);
	void UA_Minimap_Set_PVP_Type(int InType, int InRealm);
	void UA_AimTargeting_Close();
	void UA_AimTargeting_Open();
	void UA_AimTargeting_Set_Position(float PosX, float PosY);
	void UA_Set_RenderTarget(const struct FString& InPath, const struct FString& InUIName, int InIndex);
	void UA_Mount_Slot_Visible(bool bIsVisible);
	void UA_SET_MOUNT_FLAG(bool bIsMounted);
	void GetItemQuestInfoByItemInfo(struct FItemInfoData* InInfo, int* QuestGrade, int* QuestStart);
	void LobbyWarning();
	void LobbyPageChange();
	void LobbyEntering();
	void QTEButtonAlarm();
	void BattleEnd();
	void BattleStart();
	void MinimapImageChange();
	void QuestCompleted();
	void ChatWindowChange();
	void ChatWindowClose();
	void ChatWindowOpen();
	void QuestObjectiveComplete();
	void QuestFailed();
	void QuestNew();
	void UIClose();
	void UIOpen();
	void MouseOver();
	void SlotMove();
	void ButtonClick();
	void SUMMONEE_SKILL_SET(int Index, int Cid, int Level);
	void SummoneeSetSkillList(TArray<int> SkillCidList);
	void SummoneeChangeStance(TEnumAsByte<ESummoneeStance> stance);
	void SummoneeSetEnergySpherePoint(int Point);
	void SummoneeSetEnergySphereUse(bool Use);
	void OnSummoneeDespawned();
	void OnSummoneeSpawned();
	void AU_DialogBid_Confirm(bool IsYes, const struct FString& bidCP);
	void AU_DialogBid_Click_Cancel();
	void AU_DialogBid_Click_Confirm(const struct FString& CP);
	void AU_WarCitadelOwnershipView_Click_Auction();
	void AU_WarCitadelOwnershipView_Request_Init_MapData();
	void AU_WarCitadelOwnershipView_RollOver_Citadel();
	void AU_WarCitadelOwnershipView_Click_Citadel(int Index);
	void AU_WarCitadelOwnership_UI_Close();
	void AU_WarCitadelOwnership_UI_Open();
	void UA_WarCitadelOwnershipView_Set_WindowTitleData(const struct FString& Title, const struct FString& MapName, const struct FString& CitadelInfo);
	void UA_DialogBid_Close();
	void UA_DialogBid_Open(int DialogType, class UGFxObject* Data);
	void UA_WarCitadelOwnershipView_Disable_Button(bool Disable);
	void UA_WarCitadelOwnershipView_Set_Time(int Time);
	void UA_WarCitadelOwnershipView_Set_BidCP(const struct FString& bidCP);
	void UA_WarCitadelOwnershipView_Set_Info_Data(class UGFxObject* Data);
	void UA_WarCitadelOwnershipView_Set_Map_Data(TArray<class UGFxObject*> DataList);
	bool UA_Clear_ZoneName();
	void UA_ZoneName_Pool_Clear();
	bool UA_Return_To_ZoneName_Object(class UGFxObject* ZoneNameMC);
	void UA_ZoneName_Set_GuildSymbolData(int Type, class UGFxObject* Data);
	class UGFxObject* UA_Get_ZoneName_Object(int InDepth);
	bool CloseWorldMapUIs();
	void AU_WorldMap_Zoom(bool ZoomIn);
	void AU_WorldMap_Set_Area(int areaIndex);
	void AU_WorldMap_Set_Filter(const struct FString& FilterType, bool Enable);
	void AU_WorldMap_Close();
	void UA_Hide_FilterMenu(const struct FString& filterIndex, bool Enable);
	void UA_WorldMap_Set_RO_Guild_Data(class UGFxObject* inObj);
	void UA_WorldMap_Set_Filter_Data(TArray<class UGFxObject*> FilterDatas);
	int UA_Close_World_Map_UI();
	void UA_Set_Way_Point_Gold(const struct FString& Gold);
	void UA_Hide_World_Map_Tooltip();
	void UA_WorldMap_Show_Tooltip(const struct FString& Title, const struct FString& Desc, const struct FString& Gold, int PosX, int PosY);
	void UA_Set_World_Map_Area(int Index0, const struct FString& areaName0, int index1, const struct FString& areaName1, int index2, const struct FString& areaName2, int index3, const struct FString& areaName3, int index4, const struct FString& areaName4, int index5, const struct FString& areaName5);
	void UA_Set_World_Map_Scale(int InScaleValue, int InScaleMax);
	void UA_WorldMap_Set_Filter(const struct FString& filterIndex, bool Enable);
	void UA_Timer_Set_Holy_HP(int InCurrentHP, int InMaxHP);
	void UA_Timer_Set_Round(int InRound);
	void UA_Timer_Set_Time_Bonus(TEnumAsByte<EBLChallengeTowerTimerType> InTimerType, int InCurrentTime, int InMaxTime);
	void UA_Timer_Set_Time(int InSecond, bool InIsAlertMode);
	void UA_Timer_Set_Type(TEnumAsByte<EBLTimerType> InTimerType);
	void UA_Timer_Set_Visible(bool Invisible);
	void AU_Ranking_Click_Page_Stepper(int InPage);
	void AU_Ranking_Open();
	void UA_Ranking_Set_ChallengeTower_List_Data(TArray<class UGFxObject*> InRanking);
	void UA_Ranking_Set_ChallengeTower_My_Data(class UGFxObject* InMyRanking);
	void UA_Ranking_Set_ChallengeTower_Page(int InMaxPage, int InCurrentPage);
	void AU_ChallengeTower_RoundResult_Click_Confirm();
	void AU_ChallengeTower_RoundOverResult_Click_Confirm();
	void AU_ChallengeTower_Close();
	void AU_ChallengeTower_Open();
	void UA_ChallengeTower_Set_Round_Over_Data(class UGFxObject* InTowerResultData);
	void UA_ChallengeTower_Set_Round_Data(class UGFxObject* InRoundResultData);
	void AU_DialogPurchase_Cancel_Conquest_Popup();
	void UA_DialogPurchase_Set_CastingBar_Stop();
	void UA_DialogPurchase_Set_CastingBar_Start(int RemainTime, int TotalTime);
	void AU_WarRealmOwnershipResult_Click_Confirm();
	void AU_WarRealmOwnerShip_Sorting_Click(int InListIndex, int InButtonIndex, int InSortType);
	void AU_WarRealmOwnerShip_Exit();
	void AU_Open_WarRealmOwnerShip_Result();
	void UA_WarRealmOwnershipResult_Set_Type(int InType, const struct FString& InResultStr);
	void UA_WarRealmOwnerShipResult_Set_MyPosition(int InListIndex, int InIndex);
	void UA_WarRealmOwnerShipResult_Set_SortingType(int InListIndex, int InButtonIndex, int InSortType);
	void UA_WarRealmOwnerShipResult_Set_Rewardinfo(const struct FString& InReward);
	void UA_WarRealmOwnerShipResult_Set_Result_Center(const struct FString& AttackResult, const struct FString& DefenseResult, const struct FString& OwnerResult);
	void UA_WarRealmOwnerShipResult_Set_Result(int InResult);
	void UA_WarRealmOwnerShipResult_Set_Score(int InScore1, int InScore2);
	void UA_WarRealmOwnerShipResult_Set_RankData(int InIndex, TArray<class UGFxObject*> RankDataList);
	void UA_WarRealmOwnershipProgress_Set_Result(int InResult);
	void UA_WarRealmOwnershipProgress_Set_Score(int InAttackMainScore, int InDefenseMainScore, const struct FString& InPlayerName, const struct FString& InPlayerGuildName, int InPlayerKill, int InPlayerScore, const struct FString& InAttackGuildName, int InAttackKill, int InAttackScore, const struct FString& InDefenseGuildName, int InDefenseKill, int InDefenseScore);
	void UA_WarRealmOwnershipProgress_Set_Time(int inTime, int InLimitTime, bool bStop);
	void AU_WarRealmOwnershipRegister_UI_Open();
	void AU_WarRealmOwnershipRegister_Click_Defense();
	void AU_WarRealmOwnershipRegister_Click_Attack();
	void UA_WarRealmOwnershipRegister_Check_Defense_Button(bool bInJoinType, bool bDisable);
	void UA_WarRealmOwnershipRegister_Check_Attack_Button(bool bInJoinType, bool bDisable);
	void UA_WarRealmOwnershipRegister_Set_Caution(const struct FString& InCautionText);
	void UA_WarRealmOwnershipRegister_Set_Capital_Guild(const struct FString& InGuildName);
	void UA_WarRealmOwnershipRegister_Set_Contest_Capital(const struct FString& InCaptialText);
	void UA_WarRealmOwnershipRegister_Set_Start_Remaining_Date(const struct FString& InDateText);
	void UA_WarRealmOwnershipRegister_Set_Start_Date(const struct FString& InDateText);
	void UA_WarRealmOwnershipRegister_Set_Ask_Remaining_Date(const struct FString& InDateText);
	void UA_WarRealmOwnershipRegister_Set_Ask_Date(const struct FString& InDateText);
	void UA_WarConquestScoreBoard_Stop_Timer();
	void UA_WarConquestScoreBoard_Set_Time(int inTime, int InLimitTime);
	void UA_WarConquestScoreBoard_Set_ConquestScore(class UGFxObject* InScoreBoardData);
	void UA_WarConquestScoreBoard_Set_RO_Colosseum_Score(int InAttackerScore, int InDefenderScore, int InType);
	void UA_WarConquestScoreBoard_Set_State(int InRealm, int InType);
	void UA_WarConquestScoreBoard_Set_Score(int InHieronHP, int InUnionHP);
	void UA_WarConquestScoreBoard_Set_Visible(bool bVisible);
	void AU_JoinColosseum_Click_Cancel();
	void AU_JoinColosseum_Click_Join();
	void AU_WarConquest_ColosseumDialog_OKCANCEL(bool IsOk);
	void AU_WarConquest_Select_Tab(int InSelectedIndex);
	void AU_WarConquest_UI_Close();
	void AU_Open_WarConquest();
	void AU_WarConquest_Exit_Click();
	void AU_WarConquest_Sorting_Click(int InListIndex, int InButtonIndex, int InSortType);
	void UA_ContentsInfo_Set_ChallengeTower_CT(const struct FString& InTokenCT);
	void UA_ContentsInfo_Set_ChallengeTower_Monster(const struct FString& InMosterCount);
	void UA_ContentsInfo_Set_ColosseumMatching(const struct FString& InFirstText, const struct FString& InSecondText);
	void UA_ContentsInfo_Set_Visible(bool InIsVisible);
	void UA_WarConquest_Set_Colosseum_Join_Time(int InPenaltyTime);
	void UA_JoinColosseum_Set_Button_Disable(bool bDisable);
	void UA_JoinColosseum_Set_Message(const struct FString& InMessage);
	void UA_JoinColosseum_Start_Progress();
	void UA_JoinColosseum_Set_Time(float InRemainTime, float InTotlaTime);
	void UA_JoinColosseum_Set_Attendee_Info(int InIndex, int InAttendeeInfo);
	void UA_WarConquest_Set_PlayCount(int InPlayCount);
	void UA_WarConquest_Set_SortingType(int InListIndex, int InButtonIndex, int InSortType);
	void UA_WarConquest_Set_ExitButtonDisable(bool bInDisable);
	void UA_WarConquest_Set_ExitTimer(int InSeconds);
	void UA_WarConquest_Set_ExitTimer_Visible(bool bInVisible);
	void UA_WarConquest_Set_ColosseumTimeInfoText(const struct FString& ColosseumTime);
	void UA_WarConquest_Set_ConquestInfoText(bool bInVisible, int InCurrentUser, int InMaxUser, int InWaitUser);
	void UA_WarConquest_Set_Result(int InResult);
	void UA_WarConquest_Set_Score(int InScore1, int InScore2);
	void UA_WarConquest_Set_Rejoin_Time(int inTime);
	void UA_WarConquest_Disable_Join_Type(int InType, bool Disable);
	void UA_WarConquest_Select_Join_Type(int InType);
	void UA_WarConquest_Set_Tab_State(int InState);
	void UA_WarConquest_Set_RankData_Occupation(int Index, TArray<class UGFxObject*> InOccupationWarScoreData);
	void UA_WarConquest_Set_MedalData(TArray<class UGFxObject*> InMedalDataList);
	void UA_WarConquest_Set_LogData(TArray<class UGFxObject*> InLogDataList);
	void UA_WarConquest_Set_RankData_Colosseum(int InIndex, TArray<class UGFxObject*> RankDataList);
	void UA_WarConquest_Set_RankData(int InIndex, TArray<class UGFxObject*> RankDataList);
	void UA_WarConquest_Set_Join_Button(int InWarType, class UGFxObject* Obj);
	int AU_AbnormalStatus_Tooltip_Data(int InToolTipType, int InPawnType, const struct FString& InSid, const struct FString& InCid);
	int AU_Tooltip_Data(int InToolTipType, const struct FString& InCid, const struct FString& InSid, bool DisableSubToolTip);
	void UA_TooltipItem_Set_Data_Object(int TooltipType, int ContainerType, class UGFxObject* InData);
	void UA_TooltipItem_Set_Data_Array(int TooltipType, int ContainerType, TArray<class UGFxObject*> InObjs);
	void UA_TooltipItem_Set_Data_String(int TooltipType, const struct FString& Title, const struct FString& Desc);
	void DispatchToolTipDataTest(const struct FString& Desc);
	void DispatchToolTipObjectData(int TooltipType, int ContainerType, class UGFxObject* InData);
	void DispatchToolTipDataNew(int TooltipType, int ContainerType, TArray<class UGFxObject*> InObjs);
	void DispatchToolTipData(int TooltipType, const struct FString& Title, const struct FString& Desc);
	void UpdatePlayerTarget(int InNewTargetSid, int InPrevTargetSid);
	void SetPawnInfoVisible(TEnumAsByte<EPawnType> PawnType, bool Visible);
	void OnPlayerTargetChanged(const struct FString& TargetSId);
	bool AU_Show_Target_PopupMenu(class UGFxObject* PopupOwner);
	void UA_Target_Set_Sign(int IconIndex);
	void UA_Target_Set_Bubble_Step(int Step);
	void SetTargetCombatStatus(TEnumAsByte<EBLCombatStatus> CombatStatus, int Sid, bool bForce);
	void UA_Target_Set_CastingBar_BarType(int CastingBarType);
	void UA_Target_Set_Distance(const struct FString& DistanceString);
	void UA_Target_Show_AbnormalStatus(int ActiveNum);
	void UA_Target_Show_HPText(bool bShow);
	void UA_Target_Set_Casting_Step_Visible(bool bTrue);
	void UA_Target_Set_Toggle_Casting_Step(int TargetStep, bool isActive);
	void UA_Target_Set_Casting_Current_Step(int CurrentStep);
	void UA_Target_Set_Casting_Step_Total_Num(int TotalStepNum);
	void UA_Target_Stop_Casting(TEnumAsByte<ECastingStopType> InStopType);
	void UA_Target_Set_AbnormalStatus(int Index, const struct FString& Cid, float DurationSeconds, float RemainingDurationSeconds, int IconIndex, TEnumAsByte<ECEBuffDebuffType> DebuffType, int StackCount);
	void UA_Target_Start_Interaction_Casting(int InteractionType, const struct FString& InteractionName, float TotalCastingTime, float RemainingTime);
	void UA_Target_Start_Casting(int SkillType, const struct FString& SkillName, float TotalCastingTime, float RemainingTime, bool AutoHideType);
	void AU_Talk_Select_Choice(int SelectionIndex, int selectiveRewardIndex, int bonusSelectiveRewardIndex);
	bool AU_Talk_End();
	void UA_Talk_Next_Step();
	void UA_Talk_End();
	void UA_Talk_On_FKey_Event(bool bPress);
	void UA_Talk_Set_Choice_Datas(TArray<class UGFxObject*> ChoiceDatas);
	void UA_Talk_Set_Quest_Reward(TArray<class UGFxObject*> RewwardItems);
	void UA_Talk_Set_Quest_Info(const struct FString& Title, int TimeLimit, const struct FString& Objectives, int Gold, int Exp, int BonusGold, int BonusExp, class UGFxObject* tokenObject);
	void UA_Talk_Set_Show_Quest_Type(int showQuestType);
	void UA_Talk_Set_Dialog_Texts(TArray<class UGFxObject*> DialogTexts);
	void UA_Talk_Set_Dialog_Text_Position(TArray<class UGFxObject*> PosDatas);
	void UA_Talk_Set_Button_Delay_Time(int DelayTime);
	void AU_SystemMenu_Deliberation();
	void AU_SystemMenu_Emergency_Escape();
	void AU_SystemMenu_InterfaceSetting();
	void AU_SystemMenu_SystemSetting();
	bool AU_SystemMenu_GoTo_Lobby();
	void AU_SystemMenu_Set_CombatState();
	void UA_SystemMenu_Set_Position(int PositionX, int PositionY);
	void UA_SystemMenu_Set_DisableEmergencyEscape(bool bDisabled);
	void UA_SystemMenu_Set_CombatFlag(bool bCombat);
	void UA_SystemMenu_Set_SystemMenuMode(int SystemMenuMode);
	void UA_Toggle_SystemMenu();
	void UA_Print_Subtitle(const struct FString& Subtitle);
	void UA_Clear_Subtitle();
	void UA_Set_Visible_Alt_Director_Track_UI(bool Visible);
	void UA_SkillDeck_Set_Short_Cut_String(TArray<class UGFxObject*> Datas);
	void UA_SkillDeck_Set_NewSkillCount(int SkillType, int COUNT);
	void UA_SkillDeck_Select_Tabs(int typeTacktics, int typeSkill);
	void UA_SkillDeck_Set_Use_Tactics(bool bInUse);
	void UA_SkillDeck_Set_TabButton(int InSelectedIndex, int InUsableTabBitFlag, TArray<struct FString> InTabNameList);
	void UA_SkillDeck_Set_Tactics_Change_Data(TArray<class UGFxObject*> SkillDeckTacticSlotObjList);
	void UA_SkillDeck_Set_Tactics_Data(TArray<class UGFxObject*> SkillDeckTacticSlotObjList);
	void UA_SkillDeck_Set_List_Change_Data(TArray<class UGFxObject*> SkillDeckCandidateSlotObjList);
	void UA_SkillDeck_Set_List_Data(TArray<class UGFxObject*> SkillDeckCandidateSlotObjList);
	class UGFxObject* MakeSkillRecommendList(int CategoryType, TArray<int> ApplySkillList);
	struct FString AU_Get_SkillName(int SkillCidNumber);
	void AU_FlashShop_Click_Add_Lumena_Button();
	void AU_FlashShop_Click_Item_Page(int InPage);
	void AU_FlashShop_Close_CustomDialog_Purchase_Amount();
	void AU_FlashShop_Click_Purchase_Amount(int InShopProductCid);
	void AU_FlashShop_Click_Buy_Item(int InShopProductCid);
	void AU_FlashShop_Click_Category_Button(int InCategoryId);
	void UA_FlashShop_Set_My_Lumena(int InMyLumena);
	void UA_FlashShop_Set_Duration(int InRemainSeconds);
	void UA_FlashShop_Set_Category_Page(int InMaxPage, int InCurrentPage);
	void UA_FlashShop_Set_Category_Item_Data(TArray<class UGFxObject*> InCategoryItemDataList);
	void UA_FlashShop_Set_Title(const struct FString& InTitle, const struct FString& InCategoryName);
	void AU_LUMENASHOP_CLICK_PREVIEW_CLOSE();
	void AU_LUMENASHOP_ROTATERIGHT_RELEASED();
	void AU_LUMENASHOP_ROTATERIGHT_PRESSED();
	void AU_LUMENASHOP_ROTATERIGHT_ROLLOUT();
	void AU_LUMENASHOP_ROTATERIGHT_ROLLOVER();
	void AU_LUMENASHOP_ROTATELEFT_RELEASED();
	void AU_LUMENASHOP_ROTATELEFT_PRESSED();
	void AU_LUMENASHOP_ROTATELEFT_ROLLOUT();
	void AU_LUMENASHOP_ROTATELEFT_ROLLOVER();
	void AU_LUMENASHOP_CLICK_PREVIEW_ITEM(int Cid);
	void AU_LumenaShop_Click_Add_Lumena_Button();
	void AU_LumenaShop_Click_Item_Page(int InPage);
	void AU_LumenaShop_Close_CustomDialog_Purchase_Amount();
	void AU_LumenaShop_Click_Purchase_Amount(int InItemCid);
	void AU_LumenaShop_Click_Buy_Item(int InItemCid);
	void AU_LumenaShop_Click_Category_Button(int InCategoryId);
	void UA_LumenaShop_Set_PreviewVisible(bool IsVisible);
	void UA_LumenaShop_Set_ContentToken(int InCoinType, int InToken);
	void UA_LumenaShop_Set_My_Lumena(int InMyLumena);
	void UA_LumenaShop_Set_Category_Page(int InMaxPage, int InCurrentPage);
	void UA_LumenaShop_SetRender();
	void UA_LumenaShop_Set_Category_Item_Data(TArray<class UGFxObject*> InCategoryItemDataList);
	void UA_LumenaShop_Set_Category_Name(TArray<class UGFxObject*> InCategoryDataList);
	void AU_Shop_Gift_Filter_Item(bool bGift);
	void AU_Shop_Filter_Item(bool bFiltering);
	void AU_Shop_Repurchase_Item(int Index, int TabIndex, int SlotIndex);
	void AU_Shop_Close_CustomDialog_Purchase_Amount();
	void AU_Shop_Purchase_Amount(int Index, int TabIndex, int SlotIndex);
	void AU_Shop_Purchase_Item(int Index, int TabIndex, int SlotIndex);
	void UA_Shop_Clear_SelectedItem();
	void UA_Shop_Set_Gift_Filter(bool bGift);
	void UA_Shop_Set_GiftFilter_Disabled(bool bGift);
	void UA_Shop_Set_ContentTokenType(TEnumAsByte<ECoinType> InCoinType);
	void UA_Shop_Show_Filter_Option(bool Visible);
	void UA_Shop_Filter_Item(bool isFiltering);
	void UA_Shop_Set_Title(const struct FString& Title);
	void UA_Shop_Set_Coin(TEnumAsByte<ECoinType> InCoinType, const struct FString& Gold);
	void UA_Shop_Clear_SoldItem();
	void UA_Shop_Remove_SoldItem(int Index);
	void UA_Shop_Set_SoldItem(int Index, const struct FString& Cid, const struct FString& Sid, int IconIndex, int Amount, int ItemGrade);
	void UA_Shop_Clear_ShopItem();
	void UA_Shop_Remove_ShopItem(int Index);
	void UA_Shop_Set_ShopItem(class UGFxObject* InShopItem);
	void UA_Close_Shop();
	void UA_Open_Shop();
	void AU_InterfaceSettingUI_Open_Reset_Dialog();
	void AU_InterfaceSettingUI_Open_Apply_Dialog();
	void UA_InterfaceSettingUI_Lock(bool bLock);
	void UA_InterfaceSettingUI_Init();
	void UA_InterfaceSettingUI_Changed_Settings(bool bDiff1, bool bDiff2);
	void AU_InterfaceSettingUI_KeySetting_Input_End(int KeyIndex, bool IsMainKey);
	void AU_InterfaceSettingUI_KeySetting_Input_Start();
	void AU_InterfaceSettingUI_KeySetting_SubPageData();
	void AU_InterfaceSettingUI_KeySetting_Input(int EnumKeyType, bool IsMainKey, int KeyCode, int ModifierCode);
	void AU_InterfaceSettingUI_Set_GuideQuest_FilterOut(bool bSelected);
	void AU_InterfaceSettingUI_Set_MonsterAlert_OnHeadIcon(bool bSelected);
	void AU_InterfaceSettingUI_Set_AutoRegist_MonsterAlert(bool bSelected);
	void AU_InterfaceSettingUI_Set_Map_Quest_FilterOut(bool FilterOut);
	void AU_InterfaceSettingUI_Set_Expansion_Minimap_LockPositionOnInit(bool bInit);
	void AU_InterfaceSettingUI_Set_Expansion_Minimap_Movable(bool Movable);
	void AU_InterfaceSettingUI_Set_Expansion_Minimap_FG_Transparency(int Value);
	void AU_InterfaceSettingUI_Set_Expansion_Minimap_BG_Transparency(int Value);
	void AU_InterfaceSettingUI_Set_Expansion_Minimap_Size(int Step);
	void AU_InterfaceSettingUI_Show_RaidMember_SpeechBubble(bool bSelected);
	void AU_InterfaceSettingUI_Set_Guild_Announce(bool bSelected);
	void AU_InterfaceSettingUI_Set_Friend_Announce(bool bSelected);
	void AU_InterfaceSettingUI_Show_Old_SpeechBubble(bool bSelected);
	void AU_InterfaceSettingUI_Show_NPC_SpeechBubble(bool bSelected);
	void AU_InterfaceSettingUI_Show_OtherPlayer_SpeechBubble(bool bSelected);
	void AU_InterfaceSettingUI_Show_PartyMember_SpeechBubble(bool bSelected);
	void AU_InterfaceSettingUI_Show_My_SpeechBubble(bool bSelected);
	void AU_InterfaceSettingUI_Set_Mouse_Sensitivity(int Sensitivity);
	void AU_InterfaceSettingUI_Set_Aim_Buffer_Size(int AimBuffer);
	void AU_InterfaceSettingUI_Set_Fixed_Camera(bool bSelected);
	void AU_InterfaceSettingUI_Set_Mouse_Left_Move(bool bSelected);
	void AU_InterfaceSettingUI_Set_Mouse_LeftRight_Move(bool bSelected);
	void AU_InterfaceSettingUI_Set_Target_Tracking(bool bSelected);
	void AU_InterfaceSettingUI_Set_Handle_Mode(int HandleType);
	void AU_InterfaceSettingUI_Set_Camera_Shake(bool bSelected);
	void AU_InterfaceSettingUI_Set_Camera_Max_Sight(int CameraZoomStep);
	void AU_InterfaceSettingUI_Set_Camera_Rotation_Speed(int CameraRotationSpeed);
	void AU_InterfaceSettingUI_Show_Outline_War_Target(bool bSelected);
	void AU_InterfaceSettingUI_Show_Outline_War_User(bool bSelected);
	void AU_InterfaceSettingUI_Show_Outline_War(bool bSelected);
	void AU_InterfaceSettingUI_Show_Outline_Dungeon_Target(bool bSelected);
	void AU_InterfaceSettingUI_Show_Outline_Dungeon_User(bool bSelected);
	void AU_InterfaceSettingUI_Show_Outline_Dungeon(bool bSelected);
	void AU_InterfaceSettingUI_Show_Outline_Field_Target(bool bSelected);
	void AU_InterfaceSettingUI_Show_Outline_Field_User(bool bSelected);
	void AU_InterfaceSettingUI_Show_Outline_Field(bool bSelected);
	void AU_InterfaceSettingUI_Show_Outline_All(bool bSelected);
	void AU_InterfaceSettingUI_Show_AbnormalStatus_SelfStackMsg(bool bSelected);
	void AU_InterfaceSettingUI_Show_RaidMember_ReciveHealMsg(bool bSelected);
	void AU_InterfaceSettingUI_Show_RaidMember_DamageMsg(bool bSelected);
	void AU_InterfaceSettingUI_Show_RaidMember_AttackMsg(bool bSelected);
	void AU_InterfaceSettingUI_Show_PartyMember_ReciveHealMsg(bool bSelected);
	void AU_InterfaceSettingUI_Show_PartyMember_DamageMsg(bool bSelected);
	void AU_InterfaceSettingUI_Show_PartyMember_AttackMsg(bool bSelected);
	void AU_InterfaceSettingUI_Show_MyReciveHeal_BattleMsg(bool bSelected);
	void AU_InterfaceSettingUI_Show_MyDoHeal_BattleMsg(bool bSelected);
	void AU_InterfaceSettingUI_Show_MyDamage_BattleMsg(bool bSelected);
	void AU_InterfaceSettingUI_Show_MyAttack_BattleMsg(bool bSelected);
	void AU_InterfaceSettingUI_Show_Royal_Icon(bool bSelected);
	void AU_InterfaceSettingUI_Show_Monster_Icon(bool bSelected);
	void AU_InterfaceSettingUI_Show_Episode_Icon(bool bSelected);
	void AU_InterfaceSettingUI_Show_Story_Icon(bool bSelected);
	void AU_InterfaceSettingUI_Show_RaidMember_HPBar(bool bSelected);
	void AU_InterfaceSettingUI_Show_Negative_Target_HPBar(bool bSelected);
	void AU_InterfaceSettingUI_Show_Target_HPBar(bool bSelected);
	void AU_InterfaceSettingUI_Show_PartyMember_HPBar(bool bSelected);
	void AU_InterfaceSettingUI_Show_MyHPBar(bool bSelected);
	void AU_InterfaceSettingUI_Show_MPText(bool bSelected);
	void AU_InterfaceSettingUI_Show_HPText(bool bSelected);
	void AU_InterfaceSettingUI_ShowGuildMark(bool bSelected);
	void AU_InterfaceSettingUI_ShowOtherPlayerRank(bool bSelected);
	void AU_InterfaceSettingUI_ShowMyRank(bool bSelected);
	void AU_InterfaceSettingUI_ShowGuildName(bool bSelected);
	void AU_InterfaceSettingUI_Show_MonsterName(bool bSelected);
	void AU_InterfaceSettingUI_Show_NPCName(bool bSelected);
	void AU_InterfaceSettingUI_Show_RaidMemberName(bool bSelected);
	void AU_InterfaceSettingUI_Show_OtherPlayerName(bool bSelected);
	void AU_InterfaceSettingUI_Show_PartyMemberName(bool bSelected);
	void AU_InterfaceSettingUI_Show_MyName(bool bSelected);
	void AU_InterfaceSettingUI_Reset_All();
	void AU_InterfaceSettingUI_Cancel_Changed_Settings();
	void AU_InterfaceSettingUI_Apply_Changed_Settings();
	void AU_InterfaceSettingUI_Init_Settings_UI();
	void UA_InterfaceSettingUI_Set_KeySetting_End();
	void UA_InterfaceSettingUI_Set_KeySetting_Comment(const struct FString& Comment, float Time);
	void UA_InterfaceSettingUI_Set_KeySetting_Data(int KeyType, const struct FString& KeyMain, const struct FString& KeySub);
	void UA_InterfaceSettingUI_Set_KeySetting_SubPageData(TArray<class UGFxObject*> PageData);
	void UA_InterfaceSettingUI_Set_KeySetting_Category_Data(TArray<class UGFxObject*> CategoryData);
	void UA_InterfaceSettingUI_Set_GuideQuest_FilterOut(bool bSelected);
	void UA_InterfaceSettingUI_Set_MonsterAlert_OnHeadIcon(bool bSelected);
	void UA_InterfaceSettingUI_Set_BeginnersGuide(bool bSelected);
	void UA_InterfaceSettingUI_Set_AutoRegist_MonsterAlert(bool bSelected);
	void UA_InterfaceSettingUI_Set_Map_Quest_FilterOut(bool FilterOut);
	void UA_InterfaceSettingUI_Set_ExpansionMinimap_LockPosition_Init(bool bInit);
	void UA_InterfaceSettingUI_Set_ExpansionMinimap_Movable(bool Movable);
	void UA_InterfaceSettingUI_Set_ExpansionMinimap_FGOpacity(int MinValue, int MaxValue, int CurValue);
	void UA_InterfaceSettingUI_Set_ExpansionMinimap_BGOpacity(int MinValue, int MaxValue, int CurValue);
	void UA_InterfaceSettingUI_Set_ExpansionMinimap_Size(int Step);
	void UA_InterfaceSettingUI_Set_Guild_Announce(bool bSelected);
	void UA_InterfaceSettingUI_Set_Friend_Announce(bool bSelected);
	void UA_InterfaceSettingUI_Show_RaidMember_SpeechBubble(bool bSelected);
	void UA_InterfaceSettingUI_Show_Old_SpeechBubble(bool bSelected);
	void UA_InterfaceSettingUI_Show_NPC_SpeechBubble(bool bSelected);
	void UA_InterfaceSettingUI_Show_OtherPlayer_SpeechBubble(bool bSelected);
	void UA_InterfaceSettingUI_Show_PartyMember_SpeechBubble(bool bSelected);
	void UA_InterfaceSettingUI_Show_My_SpeechBubble(bool bSelected);
	void UA_InterfaceSettingUI_Set_Mouse_Sensitivity(int MinValue, int MaxValue, int CurValue);
	void UA_InterfaceSettingUI_Set_Aim_Buffer_Size(int MinValue, int MaxValue, int CurValue);
	void UA_InterfaceSettingUI_Fixed_Camera(bool bSelected);
	void UA_InterfaceSettingUI_Mouse_Left_Move(bool bSelected);
	void UA_InterfaceSettingUI_Mouse_LeftRight_Move(bool bSelected);
	void UA_InterfaceSettingUI_Target_Tracking(bool bSelected);
	void UA_InterfaceSettingUI_Set_Handle_Mode(int HandleType);
	void UA_InterfaceSettingUI_Set_Camera_Shake(bool bSelected);
	void UA_InterfaceSettingUI_Set_Camera_Max_Sight(int MinValue, int MaxValue, int CurValue);
	void UA_InterfaceSettingUI_Set_Camera_Rotation_Speed(int MinValue, int MaxValue, int CurValue);
	void UA_InterfaceSettingUI_Show_WarTargetOutline(bool bSelected);
	void UA_InterfaceSettingUI_Show_WarUserOutline(bool bSelected);
	void UA_InterfaceSettingUI_Show_WarOutline(bool bSelected);
	void UA_InterfaceSettingUI_Show_DungeonTargetOutline(bool bSelected);
	void UA_InterfaceSettingUI_Show_DungeonUserOutline(bool bSelected);
	void UA_InterfaceSettingUI_Show_DungeonOutline(bool bSelected);
	void UA_InterfaceSettingUI_Show_FieldTargetOutline(bool bSelected);
	void UA_InterfaceSettingUI_Show_FieldUserOutline(bool bSelected);
	void UA_InterfaceSettingUI_Show_FieldOutline(bool bSelected);
	void UA_InterfaceSettingUI_Show_AllOutline(bool bSelected);
	void UA_InterfaceSettingUI_Show_AbnoramlStatus_Stack(bool bSelected);
	void UA_InterfaceSettingUI_Show_RaidMember_ReciveHealMsg(bool bSelected);
	void UA_InterfaceSettingUI_Show_RaidMember_DamageMsg(bool bSelected);
	void UA_InterfaceSettingUI_Show_RaidMember_AttackMsg(bool bSelected);
	void UA_InterfaceSettingUI_Show_PartyMember_ReciveHealMsg(bool bSelected);
	void UA_InterfaceSettingUI_Show_PartyMember_DamageMsg(bool bSelected);
	void UA_InterfaceSettingUI_Show_PartyMember_AttackMsg(bool bSelected);
	void UA_InterfaceSettingUI_Show_My_ReciveHeal_BattleMsg(bool bSelected);
	void UA_InterfaceSettingUI_Show_My_MyDoHeal_BattleMsg(bool bSelected);
	void UA_InterfaceSettingUI_Show_My_Damage_BattleMsg(bool bSelected);
	void UA_InterfaceSettingUI_Show_My_Attack_BattleMsg(bool bSelected);
	void UA_InterfaceSettingUI_Show_Royal_Icon(bool Checked);
	void UA_InterfaceSettingUI_Show_Monster_Icon(bool Checked);
	void UA_InterfaceSettingUI_Show_Episode_Icon(bool Checked);
	void UA_InterfaceSettingUI_Show_Story_Icon(bool Checked);
	void UA_InterfaceSettingUI_Show_RaidMemberHPBar(bool bSelected);
	void UA_InterfaceSettingUI_Show_NegativeTargetHPBar(bool bSelected);
	void UA_InterfaceSettingUI_Show_TargetHPBar(bool bSelected);
	void UA_InterfaceSettingUI_Show_PartyMemberHPBar(bool bSelected);
	void UA_InterfaceSettingUI_Show_MyHPBar(bool bSelected);
	void UA_InterfaceSettingUI_Show_MPText(bool bSelected);
	void UA_InterfaceSettingUI_Show_HPText(bool bSelected);
	void UA_InterfaceSettingUI_Show_GuildMark(bool bSelected);
	void UA_InterfaceSettingUI_Show_OtherPlayerRank(bool bSelected);
	void UA_InterfaceSettingUI_Show_MyRank(bool bSelected);
	void UA_InterfaceSettingUI_Show_GuildName(bool bSelected);
	void UA_InterfaceSettingUI_Show_MonsterName(bool bSelected);
	void UA_InterfaceSettingUI_Show_NPCName(bool bSelected);
	void UA_InterfaceSettingUI_Show_RaidMemberName(bool bSelected);
	void UA_InterfaceSettingUI_Show_OtherPlayerName(bool bSelected);
	void UA_InterfaceSettingUI_Show_PartyMemberName(bool bSelected);
	void UA_InterfaceSettingUI_Show_MyName(bool bSelected);
	void AU_SystemSettingUI_Open_Reset_Dialog();
	void AU_SystemSettingUI_Open_Apply_Dialog();
	void AU_SystemSettingUI_Reset_All();
	void AU_SystemSettingUI_Cancel_Changed_Settings();
	void AU_SystemSettingUI_Apply_Changed_Settings();
	void AU_SystemSettingUI_Init_Settings_UI();
	void AU_SystemSettingUI_Set_UISound_Volume(int Volume);
	void AU_SystemSettingUI_Off_SystemVoice(bool bSelected);
	void AU_SystemSettingUI_Set_SystemVoice_Volume(int Volume);
	void AU_SystemSettingUI_Set_NPCVoice_Volume(int Volume);
	void AU_SystemSettingUI_Set_EffectSound_Volume(int Volume);
	void AU_SystemSettingUI_Set_AmbientSound_Volume(int Volume);
	void AU_SystemSettingUI_Off_BGMusic(bool bSelected);
	void AU_SystemSettingUI_Set_BGMusic_Volume(int Volume);
	void AU_SystemSettingUI_Off_MasterSound(bool bSelected);
	void AU_SystemSettingUI_Set_MasterSound_Volume_Finish(int Volume);
	void AU_SystemSettingUI_Set_MasterSound_Volume(int Volume);
	void AU_SystemSettingUI_Set_NPC_MaxMeshRendering(int Value);
	void AU_SystemSettingUI_Set_NPC_MaxProxyRendering(int Value);
	void AU_SystemSettingUI_Set_NPC_MaxMeshLoading(int Value);
	void AU_SystemSettingUI_Set_PC_MaxMeshRendering(int Value);
	void AU_SystemSettingUI_Set_PC_MaxProxyRendering(int Value);
	void AU_SystemSettingUI_Set_PC_MaxMeshLoading(int Value);
	void AU_SystemSettingUI_Set_ShadowDraw(int Value);
	void AU_SystemSettingUI_Set_EffectDraw_Distance(int Value);
	void AU_SystemSettingUI_Set_EffectDraw(int Value);
	void AU_SystemSettingUI_Set_Terrain_DetailDraw(int Value);
	void AU_SystemSettingUI_Set_Object_DetailDraw(int Value);
	void AU_SystemSettingUI_Set_BGDraw_Distance(int Value);
	void AU_SystemSettingUI_Set_Character_DetailDraw(int Value);
	void AU_SystemSettingUI_Set_Character_Sight_Distance(int Value);
	void AU_SystemSettingUI_Set_Texture_Resolution(int Value);
	void AU_SystemSettingUI_Enable_Detail_Graphic_Option(bool bSelected);
	void AU_SystemSettingUI_Set_All_Together_Graphic_Option(int Value);
	void AU_SystemSettingUI_Set_ScreenBrightness(int DisplayGamma);
	void AU_SystemSettingUI_Set_Display_Resolution(int ResolutionIndex);
	void AU_SystemSettingUI_Set_Display_Ratio(int DisplayRatio);
	void AU_SystemSettingUI_Set_Display_Mode(int DisplayMode);
	void UA_SystemSettingUI_Set_UI_SoundVolume(int MinValue, int MaxValue, int CurValue);
	void UA_SystemSettingUI_Off_SystemVoice(bool bSelected);
	void UA_SystemSettingUI_Set_SystemVoice_Volume(int MinValue, int MaxValue, int CurValue);
	void UA_SystemSettingUI_Set_NPCVoice_Volume(int MinValue, int MaxValue, int CurValue);
	void UA_SystemSettingUI_Set_EffectSound_Volume(int MinValue, int MaxValue, int CurValue);
	void UA_SystemSettingUI_Set_AmbientSound_Volume(int MinValue, int MaxValue, int CurValue);
	void UA_SystemSettingUI_Off_BGMusic(bool bSelected);
	void UA_SystemSettingUI_Set_BGMusic_Volume(int MinValue, int MaxValue, int CurValue);
	void UA_SystemSettingUI_Off_Master_Sound(bool bSelected);
	void UA_SystemSettingUI_Set_MasterSound_Volume(int MinValue, int MaxValue, int CurValue);
	void UA_SystemSettingUI_Set_NPC_MaxMeshRendering(int MinValue, int MaxValue, int CurValue);
	void UA_SystemSettingUI_Set_NPC_MaxProxyRendering(int MinValue, int MaxValue, int CurValue);
	void UA_SystemSettingUI_Set_NPC_MaxMeshLoading(int MinValue, int MaxValue, int CurValue);
	void UA_SystemSettingUI_Set_PC_MaxMeshRendering(int MinValue, int MaxValue, int CurValue);
	void UA_SystemSettingUI_Set_PC_MaxProxyRendering(int MinValue, int MaxValue, int CurValue);
	void UA_SystemSettingUI_Set_PC_MaxMeshLoading(int MinValue, int MaxValue, int CurValue);
	void UA_SystemSettingUI_Set_ShadowDraw(int MinValue, int MaxValue, int CurValue);
	void UA_SystemSettingUI_Set_EffectDraw_Distance(int MinValue, int MaxValue, int CurValue);
	void UA_SystemSettingUI_Set_EffectDraw(int MinValue, int MaxValue, int CurValue);
	void UA_SystemSettingUI_Set_Terrain_DetailDraw(int MinValue, int MaxValue, int CurValue);
	void UA_SystemSettingUI_Set_Object_DetailDraw(int MinValue, int MaxValue, int CurValue);
	void UA_SystemSettingUI_Set_BGDraw_Distance(int MinValue, int MaxValue, int CurValue);
	void UA_SystemSettingUI_Set_Character_DetailDraw(int MinValue, int MaxValue, int CurValue);
	void UA_SystemSettingUI_Set_Character_Sight_Distance(int MinValue, int MaxValue, int CurValue);
	void UA_SystemSettingUI_Set_Texture_Resolution(int MinValue, int MaxValue, int CurValue);
	void UA_SystemSettingUI_Enable_Detail_Graphic_Option(bool bSelected);
	void UA_SystemSettingUI_Set_All_Together_Graphic_Option(int MinValue, int MaxValue, int CurValue);
	void UA_SystemSettingUI_Set_Display_Resolution_With_UserSetting();
	void UA_SystemSettingUI_Set_Screen_Brightness(int MinValue, int MaxValue, int CurValue);
	void UA_SystemSettingUI_Set_Display_ResolutionList(TArray<int> DisplayRatioIndex, TArray<struct FString> ResolutionList, int SelectedIndex);
	void UA_SystemSettingUI_Set_Display_RatioList(TArray<struct FString> DisplayRatioList, int SelectedIndex);
	void UA_SystemSettingUI_Set_DisplayMode(int DisplayMode);
	void UA_SystemSettingUI_Lock(bool bLock);
	void UA_SystemSettingUI_Init();
	void UA_SystemSettingUI_Changed_Settings(bool bDiff1, bool bDiff2);
	void UA_SystemSettingUI_Set_SystemSettingMode(int SystemSettingMode);
	void SendSettingSliderProtocol(const struct FString& Protocol, int MinValue, int MaxValue, int CurValue);
	void SendSettingProtocol(const struct FString& Protocol, bool bValue);
	void CloseRevivalDialog(TEnumAsByte<ERevivalState> RevivalState);
	void UpdateRevivalDialog(const struct FRevivalDialogData& InData);
	void OpenRevivalDialog(const struct FRevivalDialogData& InData);
	void AU_QuestAlert_Click_Fold(int questId, bool IsFold);
	void AU_QuestAlert_Click_AutoMove(int QuestType, int questId, bool isAutoMove);
	void AU_QuestAlert_Change_CheckBox_MonsterQuestFilter(bool bChecked);
	void AU_QuestAlert_Change_CheckBox_GuideQuestFilter(bool bChecked);
	void AU_QuestAlert_Change_CheckBox_EpisodeQuestFilter(bool bChecked);
	void AU_QuestAlert_Change_CheckBox_RoyalQuestFilter(bool bChecked);
	void AU_Alert_Reward(int Id);
	void UA_QuestAlert_Set_Fold(int questId, bool IsFold);
	void UA_QuestAlert_Set_AutoMove(int QuestType, int questId, bool isAutoMove);
	void UA_QuestAlert_Set_MonsterQuestFilter(bool bChecked);
	void UA_QuestAlert_Set_GuideQuestFilter(bool bChecked);
	void UA_QuestAlert_Set_EpisodeQuestFilter(bool bChecked);
	void UA_QuestAlert_Set_RolyalQuestFilter(bool bChecked);
	void UA_QuestAlert_Set_PathGuide(int questId, int QuestType, int QuestDirection, int QuestDist);
	void UA_QuestAlert_Set_Tutorial(bool Tutorial);
	void UA_QuestAlert_Set_Item_Cooldown(int questId, int QuestType, float RemainTime, float MaxTime);
	void UA_QuestAlert_Set_Available_Item(int questId, int QuestType, bool bEnable);
	void UA_QuestAlert_Set_Story_Alert_Data(class UGFxObject* StoryAlertElement);
	void UA_QuestAlert_Set_Complete_All_Story();
	void UA_QuestAlert_Set_Alert_Data(TArray<class UGFxObject*> AlertElements);
	void UA_Close_Prop_ToolTip();
	void UA_Show_Prop_ToolTip(const struct FString& PropName, const struct FString& PropDesc, TArray<class UGFxObject*> Quests, const struct FString& GatherDesc);
	void AU_Private_Trade_Drop_From_Equip(const struct FString& InSid, int InSlotIndex);
	void AU_Private_Trade_Drop_From_Inventory(const struct FString& InSid, int InSlotIndex);
	void AU_Private_Trade_Drop_To_Inventory(const struct FString& InSid, int InTabIndex, int InSlotIndex);
	void AU_Private_Trade_Item_Out(const struct FString& InSid);
	void AU_Private_Trade_Clicked_Cancel();
	void AU_Private_Trade_Clicked_Confirm();
	void AU_Private_Trade_Kill_Focus_Input(const struct FString& Gold);
	void AU_Private_Trade_Set_Focus_Input();
	void AU_Private_Trade_Declined_Receiving();
	void AU_Private_Trade_Accepted_Receiving();
	void AU_Private_Trade_Cancel_Sending();
	void AU_Private_Trade_Close();
	void RequestCloseTargetPopupMenu();
	void RequestClosePopupMenu();
	void OnPlayerInitComplete(int Sid);
	void SetCombatStatus(TEnumAsByte<EBLCombatStatus> CombatStatus);
	void PLAYER_INIT_COMPLETE(const struct FString& Sid);
	void AU_Set_Party_Roll_Dice_Grade(int InRollDiceGrade);
	void AU_PCUI_Select_Stance(int InStanceCid);
	void AU_PCUI_Select_Tactic(int InTacticsIndex);
	bool AU_Show_PC_Menu(class UGFxObject* PopupOwner);
	bool AU_Set_Party_Distribute_Method(int PartyDistributeMethod, int distributorSid);
	bool AU_Target_Self();
	void UpdateCombatFlairs(TArray<struct FCombatFlairData>* CombatFlairDataList, TArray<struct FCombatFlairActivateData>* ActivateList);
	void UA_Show_MP_Text(bool bShow);
	void UA_PCUI_ShowHPText(bool bShow);
	void UA_PCUI_Set_Tactics_Button_Tooltip(TArray<class UGFxObject*> InTooltipObjectList);
	void UA_PCUI_Set_Tactic(TArray<int> InTacticsTypeList);
	void UA_PCUI_StanceChangeAction_Ani(bool IsPlayEffet);
	void UA_PCUI_Change_Stance_Cooltime(int InTacticsIndex, float InCoolTime);
	void UA_PCUI_Change_Stance(int InTacticsIndex);
	void UA_PCUI_Set_Stance(class UGFxObject* InStance1, class UGFxObject* InStance2);
	void UA_PCUI_Update_GearScore(const struct FString& InGearScore, bool InIsAniPlay);
	bool RequestPartySummon(int InPartyMemberSid);
	bool RequestHandlePartyInvitation(bool Answer, int sidInvitor, int sidInvitee, TEnumAsByte<EPartyType> partyType);
	bool RequestInviteToPartyWithName(const struct FString& PawnName);
	bool RequestInviteToParty(int Sid);
	bool RequestFollowPartyChannel(const struct FString& OtherPlayerName, int DestChannelId);
	bool RequestMoveToPartyChannel(int InPartyMemberSid);
	void AddPartyMemberEx(const struct FPartyMemberPCData& PartyMemberData);
	bool AU_Entrust_Party_Leader(int Sid);
	bool AU_Party_Show_PopupMenu(class UGFxObject* PopupOwner);
	bool AU_Party_Changed_Target(int Sid);
	void UA_Party_LogOut_Member(const struct FString& Sid);
	void UA_Party_LogIn_Member(const struct FString& Sid, const struct FString& PrevSID);
	void UA_Party_Remove_Member(const struct FString& Sid);
	void UA_Party_Add_Member(TEnumAsByte<EPawnType> PawnType, const struct FString& Sid, int SlotIndex, const struct FString& PlayerName, int HP, int MaxHP, int MP, int MaxMP, int iClass, int Level);
	void UA_Party_Show_Member_Select_Effect(int Sid, bool bShow);
	void UA_Party_Set_Member_Other_Channel(int Sid, bool OtherChannel, int ChannelNum, const struct FString& PvPText);
	void UA_Party_Set_Member_Death(int Sid, bool bDeath);
	void UA_Party_Set_Member_In_Instance_Field(int Sid, bool InstanceField);
	void UA_Party_Set_Member_In_Dungeon(int Sid, bool bDungeon);
	void AU_OpenerCustomizable_Already_Add_List();
	void AU_OpenerCustomizable_Full_List();
	void AU_OpenerCustomizable_Save_List(TArray<struct FString> CustomizableList);
	TArray<struct FString> AU_OpenerCustomizable_Load_List();
	TArray<class UGFxObject*> AU_OpenerAvailable_Get_Data();
	TArray<class UGFxObject*> AU_Opener_Get_Data();
	bool OpenerGotoLobby();
	void AU_Opener_Show_PopupMenu(const struct FString& OpenerType, bool IsAdd);
	void AU_Opener_Open_UI(const struct FString& OpenerType);
	void UA_OpenerCustomizable_Set_Shortcut_Datas(TArray<class UGFxObject*> ShortcutDatas);
	void UA_OpenerCustomizable_Set_Open_Level(const struct FString& OpenerType, int openLevel);
	void UA_OpenerCustomizable_Remove(const struct FString& OpenerType);
	void UA_OpenerCustomizable_Add(const struct FString& OpenerType);
	void UA_OpenerCustomizable_Set_Disable(const struct FString& OpenerType, bool bDisable, bool bIconLock);
	void UA_OpenerAvailable_Set_Available(const struct FString& OpenerType, bool bAvailable);
	void UA_OpenerAvailable_Set_Shortcut_Datas(TArray<class UGFxObject*> ShortcutDatas);
	void UA_OpenerAvailable_Set_Notification_Count(const struct FString& OpenerType, int InCount);
	void UA_Opener_Set_Open_Level(const struct FString& OpenerType, int openLevel);
	void UA_Opener_Set_Shortcut_Datas(TArray<class UGFxObject*> ShortcutDatas);
	void UA_Opener_Set_Notification_Count(const struct FString& OpenerType, int InCount);
	void UA_Opener_Set_Disable(const struct FString& OpenerType, bool bDisable, bool bIconLock);
	void UA_NoticeBoard_Set_Realm(TEnumAsByte<ECERealmType> Type);
	void UA_Show_Overlay_Message(TEnumAsByte<ECESystemMessageOverlayType> OverlayType, const struct FString& InMessage, int OverlayTime, int DelayTime, class UGFxObject* inObj);
	class UGFxUI_NameTagObject* GetPawnNameTagObject();
	void UA_Clear_NameTag();
	void UA_Pool_Clear();
	bool UA_Return_To_NameTag_Object2(class UGFxObject* NameTag);
	bool UA_Return_To_NameTag_Object(class UGFxObject* NameTag);
	bool ReturnNameTagToPool(class UGFxObject* NameTag);
	bool UA_Active_NameTag_Object2(class UGFxObject* NameTag);
	class UGFxUI_NameTagObject* UA_Get_NameTag_Object2();
	class UGFxUI_NameTagObject* UA_Get_NameTag_Object();
	void SetMinimapExtensionFGOpacity(int Opacity);
	void SetMinimapExtensionBGOpacity(int Opacity);
	void SetMinimapExtensionMovable(bool bMovable);
	void SetMinimapExtensionSize(int Step);
	void AU_MinimapExtension_Close();
	void AU_Minimap_Check_Option_Info(int checkedIndex, bool Selected);
	void RequestCloseMoveToPartyChannelDialog();
	void AU_Minimap_Open_Extension();
	bool CheckMinimapFilter(TEnumAsByte<EMinimapFilter> InFilterType);
	TArray<class UGFxObject*> AU_Minimap_Get_Filter_Data();
	void AU_Request_Update_Tooltip(TArray<class UGFxObject*> RequestedTooltipInfoList);
	float AU_Get_Minimap_Tooltip_Delay();
	struct FString AU_Get_Minimap_Zoom_Scale(int MapScaleStep);
	void AU_Move_Channel(int channelId);
	void AU_Channel_List();
	void UA_Minimap_Show_ExtendBtn(bool IsVisible);
	void UA_Update_Minimap_QuestTooltip(TArray<class UGFxObject*> arrUpdatedTooltipData);
	void UA_Set_In_Instance_Field(bool bShow);
	void UA_Show_Channel_Btn(bool bShow);
	void UA_Set_Disable_Channel_Move(bool Disable);
	void UA_Update_Channel_Move_CoolTime(int Duration, int RemainDuration, bool AutoClearType);
	void UA_Update_PC_Channel(int ChannelNum, const struct FString& ToolTip);
	void UA_Show_Channel_List(bool bShow);
	void UA_Set_Channel_List(TArray<class UGFxObject*> ChannelList);
	void UA_Set_World_Time(bool DaySymbol, float Time);
	void UA_Minimap_Set_Day(int InDayValue);
	bool FindForbidInMailContentString(const struct FString& Target, int* pos, struct FString* ForbidString);
	void AU_MailWrite_Move_Item(int FromSlot, int ToSlot);
	void AU_MailWrite_Clear_Location();
	void AU_MailWrite_Drop_To_Inventory(const struct FString& Sid, int TabIndex, int SlotIndex);
	void AU_MailWrite_Init_Contents();
	void AU_MailWrite_Cancel();
	void AU_MailWrite_Send_To_Mail(const struct FString& receiverName, const struct FString& Title, const struct FString& Content, TArray<struct FString> Items, const struct FString& Gold);
	void AU_MailWrite_Send_To_Location();
	struct FString AU_MailWrite_Check_Input_Gold(const struct FString& Gold);
	void AU_MailWrite_Remove_Item(int SlotIndex, const struct FString& Sid);
	void AU_MailWrite_Add_Item(int SlotIndex, const struct FString& Sid);
	void AU_MailWrite_Check_Input_Reciever(const struct FString& receiverName);
	void AU_Open_MailWrite_UI();
	void UA_MailWrite_Check_ForbidString(int Type, int ForbidPos, const struct FString& ForbidString);
	void UA_MailWrite_Set_Mail_Item(int Index, int Cid, const struct FString& Sid, int IconIndex, int Amount, int EquipSlotType, bool Usable);
	void UA_MailWrite_Set_Gold(const struct FString& Gold);
	void UA_MailWrite_Set_Location(const struct FString& LocationName);
	void UA_MailWrite_Check_Reciever(bool bInvalid);
	void UA_MailWrite_Set_Default(const struct FString& receiverName, const struct FString& Title, bool IsBlock);
	void UA_MailWrite_Init_Contents();
	void RequestMailBoxPage(int PageIndex);
	void AU_MailBox_Cancel();
	void AU_MailBox_Show_Popup(int MailIndex);
	void AU_MailBox_Check_Mail_State(int MailIndex);
	void AU_MailBox_Show_Location(int MailIndex);
	void AU_MailBox_Delete_Mail(int MailIndex);
	void AU_MailBox_Get_WithDraw(int MailIndex);
	void AU_MailBox_Click_MailWrite(int Type, int MailIndex);
	void AU_MailBox_Change_Page(int PageIndex);
	void AU_MailBox_Click_TabButton(int MailBoxState);
	void AU_MailBox_UI_Close();
	void AU_MailBox_UI_Open();
	void UA_MailBox_Lock(bool bLock);
	void UA_MailBox_Change_Mail_State(TEnumAsByte<EMailBoxState> StateType, int MailIndex, int MailState);
	void UA_MailBox_Set_Counter(TEnumAsByte<EMailBoxState> StateType, const struct FString& Normal, const struct FString& GM, const struct FString& System);
	void UA_MailBox_Set_Data(TEnumAsByte<EMailBoxState> StateType, int PageIndex, int MaxPageIndex, TArray<class UGFxObject*> MailDatas);
	void AU_LootingDice_Dice_TimeOver(const struct FString& Cid, const struct FString& Sid, const struct FString& OwnerSid);
	void AU_LootingDice_GiveUp_Item(const struct FString& Cid, const struct FString& Sid, const struct FString& OwnerSid);
	void AU_LootingDice_Auction_Item(const struct FString& Cid, const struct FString& Sid, const struct FString& OwnerSid);
	void UA_LootingDice_Set_Dice_Item_Datas(TArray<class UGFxObject*> Items);
	void UA_Open_Looting_Dice();
	class UGFxObject* CreateDropGold(int DropItemIndex, const struct FQWord& Gold);
	class UGFxObject* CreateDropContentToken(int DropItemIndex, const struct FEachDropContentTokenInfo& Token);
	class UGFxObject* CreateDropItem(int DropItemIndex, const struct FEachDropItemInfo& Item);
	void SetDropItemBag(TArray<struct FEachDropItemInfo> ItemList, TArray<struct FEachDropContentTokenInfo> ContentTokenList, const struct FQWord& Gold, bool bCanGiveup, bool bAddLooting, int RequireLumenaAddLooting);
	void AU_Looting_Click_Use_Lumena();
	bool AU_Looting_Take_Drop_Coin(int CoinType, int dropItemType);
	bool AU_Looting_Take_Drop_Item(const struct FString& DropItemCid, int dropItemType);
	bool AU_Looting_Take_All_Drop_Item();
	bool AU_Looting_Choose_Drop_Item_Acquirer(const struct FString& AcquirerSid);
	bool AU_Looting_Giveup_Drop_Item_Bag();
	bool AU_Looting_Close_Drop_Item_Bag();
	void UA_Looting_Set_Drop_Item_Acquirer(int Index, const struct FString& AcquirerSid, const struct FString& AcquirerName, bool IsLast);
	void UA_Looting_Close_Drop_Item_Bag();
	void UA_Looting_Open_Drop_Item_Bag();
	void UA_Looting_Set_Drop_Items(TArray<class UGFxObject*> Items);
	void UA_Looting_Set_Button(bool isCanGiveUp, bool isUseDefButton, const struct FString& Label, bool isUseLumena);
	void SetLetterInfoText(const struct FString& InletterInfoString);
	void UA_LetterInfo_Close();
	void UA_LetterInfo_Set_Text(const struct FString& InletterInfoString);
	void UA_LetterInfo_Open();
	void UpdateQuestProgressInfo(const struct FQuestProgressInfo& UpdateQuestProgressInfo, int NewQuestId, int UpdatedQuestId, int CompletedQuestId, int SequnceQuestId);
	class UGFxObject* AU_Journal_Get_MonsterBook_Default_Selected();
	void AU_Journal_Click_Repeat(int MonsterBookID);
	void AU_Request_Monster_Info(int MonsterID);
	void AU_Set_Monster_Location_Extension(int LocationID, bool extension);
	void AU_Positioning_Monster_Quest(int MonsterBookID);
	void AU_Get_Reward_Monster_Quest(int MonsterBookID);
	void AU_Set_Story_Extension(int StoryID, bool bExtension);
	void AU_Plot_Info(int StoryID, int PlotIndex);
	void AU_Journal_Guide_Quest_ReAccept(int questId);
	void AU_ReAccept_Quest(int questId);
	void AU_Set_Location_Extension(int LocationID, bool bExtension);
	void AU_Complete_History(int LocationID);
	void AU_Journal_Positioning_Quest(int questId, int Type);
	void AU_Remove_Alert_List(TArray<class UGFxObject*> RequestAlertList);
	void AU_Add_Alert_List(TArray<class UGFxObject*> RequestAlertList);
	void AU_Remove_Alert(int Type, int Id, int Stage);
	void AU_Add_Alert(int Type, int Id, int Stage);
	void AU_Positioning_Quest(int Id, int Type);
	void AU_Drop_Quest(int questId);
	void AU_Quest_Info(bool bCompleteHistory, int questId);
	void AU_Use_Quest_Item(int Cid);
	void UA_QuestAlert_Set_Quantity_Item(int questId, int QuestType, int Quantity);
	TEnumAsByte<EUI_ItemCategory> ConvertItemCategoryClientToUI(TEnumAsByte<ECEItemCategoryType> InClientType, struct FItemInfoData* InInfoData);
	int GetMPFExtractionIconIndex(const struct FString& InMPFExtractionInfo);
	void SetCharacterInventoryItem(class UBLItem* Item, int UpdateFlag);
	void SetCharacterEquipItem(class UBLItem* Item);
	void AU_Inventory_Add_Anima_Item(const struct FString& InSid);
	void AU_Inventory_Add_GradeUpAdd_Item(const struct FString& InSid);
	void AU_Inventory_Add_SkillChange_Item(const struct FString& InSid);
	void AU_Inventory_Add_FatigueRecovery_Item(const struct FString& InSid);
	void AU_Inventory_Add_MonsterBall_Item(const struct FString& InSid);
	void AU_Inventory_Add_Foster_Item(const struct FString& InSid);
	void AU_Inventory_Add_Rune_Craft_Meterial_Item(int TabIndex, int SlotIndex);
	void AU_Inventory_Add_Rune_Socket_Item(int TabIndex, int SlotIndex);
	void AU_Inventory_Add_Rune_Item(int TabIndex, int SlotIndex);
	void AU_Inventory_Add_Exchange_Item(const struct FString& InSid, const struct FString& InCid);
	void AU_Inventory_RollOver_Item(int TabIndex, int SlotIndex);
	void AU_Inventory_Cancel_Split_Mode(int InCancelType);
	void AU_Inventory_Open_Divide(const struct FString& Sid);
	void AU_Inventory_Clicked_Divide();
	void AU_Inventory_Clicked_Tab(int TabIndex);
	void AU_Inventory_Unlock_SlotComponent(int TabIndex, int SlotComponentIndex);
	void AU_Inventory_Auto_Sort();
	void AU_Inventory_MailWrite_Add_Item(int TabIndex, int SlotIndex);
	void AU_Inventory_Private_Trade_Drop_From_Inventory(const struct FString& InSid, int InSlotIndex);
	bool AU_Inventory_Item_Destruction_Dialog(const struct FString& DialogType, const struct FString& SidExecutor, const struct FString& SidTarget);
	void AU_Inventory_Equip_Item(const struct FString& Sid, int EquipSlotType);
	void OpenDialogOnUseChangeAppearanceItem(int InItemCid, int InItemSid);
	void OpenDialogOnUseChangeGenderItem(int InItemCid, int InItemSid);
	void OpenDialogInventoryExpansion(int InItemSid);
	bool AU_Inventory_Use_Item(const struct FString& Sid);
	bool AU_Inventory_Move_Item(const struct FString& Sid, int targetTabIndex, int TargetSlotIndex);
	void AU_Inventory_Private_Trade_Item(int TabIndex, int SlotIndex);
	void AU_Inventory_Sell_Item(int TabIndex, int SlotIndex);
	bool AU_Inventory_Is_Trash_Item();
	void AU_Inventory_Sell_For_All_Trash_Item();
	void AU_Inventory_Initialized_Tab(int TabIndex);
	TArray<class UGFxObject*> AU_Inventory_Get_Tab_Data();
	void UA_Inventory_Set_DestoyedItem(int SlotIndex, bool IsDestroyed);
	void UA_Inventory_Set_UnblockSlot(int TabIndex, int SlotIndex_Start, int SlotIndex_End);
	void UA_Inventory_Update_NewItemEffect(int TabIndex, int SlotIndex, bool IsNew);
	void UA_Inventory_Select_Tab(int TabIndex);
	void UA_Inventory_Tab_Clear(int TabIndex);
	void UA_Inventory_Set_Split_Mode(int Mode);
	void UA_Inventory_Set_NewItemCount(int TabIndex, int NewCount);
	void UA_Inventory_NewItem_Count(int TabIndex, int NewCount);
	void UA_Inventory_Unlock_Effect(int TabIndex, int SlotComponentIndex, int UnLockType);
	void UA_Inventory_Set_Slot_Count(const struct FString& COUNT);
	void UA_Inventory_Lock_SlotComponent(int TabIndex, int SlotComponentIndex, const struct FString& Lock);
	void UA_Inventory_Init_Lock_SlotComponent(TArray<class UGFxObject*> TabData);
	void UA_Inventory_Set_Item_Cooldown(int InTabIndex, int InSlotIndex, float InRemainTime, float InMaxTime);
	void UA_Inventory_AutoSort_StartCooldown(float DurationTime);
	void UA_Inventory_Locked_Item(const struct FString& Sid, int TabIndex, int SlotIndex, bool bLock);
	void UA_Inventory_Check_Is_TrashItem();
	void UA_Inventory_Cancel_Item_Destruction(const struct FString& Sid);
	void UA_Inventory_Set_Item(const struct FString& Sid, int Cid, int Amount, int TabIndex, int SlotIndex, bool Usable, int Grade, int EquipSlotType, int IconIndex, bool QuestGrade, bool QuestStart, int UpdateFlag, bool Registrable, TEnumAsByte<EUI_ItemCategory> UIItemCategory);
	void UA_Inventory_Clear();
	void UA_Inventory_Lock(bool bLock);
	void UA_Inventory_Remove_Item(const struct FString& Sid);
	void UA_Inventory_Move_Item(const struct FString& Sid, int targetTabIndex, int TargetSlotIndex);
	void UA_Inventory_Set_Coin(TEnumAsByte<ECoinType> Type, const struct FString& Gold);
	void UA_Inventory_Open();
	void AU_GuildMark_Click_Register();
	void AU_GuildMark_Click_Sign(int InSelectedIndex);
	void AU_GuildMark_Click_Sign_Color(int InSelectedIndex);
	void AU_GuildMark_Click_BG(int InSelectedIndex);
	void AU_GuildMark_UI_Close();
	void AU_GuildMark_UI_Open();
	void AU_Guild_Info_Click_GuildSymbolSlot();
	void UA_GuildMark_Set_Disable_Register_Button(bool InIsDisable);
	void UA_GuildMark_Set_Mark_Sign_Data(TArray<class UGFxObject*> InObjList);
	void UA_GuildMark_Set_Mark_Color_Data();
	void UA_GuildMark_Select_Mark_Color(int InIndex);
	void UA_GuildMark_Set_Mark_Background_Data(TArray<class UGFxObject*> InObjList);
	void UA_GuildMark_Set_Mark_Lock_Level(class UGFxObject* inObj);
	void UA_GuildMark_Set_CurrentMark_Data(class UGFxObject* inObj);
	void UA_Guild_Info_Set_GuildSymbol(class UGFxObject* inObj);
	void AU_Guild_GuildWar_Click_Season_Page_Stepper(int InPage);
	void AU_Guild_GuildWar_Click_Season_History_Sort(int InIndex);
	void AU_Guild_GuildWar_Click_Page_Stepper(int InPage);
	void AU_Guild_GuildWar_Click_History_Sort(int InIndex);
	void AU_Guild_GuildWar_Click_Surrender();
	void AU_Guild_GuildWar_Click_Confirm(const struct FString& InGuildName);
	void UA_Guild_GuildWar_Set_DoingWar_Disable_Surrender(bool InIsDisable);
	void UA_Guild_GuildWar_Set_StartWar_Disable_Input(bool InIsDisable);
	void UA_Guild_GuildWar_Set_SeasonHistory_Page(int InMaxPage, int InCurrentPage);
	void UA_Guild_GuildWar_Set_SeasonHistory_Data(TArray<class UGFxObject*> InDataList);
	void UA_Guild_GuildWar_Set_SeasonHistory_SortType(int InIndex, int InType);
	void UA_Guild_GuildWar_Set_SeasonHistory_Record(const struct FString& InRecord);
	void UA_Guild_GuildWar_Set_WarHistory_Page(int InMaxPage, int InCurrentPage);
	void UA_Guild_GuildWar_Set_WarHistory_Data(TArray<class UGFxObject*> InDataList);
	void UA_Guild_GuildWar_Set_WarHistory_SortType(int InIndex, int InType);
	void UA_Guild_GuildWar_Set_WarHistory_Record(const struct FString& InRecord);
	void UA_Guild_GuildWar_Set_DoingWar_Guild_Score(const struct FString& InMyGuildScore, const struct FString& InEnemyGuildScore);
	void UA_Guild_GuildWar_Set_DoingWar_Time(int InType, int InSeconds);
	void UA_Guild_GuildWar_Set_DoingWar_Guild_Name(const struct FString& MyGuildName, const struct FString& EnemyGuildName);
	void UA_Guild_GuildWar_Set_StartWar_Count(const struct FString& InStartWarCount, const struct FString& InWarCount);
	void UA_Guild_GuildWar_Set_StartWar_State(int InState);
	void AU_GuildCreationQuery_Click_Agree(bool isAgree);
	void AU_GuildCreationWaiting_Click_Cancel();
	void AU_GuildCreationWaiting_Click_Confirm();
	void UA_GuildCreationWaiting_Set_DisableConfirm(bool bDisable);
	void UA_GuildCreationWaiting_Set_WaitingList(int ListIndex, const struct FString& Desc, bool bSatisfy, bool bNeutral);
	void UA_GuildCreationWaiting_Set_WaitingListLength(int ListLength);
	void UA_GuildCreationWaiting_Set_Desc2(const struct FString& Desc);
	void UA_GuildCreationWaiting_Set_Desc1(const struct FString& Desc);
	void UA_GuildCreationWaiting_CloseUI();
	void UA_GuildCreationWaiting_OpenUI();
	void AU_GuildCreation_Click_Cancel();
	void AU_GuildCreation_Click_Confirm();
	void AU_GuildCreation_Change_InputedGuildName(const struct FString& GuildName);
	void AU_GuildCreation_Click_GuildNameCheck(const struct FString& GuildName);
	void UA_GuildCreation_Set_GuildNameError(const struct FString& ErrorGuideString);
	void UA_GuildCreation_Set_DisableConfirmBtn(bool bDisabled);
	void UA_GuildCreation_Set_DisableInputGuildName(bool bDisabled);
	void UA_GuildCreation_Set_SatisfiedGold(int Gold);
	void UA_GuildCreation_Set_SatisfiedCondition(int ConditionIndex, const struct FString& ConditionDesc, bool bSatisfy);
	void UA_GuildCreation_CloseUI();
	void UA_GuildCreation_OpenUI();
	void AU_GuildAuthority_Click_Cancel();
	void AU_GuildAuthority_Click_Apply();
	void UA_GuildAuthority_Set_CheckBox_CBT2(bool CheckedEditNotice, bool CheckedInvite, bool CheckedBanish);
	void UA_GuildAuthority_Set_InfoText(const struct FString& InfoString);
	void AU_GuildDialog_MasterDelegate_Click_Cancel();
	void AU_GuildDialog_MasterDelegate_Click_Confirm(const struct FString& SelectedMemberName);
	void AU_GuildDialog_RPGrant_Confirm(bool IsTrue, const struct FString& SelectedGuildName, int RealmPoint);
	void AU_GuildDialog_RPGrant_Click_Cancel();
	void AU_GuildDialog_RPGrant_Click_Confirm(const struct FString& SelectedGuildName, int RealmPoint);
	void UA_GuildDialog_Close();
	void UA_GuildDialog_Open(int DialogType, class UGFxObject* Data, bool bModal);
	void AU_GuildDialog_RPGrant_Button_Able();
	void AU_Guild_Info_Click_RPGrant();
	void AU_Guild_Dialog_Click_Delegate_Guild_Leader_Agreement_Confirm(bool IsTrue);
	void AU_Guild_Dialog_Click_Delegate_Guild_Leader_Confirm(bool IsTrue, const struct FString& TargetName);
	void AU_Guild_Dialog_Click_Modify_Member_Grade_Confirm(bool IsTrue, const struct FString& TargetName, int ModifyGradeID);
	void AU_Guild_Dialog_Click_Disband_Confirm(bool IsTrue);
	void AU_Guild_Dialog_Click_Invite_Input_Confirm(bool IsTrue, const struct FString& TargetName);
	void AU_Guild_Dialog_Click_Invite_Agreement_Confirm(bool IsTrue, int SenderSid);
	void AU_Guild_Dialog_Click_Remove_Confirm(bool IsTrue, const struct FString& TargetName);
	void AU_Guild_Dialog_Click_Leave_Confirm(bool IsTrue);
	void AU_Guild_PopupMenu_Click(int SelectIndex);
	void AU_Guild_Management_Click_History_Page(int InPage);
	void AU_Guild_Management_Click_History_Sort(int InIndex, int InType);
	void AU_Guild_MemberList_Click_Influence_SortingList(int InIndex, int InCurType);
	void AU_Guild_MemberList_Change_Menu(int InSelectedIndex);
	void AU_Guild_Info_Click_Advantage();
	void AU_Guild_MemberList_Click_Refresh(int InSelectedIndex);
	void AU_Guild_MemberList_Click_ShowOfflineMember(bool Selected);
	void AU_Guild_MemberList_Click_SortingList(int Index, int CurType);
	void AU_Guild_Management_Click_Rank(int SelectedGuildRankIndex);
	void AU_Guild_Management_Click_Authority(int SelectedGuildRankIndex);
	void AU_Guild_Management_Click_Delegate();
	void AU_Guild_Management_Click_Disband();
	void AU_Guild_MemberList_DoubleClick_ListItem(const struct FString& InGuildMemberName);
	void AU_Guild_MemberList_Click_ListItem(const struct FString& GuildMemberName, int MouseType);
	void AU_Guild_Management_Click_Leave();
	void AU_Guild_Info_Click_CompleteEditNotice(const struct FString& InputedNoticeText);
	void AU_Guild_Info_Click_Invite();
	void AU_Guild_Click_CloseUI();
	void AU_Guild_Click_Tab(int TabIndex);
	void UA_Guild_Management_Set_History_SortingType(int InIndex, int InType);
	void UA_Guild_Management_Set_History_Page(int InMaxPage, int InCurrentPage);
	void UA_Guild_Management_Set_History_Data(TArray<class UGFxObject*> InDataList);
	void UA_Guild_MemberList_Set_Influence_SortingType(int InIndex, int InType);
	void UA_Guild_MemberList_Set_Influence_Data(TArray<class UGFxObject*> InDataList);
	void UA_Guild_MemberList_Set_Menu_Data(class UGFxObject* InMenuList, int InSelectedIndex);
	void UA_Guild_Set_Locked_UI(bool Lock);
	void UA_Guild_Management_Set_BtnState_Authority(int BtnState);
	void UA_Guild_MemberList_Remove_ListItemByIndex(int GuildMemberIndex);
	void UA_Guild_MemberList_Remove_ListItemByName(const struct FString& GuildMemberName);
	void UA_Guild_MemberList_Set_CheckBox_ShowOfflineMember(bool Checked);
	void UA_Guild_MemberList_Set_OnlineMemberNum(int OnlineNum, int TotalNum);
	void UA_Guild_Management_Set_BtnState_Leave(int BtnState);
	void UA_Guild_Management_Set_BtnState_Delegate(int BtnState);
	void UA_Guild_Management_Set_BtnState_Disband(int BtnState);
	void UA_Guild_Info_Set_BtnState_Invite(int BtnState);
	void UA_Guild_Info_Set_BtnState_EditNotice(int BtnState);
	void UA_Guild_MemberList_Set_SortingType(int Index, int Type);
	void UA_Guild_MemberList_Clear_ListItem();
	void UA_Guild_MemberList_Set_ListItem(class UGFxObject* GuildMemberObject);
	void UA_Guild_Info_Set_DisableGuildInvite(bool Disabled);
	void UA_Guild_Info_Set_AuthorityNoticeEdit(bool bHaveAuthority);
	void UA_Guild_Info_Set_GuildNotice(const struct FString& NoticedTime, const struct FString& NoticeStr);
	void UA_Guild_Info_Set_GuildInfo(const struct FString& GuildName, int GuildLevel, int GuildCurExp, int GuildMaxExp, const struct FString& GauilMasterName, int GuildMemeberNum, const struct FString& GuildCP, const struct FString& GuildRP, bool GuildRPBtnEnable);
	void UA_Guild_Management_Set_RankNames(class UGFxObject* GuildRankNames);
	void UA_Guild_Set_SelectedTab(int TabIndex);
	void UA_Set_Pawn_Exp_Info(int PawnExp, int LevelExpRangeMin, int LevelExpRangeMax, int BarType);
	void AU_EQUIP_CHARACTER_ROTATERIGHT_RELEASED();
	void AU_EQUIP_CHARACTER_ROTATERIGHT_PRESSED();
	void AU_EQUIP_CHARACTER_ROTATERIGHT_ROLLOUT();
	void AU_EQUIP_CHARACTER_ROTATERIGHT_ROLLOVER();
	void AU_EQUIP_CHARACTER_ROTATELEFT_RELEASED();
	void AU_EQUIP_CHARACTER_ROTATELEFT_PRESSED();
	void AU_EQUIP_CHARACTER_ROTATELEFT_ROLLOUT();
	void AU_EQUIP_CHARACTER_ROTATELEFT_ROLLOVER();
	void AU_Equip_Click_Living_Prev_Step();
	void AU_Equip_Click_Living_Next_Step();
	void AU_Equip_Click_Living_Type(int InTabType);
	void AU_Request_Private_Trade_Drop_From_Equip(const struct FString& InSid, int InSlotIndex);
	void AU_Request_Private_Trade_Item_From_Equip(const struct FString& InSid);
	bool AU_Equip_Request_Unequip_Item(int EquipSlot, int TargetTabId, int TargetSlotId);
	bool AU_Equip_Unequip_Disable_Info();
	void UA_Equip_Set_Living_Data(class UGFxObject* InObject);
	void UA_Equip_Set_Living_Tab_Data(TArray<class UGFxObject*> InObjList);
	void AU_DialogPurchase_Click_Living_Get_Quest(int InValue, int InDialogOpenType, int InDialogOptionType, int InCraftType);
	void AU_DialogPurchase_Click_Living_Answer();
	void UA_Equip_Set_Living_Select_Tab(int InTabIndex);
	void UA_Equip_Select_Tab(int InTabIndex);
	void UA_Equip_SubInfoData(class UGFxObject* inObj);
	void UA_Equip_Set_DestroyedItem(int EquipSlotType, bool IsDestroyed);
	void UA_Equip_Locked_Item(int EquipSlotType, bool bLock);
	void UA_Equip_SetRender();
	void UnSetCharacterEquipItem(int SlotIndex);
	void UA_Set_Unequip_Disable(int EquipSlotNum, bool Disable);
	void UA_Unequip_Item(int SlotIndex);
	void UA_Equip_Item(const struct FString& Sid, int Cid, int Amount, int EquipSlotIndex, bool Usable, int Grade, int EquipSlotType, int IconIndex);
	bool RequestDestroyWarehouseItem(int Sid);
	bool RequestDestroyInvenItem(int Sid);
	void UA_Open_Deliberation();
	void AU_ChatOption_Click_Cancel();
	void AU_ChatOption_Click_Change(int Index);
	void AU_ChatOption_Click_Init(int InTabIndex);
	void AU_ChatOption_Change_SubjectType(int InTabIndex, int InChatType);
	bool AU_ChatOption_Change_Tab_Name(int InTabIndex, const struct FString& InTabName);
	void AU_ChatOption_Change_MSG_Type_State(int InTabIndex, int Index, bool Selected, int ChannelColor);
	void AU_ChatOption_Change_Font_Size(int InTabIndex, int InFontSize);
	void AU_ChatOption_Change_Tab_Index(int InTabIndex);
	void AU_ChatOption_UI_Close();
	void AU_ChatOption_UI_Open();
	void UA_ChatOption_Set_Tab_Active(int Index);
	void UA_ChatOption_Set_Subject_List(TArray<class UGFxObject*> InData);
	void UA_ChatOption_Set_Tab_Data(class UGFxObject* InData);
	void UA_ChatOption_Set_Tab_List(TArray<class UGFxObject*> InData, int InSelectedTab);
	void AU_ItemLink_Data(const struct FString& InSid, const struct FString& InCid);
	int AU_Chat_Player_Partner_Type();
	void AU_Chat_Focus_Mode(bool InEnable);
	void AU_Chat_Click_Hyper_Link(const struct FString& InLink);
	void AU_Chat_Show_Context_Menu(int TabIndex);
	void AU_Chat_Check_IME();
	void AU_Chat_Request_Tab_Config(const struct FString& TabName, int GeneratedTabIndex);
	bool AU_Chat_Send_Chat_Msg(const struct FString& Message, int MessageType, const struct FString& RecieverName);
	TArray<class UGFxObject*> AU_Chat_Get_Msg_CommnadData();
	void AU_Chat_Change_Command_Mode(int InMessageType, const struct FString& InWhisper);
	void AU_Chat_Change_ChatMode(int ChatMode);
	void EnableChatMode();
	void UA_Chat_Focus_Mode(bool InEnable);
	void UA_Chat_Refresh_Command_Data();
	void UA_Chat_Set_Input_Text(const struct FString& InMsg);
	void UA_Chat_Send_Input_Text();
	void UA_Chat_Set_IME(int Type);
	void UA_Chat_Change_Prev_Tab();
	void UA_Chat_Change_Next_Tab();
	void UA_Chat_Set_Tab_Active(int TabIndex);
	void UA_Chat_Update_Tab_Config(int TabIndex, class UGFxObject* TabData);
	void UA_Chat_Remove_Tab(int TabIndex);
	void UA_Chat_Add_Tab(const struct FString& TabName);
	void ToggleChatMode(int IgnoreChatMessage);
	void UA_Chat_Set_ChatMessage(const struct FString& Message, int MessageType);
	void UA_Chat_Set_SendMode(int Type, const struct FString& TalkerName, const struct FString& Message);
	void UA_Chat_Set_Input_ChatMode(bool bInputMode);
	void UA_CastingBar_Set_BarType(int CastingBarType);
	void UA_CastingBar_Hold_Casting();
	void UA_CastingBar_Start_Interaction_Casting(int InteractionType, const struct FString& InteractionName, float CastingTime, float RemainingTime);
	void UA_CastingBar_Stop_Casting(TEnumAsByte<ECastingStopType> InStopType);
	void UA_CastingBar_Start_Casting(int CastingType, const struct FString& SkillName, float CastingTime, float RemainingTime, bool AutoHideType, int currentAmount, int totalAmount);
	void UA_CastingBar_Set_Casting_Current_Step(int CurrentStep);
	void UA_CastingBar_Set_Toggle_Casting_Step(int TargetStep, bool isActive);
	void UA_CastingBar_Set_Casting_Step_Visible(bool bTrue);
	void UA_CastingBar_Set_Casting_Step_TotalNum(int TotalStepNum);
	void UA_Message_Show_KeyRecommend(const struct FString& InRecommendKeyword, bool bInShow);
	void UA_Draw_BattleMessage_Token(TEnumAsByte<EBattleMessageTargetType> PawnType, int AttackChanceType, const struct FString& Damage, float CustomScale, int PosX, int PosY);
	void UA_Draw_BattleMessage(TEnumAsByte<EBattleMessageTargetType> PawnType, int AttackChanceType, int Damage, float CustomScale, int PosX, int PosY);
	void AU_ActionBar_Change_Favorite_Page(int InPage);
	void AU_ActionBar_Click_Favorite_Slot(const struct FString& Sid);
	void UA_ActionBar_SetFavorite_Shortcut(int InIndex, const struct FString& InShortCut);
	void UA_ActionBar_Clear_Favorite(int InIndex);
	void UA_ActionBar_Set_Favorite_Page(int InPage);
	void UA_ActionBar_Update_Favorite_Fatigue(int InIndex, int InFatigue);
	void UA_ActionBar_Update_Favorite(int InSlotIndex, class UGFxObject* InObject);
	void UA_ActionBar_Set_Favorite(class UGFxObject* InObjectList);
	void FireChargeSkill(int SkillID);
	bool ReleaseMountSkill(int Cid);
	bool RequestMountSkill(int Cid);
	bool RequestInteraction();
	bool RequestActionUseItem(int Cid);
	bool RequestVoluntaryAction(bool bStart);
	bool RequestCastSpell(int Cid, bool bUsePending);
	bool AUSwapShortcutBarSlot(int SourceSlotIndex, int TargetSlotIndex);
	void AUClearShortcutBarSlot(int ShortcutBarSlotIndex);
	void AU_ActionBar_Update_Slot_With_Pet(int SlotIndex, const struct FString& TargetPetSid);
	void AU_ActionBar_Update_Slot_With_Mount(int SlotIndex, const struct FString& TargetMountSid);
	void AU_ActionBar_Update_ShortcutSlot_With_SkillBook(int InShortcutIndex, int InSkillCid);
	void AUUpdateShortcutBarSlotWithItem(int ShortcutBarSlotIndex, int InventoryTabIndex, int InventorySlotIndex);
	void AUExecuteShortcut(const struct FString& InputType, const struct FString& executeType, int shortcutType, int SlotIndex);
	void UA_ActionBar_Set_Tactics_Button(int InMaxTacticCount, int InSkillDeckTacticIndex);
	void OnPlayerAlive();
	void OnPlayerDead();
	void UA_ActionBar_Set_Hidden_StanceSkill(class UGFxObject* InCoolTimeObject);
	void UA_ActionBar_Set_Tactics_Button_Tooltip(TArray<class UGFxObject*> Datas);
	void UA_ActionBar_Set_Short_Cut_String(TArray<class UGFxObject*> Datas);
	void UA_ActionBar_IncompetentOn(bool bShowIcon);
	void UA_Lock_ActionBar_Slot(TEnumAsByte<EShortcutSlotType> SlotType, int SlotIndex, bool bLock);
	void UAExecuteSlotActiveEffect(TEnumAsByte<EShortcutSlotType> SlotType, int SlotIdx, TEnumAsByte<EActionBarIconEffect> Type, bool isActive);
	void UAShowExecuteSlot(TEnumAsByte<EShortcutSlotType> SlotType, int SlotIdx, bool bShow);
	void UAKeyInputByExecuteSlot(const struct FString& InputType, TEnumAsByte<EShortcutSlotType> SlotType, int SlotIdx);
	void UASetExecuteSlotActive(TEnumAsByte<EShortcutSlotType> SlotType, int SlotIdx, bool isActive);
	void UAStopExecuteSlotCoolDown(TEnumAsByte<EShortcutSlotType> SlotType, int SlotIdx, bool EndMotion);
	void UAStartExecuteSlotCoolDown(TEnumAsByte<EShortcutSlotType> SlotType, int SlotIdx, float RemainCoolDown, float TotalCoolDown, bool IsGlobalCoolDown);
	void UASetExecuteSlot(TEnumAsByte<EShortcutSlotType> SlotType, int SlotIdx, const struct FString& Cid, const struct FString& Uid, int IconIndex, bool bDisableMouseRightButton, const struct FString& Description, int Amount);
	void UADispatchShortcutKeyInput(const struct FString& InputType, int SlotIndex);
	void UAClearShortcutEffect(int SlotIndex);
	void UAActiveShortcutEffect(int SlotIndex, int EffectType, bool isActive);
	void UAShortcutChargingStackCount(int InSlotIndex, int InStackCount);
	void UAStopShortcutCharging(int InSlotIndex, bool bEndEffect);
	void UAStartShortcutCharging(int InSlotIndex, float InRemainingTime, float InTotalTime);
	void UAStopShortcutCoolDown(int SlotIndex, bool ShowEndEffect);
	void UAStartShortcutCoolDown(int SlotIndex, float RemainingTime, float TotalTime, bool IsGlobalCoolDown);
	void UASetShortcutSlotActive(int SlotIndex, bool isActive);
	void UALockShortcutSlot(int SlotIndex, bool Lock, bool ShowAnimEffect, const struct FString& InLockString);
	void UASetShortcutSlot(int SlotIndex, int shortcutType, const struct FString& Cid, const struct FString& Uid, int IconIndex, bool bDisableMouseRightButton, int Quantity);
	bool AU_Detach_AbnormalStatus_Group(int Cid);
	bool AU_Detach_AbnormalStatus(int Cid);
	void UA_Set_CreateCharacterInfoData(TEnumAsByte<ECERealmType> InRealmType, TEnumAsByte<ECERaceType> InRaceType, TEnumAsByte<ECEClassType> InClassType, TEnumAsByte<ECEGenderType> InGenderType, TArray<class UGFxObject*> InObjList);
	void UA_Tooltip_Toggle_AbnormalStatusList_SelfStack(bool bShowSelfStack);
	void UA_Target_Toggle_AbnormalStatusList_SelfStack(bool bShowSelfStack);
	void UA_Party_Toggle_AbnormalStatusList_SelfStack(bool bShowSelfStack);
	void UA_Party_Set_AbnormalStatusList(int InServerId, int InType, TArray<class UGFxObject*> InAbnormalStatusList);
	void UA_Target_Set_AbnormalStatusList(int InType, TArray<class UGFxObject*> InAbnormalStatusList);
	void UA_AbnormalStatus_Toggle_AbnormalStatusList_SelfStack(bool bShowSelfStack);
	void UA_AbnormalStatus_Set_AbnormalStatusList(int InType, TArray<class UGFxObject*> InAbnormalStatusList);
	void GoToLobby();
	void MakeRaceAndClassDescription();
	struct FString FindRaceSenario(TEnumAsByte<ECERaceType> InRaceType);
	class UGFxObject* MakeGFxCreateInfoData(const struct FString& InTypeName, int InType, const struct FString& InTextName, const struct FString& InText);
	bool AU_Confirm_Change_Appearance(const struct FString& CharacterName);
	bool AU_Confirm_Create_Character(const struct FString& CharacterName);
	void AU_Change_Tracking_Mode(bool usingTrakingMode);
	void AU_Chage_ShortCutKey_Preset(int preset);
	void AU_Change_MovingControl_Mode(int movingControlMode);
	void AU_Change_Targetting_Mode(int targettingMode);
	void PlayVoiceSample(const struct FString& InVoiceCodeName, int InVoicePitch, bool IsShout);
	void AU_Play_Voice_Shout(const struct FString& voiceName, int voicePitch);
	void AU_Play_Voice_Script(const struct FString& voiceName, int voicePitch);
	void AU_Change_Voice_Pitch(int voicePitch);
	void AU_Change_Voice_Name(const struct FString& voiceName);
	void AU_Customizing_Changed_AppearanceType(int AppearanceType);
	void AU_Select_Gender(int iRaceType, int iClassType, int iGenderType);
	void AU_Select_Class(int ClassID);
	void AU_Select_Race(int Race);
	void AU_Select_Realm(int InRealmType);
	void AU_Open_Create_Character();
	void AU_Open_Selected_Realm();
	TArray<class UGFxObject*> AU_Realm_Info_Data();
	void AU_Next_Click(int nextUIState);
	void SuggestionTargetingByClass(TEnumAsByte<ECEClassType> InClass, TEnumAsByte<ECETargetingControlType>* OutTargetingControlType, TEnumAsByte<ECETargetingMoveType>* OutTargetingMoveType);
	void AU_Prev_Click(int nextUIState);
	void UA_CreateChracter_Set_Disable_Cover(bool Disabled);
	void UA_Update_GameSettings(int targettingMode, int movingControl, int shortcutPreset, bool trackingMode);
	void UA_Character_InitVoicePitch(int Value, int Min, int Max);
	void UA_Character_Voice_Select(int InCid);
	void UA_Character_Voice_Data(TArray<class UGFxObject*> arrData);
	void UA_LobbyRealm_DisableRealm(int InRealmType, const struct FString& InTxtReason);
	void UA_LobbyRealm_EnableRealm(int InRealmType);
	void UA_LobbyRealm_SelectIniitialRealm(int InRealmType);
	void UA_Confirm_Create_Character(bool bSuccess, const struct FString& ErrString);
	TArray<struct FCAWorldServerInfo> SortServerList(TArray<struct FCAWorldServerInfo> srcServerList);
	void SEND_CA_CANCEL_SERVER_LOGIN_REP();
	struct FString GetServerName(const struct FCAWorldServerInfo& ServerInfo);
	void UpdateServer(const struct FCAWorldServerInfo& ServerInfo);
	struct FString GetServerState(TEnumAsByte<EWorldServerBusyType> BusyType);
	class UGFxObject* GetServerGFxData(const struct FCAWorldServerInfo& ServerInfo);
	void ServerChangePhase();
	void ChangeUIPhase_SelectServer();
	void AU_Selected_Server(const struct FString& SelectedServerName, const struct FString& ServerIP);
	void AU_Request_RefreshServerList();
	void AU_Open_ServerList_UI();
	void UA_Send_Login_Packet_Result();
	void UA_Update_Server(class UGFxObject* ServerData);
	void UA_Set_Server_Data(TArray<class UGFxObject*> ServerLists);
	void AU_Server_Change();
	void AU_Gender_Appearance_Change();
	bool AU_Delete_Character();
	void AU_Create_Character();
	void AU_Control_Button_State();
	void UA_DATA_SET_REALM(int RealmType);
	void UA_Set_Control_Button_Label(int Button, const struct FString& Label);
	void UA_Set_Control_Button_State(int Button, bool Disable);
	void DeleteSelectedCharacter();
	void UpdateLobbyCharacterList();
	bool AU_Select_Character(int SelectedCharacterIdx);
	void AU_Open_Character_List_UI();
	void UA_Set_Server_Name(const struct FString& ServerName);
	void UA_Set_Selection_Lobby_Character(int Index);
	void UA_Set_Lobby_Character(int Index, class UGFxObject* Data);
	void UA_Clear_Lobby_Character_List();
	void CheckLobbyPhase();
	void UA_Check_Login_Result(bool Result);
	void Connect();
	void WITH_PMANG_LOGIN();
	int AU_Get_DropdownScroll_Voice();
	int AU_Get_DropdownScroll_Molph();
	struct FString AU_Get_Default_ID();
	bool AU_Login(const struct FString& LoginID, const struct FString& LoginPasswd);
	void AU_Open_Login_UI();
	void AU_Opening_End_Deliberation();
	void AU_Opening_Start_Intro();
	void UA_Opening_Play_Opening();
	void UA_Show_Opening_UI(const struct FString& Text);
	void DropFromInventory(int Sid, int SlotIndex);
	float AU_HPBar_Tween_FullTime();
	void AU_WorldMap_Toggle();
	void ShowSelectQuest(int questId, int Type);
	void AU_Show_Select_Quest(int questId, int Type);
	void AU_Equip_Request_Equip_Item(const struct FString& Sid, int Slot);
	void RequestEquipItem(const struct FString& Sid, int Slot);
	void AU_Show_MouseCursor(bool bShow);
	float AU_SlotIcon_Scale_When_Dragging();
	void UA_Clear_UIMode(bool Clear, float Delay);
	void UASetMonsterBookRewardCount(int COUNT);
	void AU_Game_Open_Credit();
	struct FString ClassTypeToString(TEnumAsByte<ECEClassType> Type);
	bool AU_Game_Exit();
	void AU_Opener_Toggle_SystemSetting();
	bool AU_Game_Start();
	void UA_Class_Desc_Data(TArray<struct FString> ClassDescDatas);
	void UA_Race_Desc_Data(TArray<class UGFxObject*> RaceDescDatas);
	struct FString TranslateDirective(struct FString* InStr);
	struct FString TranslateMarkup(class UTranslationContext* InContext, struct FString* InStr);
	bool CloseAllUIs();
	bool CloseAllDialogs();
	bool ClosePopupMenu();
	void NotifyGameSessionEnded();
	void ShowLevelUpMessage(int InLevel);
	void ShowLocationMessageWithGuildOwner(int Cid, class UGFxObject* inObj);
	void ShowLocationMessage(int Cid);
	void SHOW_CHAT_MESSAGE(const struct FString& InMessage, TEnumAsByte<ECESystemMessageOverlayType> InOverlayType, TEnumAsByte<ECESystemMessageChatChannelType> InChatChannelType);
	TEnumAsByte<EChatMessageType> ConvertChatChannelTypeToEChatMessageType(TEnumAsByte<ECESystemMessageChatChannelType> InType);
	void ShowSystemMessage(TEnumAsByte<ECESystemMessageDisplayType> InType, TEnumAsByte<ECESystemMessageOverlayType> InOverlayType, const struct FString& InMessage, float InOverlayTime, class UGFxObject* InOverlayData, TEnumAsByte<ECESystemMessageChatChannelType> InChatChannelType);
	bool IsEngineLoadingState();
	bool IsInitialized();
	void AU_DEACTIVE_UI(const struct FString& UIName);
	void AU_ACTIVE_UI(const struct FString& UIName);
	void FlushPendingUITask();
	void AU_UI_Close(const struct FString& UIName);
	void AU_UI_Open(const struct FString& UIName);
	void AU_UI_Initialized(const struct FString& UIName);
	void AU_UI_UnLoad(const struct FString& UIName);
	void AU_UI_Load(const struct FString& UIName, class UGFxObject* UIInfoData);
	void AU_UCLog(const struct FString& LogText);
	class UGFxObject* AU_UI_Get_InfoData(const struct FString& UIName);
	void AU_UI_Client_Tick_End();
	void UA_Set_Client_Tick();
	void AU_Load_Complete();
	void AU_LOAD_INFO_LOADER_COMPLETE();
	TArray<class UGFxObject*> AU_Get_IconSheet_Data();
	bool GetUIPlayerVisible();
	void ToggleUIPlayer();
	void UpdateCombatFlair(const struct FCombatFlairData& CombatFlairData);
	int UA_UI_Close_All_UIs();
	void NotifyEnterWorld();
	void ClearPartyMember();
	void SetPartyLeader(const struct FString& Sid);
	void SetPawnInfo(TEnumAsByte<EPawnType> PawnType, const struct FString& Sid, const struct FString& PawnName, int PawnHP, int PawnMaxHP, int PawnMP, int PawnMaxMP, int PawnClass, const struct FString& PawnLevel, bool bIsPlayer, int PawnEnergy, int PawnMaxEnergy, bool Occupied, TEnumAsByte<ETargetFrameType> FrameType, TEnumAsByte<ECB_CompanionType> MPFType);
	void UpdatePawnStatusFinished(class ABLPawnBase* Pawn);
	void UpdateTargetBubbleStack(class ABLPawnBase* InTargetPawn);
	void UpdatePawnStatus(TEnumAsByte<EPawnType> PawnType, class ABLPawnBase* Pawn);
	void UA_SET_SERVICECODE(int ServiceCode);
	void UA_SET_LANGUAGE(const struct FString& Language);
	void UA_Load_RollBack_VisibleUI(TArray<struct FString> UINames);
	void UA_Print_UI();
	void UA_Toggle_UI(const struct FString& UIName);
	void UA_Close_UI(const struct FString& UIName);
	void UA_Open_UI(const struct FString& UIName);
	void UA_SET_UISTATE_EX(int UIStateEX);
	void UA_SET_UI_STEATE(int UIState);
	void UA_CHANGE_LOAD_STATE(int LoadState);
	int UA_UI_UnLoad(const struct FString& UIName);
	int UA_UI_Load(const struct FString& UIName);
	void SetDeviceRestore();
	void IME_COMPOSITION_STRING(int Size, const struct FString& CompositionString);
	bool UA_Is_Loaded_UI(const struct FString& UIName);
	bool FilterButtonInput(int ControllerId, const struct FName& ButtonName, TEnumAsByte<EInputEvent> InputEvent);
	bool IsFilterInputName(const struct FName& InputName);
	void OnFilterButtonInput(class UBLSeqAct_FilterButtonInput* inAction);
	void RemoveInputKeyFilter(const struct FName& Key);
	void AddInputKeyFilter(const struct FName& Key);
	void RemoveMouseButtonFilter();
	void SetMouseButtonFilter();
	void UA_Party_Set_CombatFlair(int Sid, int CombotFlairType, int CurStat, int MaxStat);
	void UA_Party_Show_HPText(bool bShow);
	void DrawHUD();
	bool IsShowUI(TEnumAsByte<EUIName> UIName);
	bool GameExit();
	bool IsClosing();
	void OnClose();
	bool NotifyCursorObjectReady(const struct FString& cursorName);
	void SetCursorPosition(int X, int Y);
	void SetCursorVisible(bool Visible);
	void SetCursorType(TEnumAsByte<EGFxCursorType> CursorType);
	void UA_UI_Set_Viewport(int X, int Y, int Width, int Height);
	void SetViewportPlayer(int X, int Y, int Width, int Height);
	bool SetGFxUIViewport(int X, int Y, int Width, int Height);
	bool WidgetUnloaded(const struct FName& WidgetName, const struct FName& WidgetPath, class UGFxObject* Widget);
	bool WidgetInitialized(const struct FName& WidgetName, const struct FName& WidgetPath, class UGFxObject* Widget);
	bool AUIsReleaseOnClient();
	bool AUIsGameUIOnDemandLoad();
	bool AUIsGameUIBoost();
	bool AUIsGameUIBackgroundInit();
	bool AUIsPlayingOnClient();
	bool RequestOpenDialog(const struct FString& DialogType, int SidExecutor, int SidTarget);
	void UA_UI_Hit_Debug_Flag(bool bVisible);
	void UA_Debugger_Set_Visible(bool bVisible);
	bool UA_UI_Hit_Test_Point_Click(int nX, int nY, bool ignoreInvisibleChildren);
	bool UA_UI_Hit_Test_Point(int nX, int nY, bool ignoreInvisibleChildren);
	void PrintDebugText(const struct FString& DebugText);
	bool UA_Enter_Key_Down();
	void UA_UI_Trace(const struct FString& Message, const struct FString& Channel);
	void AU_IME_Clear();
	bool RequestReleaseKeys();
	bool RequestCaptureKeys();
	bool AUInputEnd();
	bool AUInputStart();
	void SetUsingPrologueMovie(bool bUsing);
	struct FASValue DispatchCall(TArray<struct FASValue> EventParams);
	void DispatchEvent(TArray<struct FASValue> EventParams);
	class UObject* ASDispatchEventVoid(const struct FString& Path);
	class UObject* ASDispatchCallObject(const struct FString& Path);
	struct FString ASDispatchCallString(const struct FString& Path);
	float ASDispatchCallFloat(const struct FString& Path);
	bool ASDispatchCallBoolean(const struct FString& Path);
	int ASDispatchCallInt(const struct FString& Path);
	void ASDispatchCallVoid(const struct FString& Path);
	bool MovieIsOpened();
	void UpdateJournalNotification();
	bool IsOpenedJournalTab(struct FString* TabName);
	void AU_Register_Char_Info(class UGFxUI_CharInfo* mc);
	void AU_Register_MiniMapExtension(class UGFxUI_MinimapExtension* mc);
	void AU_Register_MiniMap(class UGFxUI_Minimap* mc);
	void SetUIServiceCode();
	void SetUILanguage();
	class UGFxObject* SetUIMain();
	void SetQuestTimeLimit(int questId, int CountDown);
	void UpdateOnGoingQuestCountDown(float InDeltaTime);
	void Tick(float DeltaTime);
	struct FASValue Send();
	void InitCharInfoUpdateHandler();
	void Init(class ULocalPlayer* LocPlay);
	void InitUIPlayer(class ULocalPlayer* LocPlay, bool InAutoPlay);
	void ForceCollectGarbage();
	bool Start(bool StartPaused);
	void NewLog(const struct FString& msg);
};


// Class BLGame.BLSkillTacticsUIManager
// 0x0034 (0x0094 - 0x0060)
class UBLSkillTacticsUIManager : public UObject
{
public:
	TArray<struct FUIMainKeyNameData>                  UIMainKeyNameList;                                        // 0x0060(0x0010) (AlwaysInit, NeedCtorLink)
	int                                                SelectTacticsNumber;                                      // 0x0070(0x0004)
	TArray<class UBLSkillTacticsUISlotSkill*>          UISkillList;                                              // 0x0074(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<class UBLSkillTacticsUISlotAction*>         UIActionSkillList;                                        // 0x0084(0x0010) (AlwaysInit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLSkillTacticsUIManager");
		return ptr;
	}


	void ClearUIOpenerNotificationSkillPoint();
	void SetUIOpenerNotificationSkillPoint();
	int GetRemainSkillPoint();
	struct FString GetExpBarString();
	struct FString GetSkillTreeLevelDescString(const struct FString& CodeName, int Level, const struct FString& DescStr);
	struct FString GetSkillTreePrecedeString(int InCid);
	struct FString GetSkillTreeNeedSPString(int SpForLearn, int UnUsedPoint);
	struct FString GetNameWithLevelStringForTooltip(const struct FString& InName, int InCid, bool IsUseTactic);
	void OpenDialogReset();
	void AddMainKeyName(int InIndex, const struct FString& InMainKeyName);
	void RemoveAllMainKeyName();
	void RemoveActionbar(int InSkillTreeCid, int InIndex);
	void AddActionbar(int InSkillTreeCid, int InIndex, bool InIsActionBar);
	void ClickDecreaseSkill(int InSkillTreeCid);
	void ClickIncreaseSkill(int InSkillTreeCid);
	void ToggleSkillUI(int InSkillTreeCid, bool InSelected);
	void ClickCancleTactics();
	void ClickResetTactics();
	void ClickTacticTab(int InTacticNumber);
	void ConfirmChange();
	void ClickConfirmChange();
	void UseTactics();
	void ClickUseTactics();
	void CloseUI();
	void RefreshUI();
	void OpenUI();
	void SetUISkillBySkillTreeCid(int InSkillTreeCid);
	void SetUIActionBarBySkillTreeCid(int InSkillTreeCid);
	void UpdateUIMainKeyNameList();
	void UpdateUIBtn();
	void UpdateUIAllSkillList();
	void UpdateUIAllActionbar();
	void UpdateUISkillPoint();
	void UpdateUISelectTab();
	void UpdateUIDisableTab();
	int GetChangedSkillLevel(int InSkillTreeCid);
	TEnumAsByte<ETacticsTreeSkillLevelState> GetSkillLevelState(int InSkillTreeCid, bool IsUseTactic);
	TEnumAsByte<ETacticsTreeSkillState> GetSkillState(int InSkillTreeCid);
	bool IsOrignalLearnSkillBySkillCid(int InSkillCid);
	bool IsLearnSkillBySkillCid(int InSkillCid);
	bool IsLearnSkillBySkillTreeCid(int InSkillTreeCid);
	bool IsRegisterActionSkillDeck(int InSkillTreeCid);
	bool IsUseSelectTactics();
	bool IsChangeTacticsSkillAndActionBar();
	int GetSkillTreeCidBySkillCid(int InSkillCid);
	class UBLSkillTacticsSkill* GetTreeSkillInUseTactics(int InSkillTreeCid);
	class UBLSkillTacticsTreeDeck* GetUseUBLSkillTacticsTreeDeck();
	class UBLSkillTacticsTreeDeck* GetUBLSkillTacticsTreeDeck();
	class UBLSkillTacticsSkill* GetTreeSkill(int InSkillTreeCid);
	class UBLSkillTacticsSkill* GetTreeSkillBySkillCid(int InSkillCid);
	int GetCurrentSwapSkillCidBySkillTreeCid(int InSkillTreeCid);
	int GetCurrentKeySkillCid();
	void RefreshAllActionbarData();
	void RefreshAllSkillData();
	void Init();
};


// Class BLGame.BLSkillTacticsUISlotSkill
// 0x0060 (0x00C0 - 0x0060)
class UBLSkillTacticsUISlotSkill : public UObject
{
public:
	struct FSkillUISlotData                            SlotData;                                                 // 0x0060(0x0050) (NeedCtorLink)
	int                                                SkillTreeCid;                                             // 0x00B0(0x0004)
	int                                                SkillCid;                                                 // 0x00B4(0x0004)
	int                                                BasicSkillCid;                                            // 0x00B8(0x0004)
	unsigned long                                      bIsSelected : 1;                                          // 0x00BC(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLSkillTacticsUISlotSkill");
		return ptr;
	}


	struct FString GetLevelStatString();
	int GetUseCid();
	void CloseSkillLevelBtn();
	void OpenSkillLevelBtn();
	class UGFxObject* CreateGFxObject();
	void UpdateUI();
	void SetUIData(const struct FSkillTreeUISlotData& InSlotData, int Index);
};


// Class BLGame.BLSkillTacticsUISlotAction
// 0x0000 (0x00C0 - 0x00C0)
class UBLSkillTacticsUISlotAction : public UBLSkillTacticsUISlotSkill
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLSkillTacticsUISlotAction");
		return ptr;
	}


	struct FString GetLevelStatString();
	void OpenSkillLevelBtn();
	int GetUseCid();
	void UpdateUI();
};


// Class BLGame.PassiveSkillManager
// 0x0010 (0x0080 - 0x0070)
class UPassiveSkillManager : public UPawnComponent
{
public:
	TArray<struct FPassiveSkillInfo>                   PassiveSkillInfos;                                        // 0x0070(0x0010) (AlwaysInit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PassiveSkillManager");
		return ptr;
	}


	void OnHit(int Index);
	void PlayPassiveSkillBroadway(struct FPassiveSkillInfo* PassiveInfo);
	int CreateReadyPassiveSkill(int InSkillCid);
};


// Class BLGame.SkillInfoDataIndicator
// 0x0000 (0x0060 - 0x0060)
class USkillInfoDataIndicator : public UObject
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.SkillInfoDataIndicator");
		return ptr;
	}


	bool STATIC_GetRushType(int InCid, TEnumAsByte<ECESkillRushType>* OutRushType);
	bool STATIC_GetTargetingType(int InCid, TEnumAsByte<ECETargetingType>* OutTargetingType);
	TEnumAsByte<ECESkillPrepareType> STATIC_GetPrepareType(int InCid);
	bool STATIC_IsStackSkill(const struct FPCSkillInfoData& InInfoData);
	struct FColor STATIC_GetGradeColor(const struct FPCSkillInfoData& InInfoData);
	struct FString STATIC_GetToolTip(const struct FPCSkillInfoData& InInfoData);
};


// Class BLGame.SkillRadialBlurManager
// 0x0020 (0x0090 - 0x0070)
class USkillRadialBlurManager : public UComponent
{
public:
	TArray<class ABLRadialBlurActor*>                  RBActors;                                                 // 0x0070(0x0010) (Transient, NeedCtorLink)
	TArray<class UBLRadialBlurComponent*>              AttachedRBComponents;                                     // 0x0080(0x0010) (ExportObject, Transient, Component, NeedCtorLink, EditInline)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.SkillRadialBlurManager");
		return ptr;
	}


	void Tick(float InDeltaSeconds);
	bool StartFadeOutActorAttachedRadialBlur(class UBLRadialBlurComponent* SpawnedBlur, float InFadeOutTime);
	bool StartFadeOutRadialBlurActor(int Index, float InFadeOutTime);
	bool DetachRadialBlur(class AActor* InDetachActor);
	bool SpawnRadialBlurMeshAttachment(class USkeletalMeshComponent* InAttachMesh, const struct FName& InAttachPointName, bool bInAttachToSocket, const struct FVector& InRelativeLoc, const struct FRotator& InRelativeRot, float InFadeTime, float InMaxBlurAmountScale, float InMaxBlurAmountOpacity, bool bInUseMaxBlurAmountScale, bool bInUseMaxBlurAmountOpacity, bool bInRenderAsVelocity);
	class UBLRadialBlurComponent* SpawnRadialBlurActorAttachment(class AActor* InAttachActor, float InFadeTime, float InMaxBlurAmountScale, float InMaxBlurAmountOpacity, bool bInUseMaxBlurAmountScale, bool bInUseMaxBlurAmountOpacity, bool bInRenderAsVelocity, bool bFadeOut);
	int SpawnRadialBlur(const struct FVector& InLoc, const struct FRotator& InRot, float InFadeTime, float InMaxBlurAmountScale, float InMaxBlurAmountOpacity, bool bInUseMaxBlurAmountScale, bool bInUseMaxBlurAmountOpacity, bool bInRenderAsVelocity, bool bFadeOut);
	void Init();
};


// Class BLGame.BLAnimBlendAllDirectional
// 0x0017 (0x0154 - 0x013D)
class UBLAnimBlendAllDirectional : public UAnimNodeBlendBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x013D(0x0003) MISSED OFFSET
	float                                              BlendSpeed;                                               // 0x0140(0x0004) (Edit)
	int                                                AnimIndexWhenTotalWeightIs0;                              // 0x0144(0x0004) (Edit)
	unsigned long                                      bBlendHorizontalAnimWithVerticalAnim : 1;                 // 0x0148(0x0004) (Edit)
	TEnumAsByte<EStandardDirectionWhenNotBlendedType>  StandardDirWhenNotBlended;                                // 0x014C(0x0001) (Edit)
	unsigned char                                      UnknownData01[0x3];                                       // 0x014D(0x0003) MISSED OFFSET
	float                                              MaxLimitDeg;                                              // 0x0150(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimBlendAllDirectional");
		return ptr;
	}

};


// Class BLGame.BLAnimBlendBase
// 0x0018 (0x017C - 0x0164)
class UBLAnimBlendBase : public UAnimNodeBlendList
{
public:
	float                                              BlendTime;                                                // 0x0164(0x0004) (Edit)
	TArray<float>                                      ChildBlendTimes;                                          // 0x0168(0x0010) (Edit, NeedCtorLink)
	unsigned long                                      bTickAnimInScript : 1;                                    // 0x0178(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimBlendBase");
		return ptr;
	}


	void TickAnim(float DeltaSeconds);
	float GetAnimDuration(int ChildIndex);
	float GetBlendTime(int ChildIndex, bool bGetDefault);
};


// Class BLGame.BLAnimBlendByAnimState
// 0x0030 (0x01AC - 0x017C)
class UBLAnimBlendByAnimState : public UBLAnimBlendBase
{
public:
	unsigned long                                      bUsingBasePawnIfExist : 1;                                // 0x017C(0x0004) (Edit)
	int                                                AnimStatMap[0x7];                                         // 0x0180(0x0004) (Edit)
	int                                                LastAnimState;                                            // 0x019C(0x0004)
	float                                              LandBlendDelay;                                           // 0x01A0(0x0004) (Edit)
	int                                                PendingChildIndex;                                        // 0x01A4(0x0004)
	float                                              PendingTimeToGo;                                          // 0x01A8(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimBlendByAnimState");
		return ptr;
	}

};


// Class BLGame.BLAnimBlendByBasePhysics
// 0x0044 (0x01C0 - 0x017C)
class UBLAnimBlendByBasePhysics : public UBLAnimBlendBase
{
public:
	unsigned long                                      bUsingBasePawnIfExist : 1;                                // 0x017C(0x0004) (Edit)
	int                                                PhysicsMap[0xC];                                          // 0x0180(0x0004) (Edit)
	int                                                LastPhysics;                                              // 0x01B0(0x0004)
	float                                              LandBlendDelay;                                           // 0x01B4(0x0004) (Edit)
	int                                                PendingChildIndex;                                        // 0x01B8(0x0004)
	float                                              PendingTimeToGo;                                          // 0x01BC(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimBlendByBasePhysics");
		return ptr;
	}

};


// Class BLGame.BLAnimBlendByClimbing
// 0x0018 (0x0194 - 0x017C)
class UBLAnimBlendByClimbing : public UBLAnimBlendBase
{
public:
	TArray<struct FClimbingAppendageTransitionInfo>    AppendageTransition;                                      // 0x017C(0x0010) (Transient, NeedCtorLink)
	float                                              ClimbStartTime;                                           // 0x018C(0x0004) (Transient)
	float                                              ClimbLength;                                              // 0x0190(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimBlendByClimbing");
		return ptr;
	}


	float GetClimbingProgress();
	bool ClimbingMove(TEnumAsByte<EClimbMoveType> ClimbMoveType);
	bool IsIdle();
};


// Class BLGame.BLAnimBlendByFall
// 0x0008 (0x0184 - 0x017C)
class UBLAnimBlendByFall : public UBLAnimBlendBase
{
public:
	TEnumAsByte<EBlendFallTypes>                       FallState;                                                // 0x017C(0x0001) (Const)
	unsigned char                                      UnknownData00[0x3];                                       // 0x017D(0x0003) MISSED OFFSET
	float                                              LastFallingVelocity;                                      // 0x0180(0x0004) (Const)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimBlendByFall");
		return ptr;
	}

};


// Class BLGame.BLAnimBlendByIdealJump
// 0x0010 (0x018C - 0x017C)
class UBLAnimBlendByIdealJump : public UBLAnimBlendBase
{
public:
	float                                              JumpUpLimitVelocity;                                      // 0x017C(0x0004) (Edit)
	float                                              FallingLimitVelocity;                                     // 0x0180(0x0004) (Edit)
	float                                              PrevNodeTotalWeight;                                      // 0x0184(0x0004) (Transient)
	float                                              PrevZVelocity;                                            // 0x0188(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimBlendByIdealJump");
		return ptr;
	}


	void ReplayAnim();
};


// Class BLGame.BLAnimBlendByIdle
// 0x000C (0x0188 - 0x017C)
class UBLAnimBlendByIdle : public UBLAnimBlendBase
{
public:
	unsigned long                                      bCheckPawnStatus : 1;                                     // 0x017C(0x0004) (Edit)
	unsigned long                                      bJumpIsNotIdle : 1;                                       // 0x017C(0x0004) (Edit)
	float                                              BasisSpeedForIdle;                                        // 0x0180(0x0004) (Edit)
	float                                              BlendTimeToJump;                                          // 0x0184(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimBlendByIdle");
		return ptr;
	}

};


// Class BLGame.BLAnimBlendByJump
// 0x0028 (0x01A4 - 0x017C)
class UBLAnimBlendByJump : public UBLAnimBlendBase
{
public:
	TEnumAsByte<EBLJumpBlendTypes>                     JumpState;                                                // 0x017C(0x0001) (Const)
	unsigned char                                      UnknownData00[0x3];                                       // 0x017D(0x0003) MISSED OFFSET
	float                                              LastFallingVelocity;                                      // 0x0180(0x0004) (Const)
	unsigned long                                      bIgnoreAnimLength : 1;                                    // 0x0184(0x0004) (Edit, Const)
	float                                              MaxJumpTime;                                              // 0x0188(0x0004) (Transient)
	float                                              DownJumpTime;                                             // 0x018C(0x0004) (Transient)
	float                                              DownLoopJumpTime;                                         // 0x0190(0x0004) (Transient)
	float                                              TotalJumpTime;                                            // 0x0194(0x0004) (Transient)
	float                                              TempStartHeight;                                          // 0x0198(0x0004) (Transient)
	float                                              TempEndHeight;                                            // 0x019C(0x0004) (Transient)
	float                                              TempJumpSize;                                             // 0x01A0(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimBlendByJump");
		return ptr;
	}

};


// Class BLGame.BLAnimBlendByLanding
// 0x0018 (0x0194 - 0x017C)
class UBLAnimBlendByLanding : public UBLAnimBlendBase
{
public:
	TArray<float>                                      Constraints;                                              // 0x017C(0x0010) (Edit, NeedCtorLink)
	unsigned long                                      bJustLanded : 1;                                          // 0x018C(0x0004) (Edit)
	float                                              LandingVelocity;                                          // 0x0190(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimBlendByLanding");
		return ptr;
	}


	void JustLanded(float InLandingVelocity);
};


// Class BLGame.BLAnimBlendByMoveType
// 0x0015 (0x0191 - 0x017C)
class UBLAnimBlendByMoveType : public UBLAnimBlendBase
{
public:
	unsigned long                                      bIgnoreZMovement : 1;                                     // 0x017C(0x0004) (Edit)
	unsigned long                                      bConsiderAcceleration : 1;                                // 0x017C(0x0004) (Edit)
	unsigned long                                      bUsingBasePawnIfExist : 1;                                // 0x017C(0x0004) (Edit)
	unsigned long                                      bUseFixedMoveSpeedType : 1;                               // 0x017C(0x0004) (Transient)
	float                                              SmallVelocity;                                            // 0x0180(0x0004) (Edit)
	float                                              SmallAcceleration;                                        // 0x0184(0x0004) (Edit)
	class ABLPawn*                                     OwnerPawn;                                                // 0x0188(0x0008) (Transient)
	TEnumAsByte<EMoveSpeedType>                        FixedMoveSpeedType;                                       // 0x0190(0x0001) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimBlendByMoveType");
		return ptr;
	}

};


// Class BLGame.BLAnimBlendByPhysics
// 0x0044 (0x01C0 - 0x017C)
class UBLAnimBlendByPhysics : public UBLAnimBlendBase
{
public:
	int                                                PhysicsMap[0xC];                                          // 0x017C(0x0004) (Edit)
	int                                                LastPhysics;                                              // 0x01AC(0x0004)
	float                                              LandBlendDelay;                                           // 0x01B0(0x0004) (Edit)
	float                                              LandBlendDelaySkipThreshold;                              // 0x01B4(0x0004) (Edit)
	int                                                PendingChildIndex;                                        // 0x01B8(0x0004)
	float                                              PendingTimeToGo;                                          // 0x01BC(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimBlendByPhysics");
		return ptr;
	}

};


// Class BLGame.BLAnimBlendByVehicleAnim
// 0x0014 (0x0190 - 0x017C)
class UBLAnimBlendByVehicleAnim : public UBLAnimBlendBase
{
public:
	int                                                DefaultChildIndex;                                        // 0x017C(0x0004) (Edit)
	TArray<struct FSeqNameToChildIndexInfo>            SeqNameChildIndexMap;                                     // 0x0180(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimBlendByVehicleAnim");
		return ptr;
	}

};


// Class BLGame.BLAnimBlendWhenRotationChange
// 0x0014 (0x0190 - 0x017C)
class UBLAnimBlendWhenRotationChange : public UBLAnimBlendBase
{
public:
	unsigned long                                      PitchChange : 1;                                          // 0x017C(0x0004) (Edit)
	unsigned long                                      YawChange : 1;                                            // 0x017C(0x0004) (Edit)
	unsigned long                                      RollChange : 1;                                           // 0x017C(0x0004) (Edit)
	int                                                StartIndexWhenJustBecameRelevant;                         // 0x0180(0x0004) (Edit)
	struct FRotator                                    LastRotation;                                             // 0x0184(0x000C) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimBlendWhenRotationChange");
		return ptr;
	}

};


// Class BLGame.BLAnimNodeBlendByCombatIdleType
// 0x0000 (0x017C - 0x017C)
class UBLAnimNodeBlendByCombatIdleType : public UBLAnimBlendBase
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNodeBlendByCombatIdleType");
		return ptr;
	}

};


// Class BLGame.BLAnimNodeBlendByRotate
// 0x002C (0x01A8 - 0x017C)
class UBLAnimNodeBlendByRotate : public UBLAnimBlendBase
{
public:
	float                                              BlendOutTime;                                             // 0x017C(0x0004) (Edit)
	float                                              BlendInTimeToStop;                                        // 0x0180(0x0004) (Edit)
	float                                              BlendInTimeToStart;                                       // 0x0184(0x0004) (Edit)
	unsigned long                                      bUsingBasePawnIfExist : 1;                                // 0x0188(0x0004) (Edit)
	class ABLPawn*                                     OwnerPawn;                                                // 0x018C(0x0008) (Transient)
	class ABLPawn*                                     BLPawnOwner;                                              // 0x0194(0x0008) (Transient)
	int                                                PrevYaw;                                                  // 0x019C(0x0004) (Transient)
	int                                                RotateDirection;                                          // 0x01A0(0x0004) (Transient)
	int                                                RotateYawThreshold;                                       // 0x01A4(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNodeBlendByRotate");
		return ptr;
	}

};


// Class BLGame.BLAnimNodeBlendByVerticalRot
// 0x000C (0x0188 - 0x017C)
class UBLAnimNodeBlendByVerticalRot : public UBLAnimBlendBase
{
public:
	float                                              UpperLimitRadianInVerticalState;                          // 0x017C(0x0004) (Edit)
	float                                              LowerLimitRadianInVerticalState;                          // 0x0180(0x0004) (Edit)
	unsigned long                                      UsingAccelForMoveDirection : 1;                           // 0x0184(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNodeBlendByVerticalRot");
		return ptr;
	}

};


// Class BLGame.BLAnimNodePlayRandomTime
// 0x0014 (0x0190 - 0x017C)
class UBLAnimNodePlayRandomTime : public UBLAnimBlendBase
{
public:
	float                                              MinPlayTime;                                              // 0x017C(0x0004) (Edit)
	float                                              MaxPlayTime;                                              // 0x0180(0x0004) (Edit)
	float                                              RandomPlayTime;                                           // 0x0184(0x0004) (Transient)
	unsigned long                                      BlendStart : 1;                                           // 0x0188(0x0004) (Transient)
	unsigned long                                      RestartWhenJustBecameRelevant : 1;                        // 0x0188(0x0004) (Edit)
	int                                                StartIndexWhenJustBecameRelevant;                         // 0x018C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNodePlayRandomTime");
		return ptr;
	}

};


// Class BLGame.BLAnimNodeSimpleJump
// 0x000C (0x0188 - 0x017C)
class UBLAnimNodeSimpleJump : public UBLAnimBlendBase
{
public:
	float                                              JumpUpVelocity;                                           // 0x017C(0x0004) (Edit)
	float                                              PrevNodeTotalWeight;                                      // 0x0180(0x0004) (Transient)
	float                                              PrevZVelocity;                                            // 0x0184(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNodeSimpleJump");
		return ptr;
	}


	void ReplayAnim();
};


// Class BLGame.BLAnimNodeStopMotion
// 0x0004 (0x0180 - 0x017C)
class UBLAnimNodeStopMotion : public UBLAnimBlendBase
{
public:
	unsigned long                                      bRequstStopMotion : 1;                                    // 0x017C(0x0004) (Transient)
	unsigned long                                      bRequestTermStopMotion : 1;                               // 0x017C(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNodeStopMotion");
		return ptr;
	}


	void RequestTermStopMotion();
	void RequestStopMotion();
	class ABLPawn* GetOwnerPawn();
};


// Class BLGame.BLAnimBlendByCustomAnim
// 0x007F (0x01BC - 0x013D)
class UBLAnimBlendByCustomAnim : public UAnimNodeBlendBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x013D(0x0003) MISSED OFFSET
	TArray<unsigned long>                              UpperBoneMap;                                             // 0x0140(0x0010) (NeedCtorLink)
	float                                              UpperBodyAnimBlendingTime;                                // 0x0150(0x0004) (Edit)
	float                                              RunUpperMotionBlendTime;                                  // 0x0154(0x0004) (Edit)
	struct FBLCustomAnimBlendInfo                      RunUpperBlendInfo;                                        // 0x0158(0x000C)
	float                                              LowerBodyBlendTime;                                       // 0x0164(0x0004) (Edit)
	struct FBLCustomAnimBlendInfo                      LowerBodyBlendInfo;                                       // 0x0168(0x000C)
	float                                              AdditiveAnimBlendOutTime;                                 // 0x0174(0x0004)
	unsigned long                                      bIsFullBodyAdditive : 1;                                  // 0x0178(0x0004)
	unsigned long                                      bForceLocalSpaceBlend : 1;                                // 0x0178(0x0004) (Edit, Const)
	struct FBLCustomAnimBlendInfo                      AdditiveAnimBlendInfo;                                    // 0x017C(0x000C)
	TArray<unsigned char>                              LocalToCompReqBones;                                      // 0x0188(0x0010) (NeedCtorLink)
	struct FName                                       UpperBranchStartBoneName;                                 // 0x0198(0x0008) (Edit)
	TEnumAsByte<EBLCustomAnimType>                     CustomAnimType;                                           // 0x01A0(0x0001)
	unsigned char                                      UnknownData01[0x3];                                       // 0x01A1(0x0003) MISSED OFFSET
	class UBLAnimNodeSlot*                             FullBody;                                                 // 0x01A4(0x0008) (Transient)
	class UBLAnimNodeSlot*                             RunUpperBody;                                             // 0x01AC(0x0008) (Transient)
	class UAnimNodeSequence*                           AdditiveAnim;                                             // 0x01B4(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimBlendByCustomAnim");
		return ptr;
	}


	void StopCustomAnim(float BlendOutTime);
	bool IsPlayingRootMotionAnim();
	bool IsPlayingAdditiveCustomAnim();
	bool IsPlayingCustomAnim();
	class UAnimNodeSequence* GetAdditiveCustomAnimNodeSeq();
	class UAnimNodeSequence* GetCustomAnimNodeSeq();
	void ReplayAnim();
	void DisableRootMotion();
	void StopAdditiveCustomAnim(float BlendOutTime);
	float PlayAdditiveCustomAnim(const struct FName& AnimName, float Rate, float BlendInTime, float BlendOutTime, bool bLooping, bool bFullBody);
	float PlayCustomAnimWithRunUpperAnim(const struct FName& AnimName, const struct FName& RunUpperAnimName, float Rate, bool bFullBody, float BlendInTime, float BlendOutTime, bool bLooping, bool bOverride, float StartTime, bool bRootMotionAnim, bool bPlayRootMotion);
	float PlayCustomAnim(const struct FName& AnimName, float Rate, bool bFullBody, float BlendInTime, float BlendOutTime, bool bLooping, bool bOverride, float StartTime, bool bRootMotionAnim, bool bPlayRootMotion);
	void SetCustomAnimType(TEnumAsByte<EBLCustomAnimType> AnimType);
};


// Class BLGame.BLAnimBlendByLandStatus
// 0x0023 (0x0160 - 0x013D)
class UBLAnimBlendByLandStatus : public UAnimNodeBlendBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x013D(0x0003) MISSED OFFSET
	float                                              LandingThreshold;                                         // 0x0140(0x0004) (Edit)
	float                                              BlendTime;                                                // 0x0144(0x0004) (Edit)
	float                                              DominantPlayingWeight;                                    // 0x0148(0x0004) (Edit)
	unsigned long                                      bUsingBasePawnIfExist : 1;                                // 0x014C(0x0004) (Edit)
	class ABLPawn*                                     BLPawnOwner;                                              // 0x0150(0x0008) (Transient)
	class UAnimNodeSequence*                           LandingSeqNode;                                           // 0x0158(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimBlendByLandStatus");
		return ptr;
	}

};


// Class BLGame.BLAnimBlendByMoveTypeWithTransition
// 0x00EC (0x0250 - 0x0164)
class UBLAnimBlendByMoveTypeWithTransition : public UAnimNodeBlendList
{
public:
	unsigned long                                      bIgnoreZMovement : 1;                                     // 0x0164(0x0004) (Edit)
	unsigned long                                      bUseVehicleMoveType : 1;                                  // 0x0164(0x0004) (Edit)
	unsigned long                                      bTransitionCompleted : 1;                                 // 0x0164(0x0004) (Transient)
	float                                              TimeFromLastChange;                                       // 0x0168(0x0004) (Transient)
	float                                              PrevNodeTotalWeight;                                      // 0x016C(0x0004) (Transient)
	class UAnimNodeSequence*                           TransitionAnimNodeSeq;                                    // 0x0170(0x0008) (Transient)
	class ABLPawn*                                     OwnerPawn;                                                // 0x0178(0x0008) (Transient)
	class ABlessPC*                                    OwnerController;                                          // 0x0180(0x0008) (Transient)
	int                                                CachedMoveAngleYaw;                                       // 0x0188(0x0004) (Transient)
	int                                                LimitMoveAngleYawForTransitionToIdle;                     // 0x018C(0x0004) (Edit)
	float                                              TransitionChargeTime[0x10];                               // 0x0190(0x0004) (Edit)
	float                                              BlendInTimes[0x10];                                       // 0x01D0(0x0004) (Edit)
	float                                              BlendOutTimes[0x10];                                      // 0x0210(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimBlendByMoveTypeWithTransition");
		return ptr;
	}

};


// Class BLGame.BLAnimBlendByOtherNodeWeight
// 0x0027 (0x0164 - 0x013D)
class UBLAnimBlendByOtherNodeWeight : public UAnimNodeBlendBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x013D(0x0003) MISSED OFFSET
	TArray<struct FName>                               TargetNodeNames;                                          // 0x0140(0x0010) (Edit, NeedCtorLink)
	TEnumAsByte<ENodesWeightSamplingMethod>            SamplingMethod;                                           // 0x0150(0x0001) (Edit)
	unsigned char                                      UnknownData01[0x3];                                       // 0x0151(0x0003) MISSED OFFSET
	TArray<class UAnimNode*>                           TargetNodes;                                              // 0x0154(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimBlendByOtherNodeWeight");
		return ptr;
	}

};


// Class BLGame.BLAnimBlendBySimplePhysics
// 0x0000 (0x01BC - 0x01BC)
class UBLAnimBlendBySimplePhysics : public UUDKAnimBlendByPhysics
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimBlendBySimplePhysics");
		return ptr;
	}

};


// Class BLGame.BLAnimBlendBySlotActive
// 0x0018 (0x019C - 0x0184)
class UBLAnimBlendBySlotActive : public UAnimNodeBlendPerBone
{
public:
	class UAnimNodeSlot*                               ChildSlot;                                                // 0x0184(0x0008)
	float                                              Child1BlendTime;                                          // 0x018C(0x0004) (Edit)
	float                                              Child2BlendTime;                                          // 0x0190(0x0004) (Edit)
	int                                                LookUpDepth;                                              // 0x0194(0x0004) (Edit)
	unsigned long                                      bChild2Activated : 1;                                     // 0x0198(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimBlendBySlotActive");
		return ptr;
	}

};


// Class BLGame.BLAnimBlendDirectional
// 0x000B (0x0148 - 0x013D)
class UBLAnimBlendDirectional : public UAnimNodeBlendBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x013D(0x0003) MISSED OFFSET
	float                                              BlendSpeed;                                               // 0x0140(0x0004) (Edit)
	float                                              DirAngle;                                                 // 0x0144(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimBlendDirectional");
		return ptr;
	}

};


// Class BLGame.BLAnimBlendFlyDirectional
// 0x000B (0x0148 - 0x013D)
class UBLAnimBlendFlyDirectional : public UAnimNodeBlendBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x013D(0x0003) MISSED OFFSET
	float                                              BlendSpeed;                                               // 0x0140(0x0004) (Edit)
	int                                                AnimIndexWhenTotalWeightIs0;                              // 0x0144(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimBlendFlyDirectional");
		return ptr;
	}

};


// Class BLGame.BLAnimNodeAdditiveBlending
// 0x0004 (0x0158 - 0x0154)
class UBLAnimNodeAdditiveBlending : public UAnimNodeAdditiveBlending
{
public:
	unsigned long                                      bReplayBoth : 1;                                          // 0x0154(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNodeAdditiveBlending");
		return ptr;
	}


	void ReplayAnim();
};


// Class BLGame.BLAnimNodeBoneDeformation
// 0x0003 (0x0140 - 0x013D)
class UBLAnimNodeBoneDeformation : public UAnimNodeBlendBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x013D(0x0003) MISSED OFFSET

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNodeBoneDeformation");
		return ptr;
	}

};


// Class BLGame.BLAnimNodeFreeze
// 0x005F (0x019C - 0x013D)
class UBLAnimNodeFreeze : public UAnimNodeBlendBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x013D(0x0003) MISSED OFFSET
	float                                              TimeToFreeze;                                             // 0x0140(0x0004) (Transient)
	float                                              FreezeBlendTime;                                          // 0x0144(0x0004) (Transient)
	float                                              TimeToThaw;                                               // 0x0148(0x0004) (Transient)
	float                                              ThawBlendTime;                                            // 0x014C(0x0004) (Transient)
	float                                              TimeToThawBlend;                                          // 0x0150(0x0004) (Transient)
	unsigned long                                      bJustFrozen : 1;                                          // 0x0154(0x0004) (Transient)
	unsigned long                                      bInfiniteFreeze : 1;                                      // 0x0154(0x0004) (Transient)
	TArray<struct FBoneAtom>                           AnimSnapshot;                                             // 0x0158(0x0010) (Transient, NeedCtorLink)
	TArray<struct FBoneAtomsSnapshotInfo>              FrameSnapshots;                                           // 0x0168(0x0010) (Transient, NeedCtorLink)
	float                                              LastFrameTime;                                            // 0x0178(0x0004) (Transient)
	float                                              FrameEndTime;                                             // 0x017C(0x0004) (Transient)
	float                                              FreezeLogBase;                                            // 0x0180(0x0004) (Edit)
	float                                              FreezeLogScale;                                           // 0x0184(0x0004) (Edit)
	float                                              FreezeLogBias;                                            // 0x0188(0x0004) (Edit)
	float                                              FreezeLogBaseLnInv;                                       // 0x018C(0x0004) (Transient)
	float                                              FreezeLogInputAdjust;                                     // 0x0190(0x0004) (Transient)
	float                                              EditorTimeToFreeze;                                       // 0x0194(0x0004) (Edit)
	float                                              EditorThawBlendTime;                                      // 0x0198(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNodeFreeze");
		return ptr;
	}


	void FreezeEnd();
	void Freeze(float SecondsToFreeze, float FreezeTime, float InThawBlendTime);
};


// Class BLGame.BLAnimNodeHIKLookAtForward
// 0x0018 (0x01C4 - 0x01AC)
class UBLAnimNodeHIKLookAtForward : public UAnimNodeHumanIKLookAt
{
public:
	struct FVector                                     LookAtOffset;                                             // 0x01AC(0x000C) (Edit)
	struct FName                                       LookAtHeightBoneName;                                     // 0x01B8(0x0008) (Edit)
	unsigned long                                      bUpdateForwardTarget : 1;                                 // 0x01C0(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNodeHIKLookAtForward");
		return ptr;
	}

};


// Class BLGame.BLAnimNodeOffsetBlending
// 0x001B (0x0158 - 0x013D)
class UBLAnimNodeOffsetBlending : public UAnimNodeBlendBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x013D(0x0003) MISSED OFFSET
	TArray<struct FOffsetProfile>                      Profiles;                                                 // 0x0140(0x0010) (Edit, Transient, NeedCtorLink)
	unsigned long                                      bBakeFromAnimations : 1;                                  // 0x0150(0x0004) (Edit)
	unsigned long                                      bPassThroughWhenNotRendered : 1;                          // 0x0150(0x0004) (Edit)
	int                                                PassThroughAtOrAboveLOD;                                  // 0x0154(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNodeOffsetBlending");
		return ptr;
	}

};


// Class BLGame.BLAnimNodeRemoveAnimation
// 0x0013 (0x0150 - 0x013D)
class UBLAnimNodeRemoveAnimation : public UAnimNodeBlendBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x013D(0x0003) MISSED OFFSET
	TArray<struct FAnimationRemoveInfo>                RemoveInfo;                                               // 0x0140(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNodeRemoveAnimation");
		return ptr;
	}


	void SetAnimEffective(const struct FName& BoneName, bool bRemoveTranslation, bool bRemoveRotation);
};


// Class BLGame.BLAnimNodeSequence_DynamicChangeSeqName
// 0x0008 (0x01B4 - 0x01AC)
class UBLAnimNodeSequence_DynamicChangeSeqName : public UAnimNodeSequence
{
public:
	struct FName                                       OriginalAnimSeqName;                                      // 0x01AC(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNodeSequence_DynamicChangeSeqName");
		return ptr;
	}

};


// Class BLGame.BLAnimNodeSequenceBaseDependent
// 0x002C (0x01D8 - 0x01AC)
class UBLAnimNodeSequenceBaseDependent : public UAnimNodeSequence
{
public:
	struct FName                                       DependentSeqNodeName;                                     // 0x01AC(0x0008) (Edit)
	unsigned long                                      bSyncRelative : 1;                                        // 0x01B4(0x0004) (Edit)
	class UAnimNodeSequence*                           DependentAnimNodeSeq;                                     // 0x01B8(0x0008) (Const, Transient)
	class AActor*                                      DependentActor;                                           // 0x01C0(0x0008) (Const, Transient)
	class USkeletalMeshComponent*                      DependentSkelComponent;                                   // 0x01C8(0x0008) (Const, ExportObject, Transient, Component, EditInline)
	class UAnimTree*                                   DependentAnimTree;                                        // 0x01D0(0x0008) (Const, Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNodeSequenceBaseDependent");
		return ptr;
	}

};


// Class BLGame.BLAnimNodeSequenceBlendedAnimSetChange
// 0x0014 (0x01C0 - 0x01AC)
class UBLAnimNodeSequenceBlendedAnimSetChange : public UAnimNodeSequence
{
public:
	float                                              BlendTime;                                                // 0x01AC(0x0004) (Edit)
	float                                              BlendTimeToGo;                                            // 0x01B0(0x0004) (Transient)
	class UAnimSequence*                               SwapedOutAnimSeq;                                         // 0x01B4(0x0008) (Const, Transient)
	int                                                SwapedOutAnimLinkupIndex;                                 // 0x01BC(0x0004) (Const, Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNodeSequenceBlendedAnimSetChange");
		return ptr;
	}

};


// Class BLGame.BLAnimNodeSequenceChangeSeqNameByWeaponState
// 0x002C (0x01EC - 0x01C0)
class UBLAnimNodeSequenceChangeSeqNameByWeaponState : public UBLAnimNodeSequenceBlendedAnimSetChange
{
public:
	struct FName                                       SheatheAnimSeqName;                                       // 0x01C0(0x0008) (Edit, Const)
	struct FName                                       UnSheatheAnimSeqName;                                     // 0x01C8(0x0008) (Edit, Const)
	struct FName                                       CurrentSheatheAnimSeqName;                                // 0x01D0(0x0008) (Const)
	struct FName                                       CurrentUnSheatheAnimSeqName;                              // 0x01D8(0x0008) (Const)
	unsigned long                                      bIsUnsheathed : 1;                                        // 0x01E0(0x0004) (Edit)
	class ABLPawn*                                     BLPawnOwner;                                              // 0x01E4(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNodeSequenceChangeSeqNameByWeaponState");
		return ptr;
	}

};


// Class BLGame.BLAnimNodeSequenceScalable
// 0x0010 (0x01BC - 0x01AC)
class UBLAnimNodeSequenceScalable : public UAnimNodeSequence
{
public:
	TArray<struct FBoneAnimScaleInfo>                  ScaleBases;                                               // 0x01AC(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNodeSequenceScalable");
		return ptr;
	}


	void SetAnim(const struct FName& Sequence);
	void SetScale(const struct FName& BoneName, bool bIsOneOff, bool bUseAbsoluteScale, struct FVector* TranslationScale);
};


// Class BLGame.BLAnimNodeSequenceWeap
// 0x0030 (0x01F0 - 0x01C0)
class UBLAnimNodeSequenceWeap : public UUDKAnimNodeSequence
{
public:
	struct FName                                       OrgAnimSeqName;                                           // 0x01C0(0x0008) (Const)
	struct FName                                       PeacePrefix;                                              // 0x01C8(0x0008) (Edit)
	struct FName                                       CombatPrefix;                                             // 0x01D0(0x0008) (Edit)
	struct FName                                       SheatheSuffix;                                            // 0x01D8(0x0008) (Edit)
	struct FName                                       DefaultWeaponSuffix;                                      // 0x01E0(0x0008) (Edit)
	TEnumAsByte<EBLCombatStatus>                       CombatStatus;                                             // 0x01E8(0x0001) (Edit)
	TEnumAsByte<EBLWeaponStatus>                       WeaponStatus;                                             // 0x01E9(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x2];                                       // 0x01EA(0x0002) MISSED OFFSET
	unsigned long                                      bSynchronizeNodesInEditor : 1;                            // 0x01EC(0x0004) (Edit)
	unsigned long                                      bApplyCombatStatus : 1;                                   // 0x01EC(0x0004) (Edit)
	unsigned long                                      bApplyWeaponStatus : 1;                                   // 0x01EC(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNodeSequenceWeap");
		return ptr;
	}


	void WeapStatusChanged(TEnumAsByte<EBLWeaponStatus> a_Type, bool a_bUpdate, bool a_bForcedUpdate);
	void CombatStatusChanged(TEnumAsByte<EBLCombatStatus> a_Type, bool a_bUpdate, bool a_bForcedUpdate);
};


// Class BLGame.BLAnimNodeShakeBone
// 0x0073 (0x01B0 - 0x013D)
class UBLAnimNodeShakeBone : public UAnimNodeBlendBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x013D(0x0003) MISSED OFFSET
	TArray<struct FName>                               ShakeBoneNameList;                                        // 0x0140(0x0010) (Edit, NeedCtorLink)
	float                                              BlendTime;                                                // 0x0150(0x0004) (Edit)
	class UBLInterpCurveData*                          AxisXCurve;                                               // 0x0154(0x0008) (Transient)
	class UBLInterpCurveData*                          AxisYCurve;                                               // 0x015C(0x0008) (Transient)
	class UBLInterpCurveData*                          AxisZCurve;                                               // 0x0164(0x0008) (Transient)
	float                                              ShakeTime;                                                // 0x016C(0x0004) (Transient)
	float                                              RemainShakeTime;                                          // 0x0170(0x0004) (Transient)
	float                                              ShakeScale;                                               // 0x0174(0x0004) (Transient)
	float                                              RemainBlendTime;                                          // 0x0178(0x0004) (Transient)
	float                                              ShakeBlendWeight;                                         // 0x017C(0x0004) (Transient)
	float                                              ShakeBlendWeightTarget;                                   // 0x0180(0x0004) (Transient)
	float                                              bShakeBone;                                               // 0x0184(0x0004) (Transient)
	int                                                ShakeBoneIndex;                                           // 0x0188(0x0004) (Transient)
	unsigned char                                      UnknownData01[0x4];                                       // 0x018C(0x0004) MISSED OFFSET
	struct FBoneAtom                                   ShakeAtom;                                                // 0x0190(0x0020) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNodeShakeBone");
		return ptr;
	}


	void PlayBodyShake(float PlayTime, float Scale);
};


// Class BLGame.BLAnimNodeSkelControlRunningLean
// 0x0033 (0x0170 - 0x013D)
class UBLAnimNodeSkelControlRunningLean : public UAnimNodeBlendBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x013D(0x0003) MISSED OFFSET
	struct FName                                       SkelControlName;                                          // 0x0140(0x0008) (Edit)
	class USkelControlBase*                            SkelControl;                                              // 0x0148(0x0008) (Transient)
	TArray<class UAnimNode*>                           RunningEffectNode;                                        // 0x0150(0x0010) (Transient, NeedCtorLink)
	TArray<class UAnimNode*>                           TargetAnimNode;                                           // 0x0160(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNodeSkelControlRunningLean");
		return ptr;
	}

};


// Class BLGame.BLAnimNodeSlot
// 0x0014 (0x0178 - 0x0164)
class UBLAnimNodeSlot : public UAnimNodeSlot
{
public:
	TArray<struct FBLChildRootMotionInfo>              ChildRootMotionInfo;                                      // 0x0164(0x0010) (Transient, NeedCtorLink)
	unsigned long                                      bIgnoreAnimReplay : 1;                                    // 0x0174(0x0004) (Edit)
	unsigned long                                      bStopCustomAnimOnCeaseRelevant : 1;                       // 0x0174(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNodeSlot");
		return ptr;
	}


	void ReplayAnim();
	void DiscardRootBoneAxisOptionToAllChildrenSequence();
	void SetRootBoneAxisOptionToAllChildrenSequence(TEnumAsByte<ERootBoneAxis> AxisX, TEnumAsByte<ERootBoneAxis> AxisY, TEnumAsByte<ERootBoneAxis> AxisZ);
	float PlayCustomAnim2(const struct FName& AnimName, const struct FName& OriginalAnimName, float Rate, float BlendInTime, float BlendOutTime, bool bLooping, bool bOverride, float StartTime, bool bSetRootBoneOption, bool bRootMotionAnim, bool bPlayRootMotion);
};


// Class BLGame.BLAnimNodeAdditiveAnimPlayWhenMoveDirectionChanging
// 0x004C (0x01C4 - 0x0178)
class UBLAnimNodeAdditiveAnimPlayWhenMoveDirectionChanging : public UBLAnimNodeSlot
{
public:
	unsigned long                                      bUsingBasePawnIfExist : 1;                                // 0x0178(0x0004) (Edit)
	unsigned long                                      bStopAnimWhenNotChangedDirection : 1;                     // 0x0178(0x0004) (Edit)
	unsigned long                                      bPlayLoop : 1;                                            // 0x0178(0x0004) (Edit)
	unsigned long                                      bPrevForward : 1;                                         // 0x0178(0x0004) (Transient)
	struct FName                                       AnimSeqNameWhenLeftTurn;                                  // 0x017C(0x0008) (Edit)
	struct FName                                       AnimSeqNameWhenRightTurn;                                 // 0x0184(0x0008) (Edit)
	struct FName                                       AnimSeqNameWhenBackwardTurn;                              // 0x018C(0x0008) (Edit)
	float                                              BlendInTime;                                              // 0x0194(0x0004) (Edit)
	float                                              BlendOutTime;                                             // 0x0198(0x0004) (Edit)
	float                                              AnimPlayIgnoreTime;                                       // 0x019C(0x0004) (Edit)
	class ABLPawn*                                     BLPawnOwner;                                              // 0x01A0(0x0008) (Transient)
	int                                                PrevMoveYawDiff;                                          // 0x01A8(0x0004) (Transient)
	int                                                PrevPawnYaw;                                              // 0x01AC(0x0004) (Transient)
	int                                                DirLastChangedYaw;                                        // 0x01B0(0x0004) (Transient)
	float                                              DirCheckAngleThreshold;                                   // 0x01B4(0x0004) (Transient)
	float                                              DirCheckResetTime;                                        // 0x01B8(0x0004) (Transient)
	float                                              DirCheckResetTimeCount;                                   // 0x01BC(0x0004) (Transient)
	float                                              AnimPlayIgnoreRemainTime;                                 // 0x01C0(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNodeAdditiveAnimPlayWhenMoveDirectionChanging");
		return ptr;
	}


	void PlayAdditiveAnim(const struct FName& AnimName);
};


// Class BLGame.BLAnimNodeStickToBone
// 0x004F (0x018C - 0x013D)
class UBLAnimNodeStickToBone : public UAnimNodeBlendBase
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x013D(0x0003) MISSED OFFSET
	struct FName                                       EffectiveBoneName;                                        // 0x0140(0x0008) (Edit)
	int                                                EffectiveBoneIndex;                                       // 0x0148(0x0004) (Transient)
	struct FName                                       TargetBoneName;                                           // 0x014C(0x0008) (Edit)
	int                                                TargetBoneIndex;                                          // 0x0154(0x0004) (Transient)
	unsigned long                                      bApplyTranslation : 1;                                    // 0x0158(0x0004) (Edit)
	unsigned long                                      bApplyRotation : 1;                                       // 0x0158(0x0004) (Edit)
	unsigned long                                      bIgnoreWhenNotRendered : 1;                               // 0x0158(0x0004) (Edit)
	struct FVector                                     BoneTranslation;                                          // 0x015C(0x000C) (Edit)
	struct FRotator                                    BoneRotation;                                             // 0x0168(0x000C) (Edit)
	float                                              BlendInTime;                                              // 0x0174(0x0004) (Edit)
	float                                              BlendOutTime;                                             // 0x0178(0x0004) (Edit)
	float                                              ControlStrength;                                          // 0x017C(0x0004) (Edit)
	float                                              StrengthTarget;                                           // 0x0180(0x0004)
	float                                              BlendTimeToGo;                                            // 0x0184(0x0004) (Transient)
	int                                                IgnoreAtOrAboveLOD;                                       // 0x0188(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNodeStickToBone");
		return ptr;
	}


	void SetTargetBoneAndOffset(const struct FName& InTargetBoneName, const struct FVector& TranslationOffset, const struct FRotator& RotationOffset);
	void SetSkelControlStrength(float NewStrength, float InBlendTime);
	void SetSkelControlActive(bool bInActive);
};


// Class BLGame.BLAnimSelectByMoveType
// 0x0004 (0x0168 - 0x0164)
class UBLAnimSelectByMoveType : public UAnimNodeBlendList
{
public:
	unsigned long                                      bIgnoreZMovement : 1;                                     // 0x0164(0x0004) (Edit)
	unsigned long                                      bUseVehicleMoveType : 1;                                  // 0x0164(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimSelectByMoveType");
		return ptr;
	}


	void ReplayAnim();
};


// Class BLGame.BLAnimSequence_RandomSeqName
// 0x0010 (0x01BC - 0x01AC)
class UBLAnimSequence_RandomSeqName : public UAnimNodeSequence
{
public:
	TArray<struct FRandomSeqName>                      RandomInfo;                                               // 0x01AC(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimSequence_RandomSeqName");
		return ptr;
	}

};


// Class BLGame.MorphController
// 0x0018 (0x0078 - 0x0060)
class UMorphController : public UObject
{
public:
	class ABLPawn*                                     OwnerPawn;                                                // 0x0060(0x0008) (Transient)
	TArray<struct FMorphInstance>                      MorphInstances;                                           // 0x0068(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MorphController");
		return ptr;
	}


	void Tick(float InDeltaTime);
	void ClearAllMorph();
	void RemoveMorph(const struct FName& MorphTargetName);
	void SetMorph(class UMorphWeightTimeVaryingSet* MorphDataSet);
	void Init(class ABLPawn* inPawn);
};


// Class BLGame.MorphWeightTimeVarying
// 0x0028 (0x0088 - 0x0060)
class UMorphWeightTimeVarying : public UObject
{
public:
	struct FName                                       MorphTargetName;                                          // 0x0060(0x0008) (Edit)
	struct FInterpCurveFloat                           MorphCurveData;                                           // 0x0068(0x0014) (Edit, EditConst, NeedCtorLink)
	class UBLInterpCurveData*                          CurveData;                                                // 0x007C(0x0008) (Edit)
	float                                              Lifetime;                                                 // 0x0084(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MorphWeightTimeVarying");
		return ptr;
	}


	float GetLastestLifeTime();
};


// Class BLGame.MorphWeightTimeVaryingSet
// 0x0010 (0x0070 - 0x0060)
class UMorphWeightTimeVaryingSet : public UObject
{
public:
	TArray<class UMorphWeightTimeVarying*>             MorphWeightTimeVaryings;                                  // 0x0060(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MorphWeightTimeVaryingSet");
		return ptr;
	}

};


// Class BLGame.BLBroadwayPlayer
// 0x010C (0x016C - 0x0060)
class UBLBroadwayPlayer : public UObject
{
public:
	class UBroadwayGameInfo*                           Broadway;                                                 // 0x0060(0x0008) (Transient)
	unsigned long                                      AcceptAnimEndNotifyOnlyCached : 1;                        // 0x0068(0x0004) (Transient)
	unsigned long                                      bIsPlaying : 1;                                           // 0x0068(0x0004)
	struct FName                                       CachedSequenceName;                                       // 0x006C(0x0008) (Transient)
	float                                              GlobalTime;                                               // 0x0074(0x0004) (Transient)
	float                                              TimeDilation;                                             // 0x0078(0x0004) (Transient)
	class ABLPawn*                                     PawnOwner;                                                // 0x007C(0x0008)
	class UBSM_Base*                                   InteractSpecialMove;                                      // 0x0084(0x0008) (Transient)
	class UBSM_Base*                                   InteractSpecialMove_NextBroadway;                         // 0x008C(0x0008) (Transient)
	int                                                ApplyInfoIndex;                                           // 0x0094(0x0004) (Transient)
	int                                                ApplyInfoSetKey;                                          // 0x0098(0x0004) (Transient)
	struct FName                                       PlayedAnimSeqName;                                        // 0x009C(0x0008) (Transient)
	int                                                PlayedAnimSeqKey;                                         // 0x00A4(0x0004) (Transient)
	TArray<struct FName>                               NotifyTriggerList;                                        // 0x00A8(0x0010) (NeedCtorLink)
	TArray<struct FBroadwayNodeInstance>               BroadwayNodeInstList;                                     // 0x00B8(0x0010) (Transient, Component, NeedCtorLink)
	TArray<int>                                        TickResourceIDs;                                          // 0x00C8(0x0010) (Transient, NeedCtorLink)
	TArray<int>                                        TickResourceHasEmitterIDs;                                // 0x00D8(0x0010) (Transient, NeedCtorLink)
	TArray<int>                                        TickResourceHasCameraFOVs;                                // 0x00E8(0x0010) (Transient, NeedCtorLink)
	TArray<int>                                        TickResourceHasPostProcessEffects;                        // 0x00F8(0x0010) (Transient, NeedCtorLink)
	TArray<int>                                        TickResourceHasMaterials;                                 // 0x0108(0x0010) (Transient, NeedCtorLink)
	TArray<int>                                        TickResourceHasRadialBlures;                              // 0x0118(0x0010) (Transient, NeedCtorLink)
	TArray<int>                                        AnimResourceIDs;                                          // 0x0128(0x0010) (Transient, NeedCtorLink)
	float                                              AnimTime_Total;                                           // 0x0138(0x0004) (Transient)
	float                                              AnimTime_Current;                                         // 0x013C(0x0004) (Transient)
	float                                              AnimTime_Played;                                          // 0x0140(0x0004) (Transient)
	struct FVector                                     TargetPoint;                                              // 0x0144(0x000C) (Transient)
	int                                                SelectedTargetPawnID;                                     // 0x0150(0x0004) (Transient)
	struct FVector                                     PrevCalcGroundLoc;                                        // 0x0154(0x000C) (Transient)
	class UBroadwayGameInfo*                           NextBroadway;                                             // 0x0160(0x0008) (Transient)
	int                                                NumOfExplodeProjectiles;                                  // 0x0168(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLBroadwayPlayer");
		return ptr;
	}


	void OnHitBy(class UBLEvent_HitBy* Event);
	void OnHit(class UBLEvent_Hit* Event);
	void SetupNextBroadway(class UBroadwayGameInfo* InNextBroadway);
	bool SetTwoBroadway(class UBroadwayGameInfo* InFirstBroadway, class UBroadwayGameInfo* InSecondBroadway, class UBSM_Base* InSM, class ABLPawn* InPawnOwner);
	bool SetBroadway(class UBroadwayGameInfo* a_Broadway, class UBSM_Base* a_SM, class ABLPawn* a_PawnOwner);
	void OnParticleSystemFinished(class UParticleSystemComponent* a_PSC, int a_InstID);
	void OnExplodeProjectile(int a_InstID);
	void EndBroadway();
	bool StartBroadway();
	bool StartBroadwayByInfo(class UBroadwayInfo* Info, class UBSM_Base* a_SM);
	void PlayNextBroadWay();
	void ProcessNextBroadway();
	void ForceStopAnimResGroupByTime();
	void CheckInfiniteBroadway();
	void CancelBroadwayNode(int a_InstID);
	void BS_AnimEndNotify(const struct FName& AnimSeqName, int InAnimSeqKey, float PlayedTime, float ExcessTime);
	void SetPlayedAnimSequence(const struct FName& InAnimSeqName, int InAnimSeqKey);
	void CancelBroadway();
	bool EndCheck();
	void StopBroadwayResource();
	void StopBroadwayEmitterInstance();
	void DestoryEmitter(class UParticleSystemComponent* a_PSC);
	class UParticleSystemComponent* SpawnEmitterSkelVertSurfActor(int a_NodeID, class UParticleSystem* a_PS, class AActor* inActor);
	class UParticleSystemComponent* SpawnEmitter(int a_NodeID, class UParticleSystem* a_PS, class AActor* a_AttachToActor, const struct FVector& a_Location, const struct FRotator& a_Rotation);
	class UParticleSystemComponent* SpawnEmitterMeshAttachment(int a_NodeID, class UParticleSystem* a_PS, class USkeletalMeshComponent* a_Mesh, const struct FName& a_AttachPointName, bool a_bAttachToSocket, const struct FVector& a_Location, const struct FRotator& a_Rotation);
	void Tick(float a_DeltaTime);
	void SetupTimeDilation_Attack(float InServerSkillTime, float InOriginalSkillTime);
	void SetupTimeDilation(float InServerSkillTime, float InOriginalSkillTime, bool bCasting);
	float GetGlobalTime();
	float CalcTimeDilation(float a_ServerTime);
	void ProcessBroadwayNodeAnimNotify(class UAnimNodeSequence* a_SeqNode, class UAnimNotify* a_NotifyObject);
	void ProcessBroadwayNode(float a_DeltaTime);
	void ProcessBroadwayNodeInstance(float a_DeltaTime);
	int ActivateBroadwayNode(float a_DeltaTime, class UBroadwayNode* a_ResInfo, int a_InstID);
	int GetAdjustApplyInfoIndex(int InApplyInfoSetKey, int InApplyInfoIndex);
	float GetTotalPlayRate();
	bool IsAnimPlaying();
	bool PlayDriverSequence(struct FSeqPlayInfo* a_Info);
	bool PlaySequence(struct FSeqPlayInfo* a_Info);
	bool IsExistTargetFromApplyResult(int InTargetSid, int InApplyInfoSetKey, int InApplyInfoIndex, bool bInMergedResult);
	bool FindApplyResults(int InApplyInfoSetKey, int InApplyInfoIndex, bool bInMergedResult, TArray<struct FActionApplyResult>* OutResults);
	bool FindApplyResult(int InTargetIndex, int InApplyInfoSetKey, int InApplyInfoIndex, bool bInMergedResult, struct FActionApplyResult* OutResult);
	class ABLPawnBase* GetPreviousDamager(int InApplyInfoSetKey, int InApplyInfoIndex);
	class ABLPawnBase* GetDamager(int InTargetIndex, int InApplyInfoSetKey, int InApplyInfoIndex, bool bInMergedResult);
	class ABLPawnBase* GetTarget(TEnumAsByte<EBAR_Target> InTargetType, int InTargetIndex, int InApplyInfoSetKey, int InApplyInfoIndex);
	int GetTargetNum(bool bInMergedResult);
	void AddBroadwayNodeToTickArray(int a_RefNodeID, int a_InstParentID, float a_DeltaTime);
	void AddBroadwayNodeToTickArrayByTrigger(int a_RefNodeID);
	bool AddBroadwayNodeToTickArrayByHit(int a_RefNodeID, int InApplyInfoSetKey, int InApplyInfoIndex);
	void OnUpdateApplyInfoSetKey(int InKey);
	void GetTickResurceIDs(TArray<int>* outTickIDs);
	void SetPawnOwner(class ABLPawn* InPawnOwner);
	void Cleanup();
	void InitAnimTime(float InTotalTime);
	void StatEnd();
	void StatStart();
};


// Class BLGame.BSM_Base
// 0x009C (0x0144 - 0x00A8)
class UBSM_Base : public UGameSpecialMove
{
public:
	class ABLPawn*                                     BLPawnOwner;                                              // 0x00A8(0x0008)
	class ABlessPC*                                    PCOwner;                                                  // 0x00B0(0x0008)
	class UBSM_BaseParameter*                          SpecialMoveParameter;                                     // 0x00B8(0x0008)
	float                                              SpeedModifier;                                            // 0x00C0(0x0004) (Edit, Const, Config)
	float                                              GravityScale;                                             // 0x00C4(0x0004)
	unsigned long                                      bCanFireWeapon : 1;                                       // 0x00C8(0x0004) (Const)
	unsigned long                                      bOnlyInteractionPawnCanDamageMe : 1;                      // 0x00C8(0x0004)
	unsigned long                                      bLockPawnRotation : 1;                                    // 0x00C8(0x0004) (Const)
	unsigned long                                      bPawnRotationLocked : 1;                                  // 0x00C8(0x0004)
	unsigned long                                      bDisableMovement : 1;                                     // 0x00C8(0x0004) (Const)
	unsigned long                                      bMovementDisabled : 1;                                    // 0x00C8(0x0004)
	unsigned long                                      bDisableTurnInPlace : 1;                                  // 0x00C8(0x0004) (Const)
	unsigned long                                      bDisableLook : 1;                                         // 0x00C8(0x0004) (Const)
	unsigned long                                      bDisableLeftHandIK : 1;                                   // 0x00C8(0x0004) (Const)
	unsigned long                                      bDisablePOIs : 1;                                         // 0x00C8(0x0004) (Const)
	unsigned long                                      bMirrorTransitionSafeNotify : 1;                          // 0x00C8(0x0004)
	unsigned long                                      bCameraFocusOnPawn : 1;                                   // 0x00C8(0x0004) (Const)
	unsigned long                                      bPlayingCameraAnim : 1;                                   // 0x00C8(0x0004)
	unsigned long                                      bConformMeshRotationToFloor : 1;                          // 0x00C8(0x0004) (Const)
	unsigned long                                      bConformMeshTranslationToFloor : 1;                       // 0x00C8(0x0004) (Const)
	unsigned long                                      bRestoreMovementAfterMove : 1;                            // 0x00C8(0x0004)
	unsigned long                                      bStopSpecialMoveWhenAnimEnd : 1;                          // 0x00C8(0x0004) (Const)
	unsigned long                                      bForceShowPCPawn : 1;                                     // 0x00C8(0x0004) (Const)
	unsigned long                                      bStartSpecialMoveInCinematicPlaying : 1;                  // 0x00C8(0x0004) (Const)
	unsigned long                                      bRootMotion : 1;                                          // 0x00C8(0x0004) (Transient)
	float                                              DamageScale;                                              // 0x00CC(0x0004) (Const, Config)
	class AActor*                                      AlignToActor;                                             // 0x00D0(0x0008)
	float                                              MotionBlurAmount;                                         // 0x00D8(0x0004) (Const, Config)
	float                                              MaxConformToFloorMeshRotation;                            // 0x00DC(0x0004) (Const)
	float                                              MaxConformToFloorMeshTranslation;                         // 0x00E0(0x0004) (Const)
	struct FBasedPosition                              OldFocalPoint;                                            // 0x00E4(0x0038)
	struct FVector                                     OldAccel;                                                 // 0x011C(0x000C)
	class UBLBroadwayPlayer*                           BwPlayer;                                                 // 0x0128(0x0008) (Transient)
	int                                                ApplyInfoIndex;                                           // 0x0130(0x0004) (Transient)
	int                                                ApplyInfoSetKey;                                          // 0x0134(0x0004) (Transient)
	struct FName                                       CurrentSequence;                                          // 0x0138(0x0008) (Transient)
	int                                                AnimSeqKey;                                               // 0x0140(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_Base");
		return ptr;
	}


	bool IsPlayerMoving();
	void GetAnimSequenceInfo(struct FSeqPlayInfo* seqInfo);
	void CancelSpecialMove();
	void STATIC_DisplayDebug_Empty(class AHUD* HUD, float* out_YL, float* out_YPos);
	void DisplayDebug(class AHUD* HUD, float* out_YL, float* out_YPos);
	bool IsOwner();
	void SpecialMoveSkipped(bool bIsCauseFromExternalFactor, const struct FName& CurrentSpecialMove);
	void SpecialMoveEnded(const struct FName& PrevMove, const struct FName& NextMove);
	bool IsThisDoingSpecialMove();
	void EndSM(const struct FName& SpecialMoveToEnd);
	void Cleanup();
	void BS_AnimEndNotify(const struct FName& AnimSeqName, int InAnimSeqKey, float PlayedTime, float ExcessTime);
	bool IsCanRepeatedlyDoing();
	void AnimNotifyEnd(class UAnimNodeSequence* SeqNode, class UBLAnimNotify_SpecialMove* NotifyObject);
	void AnimNotify(class UAnimNodeSequence* SeqNode, class UBLAnimNotify_SpecialMove* NotifyObject);
	void OnMirrorTransitionSafeNotify();
	void OnMirrorTransitionSafeNotifyInternal();
	bool IsAllowIK(TEnumAsByte<EEffectiveIK> IKIndex);
	bool IsMirrorTransitionSafe();
	bool IsPawnRotationLocked();
	void SetLockPawnRotation(bool bLock);
	void SetMovementLock(bool bEnable);
	void SpecialMoveStarted(bool bForced, const struct FName& PrevMove);
	bool PreProcessCommand(class ABlessPC* CommandController, const struct FString& InputCommand);
	void PreProcessInput(class UBLPlayerInput* Input);
	void SetSpecialMoveParameter(class UBSM_BaseParameter* InSMParam);
	void OnApplyMoment(int InKey);
	void OnUpdateApplyInfoSetKey(int InKey);
	void OnHitBy(class UBLEvent_HitBy* Event);
	void OnHit(class UBLEvent_Hit* Event);
	void SetAnimSeqKey(const struct FName& InAnimSeqName, int InAnimSeqKey);
	void ProcessEvent_HitBy(class UBLEvent_HitBy* Event);
	void ProcessEvent_Hit(class UBLEvent_Hit* Event);
	void InitSpecialMove(class AGamePawn* inPawn, const struct FName& InHandle);
	bool InternalCanDoSpecialMove();
	bool CanChainMove(const struct FName& NextMove);
	bool CanOverrideSpecialMove(const struct FName& InMove);
	bool CanOverrideMoveWith(const struct FName& NewMove);
	bool CanChainMoveParam(const struct FName& NextMove, class UBSM_BaseParameter* NextMoveParam);
	bool CanOverrideSpecialMoveParam(const struct FName& NextMove, class UBSM_BaseParameter* InSMParam);
	bool CanOverrideMoveParamWith(const struct FName& NextMove, class UBSM_BaseParameter* InSMParam);
	void SetAnimScale(const struct FName& BoneName, bool bIsOneOff, bool bUseAbsoluteScale, struct FBodyStance* TargetBodyStance, struct FVector* TranslationScale);
	bool PlayDriverSequence(struct FSeqPlayInfo* a_Info);
	bool PlaySequence(struct FSeqPlayInfo* a_Info);
};


// Class BLGame.BSM_BasicMove
// 0x0034 (0x0178 - 0x0144)
class UBSM_BasicMove : public UBSM_Base
{
public:
	class UBSM_BasicMoveParameter*                     BasicMoveParameter;                                       // 0x0144(0x0008) (Edit)
	TArray<class ABLPawn*>                             BleedPawns;                                               // 0x014C(0x0010) (Transient, NeedCtorLink)
	float                                              ContactDistance;                                          // 0x015C(0x0004) (Transient)
	struct FVector                                     DistVectToTarget;                                         // 0x0160(0x000C) (Transient)
	float                                              Dist2DToTarget;                                           // 0x016C(0x0004) (Transient)
	class ABLCamera*                                   LocalCamera;                                              // 0x0170(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_BasicMove");
		return ptr;
	}


	void SpecialMoveEnded(const struct FName& PrevMove, const struct FName& NextMove);
	void BS_AnimEndNotify(const struct FName& AnimSeqName, int InAnimSeqKey, float PlayedTime, float ExcessTime);
	void OnAnimSeqEnd(const struct FName& AnimSeqName, float PlayedTime, float ExcessTime);
	void SpecialMoveSkipped(bool bIsCauseFromExternalFactor, const struct FName& CurrentSpecialMove);
	void ProcessAllHitTimeNotifies(class UAnimNodeSequence* SeqNode);
	void Tick(float DeltaTime);
	void AdjustFacing(bool bForce);
	bool IsInContactRangeWithTarget();
	void SpecialMoveStarted(bool bForced, const struct FName& PrevMove);
	void GetAnimSequenceInfo(struct FSeqPlayInfo* seqInfo);
	bool PlaySequence(struct FSeqPlayInfo* seqInfo);
	bool StartMoveAnimation(struct FSeqPlayInfo* seqInfo);
	bool InternalCanDoSpecialMove();
	struct FString ToString();
	struct FString GetParameterDescription();
	struct FName CurrentSkillName();
	int CurrentSkillId();
	bool CanOverrideSpecialMove(const struct FName& InMove);
	bool CanChainMove(const struct FName& NextMove);
	bool CanOverrideMoveWith(const struct FName& NewMove);
	void SetSpecialMoveParameter(class UBSM_BaseParameter* InSMParam);
	void InitSpecialMove(class AGamePawn* inPawn, const struct FName& InHandle);
};


// Class BLGame.BSM_HollowDamage
// 0x0008 (0x014C - 0x0144)
class UBSM_HollowDamage : public UBSM_Base
{
public:
	class UBSM_HollowDamageParameter*                  SimpleDamageParameter;                                    // 0x0144(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_HollowDamage");
		return ptr;
	}


	void SpecialMoveSkipped(bool bIsCauseFromExternalFactor, const struct FName& CurrentSpecialMove);
	void PlayDamageEffect(bool bDamageString, bool bSound, bool bDealDamage);
	void SpecialMoveStarted(bool bForced, const struct FName& PrevMove);
	void SetSpecialMoveParameter(class UBSM_BaseParameter* InSMParam);
	bool IsCanRepeatedlyDoing();
	bool InternalCanDoSpecialMove();
};


// Class BLGame.BSM_PhysicalDamage
// 0x0008 (0x0154 - 0x014C)
class UBSM_PhysicalDamage : public UBSM_HollowDamage
{
public:
	class UBSM_PhysicalDamageParameter*                PhysicalDamageParameter;                                  // 0x014C(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_PhysicalDamage");
		return ptr;
	}


	void BS_AnimEndNotify(const struct FName& AnimSeqName, int InAnimSeqKey, float PlayedTime, float ExcessTime);
	void SpecialMoveSkipped(bool bIsCauseFromExternalFactor, const struct FName& CurrentSpecialMove);
	void SpecialMoveEnded(const struct FName& PrevMove, const struct FName& NextMove);
	void SpecialMoveStarted(bool bForced, const struct FName& PrevMove);
	struct FName GetDamageSequenceName();
	void SetSpecialMoveParameter(class UBSM_BaseParameter* InSMParam);
	bool IsAllowIK(TEnumAsByte<EEffectiveIK> IKIndex);
	bool CanOverrideSpecialMove(const struct FName& InMove);
	bool CanOverrideMoveWith(const struct FName& NewMove);
	bool InternalCanDoSpecialMove();
};


// Class BLGame.BSM_RC_Base
// 0x006C (0x01C0 - 0x0154)
class UBSM_RC_Base : public UBSM_PhysicalDamage
{
public:
	class UBSM_RiotControlParameter*                   RCParameter;                                              // 0x0154(0x0008) (Transient)
	int                                                CurrentStateIndex;                                        // 0x015C(0x0004) (Transient)
	float                                              CurrentStateDuration;                                     // 0x0160(0x0004) (Transient)
	unsigned long                                      bMovingCurrentState : 1;                                  // 0x0164(0x0004) (Transient)
	unsigned long                                      bHaveGettingUpState : 1;                                  // 0x0164(0x0004) (Transient)
	struct FVector                                     RCStartLocation;                                          // 0x0168(0x000C) (Transient)
	struct FVector                                     RCEndLocation;                                            // 0x0174(0x000C) (Transient)
	struct FVector                                     CurrentStateStartLocation;                                // 0x0180(0x000C) (Transient)
	struct FVector                                     CurrentStateMoveDirection;                                // 0x018C(0x000C) (Transient)
	float                                              AccumTime;                                                // 0x0198(0x0004) (Transient)
	float                                              TotalTime;                                                // 0x019C(0x0004) (Transient)
	TArray<struct FRCStateInfo>                        RCStateInfoList;                                          // 0x01A0(0x0010) (NeedCtorLink)
	TArray<class UBLInterpCurveData*>                  RCStateCurveDataList;                                     // 0x01B0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_RC_Base");
		return ptr;
	}


	void OnPhysicalStateChanged(int PrevStateIndex, int NextStateIndex);
	void ChangePhysicalState(int NextStateIndex, float InAdditionalDuration);
	struct FName GetDeathActionName();
	void OnUpdateState(float DeltaTime);
	float GetOffset(float inTime);
	void Tick(float DeltaTime);
	void BS_AnimEndNotify(const struct FName& AnimSeqName, int InAnimSeqKey, float PlayedTime, float ExcessTime);
	bool IsEarlyAnimEnd(const struct FName& InEndedAnimSeqName);
	void SpecialMoveEnded(const struct FName& PrevMove, const struct FName& NextMove);
	void SpecialMoveStarted(bool bForced, const struct FName& PrevMove);
	bool InternalCanDoSpecialMove();
	bool CanOverrideSpecialMove(const struct FName& InMove);
	bool CanOverrideMoveWith(const struct FName& NewMove);
	bool CanChainMove(const struct FName& NextMove);
	void SetSpecialMoveParameter(class UBSM_BaseParameter* InSMParam);
	TEnumAsByte<ECERiotControlStateType> GetRiotControlStateType();
	bool IsRiotControllStateType(TEnumAsByte<ECERiotControlStateType> InStateType);
};


// Class BLGame.BSM_Skill_Base
// 0x0000 (0x0144 - 0x0144)
class UBSM_Skill_Base : public UBSM_Base
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_Skill_Base");
		return ptr;
	}


	void DisplayDebug(class AHUD* HUD, float* out_YL, float* out_YPos);
};


// Class BLGame.BSM_Skill_Tool
// 0x0090 (0x01D4 - 0x0144)
class UBSM_Skill_Tool : public UBSM_Skill_Base
{
public:
	struct FHitJudgmentResult                          DefaultEffectiveJudgment;                                 // 0x0144(0x005C) (Transient)
	unsigned long                                      bShowAllEquipItemsWhenSMEnd : 1;                          // 0x01A0(0x0004) (Transient)
	unsigned long                                      bAdjustRootMotionApproach : 1;                            // 0x01A0(0x0004) (Transient)
	unsigned long                                      bRootMotionCanceled : 1;                                  // 0x01A0(0x0004) (Transient)
	unsigned long                                      bAdjustRootMotionHeight : 1;                              // 0x01A0(0x0004) (Transient)
	float                                              RootMotionApproachDistanceModifier;                       // 0x01A4(0x0004) (Transient)
	float                                              AdjustRootMotionDistance;                                 // 0x01A8(0x0004) (Transient)
	struct FVector                                     StartLocation;                                            // 0x01AC(0x000C) (Transient)
	struct FVector                                     TargetLocation;                                           // 0x01B8(0x000C) (Transient)
	float                                              RootMotionMovableTime;                                    // 0x01C4(0x0004) (Transient)
	struct FName                                       RootMotionMovableAnimSeqName;                             // 0x01C8(0x0008) (Transient)
	float                                              TargetPawnRadius;                                         // 0x01D0(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_Skill_Tool");
		return ptr;
	}


	bool AdjustRootMotionHeight(float InDeltaTime);
	bool CheckRootMotionHeight();
	void CancelRootMotion();
	void CalcVelocityRootMotionApproach(float InDeltaTime, struct FVector* AccelDir);
	bool CheckRootMotionApproach(float InDeltaTime);
	bool CheckRootMotionMovable();
	void BS_AnimEndNotify(const struct FName& AnimSeqName, int InAnimSeqKey, float PlayedTime, float ExcessTime);
	void SetTwoBroadway(class UBroadwayGameInfo* InFirstBroadway, class UBroadwayGameInfo* InSecondBroadway, float InSkillTime, float InSkillOriginalTime, const struct FVector& InTargetLocation, int InSelectedTargetPawnID);
	void SetBroadway(class UBroadwayGameInfo* InBroadway, float InSkillTime, float InSkillOriginalTime, const struct FVector& InTargetLocation, int InSelectedTargetPawnID);
	bool PreSetBroadway(class UBroadwayGameInfo* a_Broadway, float SkillTime, const struct FVector& InTargetLocation, int InSelectedTargetPawnID, struct FSkillRequestInfo* OutRequestInfo);
	bool PlaySequence(struct FSeqPlayInfo* a_Info);
	void EnableAdjustRootMotionHeight(bool bEnable, const struct FVector& InTargetLocation);
	bool CanChainMove(const struct FName& NextMove);
	void DisplayDebug(class AHUD* HUD, float* out_YL, float* out_YPos);
	void CancelSpecialMove();
	void SpecialMoveEnded(const struct FName& PrevMove, const struct FName& NextMove);
	void SpecialMoveStarted(bool bForced, const struct FName& PrevMove);
	void InitSpecialMove(class AGamePawn* inPawn, const struct FName& InHandle);
	bool CanOverrideMoveWith(const struct FName& NewMove);
};


// Class BLGame.BSM_Taming
// 0x0000 (0x0144 - 0x0144)
class UBSM_Taming : public UBSM_Base
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_Taming");
		return ptr;
	}


	void CancelSpecialMove();
	void SpecialMoveEnded(const struct FName& PrevMove, const struct FName& NextMove);
	bool PlaySequence(struct FSeqPlayInfo* a_Info);
	void SetTwoBroadway(class UBroadwayGameInfo* InFirstBroadway, class UBroadwayGameInfo* InSecondBroadway, float InSkillTime, float InSkillOriginalTime, const struct FVector& InTargetLocation, int InSelectedTargetPawnID);
	void SetBroadway(class UBroadwayGameInfo* InBroadway);
};


// Class BLGame.BSM_VoluntaryAction
// 0x0010 (0x0154 - 0x0144)
class UBSM_VoluntaryAction : public UBSM_Base
{
public:
	class UBSM_VoluntaryActionParameter*               VAParam;                                                  // 0x0144(0x0008) (Transient)
	class UAkEvent*                                    EndSoundEvent;                                            // 0x014C(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_VoluntaryAction");
		return ptr;
	}


	void BS_AnimEndNotify(const struct FName& AnimSeqName, int InAnimSeqKey, float PlayedTime, float ExcessTime);
	void SpecialMoveSkipped(bool bIsCauseFromExternalFactor, const struct FName& CurrentSpecialMove);
	void SpecialMoveEnded(const struct FName& PrevMove, const struct FName& NextMove);
	bool PlaySequence(struct FSeqPlayInfo* a_Info);
	void SpecialMoveStarted(bool bForced, const struct FName& PrevMove);
	void SetEndSoundEvent(class UAkEvent* InEndSoundEvent);
	void SetBroadway(class UBroadwayGameInfo* InBroadway);
	void SetSpecialMoveParameter(class UBSM_BaseParameter* InSMParam);
	bool CanOverrideMoveWith(const struct FName& NewMove);
};


// Class BLGame.BSM_BaseParameter
// 0x003C (0x009C - 0x0060)
class UBSM_BaseParameter : public UObject
{
public:
	unsigned long                                      bIsUnbreakableMove : 1;                                   // 0x0060(0x0004) (Edit)
	class UBroadwayInfo*                               Broadway;                                                 // 0x0064(0x0008) (Edit)
	class UBroadwayInfo*                               CastingBroadway;                                          // 0x006C(0x0008) (Edit)
	class UBroadwayInfo*                               NextBroadway;                                             // 0x0074(0x0008) (Edit)
	TArray<struct FConditionalBroadway>                ConditionalBroadways;                                     // 0x007C(0x0010) (Edit, NeedCtorLink)
	TArray<struct FClassifiedBroadway>                 ClassifiedBroadways;                                      // 0x008C(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_BaseParameter");
		return ptr;
	}


	class UBSM_BaseParameter* MakeDynamicParameter(class UObject* InOuter);
	void GetBroadwayInfo(class UBodyInfo* InBodyInfo, TEnumAsByte<ECEItemEquipCategory> InMainItemCategory, TEnumAsByte<ECONDITIONAL_BROADWAY_TYPE> InConditionalType, class UBroadwayInfo** OutBroadway, class UBroadwayInfo** OutCastingBroadway, class UBroadwayInfo** OutNextBroadway);
	struct FString ToString();
	struct FString GetDescription();
};


// Class BLGame.BSM_BasicMoveParameter
// 0x0078 (0x0114 - 0x009C)
class UBSM_BasicMoveParameter : public UBSM_BaseParameter
{
public:
	struct FName                                       AnimSeqName;                                              // 0x009C(0x0008) (Edit)
	float                                              FadeInSeconds;                                            // 0x00A4(0x0004) (Edit)
	float                                              FadeOutSeconds;                                           // 0x00A8(0x0004) (Edit)
	unsigned long                                      bKeepFacing : 1;                                          // 0x00AC(0x0004) (Edit)
	unsigned long                                      bCameraFollowBody : 1;                                    // 0x00AC(0x0004) (Edit)
	float                                              ContactDistance;                                          // 0x00B0(0x0004) (Edit)
	TArray<int>                                        InEditorDamageList;                                       // 0x00B4(0x0010) (Edit, NeedCtorLink)
	float                                              InEditorDamageTypeScale;                                  // 0x00C4(0x0004) (Edit)
	TArray<float>                                      InEditorDamageTypeTiming;                                 // 0x00C8(0x0010) (Edit, NeedCtorLink)
	struct FName                                       TestAnimSeqName;                                          // 0x00D8(0x0008) (Edit, Transient)
	int                                                TriggerSkillId;                                           // 0x00E0(0x0004) (Transient)
	class UBroadwayGameInfo*                           BroadwayInfo;                                             // 0x00E4(0x0008) (Transient)
	TArray<struct FSkillResult>                        ServerSideResult;                                         // 0x00EC(0x0010) (Transient, NeedCtorLink)
	class ABLPawnBase*                                 TargetPawn;                                               // 0x00FC(0x0008) (Transient)
	int                                                SkillTargetID;                                            // 0x0104(0x0004) (Transient)
	struct FVector                                     SkillTargetLocation;                                      // 0x0108(0x000C) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_BasicMoveParameter");
		return ptr;
	}


	void BuildInEditorSkillResult(class ABLPawn* OwnerPawn, int SkillID, int SkillLv);
	void SetSkillTargetData(int TargetID, const struct FVector& TargetLocation);
	void SetSkillResult(class ABLPawn* OwnerPawn, int SkillID, int SkillLv, TArray<struct FSkillResult>* InResult);
	struct FString GetDescription();
};


// Class BLGame.BSM_HollowDamageParameter
// 0x002C (0x00C8 - 0x009C)
class UBSM_HollowDamageParameter : public UBSM_BaseParameter
{
public:
	class ABLPawn*                                     Assailant;                                                // 0x009C(0x0008) (Transient)
	int                                                DamageAmount;                                             // 0x00A4(0x0004) (Transient)
	class AController*                                 InstigatedBy;                                             // 0x00A8(0x0008) (Transient)
	float                                              StiffTime;                                                // 0x00B0(0x0004) (Transient)
	float                                              DamageStringDisplayRange;                                 // 0x00B4(0x0004) (Transient)
	struct FString                                     DamageCauseDesc;                                          // 0x00B8(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_HollowDamageParameter");
		return ptr;
	}

};


// Class BLGame.BSM_PhysicalDamageParameter
// 0x001C (0x00E4 - 0x00C8)
class UBSM_PhysicalDamageParameter : public UBSM_HollowDamageParameter
{
public:
	TEnumAsByte<EHitReactionType>                      HitReaction;                                              // 0x00C8(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x3];                                       // 0x00C9(0x0003) MISSED OFFSET
	struct FVector                                     ContactPosition;                                          // 0x00CC(0x000C) (Transient)
	struct FVector                                     ContactMomentum;                                          // 0x00D8(0x000C) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_PhysicalDamageParameter");
		return ptr;
	}

};


// Class BLGame.BSM_RiotControlParameter
// 0x0024 (0x0108 - 0x00E4)
class UBSM_RiotControlParameter : public UBSM_PhysicalDamageParameter
{
public:
	int                                                RiotControlType;                                          // 0x00E4(0x0004) (Transient)
	struct FRCApplyInfo                                RiotControlInfo;                                          // 0x00E8(0x0010) (Transient)
	TArray<struct FRiotControlStateData>               RiotControlSequenceData;                                  // 0x00F8(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_RiotControlParameter");
		return ptr;
	}

};


// Class BLGame.BSM_NpcDisposableActionParameter
// 0x000C (0x00A8 - 0x009C)
class UBSM_NpcDisposableActionParameter : public UBSM_BaseParameter
{
public:
	float                                              PlayTime;                                                 // 0x009C(0x0004) (Transient)
	struct FName                                       AnimSeqName;                                              // 0x00A0(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_NpcDisposableActionParameter");
		return ptr;
	}

};


// Class BLGame.BLAggregateEquipment
// 0x0030 (0x00A0 - 0x0070)
class UBLAggregateEquipment : public UComponent
{
public:
	TArray<struct FAttachmentEquipInfo>                AttachmentInfoList;                                       // 0x0070(0x0010) (Edit, Component, NeedCtorLink)
	TArray<class UBLItem*>                             EquipmentList;                                            // 0x0080(0x0010) (Edit, EditConst, AlwaysInit, NeedCtorLink)
	class UBodyInfo*                                   TargetBodyInfo;                                           // 0x0090(0x0008)
	TEnumAsByte<ECEClassType>                          TargetClassType;                                          // 0x0098(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0099(0x0003) MISSED OFFSET
	unsigned long                                      bNeedUpdateMesh : 1;                                      // 0x009C(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAggregateEquipment");
		return ptr;
	}


	void OnLoadAsset();
	TEnumAsByte<EEquipmentHelmetType> FindEquippedHelmetType();
	void SetAttachmentVisibility(TEnumAsByte<ECEEquipSlotType> InAttachEquipSlotType, bool bShow);
	void SetConceptSlotVisibility(TEnumAsByte<ECEEquipSlotType> InConceptEquipSlotType, bool bShow);
	void UpdateAttachmentVisibility(TEnumAsByte<ECEEquipSlotType> InAttachEquipSlotType, bool bUnsheathe);
	void UpdateAllAttachmentVisibility(bool bUnsheathe);
	bool UpdateAttachments(class USkeletalMeshComponent* InMesh);
	bool UpdateAttachment(TEnumAsByte<ECEEquipSlotType> InConceptEquipSlotTypeToUpdate, class USkeletalMeshComponent* InMesh);
	void UpdateAttachmentsAnimSet(bool bUnsheathe);
	void FinishSheathe();
	void StartUnsheathe();
	struct FAttachmentEquipInfo GetAttachmentInfo(TEnumAsByte<ECEEquipSlotType> InAttachEquipSlotType);
	class UBLEquipmentItemInHandInfo* GetInHandInfo_AttachEquipSlotType(TEnumAsByte<ECEEquipSlotType> InAttachEquipSlotType);
	TEnumAsByte<ECEEquipSlotType> GetConceptEquipSlotType(TEnumAsByte<ECEEquipSlotType> InAttachEquipSlotType);
	TEnumAsByte<ECEEquipSlotType> GetAttachEquipSlotType(TEnumAsByte<ECEEquipSlotType> InConceptEquipSlotType);
	bool ValidateEquipmentSlotType();
	bool CopyToOtherSkelComponent(class USkeletalMeshComponent* OtherSkelMesh, class AActor* OuterActor);
	struct FName GetUnsheathedBoneName(TEnumAsByte<ECEEquipSlotType> Slot);
	bool IsIncludeEar();
	int COUNT();
	void CollectEquippedItems(TEnumAsByte<ECEEquipSlotType> Slot, TArray<class UBLEquipmentItemInfo*>* CollectedItems);
	void GetEquipmentItemList(TArray<class UBLItem*>* OutItemList);
	void GetEquipmentItemCidList(TArray<int>* OutItemCidList);
	int GetEquipedItemCid(TEnumAsByte<ECEEquipSlotType> Slot);
	class UBLItem* GetEquipedItem(TEnumAsByte<ECEEquipSlotType> Slot);
	int TakeOffAll();
	bool TakeOff(TArray<TEnumAsByte<ECEEquipSlotType>> SlotsToTakeoff_ConceptEquipSlotType, TArray<class UBLItem*>* TakenOffItems);
	bool EquipItems(TArray<class UBLItem*>* Items);
	void SetPawnInfo(class UPawnAsset* PawnInfo);
	void SetOwnerInfo(class UBodyInfo* InBodyInfo, TEnumAsByte<ECEClassType> InClassType);
};


// Class BLGame.BLDisplayItem
// 0x0060 (0x00C0 - 0x0060)
class UBLDisplayItem : public UObject
{
public:
	struct FMap_Mirror                                 Items;                                                    // 0x0060(0x0048) (Native, Transient)
	TArray<int>                                        OrderedKey;                                               // 0x00A8(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	int                                                LastTryItemCid;                                           // 0x00B8(0x0004) (Transient)
	float                                              ItemCachedDuration;                                       // 0x00BC(0x0004) (Config)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLDisplayItem");
		return ptr;
	}


	void RequestToServer(int InCid, int InSid);
	class UBLItem* MakeBLItem(int InSid);
	int GetCid(int InSid);
	void Remove(int InSid);
	void Update(const struct FItemData& InItemData);
	void ClearAll();
};


// Class BLGame.BLEquipmentItemDeformingInfo
// 0x0020 (0x0080 - 0x0060)
class UBLEquipmentItemDeformingInfo : public UObject
{
public:
	TArray<struct FKBoxElem>                           ClippingArea;                                             // 0x0060(0x0010) (Edit, NeedCtorLink)
	TArray<struct FReshapingAsset>                     ReshapingAssetList;                                       // 0x0070(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLEquipmentItemDeformingInfo");
		return ptr;
	}

};


// Class BLGame.BLEquipmentItemDressInfo
// 0x0020 (0x0080 - 0x0060)
class UBLEquipmentItemDressInfo : public UObject
{
public:
	TArray<struct FTargetDressDeformingInfo>           DeformingDressInfos;                                      // 0x0060(0x0010) (EditConst, NeedCtorLink, EditInline)
	TArray<struct FTargetBasePartDeformingInfo>        DeformingBaseParts;                                       // 0x0070(0x0010) (Edit, EditConst, NeedCtorLink, EditInline)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLEquipmentItemDressInfo");
		return ptr;
	}

};


// Class BLGame.BLEquipmentItemEquipInfo
// 0x004C (0x00AC - 0x0060)
class UBLEquipmentItemEquipInfo : public UObject
{
public:
	class USkeletalMesh*                               SkelMesh;                                                 // 0x0060(0x0008) (Edit)
	float                                              MeshScale;                                                // 0x0068(0x0004) (Edit)
	class UMaterialInterface*                          MaterialOverride;                                         // 0x006C(0x0008) (Edit)
	TEnumAsByte<EEquipmentHelmetType>                  HelmetType;                                               // 0x0074(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0075(0x0003) MISSED OFFSET
	class UAnimSet*                                    WeaponOnAnimSet;                                          // 0x0078(0x0008) (Edit)
	class UAnimSet*                                    WeaponOffAnimSet;                                         // 0x0080(0x0008) (Edit)
	class UBLEquipmentItemInHandInfo*                  InHandInfo;                                               // 0x0088(0x0008)
	class UBLEquipmentItemDressInfo*                   DressInfo;                                                // 0x0090(0x0008)
	struct FName                                       AnotherBoneToAttachMesh;                                  // 0x0098(0x0008) (Transient)
	unsigned long                                      FlippingAnotherMesh : 1;                                  // 0x00A0(0x0004) (Transient)
	class USkeletalMesh*                               SkelMeshForThumbnail;                                     // 0x00A4(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLEquipmentItemEquipInfo");
		return ptr;
	}


	void SetAnotherMeshFlipping(bool bFlip);
	void SetAnotherAttachBoneName(const struct FName& AnotherBoneToAttach);
	void SetMeshFlipping(bool bFlip);
	void SetAttachBoneName(const struct FName& BoneToAttach);
};


// Class BLGame.BLEquipmentItemInfo
// 0x00A8 (0x0108 - 0x0060)
class UBLEquipmentItemInfo : public UObject
{
public:
	TArray<struct FEquipInfoMapEntity>                 EquipInfoSandbox;                                         // 0x0060(0x0010) (Const, NeedCtorLink)
	unsigned char                                      UnknownData00[0x48];                                      // 0x0070(0x0048) UNKNOWN PROPERTY: MapProperty BLGame.BLEquipmentItemInfo.EquipInfoLinkMap
	TEnumAsByte<EEquipmentItemType>                    ItemType;                                                 // 0x00B8(0x0001)
	unsigned char                                      UnknownData01[0x3];                                       // 0x00B9(0x0003) MISSED OFFSET
	unsigned char                                      UnknownData02[0x48];                                      // 0x00B9(0x0048) UNKNOWN PROPERTY: MapProperty BLGame.BLEquipmentItemInfo.EquipInfoExistenceMap
	unsigned long                                      bNeedMigrate : 1;                                         // 0x0104(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLEquipmentItemInfo");
		return ptr;
	}


	bool IsExistEquipInfo(class UBodyInfo* InBodyInfo, TEnumAsByte<ECEClassType> InClassType, bool bExactBodyAndClass);
	struct FString FindEquipInfoPath(class UBodyInfo* InBodyInfo, TEnumAsByte<ECEClassType> InClassType, bool bExactBodyAndClass);
	class UBLEquipmentItemEquipInfo* LoadEquipInfo(class UBodyInfo* InBodyInfo, TEnumAsByte<ECEClassType> InClassType, bool bExactBodyAndClass);
	class UBLEquipmentItemEquipInfo* FindEquipInfo(class UBodyInfo* InBodyInfo, TEnumAsByte<ECEClassType> InClassType, bool bExactBodyAndClass);
	bool IsWearable(class UBodyInfo* InBodyInfo, TEnumAsByte<ECEClassType> InClassType, bool bExactBodyAndClass);
	bool HasInHandInfo(class UBodyInfo* InBodyInfo, TEnumAsByte<ECEClassType> InClassType, bool bExactBodyAndClass);
	bool HasDressInfo(class UBodyInfo* InBodyInfo, TEnumAsByte<ECEClassType> InClassType, bool bExactBodyAndClass);
	bool HasEquipInfo(class UBodyInfo* InBodyInfo, TEnumAsByte<ECEClassType> InClassType, bool bExactBodyAndClass);
};


// Class BLGame.BLEquipmentItemInHandInfo
// 0x009C (0x00FC - 0x0060)
class UBLEquipmentItemInHandInfo : public UObject
{
public:
	struct FName                                       SheatheBoneNameInLeftHands;                               // 0x0060(0x0008) (Edit)
	struct FRotator                                    RotateWhenSheathedInLeftHands;                            // 0x0068(0x000C) (Edit)
	struct FVector                                     LocateWhenSheathedInLeftHands;                            // 0x0074(0x000C) (Edit)
	struct FName                                       SheatheBoneNameInRightHands;                              // 0x0080(0x0008) (Edit)
	struct FRotator                                    RotateWhenSheathedInRightHands;                           // 0x0088(0x000C) (Edit)
	struct FVector                                     LocateWhenSheathedInRightHands;                           // 0x0094(0x000C) (Edit)
	float                                              BlendTimeForSheathe;                                      // 0x00A0(0x0004) (Edit)
	float                                              BlendTimeForUnsheathe;                                    // 0x00A4(0x0004) (Edit)
	unsigned long                                      bHideWhenSheathed : 1;                                    // 0x00A8(0x0004) (Edit)
	unsigned long                                      bForceAttachToLeftHand : 1;                               // 0x00A8(0x0004) (Edit)
	unsigned long                                      bFlipInLeftHand : 1;                                      // 0x00A8(0x0004) (Edit)
	unsigned long                                      bIsFloatingWeapon : 1;                                    // 0x00A8(0x0004) (Edit)
	class UAnimSet*                                    HandlerAnimSet;                                           // 0x00AC(0x0008) (Edit)
	class UAnimNotifySet*                              HandlerAnimNotifySet;                                     // 0x00B4(0x0008) (Edit)
	float                                              MeshScale;                                                // 0x00BC(0x0004) (Edit)
	class USkeletalMesh*                               DecoMesh;                                                 // 0x00C0(0x0008) (Edit)
	struct FName                                       DecoAttachSocketName;                                     // 0x00C8(0x0008) (Edit)
	struct FName                                       DecoAttachBoneName;                                       // 0x00D0(0x0008) (Edit)
	struct FRotator                                    DecoBoneRelativeRotation;                                 // 0x00D8(0x000C) (Edit)
	struct FVector                                     DecoBoneRelativeLocation;                                 // 0x00E4(0x000C) (Edit)
	float                                              DecoMeshScale;                                            // 0x00F0(0x0004) (Edit)
	class USkeletalMesh*                               AccessoryMesh;                                            // 0x00F4(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLEquipmentItemInHandInfo");
		return ptr;
	}

};


// Class BLGame.BLItem
// 0x00BE (0x011E - 0x0060)
class UBLItem : public UObject
{
public:
	int                                                mInfoCid;                                                 // 0x0060(0x0004)
	struct FInventoryItemData                          mData;                                                    // 0x0064(0x0098) (NeedCtorLink)
	class UItemAsset*                                  mAsset;                                                   // 0x00FC(0x0008)
	class UBLEquipmentItemEquipInfo*                   mEquipInfo;                                               // 0x0104(0x0008)
	int                                                DefaultErrorItemCid;                                      // 0x010C(0x0004) (Const)
	class UBLItem*                                     LinkedDummyItem;                                          // 0x0110(0x0008) (Transient)
	unsigned long                                      bDummyItem : 1;                                           // 0x0118(0x0004) (Transient)
	TEnumAsByte<ECEEquipSlotType>                      ConceptEquipSlotType;                                     // 0x011C(0x0001) (Transient)
	TEnumAsByte<ECEEquipSlotType>                      AttachEquipSlotType;                                      // 0x011D(0x0001) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLItem");
		return ptr;
	}


	class UBLItem* STATIC_Create(struct FEquipedItemData* InData);
	int GetEvolutionMaterialItemNeedAmount(int InMaterialCid);
	int GetEvolutionMaterialItemCid();
	int GetIconIndex();
	struct FString GetItemName();
	bool CheckDirtyInventoryItemData(TArray<TEnumAsByte<EDirtyInventoryItemDataType>>* OutDirtyTypeList, struct FInventoryItemData* InNewInventoryItemData);
	int GetItemLevel();
	int GetStatValue(TEnumAsByte<ECEParamType> InType);
	void SetData(struct FInventoryItemData* InNewData);
	bool IsExistEquipInfo(class UBodyInfo* BodyInfoToFind, TEnumAsByte<ECEClassType> InClassType);
	class UBLEquipmentItemEquipInfo* FindEquipInfo(class UBodyInfo* BodyInfoToFind, TEnumAsByte<ECEClassType> InClassType);
	class UBLEquipmentItemInfo* GetEquipmentInfo();
	int RetrieveHandlerAnimSets(class UBodyInfo* BodyInfoToFind, TEnumAsByte<ECEClassType> InClassType, TArray<class UAnimSet*>* outAnimSet, TArray<class UAnimNotifySet*>* outAnimNotifySet);
	bool IsEquipUpgradeNeedMaterial();
	bool IsInHandable(class UBodyInfo* BodyInfoToFind, TEnumAsByte<ECEClassType> InClassType);
	bool IsEquipable();
	bool IsEquiped();
};


// Class BLGame.BLMailItem
// 0x000A (0x0128 - 0x011E)
class UBLMailItem : public UBLItem
{
public:
	unsigned char                                      UnknownData00[0x2];                                       // 0x011E(0x0002) MISSED OFFSET
	unsigned long                                      bIsSpecificItem : 1;                                      // 0x0120(0x0004)
	int                                                MailItemKey;                                              // 0x0124(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLMailItem");
		return ptr;
	}

};


// Class BLGame.BLMerchantInventory
// 0x00C4 (0x0124 - 0x0060)
class UBLMerchantInventory : public UObject
{
public:
	struct FShopData                                   ReplicatedShopdata;                                       // 0x0060(0x0020) (NeedCtorLink)
	struct FShopData                                   ShopData;                                                 // 0x0080(0x0020) (NeedCtorLink)
	int                                                ShopCid;                                                  // 0x00A0(0x0004)
	TEnumAsByte<EMerchantPurchaseType>                 PurchaseType;                                             // 0x00A4(0x0001)
	TEnumAsByte<ECoinType>                             CoinType;                                                 // 0x00A5(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x00A6(0x0002) MISSED OFFSET
	struct FShopTradeItemData                          PurchaseGiftItemData;                                     // 0x00A8(0x0028) (NeedCtorLink)
	struct FShopTradeItemData                          PurchaseItemData;                                         // 0x00D0(0x0028) (NeedCtorLink)
	unsigned long                                      IsInShop : 1;                                             // 0x00F8(0x0004)
	unsigned long                                      IsNeedConfirm : 1;                                        // 0x00F8(0x0004)
	int                                                ItemUnitPrice;                                            // 0x00FC(0x0004)
	TArray<TEnumAsByte<ECERealmType>>                  ROTypes;                                                  // 0x0100(0x0010) (NeedCtorLink)
	TArray<int>                                        COIDs;                                                    // 0x0110(0x0010) (NeedCtorLink)
	struct FColor                                      MerchantItemDurationColor;                                // 0x0120(0x0004) (Config)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLMerchantInventory");
		return ptr;
	}


	void PurchaseGiftItem_Request();
	void LeaveShop();
	void UpdateRepurchaseItem(const struct FItemData& InRemoveRepurchaseItem, const struct FItemData& InAcquireRepurchaseItem);
	void EnterShop();
	bool FindRepurchaseItem(int InSid, struct FItemData* OutItemData);
	TEnumAsByte<EMerchantPurchaseType> GetPurchaseType();
	void SetPurchaseType(TEnumAsByte<EMerchantPurchaseType> InNewType);
	void RepurchaseItem(int SlotIndex, int InventoryTabIndex, int InventorySlotIndex);
	void PurchaseGiftItem_Select(const struct FString& InReceiverName);
	void PurchaseDataConfirm();
	void OnClickPurchaseAmountConfirm(int InItemCount);
	void PurchaseGiftItem_Prepare(int SlotIndex, int InventoryTabIndex, int InventorySlotIndex);
	void PurchaseItemAmount(int SlotIndex, int InventoryTabIndex, int InventorySlotIndex);
	void PurchaseItem(int SlotIndex, int InventoryTabIndex, int InventorySlotIndex);
	bool PurchaseQualificationCheck(int SlotIndex, int InventoryTabIndex, int InventorySlotIndex);
	void ClearPurchaseGiftItemData();
	void UpdateShopItem(struct FShopItemData* InShopItemData);
	void UpdateShopItemList(bool bFiltered);
	class UGFxObject* MakeGfxObjectShopItem(int InItemIndex, struct FShopItemData* InShopItemData);
	struct FString MakeMerchantItemDurationTagString(struct FItemInfoData* InItemInfo);
	struct FString MakeMerchantItemNameTagString(struct FItemInfoData* InItemInfo);
	void SetEnterShopData(int InShopCid, const struct FShopData& InShopData);
	bool IsLearnedSkill(struct FItemInfoData* InItemInfo);
	bool IsEnterShop();
	void Init();
};


// Class BLGame.BLPlayerInventory
// 0x0094 (0x00F4 - 0x0060)
class UBLPlayerInventory : public UObject
{
public:
	TArray<int>                                        SlotMaxes;                                                // 0x0060(0x0010) (NeedCtorLink)
	TArray<struct FInventoryTab>                       InventoryTabs;                                            // 0x0070(0x0010) (NeedCtorLink)
	struct FEquipmentTab                               EquipTab;                                                 // 0x0080(0x0014) (NeedCtorLink)
	TArray<struct FInventorySlotComponentTab>          InventorySlotComponentTabs;                               // 0x0094(0x0010) (NeedCtorLink)
	int                                                SelectedTabIndex;                                         // 0x00A4(0x0004)
	int                                                OpenerNewFlagCount;                                       // 0x00A8(0x0004)
	int                                                InitializedInventoryUI;                                   // 0x00AC(0x0004)
	unsigned long                                      bInitializedEquipUI : 1;                                  // 0x00B0(0x0004)
	unsigned long                                      bOpenedInventory : 1;                                     // 0x00B0(0x0004)
	unsigned long                                      bNeedUpdateSlotCount : 1;                                 // 0x00B0(0x0004)
	TEnumAsByte<EInventorySplitAction>                 SplitAction;                                              // 0x00B4(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x00B5(0x0003) MISSED OFFSET
	struct FInventoryExpansionPurchaseInfo             PurchaseInfo;                                             // 0x00B8(0x0024) (NeedCtorLink)
	struct FInventorySplitInfo                         SplitInfo;                                                // 0x00DC(0x0010)
	float                                              ItemCooldownUpdateTime;                                   // 0x00EC(0x0004)
	float                                              ItemCooldownUpdateTimeCount;                              // 0x00F0(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLPlayerInventory");
		return ptr;
	}


	void EquipItem(const struct FString& InSid, int InSlot);
	void UA_Inventory_Set_UnblockSlot(int TabIndex, int SlotIndex_Start, int SlotIndex_End);
	void UA_Inventory_AutoSort_StartCooldown(float DurationTime);
	void UA_Inventory_Unlock_Effect(int TabIndex, int SlotComponentIndex, int UnLockType);
	void UA_Inventory_NewItem_Count(int TabIndex, int NewCount);
	void UA_Inventory_Set_Slot_Count(const struct FString& COUNT);
	void UA_Inventory_Set_Item_Cooldown(int InTabIndex, int InSlotIndex, float InRemainTime, float InMaxTime);
	void UA_Inventory_Remove_Item(const struct FString& Sid);
	void UA_Inventory_Move_Item(const struct FString& Sid, int targetTabIndex, int TargetSlotIndex);
	void UA_Inventory_Tab_Clear(int TabIndex);
	void UA_Inventory_Clear();
	void UA_Inventory_Set_Split_Mode(int Mode);
	void UA_Inventory_Update_NewItemEffect(int TabIndex, int SlotIndex, bool IsNew);
	void UA_Inventory_Set_Item(class UBLItem* Item, int UpdateFlag);
	void UA_Inventory_Select_Tab(int InTabIndex);
	void LockInventory(bool bLock);
	void OpenInventoryItemSplitDialog(const struct FString& InTopText, const struct FString& InBottomText, int InMinNum, int InMaxNum, int InCurNum);
	void PrintSystemMessage_InventorySplitSlotFull();
	void SendInvenExpansion(int InItemSid);
	void CS_EQUIP_INVEN_ITEM_REQ(const struct FString& InSid, int InSlot);
	void CS_REMOVE_INVEN_ITEM_REQ(int InItemSid, struct FLONGLONGWrapper* InCurrentGameGuardStatus);
	void CS_MOVE_INVEN_ITEM_REQ(int InItemSid, int InTargetTabId, int InTargetSlotId);
	void CS_SHOP_CLEARANCE_REQ(TArray<int>* InItemSidList);
	void CS_SHOP_SELL_REQ(int* InItemSid, struct FLONGLONGWrapper* InCurrentGameGuardStatus);
	void CS_DIVIDE_INVEN_ITEM_REP(int InItemSid, int InCount);
	void CS_SORT_INVENTORY_REQ(TEnumAsByte<ECEInventoryType> InInventoryTab);
	void RequestRemoveItem(int Sid);
	void RequestMoveItem(int Sid, int targetTabIndex, int TargetSlotIndex);
	void RequestSellItem_AllTrash();
	void RequestSellItem(int InTabIndex, int InSlotIndex);
	void OnSelectInventorySplitItemNumFromUI(int InNum);
	void OnCanceledInventorySplitModeFromUI(int InCancelType);
	void OnSelectedInventorySplitItemFromUI(int InItemSid);
	void OnSelectedInventoryPurchaseFromUI(int InSelectIndex);
	void OnSelectedInventoryTab(int InTabIndex);
	void OnClickedInventorySplitFromUI();
	void OnClickedInventoryAutoSortFromUI();
	void OnClickedInventoryLockIconFromUI(int InTabIndex, int InComponentIndex);
	void OnClosedInventoryFromUI();
	void OnOpenedInventoryFromUI();
	void OnFinalizedEquipFromUI();
	void OnFinalizedInventoryFromUI();
	void OnInitializedEquipFromUI();
	void OnInitializedInventoryTabFromUI(int TabIndex);
	void OnInitializedInventoryFromUI();
	void UpdateAfterSetNewData(TArray<TEnumAsByte<EDirtyInventoryItemDataType>> InDirtyTypeList, class UBLItem** InInventoryItem);
	void UpdateBeforeSetNewData(TArray<TEnumAsByte<EDirtyInventoryItemDataType>> InDirtyTypeList, class UBLItem** InInventoryItem, struct FInventoryItemData* InNewInventoryItemData);
	void OnUpdateEquipItemDurabilityHUD(struct FInventoryItemData* InItemData);
	void OnUpdateSort(bool bSuccess, TEnumAsByte<ECEInventoryType> InInventoryTab);
	void OnUpdateItemSkillGlobalCoolDown();
	void OnUpdateItemSkillCoolDown(int InItemSkillCid);
	void OnUpdateItemCoolDown(int InItemCid);
	void OnUpdateQuestItem(int questId);
	void OnRemoveEquipedItem(TEnumAsByte<ECEEquipSlotType> InEquipSlotType);
	void OnRemoveItem(struct FInventoryItemData* ItemData);
	void OnAcquireItem(struct FInventoryItemData* ItemData);
	void OnUpdateItem(int UpdateFlag, struct FInventoryItemData* ItemData);
	void OnExpireExpansionCount(int InExpansionCount);
	void OnExpireExpansion(int InExpansionCid);
	void OnUpdateExpansion(int InExpansionCid, const struct FQWord& InExpireTime, TEnumAsByte<EInventoryExpansionType> InExpansionType);
	bool PlayInventorySound(TEnumAsByte<EInventorySoundType> InSoundType);
	bool PlayInventoryExpansionEffect(int InTabIndex, int InExpansionCid);
	class UBLItem* RemoveItem(int Sid);
	class UBLItem* AddItem(const struct FInventoryItemData& Item, bool bNewFlag);
	void UpdateSlotChangeEquipable(class UBLItem* InNewInventoryItem);
	void UpdateSlotChangeRemove(class UBLItem* InOldInventoryItem, struct FInventoryItemData* InNewInventoryItemData);
	bool NeedNewItemEffect(int InItemCid);
	void ShowNewItemEffect(int InTabIndex, int InSlotIndex);
	void ShowAllNewItemEffectInTab(int InTabIndex);
	void RemoveNewItemEffect(int InTabIndex, int InSlotIndex);
	void ClearAllNewItemEffectInTab(int InTabIndex);
	void UpdateInventoryNewFlag();
	void UpdateInventorySlotCountOnUI(int InTabIndex);
	void RemoveItemCoolDownOnUI(int InTabIndex, int InSlotIndex);
	void UpdateAllItemCoolDownOnUI();
	void UpdateItemCoolDownOnUI(int InTabIndex, int InSlotIndex, int InItemCid);
	void UpdateEquipedOnUI(class UBLItem* Item, int SlotIndex, bool bEquip);
	void RemoveItemOnUI(int Sid, int TabIndex);
	void MoveItemOnUI(int Sid, int targetTabIndex, int TargetSlotIndex);
	void UpdateItemOnUI(class UBLItem* Item, int UpdateFlag);
	void UpdateEquipItemsOnUI();
	void UpdateInventoryTabItemsOnUI(int TabIndex);
	void UpdateInventoryItemsOnUI();
	void UpdataInventoryTabOnUI(int TabIndex);
	void UpdataAllEquipOnUI();
	void UpdataAllInventoryOnUI();
	void UpdateAllItemsOnUI();
	void UpdateAllOnUI();
	TEnumAsByte<ECEEquipSlotType> FindEmptyEquipableSlotIndex(TEnumAsByte<ECEItemEquipSlotType> InSlotType);
	class UBLItem* FindMPSkillChangeItem(TEnumAsByte<ECECompanionGradeType> InGrade);
	class UBLItem* FindEquipItemSlot(int SlotIndex);
	class UBLItem* FindItemSlot(int TabIndex, int SlotIndex);
	class UBLItem* FindItem(int Sid);
	bool IsExitFuncByDirtyType(TArray<TEnumAsByte<EDirtyInventoryItemDataType>> InDirtyTypeList);
	bool IsEquipUpgradeSuccessRateMaterialItem(int InTargetItemSid, int InMaterialItemSid);
	bool IsEquipUpgradeMainMaterialItem(int InTargetItemSid, int InMaterialItemSid);
	bool IsRecoverMaterialItem(int InTargetItemSid, int InMaterialItemSid);
	bool IsExistAvailableSlot(int InTableIndex);
	bool IsInitializedAllTabUI();
	bool IsInitializedTabUI(int TabIndex);
	bool IsDoingSplitAction();
	bool IsValidIndex(int TabIndex, int SlotIndex);
	int IsEquipedSlotIndex(TEnumAsByte<ECEEquipSlotType> InSlotIndex);
	int IsEquipedSlot(TEnumAsByte<ECEItemEquipSlotType> SlotType);
	bool IsExistTrashItem();
	bool IsExistGatherItem(unsigned char GatherCategory);
	int GetTotalGearScore();
	int GetIncreasedGearScore(class UBLItem* InItem);
	void GetItemListByCid(int InItemCid, TArray<class UBLItem*>* OutItemList);
	void GetEquipableSlotIndex(TEnumAsByte<ECEItemEquipSlotType> InSlotType, TArray<TEnumAsByte<ECEEquipSlotType>>* OutSlotIndexList);
	int GetSlotIndexbySid(int InSid);
	void GetEquipableItemInInventorySlot(TArray<class UBLItem*>* EquipItemList);
	int GetNewFlagCount(int InTabIndex);
	TArray<TEnumAsByte<ECEItemEquipSlotType>> GetSameItemEquipSlotTypes(TEnumAsByte<ECEItemEquipSlotType> SlotType);
	struct FString GetInventoryTabTitle(int InTabIndex);
	struct FString GetInventoryLockTooltip(int InTabIndex, int InSlotCompIndex);
	TArray<class UBLItem*> GetEquippedItemListWithSlotType(TEnumAsByte<ECEItemEquipSlotType> InSlotType);
	TArray<class UBLItem*> GetEquippedItemList();
	int GetUsedSlotCountByCid(int InItemCid);
	int GetUsedSlotCount(int InTabIndex);
	int GetTotalAvaliableSlotCount(int InTabIndex);
	int GetUsedAvailableSlotCount(int InTabIndex);
	int GetMaxAvailableSlotCount(int InTabIndex);
	int GetItemStackCount(int InItemSid);
	int GetItemTotalCount(int InItemCid);
	int GetItemCidBySid(int InSid);
	int GetItemSidByCID(int Cid);
	int GetItemSid(int InTabIndex, int InSlotIndex);
	int GetItemCid(int InTabIndex, int InSlotIndex);
	void SetInitializedTabUI(int TabIndex, bool bInit);
	void SetSplitAction(TEnumAsByte<EInventorySplitAction> InNewSplitAction, bool bForce);
	void StopSplitAction();
	void Tick(float InDeltaSeconds);
	void GenerateInitUIData(TArray<struct FUIInventoryTabData>* OutInvenTabDataList);
	void InitInventory(int InExpansionSlotCount);
	void InitItems(TArray<struct FInventoryItemData>* InItemDataList);
	void Init();
};


// Class BLGame.BLWarehouse
// 0x0000 (0x00F4 - 0x00F4)
class UBLWarehouse : public UBLPlayerInventory
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLWarehouse");
		return ptr;
	}


	void UA_Inventory_AutoSort_StartCooldown(float DurationTime);
	void UA_Inventory_Unlock_Effect(int TabIndex, int SlotComponentIndex, int UnLockType);
	void UA_Inventory_NewItem_Count(int TabIndex, int NewCount);
	void UA_Inventory_Set_Slot_Count(const struct FString& COUNT);
	void UA_Inventory_Lock_SlotComponent(int TabIndex, int SlotComponentIndex, const struct FString& Lock);
	void UA_Inventory_Set_Item_Cooldown(int InTabIndex, int InSlotIndex, float InRemainTime, float InMaxTime);
	void UA_Inventory_Remove_Item(const struct FString& Sid);
	void UA_Inventory_Move_Item(const struct FString& Sid, int targetTabIndex, int TargetSlotIndex);
	void UA_Inventory_Tab_Clear(int TabIndex);
	void UA_Inventory_Clear();
	void UA_Inventory_Set_Split_Mode(int Mode);
	void UA_Inventory_Init_Lock_SlotComponent(TArray<class UGFxObject*> TabData);
	void UA_Inventory_Update_NewItemEffect(int TabIndex, int SlotIndex, bool IsNew);
	void UA_Inventory_Set_Item(class UBLItem* Item, int UpdateFlag);
	void UA_Inventory_Select_Tab(int InTabIndex);
	void LockInventory(bool bLock);
	void OpenInventoryItemSplitDialog(const struct FString& InTopText, const struct FString& InBottomText, int InMinNum, int InMaxNum, int InCurNum);
	void PrintSystemMessage_InventorySplitSlotFull();
	void CS_REMOVE_INVEN_ITEM_REQ(int InItemSid, struct FLONGLONGWrapper* InCurrentGameGuardStatus);
	void CS_MOVE_INVEN_ITEM_REQ(int InItemSid, int InTargetTabId, int InTargetSlotId);
	void CS_SHOP_CLEARANCE_REQ(TArray<int>* InItemSidList);
	void CS_SHOP_SELL_REQ(int* InItemSid, struct FLONGLONGWrapper* InCurrentGameGuardStatus);
	void CS_DIVIDE_INVEN_ITEM_REP(int InItemSid, int InCount);
	void CS_INVENTORY_EXPANSION_REQ(int InInventory_Expansion_CId, TEnumAsByte<EInventoryExpansionType> InExpansionType);
	void CS_SORT_INVENTORY_REQ(TEnumAsByte<ECEInventoryType> InInventoryTab);
	void MoveWarehouseToInven(int ItemSid, int TabIndex, int SlotIndex);
	void MoveInvenToWarehouse(int ItemSid, int SlotIndex);
	void OnAcquireItems(TArray<struct FInventoryItemData> Items);
	void OnUpdateItems(TArray<struct FInventoryItemData> Items);
	void InitUI();
	void InitInventory(int InExpansionSlotCount);
	void Init();
};


// Class BLGame.RuneManager
// 0x0078 (0x00D8 - 0x0060)
class URuneManager : public UObject
{
public:
	unsigned long                                      bOpenedUI : 1;                                            // 0x0060(0x0004)
	unsigned long                                      bProcessSynthesis : 1;                                    // 0x0060(0x0004)
	TEnumAsByte<ERuneUITabType>                        CurrentTab;                                               // 0x0064(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET
	struct FRuneEquipUIData                            EquipUIData;                                              // 0x0068(0x0018) (NeedCtorLink)
	struct FRuneSlateUIData                            SlateUIData;                                              // 0x0080(0x0014) (NeedCtorLink)
	TArray<int>                                        ESocketIndexTypeToIndex;                                  // 0x0094(0x0010) (Const, NeedCtorLink)
	TArray<TEnumAsByte<ESocketIndexType>>              IndexToESocketIndexType;                                  // 0x00A4(0x0010) (Const, NeedCtorLink)
	TArray<TEnumAsByte<ERuneSoundType>>                SlateEffectToSound;                                       // 0x00B4(0x0010) (Const, NeedCtorLink)
	int                                                SlateSlotCount;                                           // 0x00C4(0x0004) (Const)
	TArray<struct FRecipeBookInfoData>                 RecipeBookInfoDataList;                                   // 0x00C8(0x0010) (Const, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.RuneManager");
		return ptr;
	}


	void AU_Click_Meterial_Page_Button(int InCurrentPage);
	void AU_Click_Synthesis_Button();
	void AU_Swap_Meterial_Item(int InIndexA, int InIndexB);
	void AU_Slate_Drop_From_Inventory(int InIndex, int InSid);
	void AU_Remove_Slate_Meterial_Item(int InIndex);
	void UA_Set_Slate_Effect(TEnumAsByte<EUIRuneSlateEffectType> InEffectType);
	void UA_Stop_Synthesis_CastingBar();
	void UA_Cancel_Synthesis_CastingBar();
	void UA_Start_Synthesis_CastingBar();
	void UA_Set_Slate_RecipeBook_Page(int InCurrentPage, int InMaxPage);
	void UA_Set_Slate_RecipeBook_Data(int InPage);
	void UA_Update_Synthesis_Button();
	void UA_Update_Meterial_Data();
	void UA_Set_Slate_Result_Data();
	void CS_CloseSlateUI();
	void CS_CancelSynthesis();
	void CS_StartSynthesis(int InrecipeCId);
	void CS_RegistMaterialSlot(int InSlotIndex, int InItemSid);
	bool FindAndSubtractionMaterialItem(const struct FSlateMaterialData& InMaterialItem, TArray<struct FRecipeItemData>* InRequiredItemList);
	bool IsSatifiedRecipe_V2(TArray<struct FSlateMaterialData> InMaterialItemList);
	bool IsSatifiedRecipeData(const struct FRecipeInfoData& InRecipeInfoData, TArray<struct FSlateMaterialData> InMaterialItemList);
	void StopSynthesisAction(bool bComplete);
	void PlaySynthesisAction();
	bool FindSatisfiedRecipeData(struct FRecipeInfoData* RecipeInfoData);
	void EndSynthesis(int InItemSid, TEnumAsByte<ECraftResultType> InSynthesisResultType);
	void CancelSynthesis();
	void DoSynthesis();
	void ClearAllMaterial();
	void SetMaterial(int InIndex, int InItemSid);
	void SetResultItem(int InItemSid);
	void OpenDialog_NotEnoughLumena();
	void OpenDialog_NotEnoughGold();
	void OpenDialog_InventoryFull();
	void OpenDialog_ConfirmRemoveRune(int InEquipmentSid, int InIndex, int InGold, int InLumena);
	void OpenDialog_ConfirmEquipRune(int InEquipmentSid, int InIndex, int InSid);
	void AU_RequestUnEquipAllRune();
	void AU_RequestUnEquipRune(int InIndex);
	void AU_RequestEquipRune(int InRuneSid, int InIndex);
	void AU_RequestEquipEquipment(int InItemSid);
	void UA_UpdateEquipmentSlotUI();
	void UA_UpdateRuneSlotUI();
	void CS_CloseEquipUI();
	void CS_UnEquipRune(int InItemSid, int InIndex);
	void CS_EquipRune(int InItemSid, int InIndex, int InRuneSid);
	void CS_RegistEquipment(int InItemSid);
	void SC_UnEquipRune_Ack(TEnumAsByte<ERuneSystemErrorCode> InErrorCode);
	void SC_EquipRune_Ack(TEnumAsByte<ERuneSystemErrorCode> InErrorCode);
	void GetUnEquipCost(TArray<int> InRuneCidList, int* OutGold, int* OutLumena);
	void GetSlotDataList(int InItemCid, class UBLItem* InItemInst, TArray<struct FRuneSlotData>* OutSlotList);
	int GetRuneCount(int InItemCid);
	void SetRuneSlotInfo(int InEquipmentCid, int InIndex, int InRuneItemCid, TArray<struct FRuneSlotData>* OutSlotList);
	int FindEquipableRunSlot(TEnumAsByte<ECERuneCategoryType> InType);
	TEnumAsByte<ECERuneCategoryType> GetCategoryType(int InItemCid, int InIndex);
	void UpdateRuneSlot();
	void RegistEquipment(int InEquipmentSid);
	void OnUpdateItemLock(int InItemSid, bool bLock);
	void OnUpdateItem(int InItemSid);
	void AU_ChangedTab(int Type);
	void UA_LockInventoryItem(int InSid, bool bLock);
	void PlayRuneSound(TEnumAsByte<ERuneSoundType> InSoundType);
	void OnClosedUI();
	void OnOpenedUI();
	void OnInitializedUI();
	void Init();
};


// Class BLGame.V2RuneManager
// 0x0040 (0x00A0 - 0x0060)
class UV2RuneManager : public UObject
{
public:
	unsigned long                                      bOpenedUI : 1;                                            // 0x0060(0x0004)
	struct FRuneEquipUIData                            EquipUIData;                                              // 0x0064(0x0018) (NeedCtorLink)
	struct FRuneCarveUIData                            CarveUIData;                                              // 0x007C(0x0014) (NeedCtorLink)
	TArray<TEnumAsByte<EItemAdditionalEffectIndexType>> IndexToESocketIndexType;                                  // 0x0090(0x0010) (Const, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.V2RuneManager");
		return ptr;
	}


	void OpenDialog_ConfirmEquipRune(int InRuneCid, int InEquipmentCid, int InEquipmentSid, int InIndex, int InSid, bool InCaution);
	void AU_OnClickCarveRuneButton(int InRuneSid);
	void AU_OnClickSocketButton(int InIndex);
	void AU_RequestEquipEquipment(int InItemSid);
	void UA_ShowCarveList(bool IsShow);
	void UA_UpdateRuneCarveUI();
	void UA_UpdateEquipmentSlotUI();
	void UA_UpdateRuneSlotUI();
	void CS_CloseEquipUI();
	void CS_EquipRune(int InItemSid, int InIndex, int InRuneSid);
	void CS_RegistEquipment(int InItemSid);
	void SC_EquipRune_Ack(TEnumAsByte<ERuneSystemErrorCode> InErrorCode);
	void GetCarveList(TEnumAsByte<ECERuneType> InRuneType, TArray<int>* OutRuneCidList);
	void GetSlotDataList(int InItemCid, class UBLItem* InItemInst, TArray<struct FRuneSlotData>* OutSlotList);
	int FindEquipableRunSlot(TEnumAsByte<ECERuneCategoryType> InType);
	void UpdateRuneCarveList();
	void UpdateRuneSlot();
	void RegistEquipment(int InEquipmentSid);
	void OnUpdateItemLock(int InItemSid, bool bLock);
	void OnUpdateItem(int InItemSid);
	void UA_LockInventoryItem(int InSid, bool bLock);
	void PlayRuneSound(TEnumAsByte<ERuneSoundType> InSoundType);
	void OnClosedUI();
	void OnOpenedUI();
	void OnInitializedUI();
	void Init();
};


// Class BLGame.ABLCTypeEnum
// 0x0000 (0x0060 - 0x0060)
class UABLCTypeEnum : public UObject
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.ABLCTypeEnum");
		return ptr;
	}


	TEnumAsByte<ECEGaugeUseType> STATIC_GetEGaugeUseTypeByValue(int s_Value);
	int STATIC_GetValueByEGaugeUseType(TEnumAsByte<ECEGaugeUseType> c_Type);
	TEnumAsByte<ECECreditStringType> STATIC_GetECreditStringTypeByValue(int s_Value);
	int STATIC_GetValueByECreditStringType(TEnumAsByte<ECECreditStringType> c_Type);
	TEnumAsByte<ECECombatSkillType> STATIC_GetECombatSkillTypeByValue(int s_Value);
	int STATIC_GetValueByECombatSkillType(TEnumAsByte<ECECombatSkillType> c_Type);
	TEnumAsByte<ECEGemType> STATIC_GetEGemTypeByValue(int s_Value);
	int STATIC_GetValueByEGemType(TEnumAsByte<ECEGemType> c_Type);
	TEnumAsByte<ECEQTEKeyType> STATIC_GetEQTEKeyTypeByValue(int s_Value);
	int STATIC_GetValueByEQTEKeyType(TEnumAsByte<ECEQTEKeyType> c_Type);
	TEnumAsByte<ECEStanceQTEType> STATIC_GetEStanceQTETypeByValue(int s_Value);
	int STATIC_GetValueByEStanceQTEType(TEnumAsByte<ECEStanceQTEType> c_Type);
	TEnumAsByte<ECEStanceSkillType> STATIC_GetEStanceSkillTypeByValue(int s_Value);
	int STATIC_GetValueByEStanceSkillType(TEnumAsByte<ECEStanceSkillType> c_Type);
	TEnumAsByte<ECEGradeType> STATIC_GetEGradeTypeByValue(int s_Value);
	int STATIC_GetValueByEGradeType(TEnumAsByte<ECEGradeType> c_Type);
	TEnumAsByte<ECEBattleFieldWarType> STATIC_GetEBattleFieldWarTypeByValue(int s_Value);
	int STATIC_GetValueByEBattleFieldWarType(TEnumAsByte<ECEBattleFieldWarType> c_Type);
	TEnumAsByte<ECEOccupationWarType> STATIC_GetEOccupationWarTypeByValue(int s_Value);
	int STATIC_GetValueByEOccupationWarType(TEnumAsByte<ECEOccupationWarType> c_Type);
	TEnumAsByte<ECEReturnLocationType> STATIC_GetEReturnLocationTypeByValue(int s_Value);
	int STATIC_GetValueByEReturnLocationType(TEnumAsByte<ECEReturnLocationType> c_Type);
	TEnumAsByte<ECEAppearanceType> STATIC_GetEAppearanceTypeByValue(int s_Value);
	int STATIC_GetValueByEAppearanceType(TEnumAsByte<ECEAppearanceType> c_Type);
	TEnumAsByte<ECESpeicalWarVictoryType> STATIC_GetESpeicalWarVictoryTypeByValue(int s_Value);
	int STATIC_GetValueByESpeicalWarVictoryType(TEnumAsByte<ECESpeicalWarVictoryType> c_Type);
	TEnumAsByte<ECETamingMiniGameParamType> STATIC_GetETamingMiniGameParamTypeByValue(int s_Value);
	int STATIC_GetValueByETamingMiniGameParamType(TEnumAsByte<ECETamingMiniGameParamType> c_Type);
	TEnumAsByte<ECENPCTamingType> STATIC_GetENPCTamingTypeByValue(int s_Value);
	int STATIC_GetValueByENPCTamingType(TEnumAsByte<ECENPCTamingType> c_Type);
	TEnumAsByte<ECETamingBarMoveType> STATIC_GetETamingBarMoveTypeByValue(int s_Value);
	int STATIC_GetValueByETamingBarMoveType(TEnumAsByte<ECETamingBarMoveType> c_Type);
	TEnumAsByte<ECEV2CraftBroadwayType> STATIC_GetEV2CraftBroadwayTypeByValue(int s_Value);
	int STATIC_GetValueByEV2CraftBroadwayType(TEnumAsByte<ECEV2CraftBroadwayType> c_Type);
	TEnumAsByte<ECEV2CraftCategoryType> STATIC_GetEV2CraftCategoryTypeByValue(int s_Value);
	int STATIC_GetValueByEV2CraftCategoryType(TEnumAsByte<ECEV2CraftCategoryType> c_Type);
	TEnumAsByte<ECEZonePVPIconType> STATIC_GetEZonePVPIconTypeByValue(int s_Value);
	int STATIC_GetValueByEZonePVPIconType(TEnumAsByte<ECEZonePVPIconType> c_Type);
	TEnumAsByte<ECEMPFActionType> STATIC_GetEMPFActionTypeByValue(int s_Value);
	int STATIC_GetValueByEMPFActionType(TEnumAsByte<ECEMPFActionType> c_Type);
	TEnumAsByte<ECEOpenExchangeUIType> STATIC_GetEOpenExchangeUITypeByValue(int s_Value);
	int STATIC_GetValueByEOpenExchangeUIType(TEnumAsByte<ECEOpenExchangeUIType> c_Type);
	TEnumAsByte<ECEInstantRevivalPointType> STATIC_GetEInstantRevivalPointTypeByValue(int s_Value);
	int STATIC_GetValueByEInstantRevivalPointType(TEnumAsByte<ECEInstantRevivalPointType> c_Type);
	TEnumAsByte<ECEOrderPeriodType> STATIC_GetEOrderPeriodTypeByValue(int s_Value);
	int STATIC_GetValueByEOrderPeriodType(TEnumAsByte<ECEOrderPeriodType> c_Type);
	TEnumAsByte<ECEOrderGroupType> STATIC_GetEOrderGroupTypeByValue(int s_Value);
	int STATIC_GetValueByEOrderGroupType(TEnumAsByte<ECEOrderGroupType> c_Type);
	TEnumAsByte<ECEAbnormalStatusIconRaidShowType> STATIC_GetEAbnormalStatusIconRaidShowTypeByValue(int s_Value);
	int STATIC_GetValueByEAbnormalStatusIconRaidShowType(TEnumAsByte<ECEAbnormalStatusIconRaidShowType> c_Type);
	TEnumAsByte<ECERecipeCodeInfoType> STATIC_GetERecipeCodeInfoTypeByValue(int s_Value);
	int STATIC_GetValueByERecipeCodeInfoType(TEnumAsByte<ECERecipeCodeInfoType> c_Type);
	TEnumAsByte<ECETabletMaterialCategoryType> STATIC_GetETabletMaterialCategoryTypeByValue(int s_Value);
	int STATIC_GetValueByETabletMaterialCategoryType(TEnumAsByte<ECETabletMaterialCategoryType> c_Type);
	TEnumAsByte<ECERuneType> STATIC_GetERuneTypeByValue(int s_Value);
	int STATIC_GetValueByERuneType(TEnumAsByte<ECERuneType> c_Type);
	TEnumAsByte<ECERuneCategoryType> STATIC_GetERuneCategoryTypeByValue(int s_Value);
	int STATIC_GetValueByERuneCategoryType(TEnumAsByte<ECERuneCategoryType> c_Type);
	TEnumAsByte<ECENpcMeshType> STATIC_GetENpcMeshTypeByValue(int s_Value);
	int STATIC_GetValueByENpcMeshType(TEnumAsByte<ECENpcMeshType> c_Type);
	TEnumAsByte<ECEResetTimeType> STATIC_GetEResetTimeTypeByValue(int s_Value);
	int STATIC_GetValueByEResetTimeType(TEnumAsByte<ECEResetTimeType> c_Type);
	TEnumAsByte<ECEQuestAdditionalMapInfoAreaType> STATIC_GetEQuestAdditionalMapInfoAreaTypeByValue(int s_Value);
	int STATIC_GetValueByEQuestAdditionalMapInfoAreaType(TEnumAsByte<ECEQuestAdditionalMapInfoAreaType> c_Type);
	TEnumAsByte<ECECustomizingDragSignType> STATIC_GetECustomizingDragSignTypeByValue(int s_Value);
	int STATIC_GetValueByECustomizingDragSignType(TEnumAsByte<ECECustomizingDragSignType> c_Type);
	TEnumAsByte<ECECustomizingViewType> STATIC_GetECustomizingViewTypeByValue(int s_Value);
	int STATIC_GetValueByECustomizingViewType(TEnumAsByte<ECECustomizingViewType> c_Type);
	TEnumAsByte<ECECustomizingAreaType> STATIC_GetECustomizingAreaTypeByValue(int s_Value);
	int STATIC_GetValueByECustomizingAreaType(TEnumAsByte<ECECustomizingAreaType> c_Type);
	TEnumAsByte<ECECustomizingUIModeType> STATIC_GetECustomizingUIModeTypeByValue(int s_Value);
	int STATIC_GetValueByECustomizingUIModeType(TEnumAsByte<ECECustomizingUIModeType> c_Type);
	TEnumAsByte<ECECustomizingZoomModeType> STATIC_GetECustomizingZoomModeTypeByValue(int s_Value);
	int STATIC_GetValueByECustomizingZoomModeType(TEnumAsByte<ECECustomizingZoomModeType> c_Type);
	TEnumAsByte<ECECustomizeType> STATIC_GetECustomizeTypeByValue(int s_Value);
	int STATIC_GetValueByECustomizeType(TEnumAsByte<ECECustomizeType> c_Type);
	TEnumAsByte<ECEItemPeriodType> STATIC_GetEItemPeriodTypeByValue(int s_Value);
	int STATIC_GetValueByEItemPeriodType(TEnumAsByte<ECEItemPeriodType> c_Type);
	TEnumAsByte<ECEGatherCategoryType> STATIC_GetEGatherCategoryTypeByValue(int s_Value);
	int STATIC_GetValueByEGatherCategoryType(TEnumAsByte<ECEGatherCategoryType> c_Type);
	TEnumAsByte<ECECraftCategory3Type> STATIC_GetECraftCategory3TypeByValue(int s_Value);
	int STATIC_GetValueByECraftCategory3Type(TEnumAsByte<ECECraftCategory3Type> c_Type);
	TEnumAsByte<ECECraftCategory2Type> STATIC_GetECraftCategory2TypeByValue(int s_Value);
	int STATIC_GetValueByECraftCategory2Type(TEnumAsByte<ECECraftCategory2Type> c_Type);
	TEnumAsByte<ECECraftCategory1Type> STATIC_GetECraftCategory1TypeByValue(int s_Value);
	int STATIC_GetValueByECraftCategory1Type(TEnumAsByte<ECECraftCategory1Type> c_Type);
	TEnumAsByte<ECECraftCategoryType> STATIC_GetECraftCategoryTypeByValue(int s_Value);
	int STATIC_GetValueByECraftCategoryType(TEnumAsByte<ECECraftCategoryType> c_Type);
	TEnumAsByte<ECEV2MissionType> STATIC_GetEV2MissionTypeByValue(int s_Value);
	int STATIC_GetValueByEV2MissionType(TEnumAsByte<ECEV2MissionType> c_Type);
	TEnumAsByte<ECEMissionType> STATIC_GetEMissionTypeByValue(int s_Value);
	int STATIC_GetValueByEMissionType(TEnumAsByte<ECEMissionType> c_Type);
	TEnumAsByte<ECEFellowVocationType> STATIC_GetEFellowVocationTypeByValue(int s_Value);
	int STATIC_GetValueByEFellowVocationType(TEnumAsByte<ECEFellowVocationType> c_Type);
	TEnumAsByte<ECEFellowRaceType> STATIC_GetEFellowRaceTypeByValue(int s_Value);
	int STATIC_GetValueByEFellowRaceType(TEnumAsByte<ECEFellowRaceType> c_Type);
	TEnumAsByte<ECECompanionGradeType> STATIC_GetECompanionGradeTypeByValue(int s_Value);
	int STATIC_GetValueByECompanionGradeType(TEnumAsByte<ECECompanionGradeType> c_Type);
	TEnumAsByte<ECECompanionType> STATIC_GetECompanionTypeByValue(int s_Value);
	int STATIC_GetValueByECompanionType(TEnumAsByte<ECECompanionType> c_Type);
	TEnumAsByte<ECETargetStateWidgetType> STATIC_GetETargetStateWidgetTypeByValue(int s_Value);
	int STATIC_GetValueByETargetStateWidgetType(TEnumAsByte<ECETargetStateWidgetType> c_Type);
	TEnumAsByte<ECESpecialWarRankType> STATIC_GetESpecialWarRankTypeByValue(int s_Value);
	int STATIC_GetValueByESpecialWarRankType(TEnumAsByte<ECESpecialWarRankType> c_Type);
	TEnumAsByte<ECESpecialWarRankActorGroupType> STATIC_GetESpecialWarRankActorGroupTypeByValue(int s_Value);
	int STATIC_GetValueByESpecialWarRankActorGroupType(TEnumAsByte<ECESpecialWarRankActorGroupType> c_Type);
	TEnumAsByte<ECESpecialWarEndMethodType> STATIC_GetESpecialWarEndMethodTypeByValue(int s_Value);
	int STATIC_GetValueByESpecialWarEndMethodType(TEnumAsByte<ECESpecialWarEndMethodType> c_Type);
	TEnumAsByte<ECESpecialWarResetConditionType> STATIC_GetESpecialWarResetConditionTypeByValue(int s_Value);
	int STATIC_GetValueByESpecialWarResetConditionType(TEnumAsByte<ECESpecialWarResetConditionType> c_Type);
	TEnumAsByte<ECESpecialWarCheckHPType> STATIC_GetESpecialWarCheckHPTypeByValue(int s_Value);
	int STATIC_GetValueByESpecialWarCheckHPType(TEnumAsByte<ECESpecialWarCheckHPType> c_Type);
	TEnumAsByte<ECEAbnormalStatusAttachType> STATIC_GetEAbnormalStatusAttachTypeByValue(int s_Value);
	int STATIC_GetValueByEAbnormalStatusAttachType(TEnumAsByte<ECEAbnormalStatusAttachType> c_Type);
	TEnumAsByte<ECEAbnormalStatusMovementType> STATIC_GetEAbnormalStatusMovementTypeByValue(int s_Value);
	int STATIC_GetValueByEAbnormalStatusMovementType(TEnumAsByte<ECEAbnormalStatusMovementType> c_Type);
	TEnumAsByte<ECETargetingMoveType> STATIC_GetETargetingMoveTypeByValue(int s_Value);
	int STATIC_GetValueByETargetingMoveType(TEnumAsByte<ECETargetingMoveType> c_Type);
	TEnumAsByte<ECETargetingControlType> STATIC_GetETargetingControlTypeByValue(int s_Value);
	int STATIC_GetValueByETargetingControlType(TEnumAsByte<ECETargetingControlType> c_Type);
	TEnumAsByte<ECEPVPType> STATIC_GetEPVPTypeByValue(int s_Value);
	int STATIC_GetValueByEPVPType(TEnumAsByte<ECEPVPType> c_Type);
	TEnumAsByte<ECEIconShowType> STATIC_GetEIconShowTypeByValue(int s_Value);
	int STATIC_GetValueByEIconShowType(TEnumAsByte<ECEIconShowType> c_Type);
	TEnumAsByte<ECEContentTokenType> STATIC_GetEContentTokenTypeByValue(int s_Value);
	int STATIC_GetValueByEContentTokenType(TEnumAsByte<ECEContentTokenType> c_Type);
	TEnumAsByte<ECESystemMessagePendingType> STATIC_GetESystemMessagePendingTypeByValue(int s_Value);
	int STATIC_GetValueByESystemMessagePendingType(TEnumAsByte<ECESystemMessagePendingType> c_Type);
	TEnumAsByte<ECETrapType> STATIC_GetETrapTypeByValue(int s_Value);
	int STATIC_GetValueByETrapType(TEnumAsByte<ECETrapType> c_Type);
	TEnumAsByte<ECEGuildMarkRealmType> STATIC_GetEGuildMarkRealmTypeByValue(int s_Value);
	int STATIC_GetValueByEGuildMarkRealmType(TEnumAsByte<ECEGuildMarkRealmType> c_Type);
	TEnumAsByte<ECEGuildAuthorityType> STATIC_GetEGuildAuthorityTypeByValue(int s_Value);
	int STATIC_GetValueByEGuildAuthorityType(TEnumAsByte<ECEGuildAuthorityType> c_Type);
	TEnumAsByte<ECEGuildGradeType> STATIC_GetEGuildGradeTypeByValue(int s_Value);
	int STATIC_GetValueByEGuildGradeType(TEnumAsByte<ECEGuildGradeType> c_Type);
	TEnumAsByte<ECEMountActiveSkillInterfaceType> STATIC_GetEMountActiveSkillInterfaceTypeByValue(int s_Value);
	int STATIC_GetValueByEMountActiveSkillInterfaceType(TEnumAsByte<ECEMountActiveSkillInterfaceType> c_Type);
	TEnumAsByte<ECEItemAuctionCategoryThirdType> STATIC_GetEItemAuctionCategoryThirdTypeByValue(int s_Value);
	int STATIC_GetValueByEItemAuctionCategoryThirdType(TEnumAsByte<ECEItemAuctionCategoryThirdType> c_Type);
	TEnumAsByte<ECEItemAuctionCategorySecondType> STATIC_GetEItemAuctionCategorySecondTypeByValue(int s_Value);
	int STATIC_GetValueByEItemAuctionCategorySecondType(TEnumAsByte<ECEItemAuctionCategorySecondType> c_Type);
	TEnumAsByte<ECEItemAuctionCategoryFirstType> STATIC_GetEItemAuctionCategoryFirstTypeByValue(int s_Value);
	int STATIC_GetValueByEItemAuctionCategoryFirstType(TEnumAsByte<ECEItemAuctionCategoryFirstType> c_Type);
	TEnumAsByte<ECEOpenUIType> STATIC_GetEOpenUITypeByValue(int s_Value);
	int STATIC_GetValueByEOpenUIType(TEnumAsByte<ECEOpenUIType> c_Type);
	TEnumAsByte<ECEQuestPathType> STATIC_GetEQuestPathTypeByValue(int s_Value);
	int STATIC_GetValueByEQuestPathType(TEnumAsByte<ECEQuestPathType> c_Type);
	TEnumAsByte<ECEQuestNaviType> STATIC_GetEQuestNaviTypeByValue(int s_Value);
	int STATIC_GetValueByEQuestNaviType(TEnumAsByte<ECEQuestNaviType> c_Type);
	TEnumAsByte<ECEDoorInteractType> STATIC_GetEDoorInteractTypeByValue(int s_Value);
	int STATIC_GetValueByEDoorInteractType(TEnumAsByte<ECEDoorInteractType> c_Type);
	TEnumAsByte<ECEItemCategoryType> STATIC_GetEItemCategoryTypeByValue(int s_Value);
	int STATIC_GetValueByEItemCategoryType(TEnumAsByte<ECEItemCategoryType> c_Type);
	TEnumAsByte<ECEInventoryType> STATIC_GetEInventoryTypeByValue(int s_Value);
	int STATIC_GetValueByEInventoryType(TEnumAsByte<ECEInventoryType> c_Type);
	TEnumAsByte<ECENPCGradeType> STATIC_GetENPCGradeTypeByValue(int s_Value);
	int STATIC_GetValueByENPCGradeType(TEnumAsByte<ECENPCGradeType> c_Type);
	TEnumAsByte<ECEAlrimiType> STATIC_GetEAlrimiTypeByValue(int s_Value);
	int STATIC_GetValueByEAlrimiType(TEnumAsByte<ECEAlrimiType> c_Type);
	TEnumAsByte<ECEForcedTargetType> STATIC_GetEForcedTargetTypeByValue(int s_Value);
	int STATIC_GetValueByEForcedTargetType(TEnumAsByte<ECEForcedTargetType> c_Type);
	TEnumAsByte<ECEGameDayTimeType> STATIC_GetEGameDayTimeTypeByValue(int s_Value);
	int STATIC_GetValueByEGameDayTimeType(TEnumAsByte<ECEGameDayTimeType> c_Type);
	TEnumAsByte<ECEDayTimeType> STATIC_GetEDayTimeTypeByValue(int s_Value);
	int STATIC_GetValueByEDayTimeType(TEnumAsByte<ECEDayTimeType> c_Type);
	TEnumAsByte<ECESkillParamModifyType> STATIC_GetESkillParamModifyTypeByValue(int s_Value);
	int STATIC_GetValueByESkillParamModifyType(TEnumAsByte<ECESkillParamModifyType> c_Type);
	TEnumAsByte<ECEAddRemoveType> STATIC_GetEAddRemoveTypeByValue(int s_Value);
	int STATIC_GetValueByEAddRemoveType(TEnumAsByte<ECEAddRemoveType> c_Type);
	TEnumAsByte<ECESkillPhaseType> STATIC_GetESkillPhaseTypeByValue(int s_Value);
	int STATIC_GetValueByESkillPhaseType(TEnumAsByte<ECESkillPhaseType> c_Type);
	TEnumAsByte<ECECombatFlairStartType> STATIC_GetECombatFlairStartTypeByValue(int s_Value);
	int STATIC_GetValueByECombatFlairStartType(TEnumAsByte<ECECombatFlairStartType> c_Type);
	TEnumAsByte<ECELumenaShopItemLimitType> STATIC_GetELumenaShopItemLimitTypeByValue(int s_Value);
	int STATIC_GetValueByELumenaShopItemLimitType(TEnumAsByte<ECELumenaShopItemLimitType> c_Type);
	TEnumAsByte<ECEShopTradeType> STATIC_GetEShopTradeTypeByValue(int s_Value);
	int STATIC_GetValueByEShopTradeType(TEnumAsByte<ECEShopTradeType> c_Type);
	TEnumAsByte<ECETrapPhaseType> STATIC_GetETrapPhaseTypeByValue(int s_Value);
	int STATIC_GetValueByETrapPhaseType(TEnumAsByte<ECETrapPhaseType> c_Type);
	TEnumAsByte<ECEMonologSetInfoType> STATIC_GetEMonologSetInfoTypeByValue(int s_Value);
	int STATIC_GetValueByEMonologSetInfoType(TEnumAsByte<ECEMonologSetInfoType> c_Type);
	TEnumAsByte<ECETeleportType> STATIC_GetETeleportTypeByValue(int s_Value);
	int STATIC_GetValueByETeleportType(TEnumAsByte<ECETeleportType> c_Type);
	TEnumAsByte<ECEDoorStateType> STATIC_GetEDoorStateTypeByValue(int s_Value);
	int STATIC_GetValueByEDoorStateType(TEnumAsByte<ECEDoorStateType> c_Type);
	TEnumAsByte<ECETransportType> STATIC_GetETransportTypeByValue(int s_Value);
	int STATIC_GetValueByETransportType(TEnumAsByte<ECETransportType> c_Type);
	TEnumAsByte<ECEWaypointType> STATIC_GetEWaypointTypeByValue(int s_Value);
	int STATIC_GetValueByEWaypointType(TEnumAsByte<ECEWaypointType> c_Type);
	TEnumAsByte<ECEV2FellowParamType> STATIC_GetEV2FellowParamTypeByValue(int s_Value);
	int STATIC_GetValueByEV2FellowParamType(TEnumAsByte<ECEV2FellowParamType> c_Type);
	TEnumAsByte<ECEV2PetParamType> STATIC_GetEV2PetParamTypeByValue(int s_Value);
	int STATIC_GetValueByEV2PetParamType(TEnumAsByte<ECEV2PetParamType> c_Type);
	TEnumAsByte<ECEMountParamType> STATIC_GetEMountParamTypeByValue(int s_Value);
	int STATIC_GetValueByEMountParamType(TEnumAsByte<ECEMountParamType> c_Type);
	TEnumAsByte<ECEMountLegMethodType> STATIC_GetEMountLegMethodTypeByValue(int s_Value);
	int STATIC_GetValueByEMountLegMethodType(TEnumAsByte<ECEMountLegMethodType> c_Type);
	TEnumAsByte<ECEMountArmMethodType> STATIC_GetEMountArmMethodTypeByValue(int s_Value);
	int STATIC_GetValueByEMountArmMethodType(TEnumAsByte<ECEMountArmMethodType> c_Type);
	TEnumAsByte<ECEMountSpineMethodType> STATIC_GetEMountSpineMethodTypeByValue(int s_Value);
	int STATIC_GetValueByEMountSpineMethodType(TEnumAsByte<ECEMountSpineMethodType> c_Type);
	TEnumAsByte<ECEMountSkinType> STATIC_GetEMountSkinTypeByValue(int s_Value);
	int STATIC_GetValueByEMountSkinType(TEnumAsByte<ECEMountSkinType> c_Type);
	TEnumAsByte<ECEMountSpeedType> STATIC_GetEMountSpeedTypeByValue(int s_Value);
	int STATIC_GetValueByEMountSpeedType(TEnumAsByte<ECEMountSpeedType> c_Type);
	TEnumAsByte<ECEMountMaxStaminaType> STATIC_GetEMountMaxStaminaTypeByValue(int s_Value);
	int STATIC_GetValueByEMountMaxStaminaType(TEnumAsByte<ECEMountMaxStaminaType> c_Type);
	TEnumAsByte<ECEMountStaminaRegenType> STATIC_GetEMountStaminaRegenTypeByValue(int s_Value);
	int STATIC_GetValueByEMountStaminaRegenType(TEnumAsByte<ECEMountStaminaRegenType> c_Type);
	TEnumAsByte<ECEMountType> STATIC_GetEMountTypeByValue(int s_Value);
	int STATIC_GetValueByEMountType(TEnumAsByte<ECEMountType> c_Type);
	TEnumAsByte<ECEDialogCategoryType> STATIC_GetEDialogCategoryTypeByValue(int s_Value);
	int STATIC_GetValueByEDialogCategoryType(TEnumAsByte<ECEDialogCategoryType> c_Type);
	TEnumAsByte<ECEDialogShowQuestInfoType> STATIC_GetEDialogShowQuestInfoTypeByValue(int s_Value);
	int STATIC_GetValueByEDialogShowQuestInfoType(TEnumAsByte<ECEDialogShowQuestInfoType> c_Type);
	TEnumAsByte<ECELocationLevelType> STATIC_GetELocationLevelTypeByValue(int s_Value);
	int STATIC_GetValueByELocationLevelType(TEnumAsByte<ECELocationLevelType> c_Type);
	TEnumAsByte<ECEConditionPhaseType> STATIC_GetEConditionPhaseTypeByValue(int s_Value);
	int STATIC_GetValueByEConditionPhaseType(TEnumAsByte<ECEConditionPhaseType> c_Type);
	TEnumAsByte<ECETargetObjectType> STATIC_GetETargetObjectTypeByValue(int s_Value);
	int STATIC_GetValueByETargetObjectType(TEnumAsByte<ECETargetObjectType> c_Type);
	TEnumAsByte<ECEImmuneType> STATIC_GetEImmuneTypeByValue(int s_Value);
	int STATIC_GetValueByEImmuneType(TEnumAsByte<ECEImmuneType> c_Type);
	TEnumAsByte<ECECrowdControlType> STATIC_GetECrowdControlTypeByValue(int s_Value);
	int STATIC_GetValueByECrowdControlType(TEnumAsByte<ECECrowdControlType> c_Type);
	TEnumAsByte<ECECrowdControlComponentType> STATIC_GetECrowdControlComponentTypeByValue(int s_Value);
	int STATIC_GetValueByECrowdControlComponentType(TEnumAsByte<ECECrowdControlComponentType> c_Type);
	TEnumAsByte<ECEPCNormalAttackAnimSequenceType> STATIC_GetEPCNormalAttackAnimSequenceTypeByValue(int s_Value);
	int STATIC_GetValueByEPCNormalAttackAnimSequenceType(TEnumAsByte<ECEPCNormalAttackAnimSequenceType> c_Type);
	TEnumAsByte<ECENormalAttackEquipType> STATIC_GetENormalAttackEquipTypeByValue(int s_Value);
	int STATIC_GetValueByENormalAttackEquipType(TEnumAsByte<ECENormalAttackEquipType> c_Type);
	TEnumAsByte<ECESpawnPosType> STATIC_GetESpawnPosTypeByValue(int s_Value);
	int STATIC_GetValueByESpawnPosType(TEnumAsByte<ECESpawnPosType> c_Type);
	TEnumAsByte<ECENPCHideCategory> STATIC_GetENPCHideCategoryByValue(int s_Value);
	int STATIC_GetValueByENPCHideCategory(TEnumAsByte<ECENPCHideCategory> c_Type);
	TEnumAsByte<ECENPCPartyDespawnType> STATIC_GetENPCPartyDespawnTypeByValue(int s_Value);
	int STATIC_GetValueByENPCPartyDespawnType(TEnumAsByte<ECENPCPartyDespawnType> c_Type);
	TEnumAsByte<ECENPCPartySpawnType> STATIC_GetENPCPartySpawnTypeByValue(int s_Value);
	int STATIC_GetValueByENPCPartySpawnType(TEnumAsByte<ECENPCPartySpawnType> c_Type);
	TEnumAsByte<ECENPCPartyStatusType> STATIC_GetENPCPartyStatusTypeByValue(int s_Value);
	int STATIC_GetValueByENPCPartyStatusType(TEnumAsByte<ECENPCPartyStatusType> c_Type);
	TEnumAsByte<ECEAbnormalStackType> STATIC_GetEAbnormalStackTypeByValue(int s_Value);
	int STATIC_GetValueByEAbnormalStackType(TEnumAsByte<ECEAbnormalStackType> c_Type);
	TEnumAsByte<ECEInvokeAliveConditionType> STATIC_GetEInvokeAliveConditionTypeByValue(int s_Value);
	int STATIC_GetValueByEInvokeAliveConditionType(TEnumAsByte<ECEInvokeAliveConditionType> c_Type);
	TEnumAsByte<ECEQuestConditionType> STATIC_GetEQuestConditionTypeByValue(int s_Value);
	int STATIC_GetValueByEQuestConditionType(TEnumAsByte<ECEQuestConditionType> c_Type);
	TEnumAsByte<ECEDungeonRequiredPartyType> STATIC_GetEDungeonRequiredPartyTypeByValue(int s_Value);
	int STATIC_GetValueByEDungeonRequiredPartyType(TEnumAsByte<ECEDungeonRequiredPartyType> c_Type);
	TEnumAsByte<ECEDungeonEnterMethodType> STATIC_GetEDungeonEnterMethodTypeByValue(int s_Value);
	int STATIC_GetValueByEDungeonEnterMethodType(TEnumAsByte<ECEDungeonEnterMethodType> c_Type);
	TEnumAsByte<ECEDungeonStageExpireType> STATIC_GetEDungeonStageExpireTypeByValue(int s_Value);
	int STATIC_GetValueByEDungeonStageExpireType(TEnumAsByte<ECEDungeonStageExpireType> c_Type);
	TEnumAsByte<ECEHitAffectAreaShapeType> STATIC_GetEHitAffectAreaShapeTypeByValue(int s_Value);
	int STATIC_GetValueByEHitAffectAreaShapeType(TEnumAsByte<ECEHitAffectAreaShapeType> c_Type);
	TEnumAsByte<ECESkillInvokeStateType> STATIC_GetESkillInvokeStateTypeByValue(int s_Value);
	int STATIC_GetValueByESkillInvokeStateType(TEnumAsByte<ECESkillInvokeStateType> c_Type);
	TEnumAsByte<ECEQuestAcquireConditionType> STATIC_GetEQuestAcquireConditionTypeByValue(int s_Value);
	int STATIC_GetValueByEQuestAcquireConditionType(TEnumAsByte<ECEQuestAcquireConditionType> c_Type);
	TEnumAsByte<ECEQuestRewardGiverType> STATIC_GetEQuestRewardGiverTypeByValue(int s_Value);
	int STATIC_GetValueByEQuestRewardGiverType(TEnumAsByte<ECEQuestRewardGiverType> c_Type);
	TEnumAsByte<ECEQuestGiverType> STATIC_GetEQuestGiverTypeByValue(int s_Value);
	int STATIC_GetValueByEQuestGiverType(TEnumAsByte<ECEQuestGiverType> c_Type);
	TEnumAsByte<ECEQuestType> STATIC_GetEQuestTypeByValue(int s_Value);
	int STATIC_GetValueByEQuestType(TEnumAsByte<ECEQuestType> c_Type);
	TEnumAsByte<ECEQuestOnEventType> STATIC_GetEQuestOnEventTypeByValue(int s_Value);
	int STATIC_GetValueByEQuestOnEventType(TEnumAsByte<ECEQuestOnEventType> c_Type);
	TEnumAsByte<ECEQuestRewardType> STATIC_GetEQuestRewardTypeByValue(int s_Value);
	int STATIC_GetValueByEQuestRewardType(TEnumAsByte<ECEQuestRewardType> c_Type);
	TEnumAsByte<ECEQuestCategory> STATIC_GetEQuestCategoryByValue(int s_Value);
	int STATIC_GetValueByEQuestCategory(TEnumAsByte<ECEQuestCategory> c_Type);
	TEnumAsByte<ECESystemMessageChatChannelType> STATIC_GetESystemMessageChatChannelTypeByValue(int s_Value);
	int STATIC_GetValueByESystemMessageChatChannelType(TEnumAsByte<ECESystemMessageChatChannelType> c_Type);
	TEnumAsByte<ECESystemMessageOverlayType> STATIC_GetESystemMessageOverlayTypeByValue(int s_Value);
	int STATIC_GetValueByESystemMessageOverlayType(TEnumAsByte<ECESystemMessageOverlayType> c_Type);
	TEnumAsByte<ECESystemMessageDisplayType> STATIC_GetESystemMessageDisplayTypeByValue(int s_Value);
	int STATIC_GetValueByESystemMessageDisplayType(TEnumAsByte<ECESystemMessageDisplayType> c_Type);
	TEnumAsByte<ECEStatePoseType> STATIC_GetEStatePoseTypeByValue(int s_Value);
	int STATIC_GetValueByEStatePoseType(TEnumAsByte<ECEStatePoseType> c_Type);
	TEnumAsByte<ECEStateSituationType> STATIC_GetEStateSituationTypeByValue(int s_Value);
	int STATIC_GetValueByEStateSituationType(TEnumAsByte<ECEStateSituationType> c_Type);
	TEnumAsByte<ECEQuestShareType> STATIC_GetEQuestShareTypeByValue(int s_Value);
	int STATIC_GetValueByEQuestShareType(TEnumAsByte<ECEQuestShareType> c_Type);
	TEnumAsByte<ECEFieldInOutType> STATIC_GetEFieldInOutTypeByValue(int s_Value);
	int STATIC_GetValueByEFieldInOutType(TEnumAsByte<ECEFieldInOutType> c_Type);
	TEnumAsByte<ECEDungeonEnterConditionType> STATIC_GetEDungeonEnterConditionTypeByValue(int s_Value);
	int STATIC_GetValueByEDungeonEnterConditionType(TEnumAsByte<ECEDungeonEnterConditionType> c_Type);
	TEnumAsByte<ECEWorldMapType> STATIC_GetEWorldMapTypeByValue(int s_Value);
	int STATIC_GetValueByEWorldMapType(TEnumAsByte<ECEWorldMapType> c_Type);
	TEnumAsByte<ECEBuffDebuffType> STATIC_GetEBuffDebuffTypeByValue(int s_Value);
	int STATIC_GetValueByEBuffDebuffType(TEnumAsByte<ECEBuffDebuffType> c_Type);
	TEnumAsByte<ECERevivalType> STATIC_GetERevivalTypeByValue(int s_Value);
	int STATIC_GetValueByERevivalType(TEnumAsByte<ECERevivalType> c_Type);
	TEnumAsByte<ECECompareOperatorType> STATIC_GetECompareOperatorTypeByValue(int s_Value);
	int STATIC_GetValueByECompareOperatorType(TEnumAsByte<ECECompareOperatorType> c_Type);
	TEnumAsByte<ECERiotControlType> STATIC_GetERiotControlTypeByValue(int s_Value);
	int STATIC_GetValueByERiotControlType(TEnumAsByte<ECERiotControlType> c_Type);
	TEnumAsByte<ECERiotControlStateType> STATIC_GetERiotControlStateTypeByValue(int s_Value);
	int STATIC_GetValueByERiotControlStateType(TEnumAsByte<ECERiotControlStateType> c_Type);
	TEnumAsByte<ECEAbleUnableType> STATIC_GetEAbleUnableTypeByValue(int s_Value);
	int STATIC_GetValueByEAbleUnableType(TEnumAsByte<ECEAbleUnableType> c_Type);
	TEnumAsByte<ECEInvokableDistanceType> STATIC_GetEInvokableDistanceTypeByValue(int s_Value);
	int STATIC_GetValueByEInvokableDistanceType(TEnumAsByte<ECEInvokableDistanceType> c_Type);
	TEnumAsByte<ECESelectTargetConditionType> STATIC_GetESelectTargetConditionTypeByValue(int s_Value);
	int STATIC_GetValueByESelectTargetConditionType(TEnumAsByte<ECESelectTargetConditionType> c_Type);
	TEnumAsByte<ECESelectTargetType> STATIC_GetESelectTargetTypeByValue(int s_Value);
	int STATIC_GetValueByESelectTargetType(TEnumAsByte<ECESelectTargetType> c_Type);
	TEnumAsByte<ECEFunctionType> STATIC_GetEFunctionTypeByValue(int s_Value);
	int STATIC_GetValueByEFunctionType(TEnumAsByte<ECEFunctionType> c_Type);
	TEnumAsByte<ECEAbnormalStatusAddType> STATIC_GetEAbnormalStatusAddTypeByValue(int s_Value);
	int STATIC_GetValueByEAbnormalStatusAddType(TEnumAsByte<ECEAbnormalStatusAddType> c_Type);
	TEnumAsByte<ECEReferenceInfoType> STATIC_GetEReferenceInfoTypeByValue(int s_Value);
	int STATIC_GetValueByEReferenceInfoType(TEnumAsByte<ECEReferenceInfoType> c_Type);
	TEnumAsByte<ECESkillMobilityType> STATIC_GetESkillMobilityTypeByValue(int s_Value);
	int STATIC_GetValueByESkillMobilityType(TEnumAsByte<ECESkillMobilityType> c_Type);
	TEnumAsByte<ECESkillChargeType> STATIC_GetESkillChargeTypeByValue(int s_Value);
	int STATIC_GetValueByESkillChargeType(TEnumAsByte<ECESkillChargeType> c_Type);
	TEnumAsByte<ECESkillPrepareType> STATIC_GetESkillPrepareTypeByValue(int s_Value);
	int STATIC_GetValueByESkillPrepareType(TEnumAsByte<ECESkillPrepareType> c_Type);
	TEnumAsByte<ECESkillFiringType> STATIC_GetESkillFiringTypeByValue(int s_Value);
	int STATIC_GetValueByESkillFiringType(TEnumAsByte<ECESkillFiringType> c_Type);
	TEnumAsByte<ECESkillRushType> STATIC_GetESkillRushTypeByValue(int s_Value);
	int STATIC_GetValueByESkillRushType(TEnumAsByte<ECESkillRushType> c_Type);
	TEnumAsByte<ECESkillGradeType> STATIC_GetESkillGradeTypeByValue(int s_Value);
	int STATIC_GetValueByESkillGradeType(TEnumAsByte<ECESkillGradeType> c_Type);
	TEnumAsByte<ECESkillCategoryType> STATIC_GetESkillCategoryTypeByValue(int s_Value);
	int STATIC_GetValueByESkillCategoryType(TEnumAsByte<ECESkillCategoryType> c_Type);
	TEnumAsByte<ECEPropStateType> STATIC_GetEPropStateTypeByValue(int s_Value);
	int STATIC_GetValueByEPropStateType(TEnumAsByte<ECEPropStateType> c_Type);
	TEnumAsByte<ECEPropAfterInteractStateType> STATIC_GetEPropAfterInteractStateTypeByValue(int s_Value);
	int STATIC_GetValueByEPropAfterInteractStateType(TEnumAsByte<ECEPropAfterInteractStateType> c_Type);
	TEnumAsByte<ECEPropInteractByType> STATIC_GetEPropInteractByTypeByValue(int s_Value);
	int STATIC_GetValueByEPropInteractByType(TEnumAsByte<ECEPropInteractByType> c_Type);
	TEnumAsByte<ECEPropInteractType> STATIC_GetEPropInteractTypeByValue(int s_Value);
	int STATIC_GetValueByEPropInteractType(TEnumAsByte<ECEPropInteractType> c_Type);
	TEnumAsByte<ECEPropCategory> STATIC_GetEPropCategoryByValue(int s_Value);
	int STATIC_GetValueByEPropCategory(TEnumAsByte<ECEPropCategory> c_Type);
	TEnumAsByte<ECEPropCreationType> STATIC_GetEPropCreationTypeByValue(int s_Value);
	int STATIC_GetValueByEPropCreationType(TEnumAsByte<ECEPropCreationType> c_Type);
	TEnumAsByte<ECEActorEventType> STATIC_GetEActorEventTypeByValue(int s_Value);
	int STATIC_GetValueByEActorEventType(TEnumAsByte<ECEActorEventType> c_Type);
	TEnumAsByte<ECEActorEventDelivererType> STATIC_GetEActorEventDelivererTypeByValue(int s_Value);
	int STATIC_GetValueByEActorEventDelivererType(TEnumAsByte<ECEActorEventDelivererType> c_Type);
	TEnumAsByte<ECERelationshipType> STATIC_GetERelationshipTypeByValue(int s_Value);
	int STATIC_GetValueByERelationshipType(TEnumAsByte<ECERelationshipType> c_Type);
	TEnumAsByte<ECECombatElementComponentStateType> STATIC_GetECombatElementComponentStateTypeByValue(int s_Value);
	int STATIC_GetValueByECombatElementComponentStateType(TEnumAsByte<ECECombatElementComponentStateType> c_Type);
	TEnumAsByte<ECECombatElementStorageType> STATIC_GetECombatElementStorageTypeByValue(int s_Value);
	int STATIC_GetValueByECombatElementStorageType(TEnumAsByte<ECECombatElementStorageType> c_Type);
	TEnumAsByte<ECECombatElementType> STATIC_GetECombatElementTypeByValue(int s_Value);
	int STATIC_GetValueByECombatElementType(TEnumAsByte<ECECombatElementType> c_Type);
	TEnumAsByte<ECEAbnormalStatusOverlapType> STATIC_GetEAbnormalStatusOverlapTypeByValue(int s_Value);
	int STATIC_GetValueByEAbnormalStatusOverlapType(TEnumAsByte<ECEAbnormalStatusOverlapType> c_Type);
	TEnumAsByte<ECEParamChangeOvertimeFunctionType> STATIC_GetEParamChangeOvertimeFunctionTypeByValue(int s_Value);
	int STATIC_GetValueByEParamChangeOvertimeFunctionType(TEnumAsByte<ECEParamChangeOvertimeFunctionType> c_Type);
	TEnumAsByte<ECEParamChangeOvertimePeriodType> STATIC_GetEParamChangeOvertimePeriodTypeByValue(int s_Value);
	int STATIC_GetValueByEParamChangeOvertimePeriodType(TEnumAsByte<ECEParamChangeOvertimePeriodType> c_Type);
	TEnumAsByte<ECEParamChangeReferenceType> STATIC_GetEParamChangeReferenceTypeByValue(int s_Value);
	int STATIC_GetValueByEParamChangeReferenceType(TEnumAsByte<ECEParamChangeReferenceType> c_Type);
	TEnumAsByte<ECEParamChangeType> STATIC_GetEParamChangeTypeByValue(int s_Value);
	int STATIC_GetValueByEParamChangeType(TEnumAsByte<ECEParamChangeType> c_Type);
	TEnumAsByte<ECEParamType> STATIC_GetEParamTypeByValue(int s_Value);
	int STATIC_GetValueByEParamType(TEnumAsByte<ECEParamType> c_Type);
	TEnumAsByte<ECEItemBondingType> STATIC_GetEItemBondingTypeByValue(int s_Value);
	int STATIC_GetValueByEItemBondingType(TEnumAsByte<ECEItemBondingType> c_Type);
	TEnumAsByte<ECEItemGradeType> STATIC_GetEItemGradeTypeByValue(int s_Value);
	int STATIC_GetValueByEItemGradeType(TEnumAsByte<ECEItemGradeType> c_Type);
	TEnumAsByte<ECEEquipLayerType> STATIC_GetEEquipLayerTypeByValue(int s_Value);
	int STATIC_GetValueByEEquipLayerType(TEnumAsByte<ECEEquipLayerType> c_Type);
	TEnumAsByte<ECEItemRepairType> STATIC_GetEItemRepairTypeByValue(int s_Value);
	int STATIC_GetValueByEItemRepairType(TEnumAsByte<ECEItemRepairType> c_Type);
	TEnumAsByte<ECECompanionSlotType> STATIC_GetECompanionSlotTypeByValue(int s_Value);
	int STATIC_GetValueByECompanionSlotType(TEnumAsByte<ECECompanionSlotType> c_Type);
	TEnumAsByte<ECEItemEquipSlotType> STATIC_GetEItemEquipSlotTypeByValue(int s_Value);
	int STATIC_GetValueByEItemEquipSlotType(TEnumAsByte<ECEItemEquipSlotType> c_Type);
	TEnumAsByte<ECEItemCusomizingEquipCategory> STATIC_GetEItemCusomizingEquipCategoryByValue(int s_Value);
	int STATIC_GetValueByEItemCusomizingEquipCategory(TEnumAsByte<ECEItemCusomizingEquipCategory> c_Type);
	TEnumAsByte<ECEItemEquipCategory> STATIC_GetEItemEquipCategoryByValue(int s_Value);
	int STATIC_GetValueByEItemEquipCategory(TEnumAsByte<ECEItemEquipCategory> c_Type);
	TEnumAsByte<ECEItemCooltimeType> STATIC_GetEItemCooltimeTypeByValue(int s_Value);
	int STATIC_GetValueByEItemCooltimeType(TEnumAsByte<ECEItemCooltimeType> c_Type);
	TEnumAsByte<ECEItemWeightCategory> STATIC_GetEItemWeightCategoryByValue(int s_Value);
	int STATIC_GetValueByEItemWeightCategory(TEnumAsByte<ECEItemWeightCategory> c_Type);
	TEnumAsByte<ECEGroupCoolDownType> STATIC_GetEGroupCoolDownTypeByValue(int s_Value);
	int STATIC_GetValueByEGroupCoolDownType(TEnumAsByte<ECEGroupCoolDownType> c_Type);
	TEnumAsByte<ECERelativePositionType> STATIC_GetERelativePositionTypeByValue(int s_Value);
	int STATIC_GetValueByERelativePositionType(TEnumAsByte<ECERelativePositionType> c_Type);
	TEnumAsByte<ECEImpactDelayCalcType> STATIC_GetEImpactDelayCalcTypeByValue(int s_Value);
	int STATIC_GetValueByEImpactDelayCalcType(TEnumAsByte<ECEImpactDelayCalcType> c_Type);
	TEnumAsByte<ECEProjectileType> STATIC_GetEProjectileTypeByValue(int s_Value);
	int STATIC_GetValueByEProjectileType(TEnumAsByte<ECEProjectileType> c_Type);
	TEnumAsByte<ECEProjectileCategory> STATIC_GetEProjectileCategoryByValue(int s_Value);
	int STATIC_GetValueByEProjectileCategory(TEnumAsByte<ECEProjectileCategory> c_Type);
	TEnumAsByte<ECEApplyingAreaLocationReferenceDirectionType> STATIC_GetEApplyingAreaLocationReferenceDirectionTypeByValue(int s_Value);
	int STATIC_GetValueByEApplyingAreaLocationReferenceDirectionType(TEnumAsByte<ECEApplyingAreaLocationReferenceDirectionType> c_Type);
	TEnumAsByte<ECEApplyingAreaLocationReferencePointType> STATIC_GetEApplyingAreaLocationReferencePointTypeByValue(int s_Value);
	int STATIC_GetValueByEApplyingAreaLocationReferencePointType(TEnumAsByte<ECEApplyingAreaLocationReferencePointType> c_Type);
	TEnumAsByte<ECEAttackAreaShapeType> STATIC_GetEAttackAreaShapeTypeByValue(int s_Value);
	int STATIC_GetValueByEAttackAreaShapeType(TEnumAsByte<ECEAttackAreaShapeType> c_Type);
	TEnumAsByte<ECEExtendAttackChanceType> STATIC_GetEExtendAttackChanceTypeByValue(int s_Value);
	int STATIC_GetValueByEExtendAttackChanceType(TEnumAsByte<ECEExtendAttackChanceType> c_Type);
	TEnumAsByte<ECEAttackChanceType> STATIC_GetEAttackChanceTypeByValue(int s_Value);
	int STATIC_GetValueByEAttackChanceType(TEnumAsByte<ECEAttackChanceType> c_Type);
	TEnumAsByte<ECEAttackRangeCategory> STATIC_GetEAttackRangeCategoryByValue(int s_Value);
	int STATIC_GetValueByEAttackRangeCategory(TEnumAsByte<ECEAttackRangeCategory> c_Type);
	TEnumAsByte<ECEDamageType> STATIC_GetEDamageTypeByValue(int s_Value);
	int STATIC_GetValueByEDamageType(TEnumAsByte<ECEDamageType> c_Type);
	TEnumAsByte<ECEJudgeType> STATIC_GetEJudgeTypeByValue(int s_Value);
	int STATIC_GetValueByEJudgeType(TEnumAsByte<ECEJudgeType> c_Type);
	TEnumAsByte<ECEVoluntaryActionEffectType> STATIC_GetEVoluntaryActionEffectTypeByValue(int s_Value);
	int STATIC_GetValueByEVoluntaryActionEffectType(TEnumAsByte<ECEVoluntaryActionEffectType> c_Type);
	TEnumAsByte<ECEVoluntaryActionType> STATIC_GetEVoluntaryActionTypeByValue(int s_Value);
	int STATIC_GetValueByEVoluntaryActionType(TEnumAsByte<ECEVoluntaryActionType> c_Type);
	TEnumAsByte<ECEAggressiveType> STATIC_GetEAggressiveTypeByValue(int s_Value);
	int STATIC_GetValueByEAggressiveType(TEnumAsByte<ECEAggressiveType> c_Type);
	TEnumAsByte<ECENPCShowConditionPhaseType> STATIC_GetENPCShowConditionPhaseTypeByValue(int s_Value);
	int STATIC_GetValueByENPCShowConditionPhaseType(TEnumAsByte<ECENPCShowConditionPhaseType> c_Type);
	TEnumAsByte<ECEApplyingType> STATIC_GetEApplyingTypeByValue(int s_Value);
	int STATIC_GetValueByEApplyingType(TEnumAsByte<ECEApplyingType> c_Type);
	TEnumAsByte<ECETargetingType> STATIC_GetETargetingTypeByValue(int s_Value);
	int STATIC_GetValueByETargetingType(TEnumAsByte<ECETargetingType> c_Type);
	TEnumAsByte<ECEAttackType> STATIC_GetEAttackTypeByValue(int s_Value);
	int STATIC_GetValueByEAttackType(TEnumAsByte<ECEAttackType> c_Type);
	TEnumAsByte<ECEAttackTableType> STATIC_GetEAttackTableTypeByValue(int s_Value);
	int STATIC_GetValueByEAttackTableType(TEnumAsByte<ECEAttackTableType> c_Type);
	TEnumAsByte<ECENatureType> STATIC_GetENatureTypeByValue(int s_Value);
	int STATIC_GetValueByENatureType(TEnumAsByte<ECENatureType> c_Type);
	TEnumAsByte<ECEMagicalSubNatureType> STATIC_GetEMagicalSubNatureTypeByValue(int s_Value);
	int STATIC_GetValueByEMagicalSubNatureType(TEnumAsByte<ECEMagicalSubNatureType> c_Type);
	TEnumAsByte<ECEPhysicalSubNatureType> STATIC_GetEPhysicalSubNatureTypeByValue(int s_Value);
	int STATIC_GetValueByEPhysicalSubNatureType(TEnumAsByte<ECEPhysicalSubNatureType> c_Type);
	TEnumAsByte<ECEEquipSlotType> STATIC_GetEEquipSlotTypeByValue(int s_Value);
	int STATIC_GetValueByEEquipSlotType(TEnumAsByte<ECEEquipSlotType> c_Type);
	TEnumAsByte<ECENPCStateType> STATIC_GetENPCStateTypeByValue(int s_Value);
	int STATIC_GetValueByENPCStateType(TEnumAsByte<ECENPCStateType> c_Type);
	TEnumAsByte<ECEWeaponSheatheType> STATIC_GetEWeaponSheatheTypeByValue(int s_Value);
	int STATIC_GetValueByEWeaponSheatheType(TEnumAsByte<ECEWeaponSheatheType> c_Type);
	TEnumAsByte<ECEMerchantCategory> STATIC_GetEMerchantCategoryByValue(int s_Value);
	int STATIC_GetValueByEMerchantCategory(TEnumAsByte<ECEMerchantCategory> c_Type);
	TEnumAsByte<ECENPCProductionCategory> STATIC_GetENPCProductionCategoryByValue(int s_Value);
	int STATIC_GetValueByENPCProductionCategory(TEnumAsByte<ECENPCProductionCategory> c_Type);
	TEnumAsByte<ECENPCCategory> STATIC_GetENPCCategoryByValue(int s_Value);
	int STATIC_GetValueByENPCCategory(TEnumAsByte<ECENPCCategory> c_Type);
	TEnumAsByte<ECEFactionRelationshipType> STATIC_GetEFactionRelationshipTypeByValue(int s_Value);
	int STATIC_GetValueByEFactionRelationshipType(TEnumAsByte<ECEFactionRelationshipType> c_Type);
	TEnumAsByte<ECECostType> STATIC_GetECostTypeByValue(int s_Value);
	int STATIC_GetValueByECostType(TEnumAsByte<ECECostType> c_Type);
	TEnumAsByte<ECEWeekDayType> STATIC_GetEWeekDayTypeByValue(int s_Value);
	int STATIC_GetValueByEWeekDayType(TEnumAsByte<ECEWeekDayType> c_Type);
	TEnumAsByte<ECEActionShowType> STATIC_GetEActionShowTypeByValue(int s_Value);
	int STATIC_GetValueByEActionShowType(TEnumAsByte<ECEActionShowType> c_Type);
	TEnumAsByte<ECERefActionComboType> STATIC_GetERefActionComboTypeByValue(int s_Value);
	int STATIC_GetValueByERefActionComboType(TEnumAsByte<ECERefActionComboType> c_Type);
	TEnumAsByte<ECEPlacebleObjectType> STATIC_GetEPlacebleObjectTypeByValue(int s_Value);
	int STATIC_GetValueByEPlacebleObjectType(TEnumAsByte<ECEPlacebleObjectType> c_Type);
	TEnumAsByte<ECEGenderType> STATIC_GetEGenderTypeByValue(int s_Value);
	int STATIC_GetValueByEGenderType(TEnumAsByte<ECEGenderType> c_Type);
	TEnumAsByte<ECEClassSubCategory> STATIC_GetEClassSubCategoryByValue(int s_Value);
	int STATIC_GetValueByEClassSubCategory(TEnumAsByte<ECEClassSubCategory> c_Type);
	TEnumAsByte<ECEClassCategory> STATIC_GetEClassCategoryByValue(int s_Value);
	int STATIC_GetValueByEClassCategory(TEnumAsByte<ECEClassCategory> c_Type);
	TEnumAsByte<ECEClassType> STATIC_GetEClassTypeByValue(int s_Value);
	int STATIC_GetValueByEClassType(TEnumAsByte<ECEClassType> c_Type);
	TEnumAsByte<ECEVehicleType> STATIC_GetEVehicleTypeByValue(int s_Value);
	int STATIC_GetValueByEVehicleType(TEnumAsByte<ECEVehicleType> c_Type);
	TEnumAsByte<ECERaceType> STATIC_GetERaceTypeByValue(int s_Value);
	int STATIC_GetValueByERaceType(TEnumAsByte<ECERaceType> c_Type);
	TEnumAsByte<ECERealmType> STATIC_GetERealmTypeByValue(int s_Value);
	int STATIC_GetValueByERealmType(TEnumAsByte<ECERealmType> c_Type);
};


// Class BLGame.MaterialController
// 0x00BD (0x012D - 0x0070)
class UMaterialController : public UComponent
{
public:
	struct FBodyMatCachingKeyType                      BodyMatCachingKey;                                        // 0x0070(0x0030) (NeedCtorLink)
	struct FEquipmentMatCachingKeyType                 EquipmentMatCachingKey;                                   // 0x00A0(0x0010) (NeedCtorLink)
	TArray<class UMaterialInterface*>                  BaseMaterials_Body;                                       // 0x00B0(0x0010) (NeedCtorLink)
	TArray<class UMaterialInterface*>                  BaseMaterials_Equipment;                                  // 0x00C0(0x0010) (NeedCtorLink)
	TArray<class UMaterialInstanceTimeVarying*>        MITVs_Body;                                               // 0x00D0(0x0010) (NeedCtorLink)
	TArray<class UMaterialInstanceTimeVarying*>        MITVs_Weapon;                                             // 0x00E0(0x0010) (NeedCtorLink)
	TArray<class UMaterialInstanceTimeVarying*>        MITVs_Shield;                                             // 0x00F0(0x0010) (NeedCtorLink)
	TArray<class UMaterialInstanceTimeVarying*>        MITVs_Additional_Body;                                    // 0x0100(0x0010) (NeedCtorLink)
	TArray<struct FMITVSchedule>                       MITVSchedules;                                            // 0x0110(0x0010) (NeedCtorLink)
	unsigned long                                      ForceOverrideMICParams : 1;                               // 0x0120(0x0004) (Config)
	unsigned long                                      bDirty : 1;                                               // 0x0120(0x0004) (Transient)
	unsigned long                                      bEnableTargetOutline : 1;                                 // 0x0120(0x0004) (Transient)
	unsigned long                                      bOverrideMaterial : 1;                                    // 0x0120(0x0004) (Transient)
	class UMaterialInterface*                          OverridedMaterial;                                        // 0x0124(0x0008) (Transient)
	TEnumAsByte<ECEAppearanceType>                     AppearanceType;                                           // 0x012C(0x0001)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MaterialController");
		return ptr;
	}


	bool IsShieldItem(class UBLItem* InItem);
	bool IsWeaponItem(class UBLItem* InItem);
	float STATIC_GetMaxDuration(class UMaterialInstanceTimeVarying* InMITV, const struct FName& ParamName);
	void STATIC_SetAllStartTime(class UMaterialInstanceTimeVarying* InMITV, float StartTime);
	class UMaterialInstanceTimeVarying* STATIC_CreateReverseMITV(class UMaterialInstanceTimeVarying* InSrcMITV, class UObject* InOuter, float PlayedTime, float PlayRate);
	class UMaterialInstanceTimeVarying* STATIC_CreateMITV(class UMaterialInstanceTimeVarying* InSrcMITV);
	class UMaterialInterface* STATIC_CreateParentParameterOverridedMI(class UMaterialInterface* InParentMI, class UObject* InOuter);
	void STATIC_SetOverrideParentParameter(class UMaterialInterface* InParentMI, class UMaterialInstanceConstant* InDestMIC);
	void STATIC_ForceCopyMICParameter(class UMaterialInstanceConstant* InSrcMIC, class UMaterialInstanceConstant* InTargetMIC);
	void STATIC_ForceCopyMITVParameter(class UMaterialInstanceTimeVarying* InSrcMITV, class UMaterialInstanceTimeVarying* InTargetMITV);
	bool STATIC_SetMITVParameter(class UMaterialInstanceTimeVarying* InSrcMITV, class UMaterialInstanceTimeVarying* InTargetMITV);
	void Tick(float InDeltaTime);
	void UpdateTargetOutline();
	void SetTargetOutline(bool bInEnable);
	bool SetMITVNextLoopSchedule(struct FMITVSchedule* OutResetedMITV);
	void DeleteMITV(int InKeyIndex);
	void UpdateMITV();
	void ApplyMITV(class UMaterialInstanceTimeVarying* InSrcMITV, TEnumAsByte<EMCApplyType> InApplyType, bool bClearParameterValue);
	void ClearMITV();
	void SetDefaultMITV(bool InClearSchedule);
	void SetMITV_KeyIndex_NextLoopType(class UMaterialInstanceTimeVarying* InSrcMITV, class UMaterialInstanceTimeVarying* InSrcMITVNextLoop, int InKeyIndex, float InLifeTime, int InPriority, TEnumAsByte<EMCApplyType> InApplyType);
	void SetMITV_KeyIndex(class UMaterialInstanceTimeVarying* InSrcMITV, int InKeyIndex, float InLifeTime, int InPriority, TEnumAsByte<EMCApplyType> InApplyType);
	void SetMITV(class UMaterialInstanceTimeVarying* InSrcMITV, float InLifeTime, int InPriority, TEnumAsByte<EMCApplyType> InApplyType);
	void SetMITV_Infinity(class UMaterialInstanceTimeVarying* InSrcMITV, int InPriority, TEnumAsByte<EMCApplyType> InApplyType);
	void SetEquipMaterial(class UBLAggregateEquipment* InEquipment, int InIndex, class UMaterialInterface* InMaterial, TArray<struct FString>* InKeepTextureParameterNameList);
	void SetHeadMaterial(class USkeletalMeshComponent* InHeadMesh, int InIndex, class UMaterialInterface* InMaterial, TArray<struct FString>* InKeepTextureParameterNameList);
	void SetBodyMaterial(class USkeletalMeshComponent* InBodyMesh, int InIndex, class UMaterialInterface* InMaterial, TArray<struct FString>* InKeepTextureParameterNameList);
	void SetAllMaterial(class USkeletalMeshComponent* InBodyMesh, class USkeletalMeshComponent* InHeadMesh, class UBLAggregateEquipment* InEquipment, class UMaterialInterface* InMaterial);
	void SetAllMaterialWithSettingInfo(class USkeletalMeshComponent* InBodyMesh, class USkeletalMeshComponent* InHeadMesh, class UBLAggregateEquipment* InEquipment, struct FBLMaterialSettingInfo* DefaultSettingInfo, TArray<struct FBLMaterialSettingInfo>* InSettingInfoList);
	void ClearOverrideMaterial();
	void SetOverrideMaterial(class USkeletalMeshComponent* InBodyMesh, class USkeletalMeshComponent* InHeadMesh, class UBLAggregateEquipment* InEquipment, class UMaterialInterface* InMaterial);
	void GetBaseMaterials(TArray<class UMaterialInterface*>* OutBaseMaterials);
	void InitAttachedEquipments(class UBLAggregateEquipment* InEquipment);
	void InitBody(class USkeletalMeshComponent* InBodyMesh, class USkeletalMeshComponent* InHeadMesh, class UPawnAsset* InPawnAsset, TEnumAsByte<ECEAppearanceType> InAppearanceType);
	void InitAll(class USkeletalMeshComponent* InBodyMesh, class USkeletalMeshComponent* InHeadMesh, class UBLAggregateEquipment* InEquipment, class UPawnAsset* InPawnAsset, TEnumAsByte<ECEAppearanceType> InAppearanceType);
};


// Class BLGame.MaterialExpressionDecoderFaceDividedMask
// 0x00D0 (0x0188 - 0x00B8)
class UMaterialExpressionDecoderFaceDividedMask : public UMaterialExpression
{
public:
	struct FExpressionInput                            OriginalUV;                                               // 0x00B8(0x0034) (NeedCtorLink)
	struct FExpressionInput                            Channel;                                                  // 0x00EC(0x0034) (NeedCtorLink)
	struct FExpressionInput                            Rows;                                                     // 0x0120(0x0034) (NeedCtorLink)
	struct FExpressionInput                            Cols;                                                     // 0x0154(0x0034) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MaterialExpressionDecoderFaceDividedMask");
		return ptr;
	}

};


// Class BLGame.MaterialExpressionDecoderRangeDividedMask
// 0x00A0 (0x0158 - 0x00B8)
class UMaterialExpressionDecoderRangeDividedMask : public UMaterialExpression
{
public:
	struct FExpressionInput                            Texture;                                                  // 0x00B8(0x0034) (NeedCtorLink)
	struct FExpressionInput                            Channel;                                                  // 0x00EC(0x0034) (NeedCtorLink)
	struct FExpressionInput                            Steps;                                                    // 0x0120(0x0034) (NeedCtorLink)
	unsigned long                                      bUseBlendingWithMaskValue : 1;                            // 0x0154(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MaterialExpressionDecoderRangeDividedMask");
		return ptr;
	}

};


// Class BLGame.MaterialExpressionDepthBiasedAlphaDistortion
// 0x00A8 (0x0160 - 0x00B8)
class UMaterialExpressionDepthBiasedAlphaDistortion : public UMaterialExpression
{
public:
	unsigned long                                      bNormalize : 1;                                           // 0x00B8(0x0004) (Edit)
	unsigned long                                      bDepthDistanceAsPositive : 1;                             // 0x00B8(0x0004) (Edit)
	unsigned long                                      bUseCloserDepth : 1;                                      // 0x00B8(0x0004) (Edit)
	unsigned long                                      bMirrorDistortion : 1;                                    // 0x00B8(0x0004) (Edit)
	float                                              BiasScale;                                                // 0x00BC(0x0004) (Edit)
	float                                              DistortionFadeoutFactor;                                  // 0x00C0(0x0004) (Edit)
	struct FExpressionInput                            Alpha;                                                    // 0x00C4(0x0034) (NeedCtorLink)
	struct FExpressionInput                            Bias;                                                     // 0x00F8(0x0034) (NeedCtorLink)
	struct FExpressionInput                            DistortionInput;                                          // 0x012C(0x0034) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MaterialExpressionDepthBiasedAlphaDistortion");
		return ptr;
	}

};


// Class BLGame.MaterialExpressionExposedShadowFactor
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionExposedShadowFactor : public UMaterialExpression
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MaterialExpressionExposedShadowFactor");
		return ptr;
	}

};


// Class BLGame.MaterialExpressionKelemanSzirmaySpecular
// 0x0070 (0x0128 - 0x00B8)
class UMaterialExpressionKelemanSzirmaySpecular : public UMaterialExpression
{
public:
	float                                              Exponent;                                                 // 0x00B8(0x0004) (Edit)
	float                                              Eta;                                                      // 0x00BC(0x0004) (Edit)
	struct FExpressionInput                            Normal;                                                   // 0x00C0(0x0034) (NeedCtorLink)
	struct FExpressionInput                            Roughness;                                                // 0x00F4(0x0034) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MaterialExpressionKelemanSzirmaySpecular");
		return ptr;
	}

};


// Class BLGame.MaterialExpressionOpacityAdaptation
// 0x0070 (0x0128 - 0x00B8)
class UMaterialExpressionOpacityAdaptation : public UMaterialExpression
{
public:
	struct FExpressionInput                            DominantColorChannel;                                     // 0x00B8(0x0034) (NeedCtorLink)
	struct FExpressionInput                            OverallOpacityBias;                                       // 0x00EC(0x0034) (NeedCtorLink)
	float                                              ClampMin;                                                 // 0x0120(0x0004) (Edit)
	float                                              ClampMax;                                                 // 0x0124(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MaterialExpressionOpacityAdaptation");
		return ptr;
	}

};


// Class BLGame.MaterialExpressionPerVertexWind
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionPerVertexWind : public UMaterialExpression
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MaterialExpressionPerVertexWind");
		return ptr;
	}

};


// Class BLGame.MaterialExpressionPerVertexWindMovement
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionPerVertexWindMovement : public UMaterialExpression
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MaterialExpressionPerVertexWindMovement");
		return ptr;
	}

};


// Class BLGame.MaterialExpressionPerVertexWindProperty
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionPerVertexWindProperty : public UMaterialExpression
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MaterialExpressionPerVertexWindProperty");
		return ptr;
	}

};


// Class BLGame.MaterialExpressionPhongSpecular
// 0x0068 (0x0120 - 0x00B8)
class UMaterialExpressionPhongSpecular : public UMaterialExpression
{
public:
	struct FExpressionInput                            SpecularColorInput;                                       // 0x00B8(0x0034) (NeedCtorLink)
	struct FExpressionInput                            SpecularPowerInput;                                       // 0x00EC(0x0034) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MaterialExpressionPhongSpecular");
		return ptr;
	}

};


// Class BLGame.MaterialExpressionSnowfalls
// 0x003C (0x00F4 - 0x00B8)
class UMaterialExpressionSnowfalls : public UMaterialExpression
{
public:
	float                                              Amount;                                                   // 0x00B8(0x0004) (Edit)
	float                                              Sharpness;                                                // 0x00BC(0x0004) (Edit)
	struct FExpressionInput                            Normal;                                                   // 0x00C0(0x0034) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MaterialExpressionSnowfalls");
		return ptr;
	}

};


// Class BLGame.MaterialExpressionStep
// 0x0068 (0x0120 - 0x00B8)
class UMaterialExpressionStep : public UMaterialExpression
{
public:
	struct FExpressionInput                            A;                                                        // 0x00B8(0x0034) (NeedCtorLink)
	struct FExpressionInput                            B;                                                        // 0x00EC(0x0034) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MaterialExpressionStep");
		return ptr;
	}

};


// Class BLGame.MaterialExpressionTextureObjectParameterStatic
// 0x0008 (0x0150 - 0x0148)
class UMaterialExpressionTextureObjectParameterStatic : public UMaterialExpressionTextureObjectParameter
{
public:
	struct FPointer                                    InstanceOverride;                                         // 0x0148(0x0008) (Const, Native, Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MaterialExpressionTextureObjectParameterStatic");
		return ptr;
	}

};


// Class BLGame.MaterialExpressionTextureSampleBicubic
// 0x0000 (0x0128 - 0x0128)
class UMaterialExpressionTextureSampleBicubic : public UMaterialExpressionTextureSample
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MaterialExpressionTextureSampleBicubic");
		return ptr;
	}

};


// Class BLGame.MaterialExpressionTextureSampleFaceDividedMask
// 0x000C (0x0134 - 0x0128)
class UMaterialExpressionTextureSampleFaceDividedMask : public UMaterialExpressionTextureSample
{
public:
	int                                                ChannelIndex;                                             // 0x0128(0x0004) (Edit)
	int                                                RowCount;                                                 // 0x012C(0x0004) (Edit)
	int                                                ColumnCount;                                              // 0x0130(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MaterialExpressionTextureSampleFaceDividedMask");
		return ptr;
	}

};


// Class BLGame.MaterialExpressionTextureSampleFrequencyDividedMask
// 0x0034 (0x015C - 0x0128)
class UMaterialExpressionTextureSampleFrequencyDividedMask : public UMaterialExpressionTextureSample
{
public:
	struct FExpressionInput                            ChannelIndex;                                             // 0x0128(0x0034) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MaterialExpressionTextureSampleFrequencyDividedMask");
		return ptr;
	}

};


// Class BLGame.MaterialExpressionTextureSampleParameterDD
// 0x0038 (0x0180 - 0x0148)
class UMaterialExpressionTextureSampleParameterDD : public UMaterialExpressionTextureSampleParameter2D
{
public:
	struct FExpressionInput                            CoordinatesForDerivative;                                 // 0x0148(0x0034) (NeedCtorLink)
	int                                                DerivativeFurtherCorrection;                              // 0x017C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MaterialExpressionTextureSampleParameterDD");
		return ptr;
	}

};


// Class BLGame.MaterialExpressionTextureSampleParameterFaceDividedMask
// 0x001C (0x0164 - 0x0148)
class UMaterialExpressionTextureSampleParameterFaceDividedMask : public UMaterialExpressionTextureSampleParameter
{
public:
	int                                                ChannelIndex;                                             // 0x0148(0x0004) (Edit)
	int                                                RowCount;                                                 // 0x014C(0x0004) (Edit)
	int                                                ColumnCount;                                              // 0x0150(0x0004) (Edit)
	int                                                TilingCountU;                                             // 0x0154(0x0004) (Edit)
	int                                                TilingCountV;                                             // 0x0158(0x0004) (Edit)
	unsigned long                                      bUseNonTiledDerivative : 1;                               // 0x015C(0x0004) (Edit)
	int                                                NonTiledDerivativeFurtherCorrection;                      // 0x0160(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MaterialExpressionTextureSampleParameterFaceDividedMask");
		return ptr;
	}

};


// Class BLGame.MaterialExpressionTextureSampleParameterLOD
// 0x0038 (0x0180 - 0x0148)
class UMaterialExpressionTextureSampleParameterLOD : public UMaterialExpressionTextureSampleParameter2D
{
public:
	struct FExpressionInput                            MipMapLOD;                                                // 0x0148(0x0034) (NeedCtorLink)
	unsigned long                                      bSmoothMipTransition : 1;                                 // 0x017C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MaterialExpressionTextureSampleParameterLOD");
		return ptr;
	}

};


// Class BLGame.MaterialExpressionTextureSampleParameterSDF
// 0x0004 (0x014C - 0x0148)
class UMaterialExpressionTextureSampleParameterSDF : public UMaterialExpressionTextureSampleParameter
{
public:
	int                                                SamplePower;                                              // 0x0148(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MaterialExpressionTextureSampleParameterSDF");
		return ptr;
	}

};


// Class BLGame.MaterialExpressionTextureSampleParameterStatic
// 0x0008 (0x0150 - 0x0148)
class UMaterialExpressionTextureSampleParameterStatic : public UMaterialExpressionTextureSampleParameter2D
{
public:
	struct FPointer                                    InstanceOverride;                                         // 0x0148(0x0008) (Const, Native, Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MaterialExpressionTextureSampleParameterStatic");
		return ptr;
	}

};


// Class BLGame.MaterialExpressionTextureSampleRangeDividedMask
// 0x000C (0x0134 - 0x0128)
class UMaterialExpressionTextureSampleRangeDividedMask : public UMaterialExpressionTextureSample
{
public:
	int                                                ChannelIndex;                                             // 0x0128(0x0004) (Edit)
	int                                                Steps;                                                    // 0x012C(0x0004) (Edit)
	unsigned long                                      bUseBlendingWithMaskValue : 1;                            // 0x0130(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MaterialExpressionTextureSampleRangeDividedMask");
		return ptr;
	}

};


// Class BLGame.BLSeqAct_LobbyMatineeEnd
// 0x0000 (0x0150 - 0x0150)
class UBLSeqAct_LobbyMatineeEnd : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLSeqAct_LobbyMatineeEnd");
		return ptr;
	}

};


// Class BLGame.BLSeqAct_LoopingCinemaPCMatinee
// 0x0004 (0x027C - 0x0278)
class UBLSeqAct_LoopingCinemaPCMatinee : public USeqAct_Interp
{
public:
	unsigned long                                      bIsSkipedBeforePlay : 1;                                  // 0x0278(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLSeqAct_LoopingCinemaPCMatinee");
		return ptr;
	}

};


// Class BLGame.BLSeqEvent_MouseOut
// 0x0000 (0x0170 - 0x0170)
class UBLSeqEvent_MouseOut : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLSeqEvent_MouseOut");
		return ptr;
	}

};


// Class BLGame.BLSeqEvent_MouseOver
// 0x0000 (0x0170 - 0x0170)
class UBLSeqEvent_MouseOver : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLSeqEvent_MouseOver");
		return ptr;
	}

};


// Class BLGame.BLSeqEvent_Select
// 0x0000 (0x0170 - 0x0170)
class UBLSeqEvent_Select : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLSeqEvent_Select");
		return ptr;
	}

};


// Class BLGame.BLSeqEvent_Unselect
// 0x0000 (0x0170 - 0x0170)
class UBLSeqEvent_Unselect : public USequenceEvent
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLSeqEvent_Unselect");
		return ptr;
	}

};


// Class BLGame.BLCinematicMovieManager
// 0x0020 (0x0080 - 0x0060)
class UBLCinematicMovieManager : public UObject
{
public:
	struct FPointer                                    VfTable_FTickableObject;                                  // 0x0060(0x0008) (Const, Native, NoExport)
	struct FMoviePlayInfo                              CinemaPlayInfo;                                           // 0x0068(0x0014) (Transient)
	unsigned long                                      bHidePawn : 1;                                            // 0x007C(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLCinematicMovieManager");
		return ptr;
	}


	void TickProcess(float DeltaTime);
	void TickInternal(float DeltaTime);
	bool HasCinematicMovieStarted();
	void ExcutePlayRemoteEvent();
	class ULevelStreaming* StartLoadingCinematicLevel(int InCinematicMovieId);
	bool IsCinematicLevelLoadingComplete();
	void ResetPlayInfo();
	void HidePawn(bool bInHide);
	void DisableSkip();
	void SetEnableStartTimeFadeIn(bool bEnable);
	void UnloadingCinematicLevel();
	bool IsCinematicMovieLoadingComplete();
	bool IsExistCinematicMovie();
	bool IsPlayingCinematicMovie();
	bool IsPlayedMovie();
	bool IsCinematicMovieSkipped();
	void StopMovie();
	void PrepareMovieStarting();
	void PlayMovie();
	void StartMovie(int InCinematicMovieId, bool bAutoPlay);
	void StreamResourceWithCinematicActorTexture(float InTimeLimit);
	void HideAllCinematicActor();
	void UpdateCinematicActors();
	void DisableFadeTrackAll(class ULevelStreaming* InStreamLevel);
	void UnLoadStreamingLevel(class ULevelStreaming* InStreamLevel);
	void AddStreamingLevelToLoad(class ULevelStreaming* InStreamLevel, const struct FName& NewName, bool bShouldBeBlockLoading);
	bool GetGameSeqAll(class ULevelStreaming* InStreamLevel, TArray<class USequence*>* OutData);
	bool GetSeqAct_InterpAll(class ULevelStreaming* InStreamLevel, TArray<class USeqAct_Interp*>* OutData);
};


// Class BLGame.BLPCInterpGroup
// 0x003C (0x00EC - 0x00B0)
class UBLPCInterpGroup : public UInterpGroup
{
public:
	class UPCAsset*                                    SelectedPCAsset;                                          // 0x00B0(0x0008) (Edit, Const, Transient)
	unsigned long                                      bPlayerIsNude : 1;                                        // 0x00B8(0x0004) (Edit)
	unsigned long                                      bActorIsTransform : 1;                                    // 0x00B8(0x0004) (Edit)
	class USkeletalMeshComponent*                      OriginalSkelMeshBackup;                                   // 0x00BC(0x0008) (ExportObject, Transient, Component, EditInline)
	class USkeletalMeshComponent*                      OriginalHeadSkelMeshBackup;                               // 0x00C4(0x0008) (ExportObject, Transient, Component, EditInline)
	TArray<class USkeletalMeshSocket*>                 OriginalPCMeshSockets;                                    // 0x00CC(0x0010) (Transient, NeedCtorLink)
	TArray<class USkeletalMeshSocket*>                 OriginalPCHeadMeshSockets;                                // 0x00DC(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLPCInterpGroup");
		return ptr;
	}

};


// Class BLGame.BLPCInterpGroupInst
// 0x0000 (0x0088 - 0x0088)
class UBLPCInterpGroupInst : public UInterpGroupInst
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLPCInterpGroupInst");
		return ptr;
	}

};


// Class BLGame.BLSeqAct_AdjustSkelControlWeaponSheathe
// 0x0030 (0x0180 - 0x0150)
class UBLSeqAct_AdjustSkelControlWeaponSheathe : public USequenceAction
{
public:
	struct FName                                       SkelControlName;                                          // 0x0150(0x0008) (Edit)
	struct FName                                       TransformedSpaceBoneName;                                 // 0x0158(0x0008) (Edit)
	struct FRotator                                    BoneRotation;                                             // 0x0160(0x000C) (Edit)
	struct FVector                                     BoneTranslation;                                          // 0x016C(0x000C) (Edit)
	float                                              BlendTime;                                                // 0x0178(0x0004) (Edit)
	unsigned long                                      SheatheWeapon : 1;                                        // 0x017C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLSeqAct_AdjustSkelControlWeaponSheathe");
		return ptr;
	}

};


// Class BLGame.BLSeqAct_ChangeStreamingTarget
// 0x0000 (0x0150 - 0x0150)
class UBLSeqAct_ChangeStreamingTarget : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLSeqAct_ChangeStreamingTarget");
		return ptr;
	}


	void Activated();
};


// Class BLGame.BLSeqAct_PostCinema
// 0x000C (0x015C - 0x0150)
class UBLSeqAct_PostCinema : public USequenceAction
{
public:
	unsigned long                                      bInterpToPlayerCamera : 1;                                // 0x0150(0x0004) (Edit)
	float                                              InterpTotalSec;                                           // 0x0154(0x0004) (Edit)
	float                                              AccumTime;                                                // 0x0158(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLSeqAct_PostCinema");
		return ptr;
	}


	void RestoreStatus();
};


// Class BLGame.BLSeqAct_PreCinema
// 0x0014 (0x0164 - 0x0150)
class UBLSeqAct_PreCinema : public USequenceAction
{
public:
	unsigned long                                      bInterpToMatineeCam : 1;                                  // 0x0150(0x0004) (Edit)
	unsigned long                                      bDisableMovement : 1;                                     // 0x0150(0x0004) (Edit)
	unsigned long                                      ShowPlayerInfinity : 1;                                   // 0x0150(0x0004) (Edit)
	unsigned long                                      bHideNPC : 1;                                             // 0x0150(0x0004) (Edit)
	float                                              InterpTotalSec;                                           // 0x0154(0x0004) (Edit)
	float                                              AccumTime;                                                // 0x0158(0x0004) (Transient)
	float                                              ShowPlayerAccumTime;                                      // 0x015C(0x0004) (Transient)
	float                                              ShowPlayerTotalSec;                                       // 0x0160(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLSeqAct_PreCinema");
		return ptr;
	}


	void Activated();
};


// Class BLGame.InterpPlayInstance
// 0x0074 (0x02EC - 0x0278)
class UInterpPlayInstance : public USeqAct_Interp
{
public:
	int                                                PlayerPawnId;                                             // 0x0278(0x0004) (Transient)
	class ABLPawn*                                     PlayerPawn;                                               // 0x027C(0x0008) (Transient)
	unsigned long                                      bIsLocalPlayer : 1;                                       // 0x0284(0x0004) (Transient)
	unsigned long                                      bIsHoldEnding : 1;                                        // 0x0284(0x0004) (Transient)
	unsigned long                                      bIgnoreMoveSync : 1;                                      // 0x0284(0x0004) (Transient)
	class ULevelStreamingBlessCinematic*               StreamingLevel;                                           // 0x0288(0x0008) (Transient)
	float                                              SyncDelta;                                                // 0x0290(0x0004) (Transient)
	float                                              SyncTimeToGo;                                             // 0x0294(0x0004) (Transient)
	float                                              SyncTime;                                                 // 0x0298(0x0004) (Transient)
	float                                              TimeOffset;                                               // 0x029C(0x0004) (Transient)
	float                                              TimeToStart;                                              // 0x02A0(0x0004) (Transient)
	unsigned char                                      UnknownData00[0x48];                                      // 0x02A4(0x0048) UNKNOWN PROPERTY: MapProperty BLGame.InterpPlayInstance.ObjectVarInstanceMap

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.InterpPlayInstance");
		return ptr;
	}


	float CurrentOnlinePosition();
};


// Class BLGame.ABLDef
// 0x0000 (0x0060 - 0x0060)
class UABLDef : public UObject
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.ABLDef");
		return ptr;
	}


	struct FPCInfoKey STATIC_MakePCInfoKey(TEnumAsByte<ECERaceType> InRace, TEnumAsByte<ECEGenderType> InGender, TEnumAsByte<ECEClassType> InClass);
};


// Class BLGame.ABLInfoCollectionTypes
// 0x0000 (0x0060 - 0x0060)
class UABLInfoCollectionTypes : public UObject
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.ABLInfoCollectionTypes");
		return ptr;
	}

};


// Class BLGame.ABLUIDef
// 0x0000 (0x0060 - 0x0060)
class UABLUIDef : public UObject
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.ABLUIDef");
		return ptr;
	}

};


// Class BLGame.BLTypes
// 0x0000 (0x0060 - 0x0060)
class UBLTypes : public UObject
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLTypes");
		return ptr;
	}

};


// Class BLGame.CustomizeElement
// 0x000C (0x006C - 0x0060)
class UCustomizeElement : public UObject
{
public:
	TEnumAsByte<ECECustomizeType>                      Type;                                                     // 0x0060(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	class UCustomizeFunctionParameter*                 FunctionParameter;                                        // 0x0064(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CustomizeElement");
		return ptr;
	}

};


// Class BLGame.CustomizeFunctionParameter
// 0x000C (0x006C - 0x0060)
class UCustomizeFunctionParameter : public UObject
{
public:
	TEnumAsByte<ECustomizeModuleType>                  ModuleType;                                               // 0x0060(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	class UCustomizeValueParameter*                    ValueParameter;                                           // 0x0064(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CustomizeFunctionParameter");
		return ptr;
	}

};


// Class BLGame.CustomizeValueParameter
// 0x0004 (0x0064 - 0x0060)
class UCustomizeValueParameter : public UObject
{
public:
	int                                                RawData;                                                  // 0x0060(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CustomizeValueParameter");
		return ptr;
	}

};


// Class BLGame.CustomizeValueParameterColor
// 0x0004 (0x0068 - 0x0064)
class UCustomizeValueParameterColor : public UCustomizeValueParameter
{
public:
	struct FColor                                      Value;                                                    // 0x0064(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CustomizeValueParameterColor");
		return ptr;
	}

};


// Class BLGame.CustomizeValueParameterFloat
// 0x0004 (0x0068 - 0x0064)
class UCustomizeValueParameterFloat : public UCustomizeValueParameter
{
public:
	float                                              Value;                                                    // 0x0064(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CustomizeValueParameterFloat");
		return ptr;
	}

};


// Class BLGame.CustomizeValueParameterHairAsset
// 0x0008 (0x006C - 0x0064)
class UCustomizeValueParameterHairAsset : public UCustomizeValueParameter
{
public:
	class UHairAsset*                                  Value;                                                    // 0x0064(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CustomizeValueParameterHairAsset");
		return ptr;
	}

};


// Class BLGame.CustomizeValueParameterInt
// 0x0004 (0x0068 - 0x0064)
class UCustomizeValueParameterInt : public UCustomizeValueParameter
{
public:
	int                                                Value;                                                    // 0x0064(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CustomizeValueParameterInt");
		return ptr;
	}

};


// Class BLGame.CustomizeValueParameterMesh
// 0x0008 (0x006C - 0x0064)
class UCustomizeValueParameterMesh : public UCustomizeValueParameter
{
public:
	class USkeletalMesh*                               Value;                                                    // 0x0064(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CustomizeValueParameterMesh");
		return ptr;
	}

};


// Class BLGame.CustomizeValueParameterMorphTarget
// 0x0020 (0x0084 - 0x0064)
class UCustomizeValueParameterMorphTarget : public UCustomizeValueParameter
{
public:
	class UTexture2D*                                  Value;                                                    // 0x0064(0x0008)
	struct FName                                       SelectedMorphTargetName;                                  // 0x006C(0x0008)
	TArray<struct FName>                               DeselectedMorphTargetNameList;                            // 0x0074(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CustomizeValueParameterMorphTarget");
		return ptr;
	}

};


// Class BLGame.CustomizeValueParameterMultiTexture
// 0x0010 (0x0074 - 0x0064)
class UCustomizeValueParameterMultiTexture : public UCustomizeValueParameter
{
public:
	TArray<struct FCustomzingMultiTextureResource>     Value;                                                    // 0x0064(0x0010) (AlwaysInit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CustomizeValueParameterMultiTexture");
		return ptr;
	}

};


// Class BLGame.CustomizeValueParameterPreset
// 0x0010 (0x0074 - 0x0064)
class UCustomizeValueParameterPreset : public UCustomizeValueParameter
{
public:
	TArray<struct FCustomizeUISettingInfo>             Value;                                                    // 0x0064(0x0010) (AlwaysInit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CustomizeValueParameterPreset");
		return ptr;
	}

};


// Class BLGame.CustomizeValueParameterTexture
// 0x0008 (0x006C - 0x0064)
class UCustomizeValueParameterTexture : public UCustomizeValueParameter
{
public:
	class UTexture2D*                                  Value;                                                    // 0x0064(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CustomizeValueParameterTexture");
		return ptr;
	}

};


// Class BLGame.SharedTypeWaypointInfo
// 0x0000 (0x0060 - 0x0060)
class USharedTypeWaypointInfo : public UObject
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.SharedTypeWaypointInfo");
		return ptr;
	}

};


// Class BLGame.BLPhysicalMaterial
// 0x0000 (0x00E4 - 0x00E4)
class UBLPhysicalMaterial : public UPhysicalMaterial
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLPhysicalMaterial");
		return ptr;
	}

};


// Class BLGame.BLPhysicalMaterialProperty
// 0x008C (0x00EC - 0x0060)
class UBLPhysicalMaterialProperty : public UPhysicalMaterialPropertyBase
{
public:
	struct FFOOT_STEP_EFFECT_INFO                      FootStepEffectInfo;                                       // 0x0060(0x0070) (Edit)
	TArray<struct FFOOT_STEP_EFFECT_INFO_SPECIAL>      FootStepEffectInfoSpecial;                                // 0x00D0(0x0010) (Edit, NeedCtorLink)
	class UBLPhysMatSound*                             Sound;                                                    // 0x00E0(0x0008) (Edit)
	struct FColor                                      DustColor;                                                // 0x00E8(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLPhysicalMaterialProperty");
		return ptr;
	}

};


// Class BLGame.BLPhysMatSound
// 0x0008 (0x0068 - 0x0060)
class UBLPhysMatSound : public UObject
{
public:
	struct FName                                       LandMaterialParamName;                                    // 0x0060(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLPhysMatSound");
		return ptr;
	}

};


// Class BLGame.BLProjectile
// 0x018C (0x047C - 0x02F0)
class ABLProjectile : public AUDKProjectile
{
public:
	class UParticleSystemComponent*                    ProjEffects;                                              // 0x02F0(0x0008) (ExportObject, Component, EditInline)
	class UParticleSystemComponent*                    ContrailEffects;                                          // 0x02F8(0x0008) (ExportObject, Component, EditInline)
	class UParticleSystemComponent*                    ExplodeEffects;                                           // 0x0300(0x0008) (ExportObject, Component, EditInline)
	class UParticleSystem*                             ProjExplosionTemplate;                                    // 0x0308(0x0008) (Transient)
	class UParticleSystem*                             ProjRemainTemplate;                                       // 0x0310(0x0008) (Transient)
	class UUDKExplosionLight*                          ImpactLight;                                              // 0x0318(0x0008) (ExportObject, Component, EditInline)
	unsigned long                                      bWaitForEffects : 1;                                      // 0x0320(0x0004)
	unsigned long                                      bArrived : 1;                                             // 0x0320(0x0004) (Transient)
	unsigned long                                      bDoingFadeOut : 1;                                        // 0x0320(0x0004) (Transient)
	unsigned long                                      bUseFadeOut : 1;                                          // 0x0320(0x0004) (Transient)
	unsigned long                                      bNextTickArrive : 1;                                      // 0x0320(0x0004)
	unsigned long                                      bEnableUpdateDLE : 1;                                     // 0x0320(0x0004)
	class AActor*                                      TargetActor;                                              // 0x0324(0x0008)
	int                                                AttackerID;                                               // 0x032C(0x0004)
	int                                                DamagerID;                                                // 0x0330(0x0004)
	struct FVector                                     PrevLocation;                                             // 0x0334(0x000C)
	int                                                BroadwayNodeInstID;                                       // 0x0340(0x0004)
	float                                              FadeOutTime;                                              // 0x0344(0x0004)
	float                                              InvFadeOutTime;                                           // 0x0348(0x0004)
	float                                              FlyingDistance;                                           // 0x034C(0x0004)
	struct FProjectileFlyingInfo                       DefaultInfo;                                              // 0x0350(0x00B4) (Transient)
	struct FMatrix3x4Trans                             BZGeometry;                                               // 0x0404(0x0030)
	struct FVector                                     SpawnedLoc;                                               // 0x0434(0x000C)
	float                                              BZTime;                                                   // 0x0440(0x0004)
	float                                              FlyingTime;                                               // 0x0444(0x0004)
	struct FVector                                     HitNormal;                                                // 0x0448(0x000C)
	int                                                ApplyInfoIndex;                                           // 0x0454(0x0004)
	int                                                ApplyInfoSetKey;                                          // 0x0458(0x0004)
	int                                                ApplyTargetID;                                            // 0x045C(0x0004)
	float                                              UpdateDLERadius;                                          // 0x0460(0x0004)
	float                                              UpdateDLETimer;                                           // 0x0464(0x0004)
	float                                              UpdateDLEIntervalTime;                                    // 0x0468(0x0004) (Const)
	struct FScriptDelegate                             __OnExplodeProjectile__Delegate;                          // 0x046C(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x046C(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLProjectile");
		return ptr;
	}


	void UpdateDLE(float InDeltaTime);
	bool GetDustColor(const struct FVector& InCheckLocation, struct FColor* OutDustColor);
	bool IsExploded();
	void PostBeginPlay();
	void ExplodeNow();
	void Explode(const struct FVector& HitLocation, const struct FVector& a_HitNormal);
	void FellOutOfWorld(class UClass* dmgType);
	void SpawnRemainEffects(const struct FVector& HitLocation, const struct FVector& a_HitNormal);
	bool IsNearlyZero(const struct FVector& InVector);
	struct FVector GetProjectileAttachRelativeLocation(class ABLPawnBase* InAttachPawn, const struct FName& InAttachBoneName, const struct FVector& InWorldLoc);
	struct FRotator GetProjectileAttachRotator(class ABLPawnBase* InAttachPawn, const struct FName& InAttachBoneName, const struct FRotator& InProjRot);
	void RemoveImpactLight();
	void SpawnFlightEffects(class UParticleSystem* InFlightPS, class UParticleSystem* InContrailPS, const struct FProjectileImpactLightInfo& InFlightImpactLight);
	void MyOnLightFinished(class UUDKExplosionLight* InLight);
	void MyOnParticleSystemFinished(class UParticleSystemComponent* PSC);
	void OnExplodeProjectile(int a_BroadwayesID);
	void Tick(float a_DeltaTime);
	void ProcessFadeOut(float a_DeltaTime);
	void FadeOut();
	void Cleaup();
	void SetMoveResult(class ABLPawnBase* InTargetPawn);
	void SetApplyInfo(class ABLPawnBase* InTargetPawn, int InApplyInfoSetKey, int InApplyInfoIndex, int InApplyTargetID);
	float GetImpactLightMaxRadius(class UUDKExplosionLight* InLight);
	void SetProjectileInfo(int a_NodeInstID, class UProjectileInfo* a_Info, const struct FProjectileFlyingInfo& a_FlyingInfo, bool a_Hidden);
	void SetBroadwayNodeInstID(int a_NodeInstID);
	void UpdateVelocity(float a_DeltaTime);
	void InitNative();
};


// Class BLGame.ProjectileInfo
// 0x0050 (0x00B0 - 0x0060)
class UProjectileInfo : public UObject
{
public:
	class UParticleSystem*                             FlightEmitter;                                            // 0x0060(0x0008) (Edit)
	class UParticleSystem*                             ContrailEmitter;                                          // 0x0068(0x0008) (Edit)
	class UParticleSystem*                             ExplosionEmitter;                                         // 0x0070(0x0008) (Edit)
	class UMaterialInstance*                           ExplosionDecal;                                           // 0x0078(0x0008) (Edit)
	class UParticleSystem*                             RemainEmitter;                                            // 0x0080(0x0008) (Edit)
	class UObject*                                     ImpactLightCustom;                                        // 0x0088(0x0008) (Edit)
	TEnumAsByte<EBAR_ImpactLight>                      ImpactLightType;                                          // 0x0090(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0091(0x0003) MISSED OFFSET
	float                                              Radius;                                                   // 0x0094(0x0004) (Edit)
	float                                              Strength;                                                 // 0x0098(0x0004) (Edit)
	float                                              Speed;                                                    // 0x009C(0x0004) (Edit)
	float                                              Pressure;                                                 // 0x00A0(0x0004) (Edit)
	float                                              SpreadSpeed;                                              // 0x00A4(0x0004) (Edit)
	class UTexture2D*                                  WindPattern;                                              // 0x00A8(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.ProjectileInfo");
		return ptr;
	}

};


// Class BLGame.BLAkAmbientSoundEvent
// 0x0020 (0x0080 - 0x0060)
class UBLAkAmbientSoundEvent : public UObject
{
public:
	class UAkEvent*                                    PlayEvent;                                                // 0x0060(0x0008) (Transient)
	class UAkEvent*                                    StopEvent;                                                // 0x0068(0x0008) (Transient)
	int                                                Group;                                                    // 0x0070(0x0004) (Transient)
	int                                                Priority;                                                 // 0x0074(0x0004) (Transient)
	class AActor*                                      Initiator;                                                // 0x0078(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAkAmbientSoundEvent");
		return ptr;
	}


	void Stop();
	void Play();
};


// Class BLGame.BLAkVolumeBase
// 0x0000 (0x028C - 0x028C)
class ABLAkVolumeBase : public AVolume
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAkVolumeBase");
		return ptr;
	}

};


// Class BLGame.BLAkReverbToggleVolume
// 0x0024 (0x02B0 - 0x028C)
class ABLAkReverbToggleVolume : public ABLAkVolumeBase
{
public:
	class UAkEvent*                                    ReverbOnEvent;                                            // 0x028C(0x0008) (Edit, Transient, EditConst)
	class UAkEvent*                                    ReverbOffEvent;                                           // 0x0294(0x0008) (Edit, Transient, EditConst)
	struct FString                                     Param;                                                    // 0x029C(0x0010) (NeedCtorLink)
	float                                              DecayValue;                                               // 0x02AC(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAkReverbToggleVolume");
		return ptr;
	}


	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void Reverb(bool bTouch);
};


// Class BLGame.BLAkSetupVolumeBase
// 0x0044 (0x02D0 - 0x028C)
class ABLAkSetupVolumeBase : public ABLAkVolumeBase
{
public:
	struct FString                                     StateGroup;                                               // 0x028C(0x0010) (Edit, NeedCtorLink)
	class UAkBank*                                     ToLoadBank;                                               // 0x029C(0x0008) (Edit)
	class UAkEvent*                                    PlayEvent;                                                // 0x02A4(0x0008) (Edit)
	class UAkEvent*                                    StopEvent;                                                // 0x02AC(0x0008) (Edit)
	float                                              StopDelayTime;                                            // 0x02B4(0x0004) (Edit)
	unsigned long                                      bStopFlag : 1;                                            // 0x02B8(0x0004) (Transient)
	float                                              ElapsedTime;                                              // 0x02BC(0x0004) (Transient)
	TArray<class ABLAkZoneStateVolumeBase*>            ChildVolumes;                                             // 0x02C0(0x0010) (Edit, NeedCtorLink, Deprecated)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAkSetupVolumeBase");
		return ptr;
	}


	void Destroyed();
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void StopAmbientSound();
	void PlayAmbientSound();
};


// Class BLGame.BLAkAmbientSetupVolume
// 0x0000 (0x02D0 - 0x02D0)
class ABLAkAmbientSetupVolume : public ABLAkSetupVolumeBase
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAkAmbientSetupVolume");
		return ptr;
	}

};


// Class BLGame.BLAkBGMSetupVolume
// 0x0000 (0x02D0 - 0x02D0)
class ABLAkBGMSetupVolume : public ABLAkSetupVolumeBase
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAkBGMSetupVolume");
		return ptr;
	}

};


// Class BLGame.BLAkZoneStateVolumeBase
// 0x0044 (0x02D0 - 0x028C)
class ABLAkZoneStateVolumeBase : public ABLAkVolumeBase
{
public:
	struct FString                                     StateGroup;                                               // 0x028C(0x0010) (Edit, EditConst, NeedCtorLink)
	struct FString                                     State;                                                    // 0x029C(0x0010) (Edit, NeedCtorLink)
	TEnumAsByte<EGradeChar>                            Grade;                                                    // 0x02AC(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x02AD(0x0003) MISSED OFFSET
	class ABLAkSetupVolumeBase*                        GroupVolume;                                              // 0x02B0(0x0008) (Edit, EditConst)
	class ABLAkZoneStateVolumeBase*                    Parent;                                                   // 0x02B8(0x0008) (Edit, EditConst)
	TArray<class ABLAkZoneStateVolumeBase*>            Childs;                                                   // 0x02C0(0x0010) (Edit, NeedCtorLink, Deprecated)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAkZoneStateVolumeBase");
		return ptr;
	}


	void Destroyed();
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void SetAmbientState(bool bTouch, class AActor* Other);
};


// Class BLGame.BLAkAmbientZoneStateVolume
// 0x0000 (0x02D0 - 0x02D0)
class ABLAkAmbientZoneStateVolume : public ABLAkZoneStateVolumeBase
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAkAmbientZoneStateVolume");
		return ptr;
	}

};


// Class BLGame.BLAkBGMZoneStateVolume
// 0x0000 (0x02D0 - 0x02D0)
class ABLAkBGMZoneStateVolume : public ABLAkZoneStateVolumeBase
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAkBGMZoneStateVolume");
		return ptr;
	}

};


// Class BLGame.BLChallengeTowerEntranceVolume
// 0x0028 (0x02B4 - 0x028C)
class ABLChallengeTowerEntranceVolume : public AVolume
{
public:
	struct FString                                     VolumeName;                                               // 0x028C(0x0010) (Edit, NeedCtorLink)
	struct FString                                     ChallengeTowerCodeName;                                   // 0x029C(0x0010) (Edit, NeedCtorLink)
	int                                                ChallengeTowerVolumeCid;                                  // 0x02AC(0x0004) (Edit, EditConst)
	int                                                ChallengeTowerCid;                                        // 0x02B0(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLChallengeTowerEntranceVolume");
		return ptr;
	}


	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class BLGame.BLChallengeTowerExitVolume
// 0x0028 (0x02B4 - 0x028C)
class ABLChallengeTowerExitVolume : public AVolume
{
public:
	struct FString                                     VolumeName;                                               // 0x028C(0x0010) (Edit, NeedCtorLink)
	struct FString                                     ChallengeTowerCodeName;                                   // 0x029C(0x0010) (Edit, NeedCtorLink)
	int                                                ChallengeTowerVolumeCid;                                  // 0x02AC(0x0004) (Edit, EditConst)
	int                                                ChallengeTowerCid;                                        // 0x02B0(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLChallengeTowerExitVolume");
		return ptr;
	}


	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class BLGame.BLCustomVolume
// 0x0004 (0x0290 - 0x028C)
class ABLCustomVolume : public ATriggerVolume
{
public:
	int                                                Priority;                                                 // 0x028C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLCustomVolume");
		return ptr;
	}


	bool EncompassesWithExtent(class AActor* InCheckActor);
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class BLGame.BLAkAmbientVolume
// 0x0024 (0x02B4 - 0x0290)
class ABLAkAmbientVolume : public ABLCustomVolume
{
public:
	class UAkEvent*                                    PlayEvent;                                                // 0x0290(0x0008) (Edit)
	class UAkEvent*                                    StopEvent;                                                // 0x0298(0x0008) (Edit)
	int                                                Group;                                                    // 0x02A0(0x0004) (Edit)
	class ABlessPC*                                    Touched;                                                  // 0x02A4(0x0008) (Transient)
	class UBLAkAmbientSoundEvent*                      BindAmbEvent;                                             // 0x02AC(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAkAmbientVolume");
		return ptr;
	}


	void UnTouchAmbientVolume(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void PostBeginPlay();
};


// Class BLGame.BLNpcFactoryDummyVolume
// 0x0010 (0x02A0 - 0x0290)
class ABLNpcFactoryDummyVolume : public ABLCustomVolume
{
public:
	struct FString                                     CodeName;                                                 // 0x0290(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLNpcFactoryDummyVolume");
		return ptr;
	}


	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void NotifyTerritoryVolumeTouch(bool isTouch);
};


// Class BLGame.BLZoneVolume
// 0x002C (0x02BC - 0x0290)
class ABLZoneVolume : public ABLCustomVolume
{
public:
	int                                                Cid;                                                      // 0x0290(0x0004) (Edit)
	struct FString                                     CodeName;                                                 // 0x0294(0x0010) (Edit, EditConst, NeedCtorLink)
	struct FString                                     LocalizeName;                                             // 0x02A4(0x0010) (Edit, EditConst, NeedCtorLink)
	TEnumAsByte<ECELocationLevelType>                  LocationLevelType;                                        // 0x02B4(0x0001) (Edit, EditConst)
	TEnumAsByte<ECEZonePVPIconType>                    ZonePVPIconType;                                          // 0x02B5(0x0001) (Edit, EditConst)
	unsigned char                                      UnknownData00[0x2];                                       // 0x02B6(0x0002) MISSED OFFSET
	int                                                Parent;                                                   // 0x02B8(0x0004) (Edit, EditConst)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLZoneVolume");
		return ptr;
	}


	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void NotifyTerritoryVolumeTouch(bool isTouch);
};


// Class BLGame.BLDungeonEntranceVolume
// 0x0028 (0x02B4 - 0x028C)
class ABLDungeonEntranceVolume : public AVolume
{
public:
	struct FString                                     VolumeName;                                               // 0x028C(0x0010) (Edit, NeedCtorLink)
	struct FString                                     DungeonEntranceGroupCodeName;                             // 0x029C(0x0010) (Edit, NeedCtorLink)
	int                                                DungeonEntranceVolCid;                                    // 0x02AC(0x0004)
	int                                                DungeonEntranceGroupCid;                                  // 0x02B0(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLDungeonEntranceVolume");
		return ptr;
	}


	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class BLGame.BLDungeonExitVolume
// 0x0024 (0x02B0 - 0x028C)
class ABLDungeonExitVolume : public AVolume
{
public:
	struct FString                                     VolumeName;                                               // 0x028C(0x0010) (Edit, NeedCtorLink)
	struct FString                                     InstanceDungeonCodeName;                                  // 0x029C(0x0010) (Edit, NeedCtorLink)
	int                                                DungeonEntranceVolCid;                                    // 0x02AC(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLDungeonExitVolume");
		return ptr;
	}


	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class BLGame.BLEnvironmentVolume
// 0x00BC (0x0348 - 0x028C)
class ABLEnvironmentVolume : public AVolume
{
public:
	int                                                Priority;                                                 // 0x028C(0x0004) (Edit)
	unsigned long                                      bForceDetachInterpTime : 1;                               // 0x0290(0x0004) (Transient)
	unsigned long                                      bFlagLight : 1;                                           // 0x0290(0x0004) (Edit)
	unsigned long                                      bLightEnabled : 1;                                        // 0x0290(0x0004) (Edit)
	unsigned long                                      bFlagLightShafts : 1;                                     // 0x0290(0x0004) (Edit)
	unsigned long                                      bRenderLightShafts : 1;                                   // 0x0290(0x0004) (Edit)
	unsigned long                                      bFlagWind : 1;                                            // 0x0290(0x0004) (Edit)
	unsigned long                                      bFlagHeightFog : 1;                                       // 0x0290(0x0004) (Edit)
	unsigned long                                      bFlagLensFlare : 1;                                       // 0x0290(0x0004) (Edit)
	unsigned long                                      bExponentialHeightFogEnabled : 1;                         // 0x0290(0x0004) (Edit)
	unsigned long                                      bFlagExponentialHeightFog : 1;                            // 0x0290(0x0004) (Edit)
	float                                              Brightness;                                               // 0x0294(0x0004) (Edit)
	struct FColor                                      LightColor;                                               // 0x0298(0x0004) (Edit)
	float                                              LightInterpolateTime;                                     // 0x029C(0x0004) (Edit)
	float                                              BloomScale;                                               // 0x02A0(0x0004) (Edit)
	float                                              BloomScreenBlendThreshold;                                // 0x02A4(0x0004) (Edit)
	float                                              BloomThreshold;                                           // 0x02A8(0x0004) (Edit)
	struct FColor                                      BloomTint;                                                // 0x02AC(0x0004) (Edit)
	float                                              OcclusionDepthRange;                                      // 0x02B0(0x0004) (Edit)
	float                                              OcclusionMaskDarkness;                                    // 0x02B4(0x0004) (Edit)
	float                                              RadialBlurPercent;                                        // 0x02B8(0x0004) (Edit)
	float                                              LightShaftInterpolateTime;                                // 0x02BC(0x0004) (Edit)
	struct FString                                     RefDirectWindTag;                                         // 0x02C0(0x0010) (Edit, NeedCtorLink)
	float                                              WindStrength;                                             // 0x02D0(0x0004) (Edit)
	float                                              WindSpeed;                                                // 0x02D4(0x0004) (Edit)
	float                                              WindInterpolateTime;                                      // 0x02D8(0x0004) (Edit)
	class UWindDirectionalSourceComponent*             RefDirectWindInstance;                                    // 0x02DC(0x0008) (ExportObject, Transient, Component, EditInline)
	TArray<struct FHeightFogValue>                     HeightFogs;                                               // 0x02E4(0x0010) (Edit, Component, NeedCtorLink, EditInline)
	TArray<struct FLensFlareValue>                     LensFlares;                                               // 0x02F4(0x0010) (Edit, Component, NeedCtorLink, EditInline)
	struct FString                                     RefExponentialHeightFogTag;                               // 0x0304(0x0010) (Edit, NeedCtorLink)
	class UExponentialHeightFogComponent*              RefExponentialHeightFogInst;                              // 0x0314(0x0008) (ExportObject, Transient, Component, EditInline)
	float                                              FogDensity;                                               // 0x031C(0x0004) (Edit)
	float                                              FogHeightFalloff;                                         // 0x0320(0x0004) (Edit)
	float                                              FogMaxOpacity;                                            // 0x0324(0x0004) (Edit)
	float                                              StartDistance;                                            // 0x0328(0x0004) (Edit)
	float                                              LightTerminatorAngle;                                     // 0x032C(0x0004) (Edit)
	float                                              OppositeLightBrightness;                                  // 0x0330(0x0004) (Edit)
	struct FColor                                      OppositeLightColor;                                       // 0x0334(0x0004) (Edit)
	float                                              LightInscatteringBrightness;                              // 0x0338(0x0004) (Edit)
	struct FColor                                      LightInscatteringColor;                                   // 0x033C(0x0004) (Edit)
	float                                              ExponentialHeightFogLocZ;                                 // 0x0340(0x0004) (Edit)
	float                                              ExponentialHeightFogInterpolateTime;                      // 0x0344(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLEnvironmentVolume");
		return ptr;
	}


	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	class UObject* FindInstanceWithTag(const struct FString& TagString, class UClass* BaseClass);
	void PostBeginPlay();
};


// Class BLGame.BLEnvPPVolume
// 0x0184 (0x06D0 - 0x054C)
class ABLEnvPPVolume : public APostProcessVolume
{
public:
	struct FBLEnvVolumeSettings                        DefaultEnvVolumeSettings;                                 // 0x054C(0x0170) (Edit, Component, NeedCtorLink)
	TArray<struct FBLEnvVolumeSettings>                EnvVolumeSettings_ForTOD;                                 // 0x06BC(0x0010) (Edit, Component, NeedCtorLink)
	unsigned long                                      bForceDetachInterpTime : 1;                               // 0x06CC(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLEnvPPVolume");
		return ptr;
	}


	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	class UObject* FindInstanceWithTag(const struct FString& TagString, class UClass* BaseClass);
	void PostBeginPlay();
};


// Class BLGame.BLSpiritVolume
// 0x0000 (0x06D0 - 0x06D0)
class ABLSpiritVolume : public ABLEnvPPVolume
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLSpiritVolume");
		return ptr;
	}

};


// Class BLGame.BLTransportVolume
// 0x0000 (0x06D0 - 0x06D0)
class ABLTransportVolume : public ABLEnvPPVolume
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLTransportVolume");
		return ptr;
	}


	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class BLGame.BLNpcFactoryActor
// 0x0044 (0x0294 - 0x0250)
class ABLNpcFactoryActor : public AActor
{
public:
	class USpriteComponent*                            SpriteComp;                                               // 0x0250(0x0008) (Edit, ExportObject, Component, EditInline)
	unsigned long                                      MoveStickToGeometry : 1;                                  // 0x0258(0x0004) (Edit)
	unsigned long                                      NotifyStopToParent : 1;                                   // 0x0258(0x0004)
	float                                              LineCheckOffset;                                          // 0x025C(0x0004) (Edit)
	class ABLNpcFactoryVolume*                         ParentVolume;                                             // 0x0260(0x0008) (Edit)
	struct FString                                     Named;                                                    // 0x0268(0x0010) (Edit, NeedCtorLink)
	struct FString                                     ActorPathway;                                             // 0x0278(0x0010) (Edit, NeedCtorLink)
	unsigned char                                      SavedDPGIndex;                                            // 0x0288(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0289(0x0003) MISSED OFFSET
	class UBLNpcFactoryActorArrowComponent*            ArrowComp;                                                // 0x028C(0x0008) (ExportObject, Transient, Component, EditInline)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLNpcFactoryActor");
		return ptr;
	}


	void SpriteHiddenGame(bool InHidden);
	void PostBeginPlay();
};


// Class BLGame.BLNpcFactoryActorArrowComponent
// 0x0010 (0x0248 - 0x0238)
class UBLNpcFactoryActorArrowComponent : public UPrimitiveComponent
{
public:
	struct FColor                                      ArrowColor;                                               // 0x0238(0x0004) (Edit)
	float                                              ArrowSize;                                                // 0x023C(0x0004) (Edit)
	struct FName                                       SpriteCategoryName;                                       // 0x0240(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLNpcFactoryActorArrowComponent");
		return ptr;
	}

};


// Class BLGame.BLNpcFactoryVolume
// 0x00B4 (0x0340 - 0x028C)
class ABLNpcFactoryVolume : public AVolume
{
public:
	struct FString                                     VolumeName;                                               // 0x028C(0x0010) (Edit, NeedCtorLink)
	struct FString                                     VolumeCopyFrom;                                           // 0x029C(0x0010) (Edit, NeedCtorLink)
	struct FString                                     OwningZoneVolumeName;                                     // 0x02AC(0x0010) (Edit, EditConst, NeedCtorLink)
	struct FBLNpcFactoryPropperty                      NpcFactoryVolumeProperty;                                 // 0x02BC(0x0050) (Edit, NeedCtorLink)
	TArray<class ABLNpcFactoryActor*>                  GeneratedActors;                                          // 0x030C(0x0010) (NeedCtorLink)
	unsigned long                                      bEnableNotify : 1;                                        // 0x031C(0x0004)
	unsigned long                                      bSupressZoneVolumeOverlapCheck : 1;                       // 0x031C(0x0004) (Edit)
	TArray<struct FBLLevel>                            Level;                                                    // 0x0320(0x0010) (Edit, NeedCtorLink)
	TArray<struct FBLLevel>                            LevelBackup;                                              // 0x0330(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLNpcFactoryVolume");
		return ptr;
	}

};


// Class BLGame.BLRaidFieldActor
// 0x0010 (0x0260 - 0x0250)
class ABLRaidFieldActor : public AActor
{
public:
	class USpriteComponent*                            SpriteComp;                                               // 0x0250(0x0008) (Edit, ExportObject, Component, EditInline)
	float                                              LineCheckOffset;                                          // 0x0258(0x0004) (Edit)
	unsigned long                                      MoveStickToGeometry : 1;                                  // 0x025C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLRaidFieldActor");
		return ptr;
	}


	void PostBeginPlay();
};


// Class BLGame.BLRaidFieldVolumeBase
// 0x0048 (0x02D4 - 0x028C)
class ABLRaidFieldVolumeBase : public AVolume
{
public:
	struct FString                                     VolumeName;                                               // 0x028C(0x0010) (Edit, NeedCtorLink)
	struct FString                                     RaidFieldName;                                            // 0x029C(0x0010) (Edit, NeedCtorLink)
	int                                                RaidFieldCid;                                             // 0x02AC(0x0004) (Edit, EditConst)
	class UPropAsset*                                  PropAsset;                                                // 0x02B0(0x0008) (Edit)
	class ABLRaidFieldActor*                           PropActor;                                                // 0x02B8(0x0008) (Edit)
	struct FGuid                                       SpawnPropGuid;                                            // 0x02C0(0x0010)
	int                                                RaidFieldVolCid;                                          // 0x02D0(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLRaidFieldVolumeBase");
		return ptr;
	}

};


// Class BLGame.BLRaidFieldEntranceVolume
// 0x0000 (0x02D4 - 0x02D4)
class ABLRaidFieldEntranceVolume : public ABLRaidFieldVolumeBase
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLRaidFieldEntranceVolume");
		return ptr;
	}


	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class BLGame.BLRaidFieldExitVolume
// 0x0000 (0x02D4 - 0x02D4)
class ABLRaidFieldExitVolume : public ABLRaidFieldVolumeBase
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLRaidFieldExitVolume");
		return ptr;
	}


	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
};


// Class BLGame.BLTerritoryVolume
// 0x0014 (0x02A0 - 0x028C)
class ABLTerritoryVolume : public AVolume
{
public:
	TEnumAsByte<ETerritoryVolumeType>                  VolumeType;                                               // 0x028C(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x028D(0x0003) MISSED OFFSET
	struct FString                                     VolumeName;                                               // 0x0290(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLTerritoryVolume");
		return ptr;
	}

};


// Class BLGame.BLWaterVolume
// 0x0030 (0x032C - 0x02FC)
class ABLWaterVolume : public AWaterVolume
{
public:
	class UAkEvent*                                    EntryAkEvent;                                             // 0x02FC(0x0008) (Edit)
	class UAkEvent*                                    ExitAkEvent;                                              // 0x0304(0x0008) (Edit)
	class UAkEvent*                                    PlayEvent;                                                // 0x030C(0x0008) (Edit)
	class UAkEvent*                                    StopEvent;                                                // 0x0314(0x0008) (Edit)
	int                                                Group;                                                    // 0x031C(0x0004) (Edit)
	int                                                AmbientEventPriority;                                     // 0x0320(0x0004) (Edit)
	class UBLAkAmbientSoundEvent*                      InnerAmbientSoundEvent;                                   // 0x0324(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLWaterVolume");
		return ptr;
	}


	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void PostBeginPlay();
};


// Class BLGame.AutoFiringComponent
// 0x0029 (0x0099 - 0x0070)
class UAutoFiringComponent : public UComponent
{
public:
	int                                                ToggleSkillIndex;                                         // 0x0070(0x0004)
	int                                                SkillCid;                                                 // 0x0074(0x0004)
	class ABlessPC*                                    PC;                                                       // 0x0078(0x0008)
	unsigned long                                      bIsChainSkill : 1;                                        // 0x0080(0x0004)
	unsigned long                                      bIsCastingSkill : 1;                                      // 0x0080(0x0004)
	int                                                TargetID;                                                 // 0x0084(0x0004)
	class UActionMappingManager*                       AMManager;                                                // 0x0088(0x0008)
	float                                              ElapsedTime;                                              // 0x0090(0x0004)
	float                                              AutoFiringWaitingUserInputTime;                           // 0x0094(0x0004) (Config)
	TEnumAsByte<EToggleAutoFiringState>                FiringState;                                              // 0x0098(0x0001)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.AutoFiringComponent");
		return ptr;
	}


	bool IsInSkillRange(class ABLPawnBase* InPlayerPawn, class ABLPawnBase* InTargetPawn, float InUpperLimit, float InAngleDegree);
	void DoAutoFiringSkill(int PendingSkillID);
	void Tick(float DeltaTime);
	int GetAutoFiringSkillID();
	void ToggleSkillFiring();
	void SetPlayerSkillCanceledDelegate();
	void ToggleSkillReady();
	void ToggleSkillOff();
	void ToggleSkillOn(int UISlotIdx);
	void ToggleSkillClear();
	void Initialize();
	bool SkillInfoSetting(int SlotIdx);
	bool CheckRegistPendingSkill();
};


// Class BLGame.BLAkAmbientEventComponent
// 0x001F (0x00A4 - 0x0085)
class UBLAkAmbientEventComponent : public UActorComponent
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0085(0x0003) MISSED OFFSET
	float                                              PlayCheckTime;                                            // 0x0088(0x0004)
	TArray<class UBLAkAmbientSoundEvent*>              AmbientEvents;                                            // 0x008C(0x0010) (Transient, NeedCtorLink)
	class UBLAkAmbientSoundEvent*                      CurrentAmbientEvent;                                      // 0x009C(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAkAmbientEventComponent");
		return ptr;
	}


	void ProcessEventComponent(float DeltaTime);
	void DetachSoundEvent(class UBLAkAmbientSoundEvent* AmbEvent);
	void AttachSoundEvent(class UBLAkAmbientSoundEvent* AmbSoundEvent);
	void InitEventComponent(class APawn* inPawn);
	void SetCurrentAmbientEvent(class UBLAkAmbientSoundEvent* SoundEvent);
	class UBLAkAmbientSoundEvent* GetCurrentAmbientEvent();
};


// Class BLGame.BLCustomVolumeComponent
// 0x002F (0x00B4 - 0x0085)
class UBLCustomVolumeComponent : public UActorComponent
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0085(0x0003) MISSED OFFSET
	TArray<class ABLCustomVolume*>                     VolumeList;                                               // 0x0088(0x0010) (Transient, NeedCtorLink)
	class ABLCustomVolume*                             ChangedVolume;                                            // 0x0098(0x0008)
	class ABLCustomVolume*                             CurrentVolume;                                            // 0x00A0(0x0008)
	unsigned long                                      bChangedVolumeList : 1;                                   // 0x00A8(0x0004)
	class APawn*                                       TargetPawn;                                               // 0x00AC(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLCustomVolumeComponent");
		return ptr;
	}


	void InitVolumeComponent(class APawn* inPawn);
	void ProcessVolumeListEmpty();
	void ProcessCurrentVolume();
	class APawn* GetTargetPawn();
	void SetTargetPawn(class APawn* inPawn);
	class ABLCustomVolume* GetCurrentVolume();
	void SetCurrentVolume(class ABLCustomVolume* InVolume);
	bool CheckSameCurrentVolume();
	bool IsChangedVolume();
	class ABLCustomVolume* GetChangedVolume();
	void SetChangedVolume(class ABLCustomVolume* InVolume);
	bool CheckChangedVolume();
	bool IsChangedVolumeList();
	void SetChangedVolumeListFlag(bool bFlag);
	void ProcessVolumeComponent(float DeltaTime);
	void DetachVolume(class ABLCustomVolume* OutVolume);
	void AttachVolume(class ABLCustomVolume* InVolume);
	bool IsInEncompasses(class ABLCustomVolume* HighVolume, class ABLCustomVolume* LowVolume);
};


// Class BLGame.BLZoneVolumeComponent
// 0x0014 (0x00C8 - 0x00B4)
class UBLZoneVolumeComponent : public UBLCustomVolumeComponent
{
public:
	struct FString                                     PreviousZoneLocalizedName;                                // 0x00B4(0x0010) (NeedCtorLink)
	int                                                CurrentZoneID;                                            // 0x00C4(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLZoneVolumeComponent");
		return ptr;
	}


	int GetNextPriorotyValue(int Order);
	int GetCurrentZoneID();
	void ProcessCurrentVolume();
	bool CheckChangedVolume();
	void AttachVolume(class ABLCustomVolume* InVolume);
};


// Class BLGame.BLEnvComponent
// 0x0047 (0x00CC - 0x0085)
class UBLEnvComponent : public UActorComponent
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0085(0x0003) MISSED OFFSET
	TArray<class UBLEnvCtrlModuleBase*>                Modules;                                                  // 0x0088(0x0010) (NeedCtorLink)
	class AVolume*                                     OverridedEnvVolume;                                       // 0x0098(0x0008) (Transient)
	TArray<class AVolume*>                             AttachedVolumes;                                          // 0x00A0(0x0010) (Transient, NeedCtorLink)
	TArray<class AVolume*>                             WillTouchVolumes;                                         // 0x00B0(0x0010) (Transient, NeedCtorLink)
	class AActor*                                      InteractActor;                                            // 0x00C0(0x0008) (Transient)
	unsigned long                                      bIsDirty : 1;                                             // 0x00C8(0x0004)
	unsigned long                                      bPause : 1;                                               // 0x00C8(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLEnvComponent");
		return ptr;
	}


	void PreTick();
	void AddVolume(class AVolume* InVolume);
	void TouchingWillTouchVolumes();
	void CheckBLEnvVolWhenReset(bool bInteractPawn, class AActor* ForceInteractiveActor);
	void PreInitialize();
	void DetachEnvVol(class AVolume* InVolume);
	void AttachEnvVol(class AVolume* InVolume);
	void ClearOverridedEnvVolume();
	void OverrideVolume(class AVolume* Volume);
	void FlushInterpolatingVolume();
	void Resume(bool bFlush);
	void Pause();
	void Restore();
};


// Class BLGame.BLEnvCtrlModuleBase
// 0x0000 (0x0060 - 0x0060)
class UBLEnvCtrlModuleBase : public UObject
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLEnvCtrlModuleBase");
		return ptr;
	}


	class UDominantDirectionalLightComponent* STATIC_GetDominantDirectionalLightComponent();
	void Initialize();
	void Interpolate(float DeltaTime);
	void DetachEnvPPVolume(class ABLEnvPPVolume* Volume);
	void AttachEnvPPVolume(class ABLEnvPPVolume* Volume);
	void DetachEnvironmentVolume(class ABLEnvironmentVolume* Volume);
	void AttachEnvironmentVolume(class ABLEnvironmentVolume* Volume);
};


// Class BLGame.BLEnvMultiCtrlModule
// 0x0010 (0x0070 - 0x0060)
class UBLEnvMultiCtrlModule : public UBLEnvCtrlModuleBase
{
public:
	TArray<class UBLEnvSingleCtrlModule*>              Modules;                                                  // 0x0060(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLEnvMultiCtrlModule");
		return ptr;
	}


	void Interpolate(float DeltaTime);
	void DetachEnvPPVolume(class ABLEnvPPVolume* Volume);
	void AttachEnvPPVolume(class ABLEnvPPVolume* Volume);
	void DetachEnvironmentVolume(class ABLEnvironmentVolume* Volume);
	void AttachEnvironmentVolume(class ABLEnvironmentVolume* Volume);
};


// Class BLGame.BLEnvHFSuperModule
// 0x0000 (0x0070 - 0x0070)
class UBLEnvHFSuperModule : public UBLEnvMultiCtrlModule
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLEnvHFSuperModule");
		return ptr;
	}


	void Initialize();
	void DetachEnvPPVolume(class ABLEnvPPVolume* Volume);
	void AttachEnvPPVolume(class ABLEnvPPVolume* Volume);
	void DetachEnvironmentVolume(class ABLEnvironmentVolume* Volume);
	void AttachEnvironmentVolume(class ABLEnvironmentVolume* Volume);
};


// Class BLGame.BLEnvLFSuperModule
// 0x0000 (0x0070 - 0x0070)
class UBLEnvLFSuperModule : public UBLEnvMultiCtrlModule
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLEnvLFSuperModule");
		return ptr;
	}


	void Initialize();
	void DetachEnvPPVolume(class ABLEnvPPVolume* Volume);
	void AttachEnvPPVolume(class ABLEnvPPVolume* Volume);
	void DetachEnvironmentVolume(class ABLEnvironmentVolume* Volume);
	void AttachEnvironmentVolume(class ABLEnvironmentVolume* Volume);
};


// Class BLGame.BLEnvSingleCtrlModule
// 0x0014 (0x0074 - 0x0060)
class UBLEnvSingleCtrlModule : public UBLEnvCtrlModuleBase
{
public:
	TEnumAsByte<ETODTimePhase>                         LastTODTimePhase;                                         // 0x0060(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	unsigned long                                      bIsReverse : 1;                                           // 0x0064(0x0004) (Transient)
	unsigned long                                      bInterpPlaying : 1;                                       // 0x0064(0x0004) (Transient)
	unsigned long                                      bIsAttachInterpolation : 1;                               // 0x0064(0x0004) (Transient)
	int                                                ValueStructIndexNumber;                                   // 0x0068(0x0004) (Transient)
	class UActorComponent*                             LinkedInstance;                                           // 0x006C(0x0008) (ExportObject, Transient, Component, EditInline)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLEnvSingleCtrlModule");
		return ptr;
	}


	void SaveCurrentInfo(bool bAddGlobal);
	void PostInterpolate();
	void DetachingEnvPP(class ABLEnvPPVolume* Volume, float InterpTime);
	void AttachingEnvPP(class ABLEnvPPVolume* Volume, float InterpTime);
	void Detaching(class ABLEnvironmentVolume* Volume, float InterpTime);
	void Attaching(class ABLEnvironmentVolume* Volume, float InterpTime);
	void DetachEnvPPVolume(class ABLEnvPPVolume* Volume);
	void AttachEnvPPVolume(class ABLEnvPPVolume* Volume);
	void DetachEnvironmentVolume(class ABLEnvironmentVolume* Volume);
	void AttachEnvironmentVolume(class ABLEnvironmentVolume* Volume);
};


// Class BLGame.BLEnvDirectWindCtrlModule
// 0x006C (0x00E0 - 0x0074)
class UBLEnvDirectWindCtrlModule : public UBLEnvSingleCtrlModule
{
public:
	struct FBLEnvDirectWindInfo                        CurrentInfo;                                              // 0x0074(0x0058) (Transient, NeedCtorLink)
	TArray<struct FBLEnvDirectWindInfo>                EnvVolumeDatas;                                           // 0x00CC(0x0010) (Transient, NeedCtorLink)
	unsigned long                                      bDirtyDirectWind : 1;                                     // 0x00DC(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLEnvDirectWindCtrlModule");
		return ptr;
	}


	void PostInterpolate();
	void DetachEnvPPVolume(class ABLEnvPPVolume* Volume);
	void AttachEnvPPVolume(class ABLEnvPPVolume* Volume);
	void DetachEnvironmentVolume(class ABLEnvironmentVolume* Volume);
	void AttachEnvironmentVolume(class ABLEnvironmentVolume* Volume);
	void DetachingEnvPP(class ABLEnvPPVolume* Volume, float InterpTime);
	void AttachingEnvPP(class ABLEnvPPVolume* Volume, float InterpTime);
	void Detaching(class ABLEnvironmentVolume* Volume, float InterpTime);
	void Attaching(class ABLEnvironmentVolume* Volume, float InterpTime);
	void SaveCurrentInfo(bool bAddGlobal);
};


// Class BLGame.BLEnvExpHeightFogCtrlModule
// 0x00B0 (0x0124 - 0x0074)
class UBLEnvExpHeightFogCtrlModule : public UBLEnvSingleCtrlModule
{
public:
	struct FBLEnvExpHeightFogInfo                      CurrentInfo;                                              // 0x0074(0x00A0) (Transient, NeedCtorLink)
	TArray<struct FBLEnvExpHeightFogInfo>              EnvVolumeDatas;                                           // 0x0114(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLEnvExpHeightFogCtrlModule");
		return ptr;
	}


	void DetachEnvPPVolume(class ABLEnvPPVolume* Volume);
	void AttachEnvPPVolume(class ABLEnvPPVolume* Volume);
	void DetachEnvironmentVolume(class ABLEnvironmentVolume* Volume);
	void AttachEnvironmentVolume(class ABLEnvironmentVolume* Volume);
	void DetachingEnvPP(class ABLEnvPPVolume* Volume, float InterpTime);
	void AttachingEnvPP(class ABLEnvPPVolume* Volume, float InterpTime);
	void Detaching(class ABLEnvironmentVolume* Volume, float InterpTime);
	void Attaching(class ABLEnvironmentVolume* Volume, float InterpTime);
	void SaveCurrentInfo(bool bAddGlobal);
};


// Class BLGame.BLEnvHeightFogCtrlModule
// 0x0090 (0x0104 - 0x0074)
class UBLEnvHeightFogCtrlModule : public UBLEnvSingleCtrlModule
{
public:
	struct FBLEnvHeightFogInfo                         CurrentInfo;                                              // 0x0074(0x0080) (Transient, NeedCtorLink)
	TArray<struct FBLEnvHeightFogInfo>                 EnvVolumeDatas;                                           // 0x00F4(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLEnvHeightFogCtrlModule");
		return ptr;
	}


	void DetachEnvPPVolume(class ABLEnvPPVolume* Volume);
	void AttachEnvPPVolume(class ABLEnvPPVolume* Volume);
	void DetachEnvironmentVolume(class ABLEnvironmentVolume* Volume);
	void AttachEnvironmentVolume(class ABLEnvironmentVolume* Volume);
	void DetachingEnvPP(class ABLEnvPPVolume* Volume, float InterpTime);
	void AttachingEnvPP(class ABLEnvPPVolume* Volume, float InterpTime);
	void Detaching(class ABLEnvironmentVolume* Volume, float InterpTime);
	void Attaching(class ABLEnvironmentVolume* Volume, float InterpTime);
	void SaveCurrentInfo(bool bAddGlobal);
};


// Class BLGame.BLEnvLensFlareCtrlModule
// 0x0060 (0x00D4 - 0x0074)
class UBLEnvLensFlareCtrlModule : public UBLEnvSingleCtrlModule
{
public:
	struct FBLEnvLensFlareInfo                         CurrentInfo;                                              // 0x0074(0x0050) (Transient, NeedCtorLink)
	TArray<struct FBLEnvLensFlareInfo>                 EnvVolumeDatas;                                           // 0x00C4(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLEnvLensFlareCtrlModule");
		return ptr;
	}


	void DetachEnvPPVolume(class ABLEnvPPVolume* Volume);
	void AttachEnvPPVolume(class ABLEnvPPVolume* Volume);
	void DetachEnvironmentVolume(class ABLEnvironmentVolume* Volume);
	void AttachEnvironmentVolume(class ABLEnvironmentVolume* Volume);
	void DetachingEnvPP(class ABLEnvPPVolume* Volume, float InterpTime);
	void AttachingEnvPP(class ABLEnvPPVolume* Volume, float InterpTime);
	void Detaching(class ABLEnvironmentVolume* Volume, float InterpTime);
	void Attaching(class ABLEnvironmentVolume* Volume, float InterpTime);
	void SaveCurrentInfo(bool bAddGlobal);
};


// Class BLGame.BLEnvLightColorCtrlModule
// 0x0088 (0x00FC - 0x0074)
class UBLEnvLightColorCtrlModule : public UBLEnvSingleCtrlModule
{
public:
	struct FBLEnvLightColorInfo                        CurrentInfo;                                              // 0x0074(0x0078) (Transient, NeedCtorLink)
	TArray<struct FBLEnvLightColorInfo>                EnvVolumeDatas;                                           // 0x00EC(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLEnvLightColorCtrlModule");
		return ptr;
	}


	void DetachEnvPPVolume(class ABLEnvPPVolume* Volume);
	void AttachEnvPPVolume(class ABLEnvPPVolume* Volume);
	void DetachEnvironmentVolume(class ABLEnvironmentVolume* Volume);
	void AttachEnvironmentVolume(class ABLEnvironmentVolume* Volume);
	void DetachingEnvPP(class ABLEnvPPVolume* Volume, float InterpTime);
	void AttachingEnvPP(class ABLEnvPPVolume* Volume, float InterpTime);
	void Detaching(class ABLEnvironmentVolume* Volume, float InterpTime);
	void Attaching(class ABLEnvironmentVolume* Volume, float InterpTime);
	void SaveCurrentInfo(bool bAddGlobal);
};


// Class BLGame.BLEnvLightShaftCtrlModule
// 0x009C (0x0110 - 0x0074)
class UBLEnvLightShaftCtrlModule : public UBLEnvSingleCtrlModule
{
public:
	struct FBLEnvLightShaftInfo                        CurrentInfo;                                              // 0x0074(0x0088) (Transient, NeedCtorLink)
	TArray<struct FBLEnvLightShaftInfo>                EnvVolumeDatas;                                           // 0x00FC(0x0010) (Transient, NeedCtorLink)
	unsigned long                                      bDirtyLightShaft : 1;                                     // 0x010C(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLEnvLightShaftCtrlModule");
		return ptr;
	}


	void PostInterpolate();
	void DetachEnvPPVolume(class ABLEnvPPVolume* Volume);
	void AttachEnvPPVolume(class ABLEnvPPVolume* Volume);
	void DetachEnvironmentVolume(class ABLEnvironmentVolume* Volume);
	void AttachEnvironmentVolume(class ABLEnvironmentVolume* Volume);
	void DetachingEnvPP(class ABLEnvPPVolume* Volume, float InterpTime);
	void AttachingEnvPP(class ABLEnvPPVolume* Volume, float InterpTime);
	void Detaching(class ABLEnvironmentVolume* Volume, float InterpTime);
	void Attaching(class ABLEnvironmentVolume* Volume, float InterpTime);
	void SaveCurrentInfo(bool bAddGlobal);
};


// Class BLGame.BLSkillAreaDecalComponent
// 0x004B (0x00D0 - 0x0085)
class UBLSkillAreaDecalComponent : public UActorComponent
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0085(0x0003) MISSED OFFSET
	class ABLDecalActor*                               ShowingDecalActor;                                        // 0x0088(0x0008) (Transient)
	float                                              Huge_Size;                                                // 0x0090(0x0004) (Transient)
	float                                              Large_Size;                                               // 0x0094(0x0004) (Transient)
	float                                              Medium_Size;                                              // 0x0098(0x0004) (Transient)
	float                                              Small_Size;                                               // 0x009C(0x0004) (Transient)
	class UMaterialInstanceTimeVarying*                CurrentAppliedDecal;                                      // 0x00A0(0x0008) (Transient)
	class ABLPawnBase*                                 OwnerPawn;                                                // 0x00A8(0x0008) (Transient)
	class USkillAsset*                                 CurrentSkillAsset;                                        // 0x00B0(0x0008) (Transient)
	float                                              FiringTime;                                               // 0x00B8(0x0004) (Transient)
	float                                              ReleaseTime;                                              // 0x00BC(0x0004) (Transient)
	float                                              MaxTime;                                                  // 0x00C0(0x0004) (Transient)
	float                                              CurrentTime;                                              // 0x00C4(0x0004) (Transient)
	float                                              TimeRate;                                                 // 0x00C8(0x0004) (Transient)
	float                                              DecalOffsetHeight;                                        // 0x00CC(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLSkillAreaDecalComponent");
		return ptr;
	}


	void Tick(float DeltaTime);
	struct FVector GetHitLocation(const struct FVector& OriginLoc);
	void UpdateDecalTransform();
	void UpdateTimeRate(float Rate);
	void HideDecal();
	void ShowDecal(class ABLPawnBase* PlayOwner, class USkillAsset* UseSkillAsset);
	struct FApplyDecalData GetMaterialBySize(const struct FVector2D& DecalSize);
	struct FVector CalcDecalLocation();
	struct FRotator CalcDecalRotation();
};


// Class BLGame.BLTargetDecalComponent
// 0x0000 (0x03C0 - 0x03C0)
class UBLTargetDecalComponent : public UDecalComponent
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLTargetDecalComponent");
		return ptr;
	}

};


// Class BLGame.BLTranslucentSpriteComponent
// 0x0010 (0x0270 - 0x0260)
class UBLTranslucentSpriteComponent : public USpriteComponent
{
public:
	TEnumAsByte<EAlignHotSpot_Vertical>                HotSpotVertical;                                          // 0x0260(0x0001)
	TEnumAsByte<EAlignHotSpot_Horizontal>              HotSpotHorizontal;                                        // 0x0261(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x0262(0x0002) MISSED OFFSET
	struct FVector2D                                   HotSpotOffset;                                            // 0x0264(0x0008)
	int                                                Alpha;                                                    // 0x026C(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLTranslucentSpriteComponent");
		return ptr;
	}


	void SetAlpha(int InA);
	void SetScale(float S);
	void SetRotation(const struct FRotator& R);
};


// Class BLGame.CutInCaptureComponent
// 0x0004 (0x0174 - 0x0170)
class UCutInCaptureComponent : public USceneCapture2DComponent
{
public:
	unsigned long                                      bShowPlayer : 1;                                          // 0x0170(0x0004) (Edit)
	unsigned long                                      bShowOtherPlayers : 1;                                    // 0x0170(0x0004) (Edit)
	unsigned long                                      bShowMonsters : 1;                                        // 0x0170(0x0004) (Edit)
	unsigned long                                      bShowEnvironments : 1;                                    // 0x0170(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CutInCaptureComponent");
		return ptr;
	}

};


// Class BLGame.DeferredSystemMessageComponent
// 0x003C (0x00AC - 0x0070)
class UDeferredSystemMessageComponent : public UComponent
{
public:
	TArray<struct FPendingMessageInfo>                 PendingMessageArray;                                      // 0x0070(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<struct FPendingMessageInfo>                 PendingOverlayMessageArray;                               // 0x0080(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<struct FShowingOverlayCountInfo>            ShowingTable;                                             // 0x0090(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	unsigned long                                      bPause : 1;                                               // 0x00A0(0x0004) (Transient)
	float                                              WaitingTimerForPlay;                                      // 0x00A4(0x0004) (Transient)
	int                                                ProcCountOnTick;                                          // 0x00A8(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.DeferredSystemMessageComponent");
		return ptr;
	}


	void OnPlay();
	void SetPause(bool Toggle, float InWaitingTimeForPlay);
	void STATIC_AddPendingMessageScript(int InMessageCid, TEnumAsByte<ECESystemMessageDisplayType> InType, TEnumAsByte<ECESystemMessageOverlayType> InOverlayType, TEnumAsByte<ECESystemMessagePendingType> InPendingType, TEnumAsByte<ECESystemMessageChatChannelType> InChatChannelType, const struct FString& InMessage, float InOverlayTime, class UGFxObject* inObj);
	void ShowAgain();
	void Initialize();
};


// Class BLGame.DLEChangeComponent
// 0x0037 (0x00BC - 0x0085)
class UDLEChangeComponent : public UActorComponent
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0085(0x0003) MISSED OFFSET
	struct FVector2D                                   CurMousePos;                                              // 0x0088(0x0008)
	struct FVector                                     CurCameraPos;                                             // 0x0090(0x000C)
	class UDynamicLightEnvironmentComponent*           PrevPickedDLE;                                            // 0x009C(0x0008) (ExportObject, Component, EditInline)
	class UDynamicLightEnvironmentComponent*           StayDLE;                                                  // 0x00A4(0x0008) (ExportObject, Component, EditInline)
	struct FLinearColor                                ColorOnMouseOver;                                         // 0x00AC(0x0010) (Edit, Config)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.DLEChangeComponent");
		return ptr;
	}

};


// Class BLGame.FootStepEffectComponent
// 0x000B (0x0090 - 0x0085)
class UFootStepEffectComponent : public UActorComponent
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0085(0x0003) MISSED OFFSET
	class ABLPawn*                                     PawnOwner;                                                // 0x0088(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.FootStepEffectComponent");
		return ptr;
	}


	void SpawnEffect(int FootDown);
	void SpawnEffect_Sound(class ABLPawn* inPawn, class UBLPhysMatSound* InSound, const struct FVector& InSpawnLoc);
	void SpawnEffect_FootPrint(class ABLPawn* inPawn, const struct FFOOT_STEP_EFFECT_INFO& InInfo, const struct FVector& InSpawnLoc, const struct FTraceHitInfo& InHitInfo);
	void SpawnDecalWithMITV(class UMaterialInstanceTimeVarying* a_MaterialInstance, float InDecalLifeSpan, float Width, float Height, float Thickness, const struct FVector& SpawnLocation, const struct FRotator& a_Rotation, const struct FTraceHitInfo& InHitInfo);
	void SpawnEffect_Dust(class ABLPawn* inPawn, const struct FFOOT_STEP_EFFECT_INFO& InInfo, const struct FVector& InSpawnLoc);
	class UBLPhysicalMaterialProperty* GetBLPhysMatProp(const struct FVector& End, const struct FVector& Start, float CheckRadius, int* TraceSuccess, struct FVector* OutLocation);
	class UBLPhysicalMaterial* GetBLPhysMat(const struct FVector& End, const struct FVector& Start, float CheckRadius, int* TraceSuccess, struct FVector* OutLocation);
};


// Class BLGame.BLRadialBlurActor
// 0x0008 (0x0258 - 0x0250)
class ABLRadialBlurActor : public AActor
{
public:
	class UBLRadialBlurComponent*                      RadialBlur;                                               // 0x0250(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLRadialBlurActor");
		return ptr;
	}

};


// Class BLGame.BLRadialBlurComponent
// 0x0014 (0x0104 - 0x00F0)
class UBLRadialBlurComponent : public URadialBlurComponent
{
public:
	float                                              RadialBlurFadeTime;                                       // 0x00F0(0x0004) (Transient)
	float                                              RadialBlurFadeTimeRemaining;                              // 0x00F4(0x0004) (Transient)
	float                                              RadialBlurMaxBlurAmountScale;                             // 0x00F8(0x0004) (Transient)
	float                                              RadialBlurMaxBlurAmountOpacity;                           // 0x00FC(0x0004) (Transient)
	unsigned long                                      bUseRadialBlurMaxBlurAmountScale : 1;                     // 0x0100(0x0004) (Transient)
	unsigned long                                      bUseRadialBlurMaxBlurAmountOpacity : 1;                   // 0x0100(0x0004) (Transient)
	unsigned long                                      bFadeOut : 1;                                             // 0x0100(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLRadialBlurComponent");
		return ptr;
	}

};


// Class BLGame.BroadwayBaseResource
// 0x0084 (0x00E4 - 0x0060)
class UBroadwayBaseResource : public UObject
{
public:
	struct FName                                       ResName;                                                  // 0x0060(0x0008) (Transient)
	struct FName                                       ParentName;                                               // 0x0068(0x0008) (Transient)
	unsigned long                                      bHidden : 1;                                              // 0x0070(0x0004) (Edit)
	unsigned long                                      bPlayOnlyLocalPlayer : 1;                                 // 0x0070(0x0004) (Edit)
	unsigned long                                      bCanTargetStealthPawn : 1;                                // 0x0070(0x0004) (Transient)
	struct FBroadwayLocationInfo                       SpawnLocation;                                            // 0x0074(0x0044) (Edit)
	struct FBroadwayTarget                             SpawnTarget;                                              // 0x00B8(0x000C) (Edit)
	struct FVector                                     LatestCalcLocation;                                       // 0x00C4(0x000C)
	struct FRotator                                    LatestCalcRotation;                                       // 0x00D0(0x000C)
	int                                                ApplyInfoIndex;                                           // 0x00DC(0x0004) (Transient)
	int                                                ApplyInfoSetKey;                                          // 0x00E0(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BroadwayBaseResource");
		return ptr;
	}


	bool CheckHitChanceConditionFromResult(const struct FActionApplyResult& InResult, TArray<TEnumAsByte<EBAR_HitCondition>> InAcceptHitConditions);
	bool CheckHitChanceConditionFromResults(TArray<struct FActionApplyResult> InResults, TArray<TEnumAsByte<EBAR_HitCondition>> InAcceptHitConditions);
	struct FVector GetSpawnPoint(class UBLBroadwayPlayer* BwPlayer);
	class ABLPawnBase* GetPlayPawn(class UBLBroadwayPlayer* BwPlayer);
	bool GetTargetApplyResults(class UBLBroadwayPlayer* InBwPlayer, TArray<struct FActionApplyResult>* OutResults);
	bool GetSpawnTargetApplyResult(class UBLBroadwayPlayer* InBwPlayer, struct FActionApplyResult* OutResult);
	class ABLPawnBase* GetDefenceMaterialPawn(class UBLBroadwayPlayer* InBwPlayer, TEnumAsByte<EBAR_Target> InDefenceMaterialTargetType);
	class ABLPawnBase* GetSpawnPawn(class UBLBroadwayPlayer* InBwPlayer);
	void GetSpawnInfo(class UBLBroadwayPlayer* BwPlayer, struct FVector* Loc, struct FRotator* Rot, struct FVector* Offset);
	struct FName GetParentName();
	struct FName GetResName();
	void EndPlayResource(class UBLBroadwayPlayer* a_Player, int a_InstID);
	void ProcessBroadwayNodeInstance(class UBLBroadwayPlayer* a_Player, float a_DeltaTime, int a_InstID);
	void CleanupPlayResource();
	TEnumAsByte<EBroadwayErrorType> PlayResource(float a_Rate, class UBLBroadwayPlayer* a_Player, int a_NodeID, int a_InstIndex, int a_TargetNumber, bool bCheckHitCondition);
	bool GetSocketHeight(class ABLPawnBase* InPlayPawn, class ABLPawnBase* InTargetPawn, const struct FName& InSocketName, bool bLimitTargetMinMax, float* OutResultHeight);
	float GetGroundHeightWithDegree(const struct FVector& CheckLocation, const struct FVector& PrevLocation, float CheckMaxDegree, TEnumAsByte<EBAR_GroundHeightCheckType> CheckType);
	float GetGroundHeight(const struct FVector& CheckLocation, TEnumAsByte<EBAR_GroundHeightCheckType> CheckType);
	void CalcLocation_PointType(const struct FBroadwayLocationInfo& BwLocation, const struct FVector& Point, class ABLPawnBase* PlayPawn, struct FVector* Loc, struct FRotator* Rot, struct FVector* Offset);
	void CalcLocation(const struct FBroadwayLocationInfo& BwLocation, class ABLPawnBase* OriginPawn, class ABLPawnBase* PlayPawn, class UBLBroadwayPlayer* BwPlayer, struct FVector* Loc, struct FRotator* Rot, struct FVector* Offset);
};


// Class BLGame.BroadwayAnimFreezeResource
// 0x0004 (0x00E8 - 0x00E4)
class UBroadwayAnimFreezeResource : public UBroadwayBaseResource
{
public:
	float                                              FreezeTime;                                               // 0x00E4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BroadwayAnimFreezeResource");
		return ptr;
	}


	TEnumAsByte<EBroadwayErrorType> PlayResource(float a_Rate, class UBLBroadwayPlayer* a_Player, int a_NodeID, int a_InstIndex, int a_TargetNumber, bool bCheckHitCondition);
};


// Class BLGame.BroadwayAnimResource
// 0x002D (0x0111 - 0x00E4)
class UBroadwayAnimResource : public UBroadwayBaseResource
{
public:
	struct FName                                       AnimSeqName;                                              // 0x00E4(0x0008) (Edit)
	float                                              AnimRate;                                                 // 0x00EC(0x0004) (Edit, EditConst)
	float                                              AnimBlendOut;                                             // 0x00F0(0x0004) (Edit)
	float                                              AnimBlendIn;                                              // 0x00F4(0x0004) (Edit)
	unsigned long                                      bLoopAnimSeq : 1;                                         // 0x00F8(0x0004) (Edit)
	unsigned long                                      bUseRootMotion : 1;                                       // 0x00F8(0x0004) (Edit)
	unsigned long                                      bAdjustRootMotionApproach : 1;                            // 0x00F8(0x0004) (Edit)
	unsigned long                                      bAdjustRootMotionHeight : 1;                              // 0x00F8(0x0004) (Edit)
	unsigned long                                      bIsFullBodyAnim : 1;                                      // 0x00F8(0x0004) (Edit)
	unsigned long                                      bUseMeshOrientedCam : 1;                                  // 0x00F8(0x0004) (Edit)
	unsigned long                                      bWaitAnimEnd : 1;                                         // 0x00F8(0x0004) (Edit)
	float                                              RootMotionMovableTime;                                    // 0x00FC(0x0004) (Edit)
	float                                              RootMotionApproachDistMyRadiusMultiplier;                 // 0x0100(0x0004) (Edit)
	float                                              RootMotionApproachDistTargetRadiusMultiplier;             // 0x0104(0x0004) (Edit)
	float                                              RootMotionApproachAdditionalDist;                         // 0x0108(0x0004) (Edit)
	float                                              StandardDistanceToTarget;                                 // 0x010C(0x0004) (Edit)
	TEnumAsByte<EMeshOrientedCamMode>                  MeshOrientedCamMode;                                      // 0x0110(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BroadwayAnimResource");
		return ptr;
	}


	bool GetSeqInfo(struct FSeqPlayInfo* seqInfo);
};


// Class BLGame.BroadwayCameraFOVResource
// 0x000C (0x00F0 - 0x00E4)
class UBroadwayCameraFOVResource : public UBroadwayBaseResource
{
public:
	float                                              DesiredFOV;                                               // 0x00E4(0x0004) (Edit)
	float                                              Duration;                                                 // 0x00E8(0x0004) (Edit)
	float                                              Transition;                                               // 0x00EC(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BroadwayCameraFOVResource");
		return ptr;
	}


	class ACamera* GetPlayerCamera(class UBLBroadwayPlayer* a_Player);
	void RestoreFOV(class UBLBroadwayPlayer* a_Player, int a_InstID);
	void EndPlayResource(class UBLBroadwayPlayer* a_Player, int a_InstID);
	void ProcessBroadwayNodeInstance(class UBLBroadwayPlayer* a_Player, float a_DeltaTime, int a_InstID);
	TEnumAsByte<EBroadwayErrorType> PlayResource(float a_Rate, class UBLBroadwayPlayer* a_Player, int a_NodeID, int a_InstIndex, int a_TargetNumber, bool bCheckHitCondition);
};


// Class BLGame.BroadwayDecalResource
// 0x001A (0x00FE - 0x00E4)
class UBroadwayDecalResource : public UBroadwayBaseResource
{
public:
	class UMaterialInstanceTimeVarying*                DecalMITV;                                                // 0x00E4(0x0008) (Edit)
	struct FVector                                     DecalSize;                                                // 0x00EC(0x000C) (Edit)
	unsigned long                                      bDecalRandomRotate : 1;                                   // 0x00F8(0x0004) (Edit)
	unsigned long                                      bUseHitSet : 1;                                           // 0x00F8(0x0004) (Edit)
	TEnumAsByte<EMaterialOffenceType>                  OffenceType;                                              // 0x00FC(0x0001) (Edit)
	TEnumAsByte<EBAR_Target>                           OverrideDefenceMaterialTarget;                            // 0x00FD(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BroadwayDecalResource");
		return ptr;
	}


	TEnumAsByte<EBroadwayErrorType> PlayResource(float a_Rate, class UBLBroadwayPlayer* a_Player, int a_NodeID, int a_InstIndex, int a_TargetNumber, bool bCheckHitCondition);
};


// Class BLGame.BroadwayDecorationEffectResource
// 0x0014 (0x00F8 - 0x00E4)
class UBroadwayDecorationEffectResource : public UBroadwayBaseResource
{
public:
	TEnumAsByte<EBAR_DecorationEffectControlType>      ControlType;                                              // 0x00E4(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x00E5(0x0003) MISSED OFFSET
	class UDecorationEffectInfo*                       DecorationEffect;                                         // 0x00E8(0x0008) (Edit)
	struct FName                                       DecorationEffectPath;                                     // 0x00F0(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BroadwayDecorationEffectResource");
		return ptr;
	}


	TEnumAsByte<EBroadwayErrorType> PlayResource(float a_Rate, class UBLBroadwayPlayer* a_Player, int a_NodeID, int a_InstIndex, int a_TargetNumber, bool bCheckHitCondition);
};


// Class BLGame.BroadwayDriverAnimResource
// 0x0019 (0x00FD - 0x00E4)
class UBroadwayDriverAnimResource : public UBroadwayBaseResource
{
public:
	struct FName                                       AnimSeqName;                                              // 0x00E4(0x0008) (Edit)
	float                                              AnimRate;                                                 // 0x00EC(0x0004) (Edit)
	float                                              AnimBlendOut;                                             // 0x00F0(0x0004) (Edit)
	float                                              AnimBlendIn;                                              // 0x00F4(0x0004) (Edit)
	unsigned long                                      bLoopAnimSeq : 1;                                         // 0x00F8(0x0004) (Edit)
	unsigned long                                      bUseMeshOrientedCam : 1;                                  // 0x00F8(0x0004) (Edit)
	TEnumAsByte<EMeshOrientedCamMode>                  MeshOrientedCamMode;                                      // 0x00FC(0x0001) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BroadwayDriverAnimResource");
		return ptr;
	}


	bool GetSeqInfo(struct FSeqPlayInfo* seqInfo);
};


// Class BLGame.BroadwayEmitterResource
// 0x001C (0x0100 - 0x00E4)
class UBroadwayEmitterResource : public UBroadwayBaseResource
{
public:
	class UParticleSystem*                             Emitter;                                                  // 0x00E4(0x0008) (Edit)
	struct FVector                                     EmitterScale;                                             // 0x00EC(0x000C) (Edit)
	TEnumAsByte<EBAR_AttachMode>                       AttachMode;                                               // 0x00F8(0x0001) (Edit)
	TEnumAsByte<EMaterialOffenceType>                  OffenceType;                                              // 0x00F9(0x0001) (Edit)
	TEnumAsByte<EBAR_Target>                           OverrideDefenceMaterialTarget;                            // 0x00FA(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x1];                                       // 0x00FB(0x0001) MISSED OFFSET
	unsigned long                                      EnablePlayRate : 1;                                       // 0x00FC(0x0004) (Edit)
	unsigned long                                      bUseDustColor : 1;                                        // 0x00FC(0x0004) (Edit)
	unsigned long                                      bUseHitSet : 1;                                           // 0x00FC(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BroadwayEmitterResource");
		return ptr;
	}


	bool GetDustColor(class ABLPawnBase* InTargetPawn, const struct FVector& InCheckLocation, struct FColor* OutDustColor);
	void ProcessBroadwayNodeInstance(class UBLBroadwayPlayer* a_Player, float a_DeltaTime, int a_InstID);
	TEnumAsByte<EBroadwayErrorType> PlayResource(float a_Rate, class UBLBroadwayPlayer* a_Player, int a_NodeID, int a_InstIndex, int a_TargetNumber, bool bCheckHitCondition);
};


// Class BLGame.BroadwayImpactLightResource
// 0x0014 (0x00F8 - 0x00E4)
class UBroadwayImpactLightResource : public UBroadwayBaseResource
{
public:
	class UObject*                                     ImpactLightCustom;                                        // 0x00E4(0x0008) (Edit)
	TEnumAsByte<EBAR_ImpactLight>                      ImpactLightType;                                          // 0x00EC(0x0001) (Edit)
	TEnumAsByte<EBAR_ImpactLight_AttachMode>           AttachMode;                                               // 0x00ED(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x2];                                       // 0x00EE(0x0002) MISSED OFFSET
	struct FName                                       ImpactLightCustomPath;                                    // 0x00F0(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BroadwayImpactLightResource");
		return ptr;
	}


	void EndPlayResource(class UBLBroadwayPlayer* a_Player, int a_InstID);
	float GetImpactLightMaxRadius(class UUDKExplosionLight* InLight);
	TEnumAsByte<EBroadwayErrorType> PlayResource(float a_Rate, class UBLBroadwayPlayer* a_Player, int a_NodeID, int a_InstIndex, int a_TargetNumber, bool bCheckHitCondition);
};


// Class BLGame.BroadwayMaterialResource
// 0x0024 (0x0108 - 0x00E4)
class UBroadwayMaterialResource : public UBroadwayBaseResource
{
public:
	class UMaterialInstanceTimeVarying*                MITV;                                                     // 0x00E4(0x0008) (Edit)
	float                                              Lifetime;                                                 // 0x00EC(0x0004) (Edit)
	int                                                Priority;                                                 // 0x00F0(0x0004) (Edit)
	TEnumAsByte<EMCApplyType>                          ApplyType;                                                // 0x00F4(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x00F5(0x0003) MISSED OFFSET
	int                                                DeleteMITVKey;                                            // 0x00F8(0x0004) (Edit)
	struct FName                                       MITVPath;                                                 // 0x00FC(0x0008)
	int                                                MITVKeyStart;                                             // 0x0104(0x0004) (Const, Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BroadwayMaterialResource");
		return ptr;
	}


	void EndPlayResource(class UBLBroadwayPlayer* a_Player, int a_InstID);
	TEnumAsByte<EBroadwayErrorType> PlayResource(float a_Rate, class UBLBroadwayPlayer* a_Player, int a_NodeID, int a_InstIndex, int a_TargetNumber, bool bCheckHitCondition);
	int GetDeleteMITVKey();
};


// Class BLGame.BroadwayPairResource
// 0x0050 (0x0134 - 0x00E4)
class UBroadwayPairResource : public UBroadwayBaseResource
{
public:
	struct FBroadwayLocationInfo                       DestLocation;                                             // 0x00E4(0x0044) (Edit)
	struct FBroadwayTarget                             DestTarget;                                               // 0x0128(0x000C) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BroadwayPairResource");
		return ptr;
	}


	void CleanupPlayResource();
	void GetDestInfo(class UBLBroadwayPlayer* BwPlayer, struct FVector* Loc, struct FRotator* Rot, struct FVector* Offset);
	bool GetDestTargetApplyResult(class UBLBroadwayPlayer* InBwPlayer, struct FActionApplyResult* OutResult);
	struct FVector GetDestPoint(class UBLBroadwayPlayer* BwPlayer);
	class ABLPawnBase* GetDestPawn(class UBLBroadwayPlayer* InBwPlayer);
	TEnumAsByte<EBroadwayErrorType> PlayResource(float a_Rate, class UBLBroadwayPlayer* a_Player, int a_NodeID, int a_InstIndex, int a_TargetNumber, bool bCheckHitCondition);
};


// Class BLGame.BroadwayBeamTrailResource
// 0x001C (0x0150 - 0x0134)
class UBroadwayBeamTrailResource : public UBroadwayPairResource
{
public:
	class UParticleSystem*                             BeamTrail;                                                // 0x0134(0x0008) (Edit)
	struct FVector                                     BeamTrailScale;                                           // 0x013C(0x000C) (Edit)
	struct FName                                       BeamTrailPath;                                            // 0x0148(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BroadwayBeamTrailResource");
		return ptr;
	}


	int UpdateBeamTrailModifierPosition(float a_DeltaTime, class UParticleSystemComponent* a_PSC, TEnumAsByte<EBeamModifierType> a_Type, const struct FVector& a_Position);
	void ProcessBroadwayNodeInstance(class UBLBroadwayPlayer* a_Player, float a_DeltaTime, int a_InstID);
	TEnumAsByte<EBroadwayErrorType> PlayResource(float a_Rate, class UBLBroadwayPlayer* a_Player, int a_NodeID, int a_InstIndex, int a_TargetNumber, bool bCheckHitCondition);
};


// Class BLGame.BroadwayProjectileResource
// 0x0030 (0x0164 - 0x0134)
class UBroadwayProjectileResource : public UBroadwayPairResource
{
public:
	class UProjectileInfo*                             Projectile;                                               // 0x0134(0x0008) (Edit)
	float                                              ProjectileSpeed;                                          // 0x013C(0x0004) (Edit)
	float                                              ProjectileMaxSpeed;                                       // 0x0140(0x0004) (Edit)
	float                                              ProjectileAccel;                                          // 0x0144(0x0004) (Edit)
	TEnumAsByte<EBezierCurveType>                      ProjectileCurveType;                                      // 0x0148(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0149(0x0003) MISSED OFFSET
	int                                                ProjectileCurveBiDirection;                               // 0x014C(0x0004) (Edit)
	float                                              ProjectileCurveForce;                                     // 0x0150(0x0004) (Edit)
	unsigned long                                      bUseContrailDustColor : 1;                                // 0x0154(0x0004) (Edit)
	unsigned long                                      bUseExplosionDustColor : 1;                               // 0x0154(0x0004) (Edit)
	unsigned long                                      bMultiResult : 1;                                         // 0x0154(0x0004) (Edit)
	unsigned long                                      bLikeEmitter : 1;                                         // 0x0154(0x0004) (Transient)
	float                                              ProjectileSkidMove;                                       // 0x0158(0x0004) (Edit)
	struct FName                                       ProjectilePath;                                           // 0x015C(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BroadwayProjectileResource");
		return ptr;
	}


	class ABLProjectile* SpawnProjectile(class UBLBroadwayPlayer* a_Player, int a_NodeInstID, const struct FVector& a_Location, const struct FRotator& a_Rotation, bool a_Hidden);
	TEnumAsByte<EBroadwayErrorType> PlayResource(float a_Rate, class UBLBroadwayPlayer* a_Player, int a_NodeID, int a_InstIndex, int a_TargetNumber, bool bCheckHitCondition);
};


// Class BLGame.BroadwayPostProcessEffectResource
// 0x0014 (0x00F8 - 0x00E4)
class UBroadwayPostProcessEffectResource : public UBroadwayBaseResource
{
public:
	class UMaterialInstance*                           MaterialEffect;                                           // 0x00E4(0x0008) (Edit)
	float                                              Duration;                                                 // 0x00EC(0x0004) (Edit)
	unsigned long                                      bReversePlayWhenEnded : 1;                                // 0x00F0(0x0004) (Edit)
	float                                              ReverseDuration;                                          // 0x00F4(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BroadwayPostProcessEffectResource");
		return ptr;
	}


	class UBLPlayerPostProcessController* GetPostProcessController(class UBLBroadwayPlayer* a_Player);
	class ULocalPlayer* GetLocalPlayer(class UBLBroadwayPlayer* a_Player);
	void RestorePostProcessEffect(class UBLBroadwayPlayer* a_Player, int a_InstID);
	void EndPlayResource(class UBLBroadwayPlayer* a_Player, int a_InstID);
	void ProcessBroadwayNodeInstance(class UBLBroadwayPlayer* a_Player, float a_DeltaTime, int a_InstID);
	TEnumAsByte<EBroadwayErrorType> PlayResource(float a_Rate, class UBLBroadwayPlayer* a_Player, int a_NodeID, int a_InstIndex, int a_TargetNumber, bool bCheckHitCondition);
};


// Class BLGame.BroadwayRadialBlurResource
// 0x002C (0x0110 - 0x00E4)
class UBroadwayRadialBlurResource : public UBroadwayBaseResource
{
public:
	class URadialBlurComponent*                        RadialBlur;                                               // 0x00E4(0x0008) (Edit, ExportObject, Component, EditInline)
	float                                              RadialBlurFadeTime;                                       // 0x00EC(0x0004) (Edit)
	unsigned long                                      bStartFadeOutWhenBroadwayEnded : 1;                       // 0x00F0(0x0004) (Edit)
	unsigned long                                      bAttachToActor : 1;                                       // 0x00F0(0x0004) (Edit)
	unsigned long                                      bUseRadialBlurMaxBlurAmountScale : 1;                     // 0x00F0(0x0004) (Edit)
	unsigned long                                      bUseRadialBlurMaxBlurAmountOpacity : 1;                   // 0x00F0(0x0004) (Edit)
	int                                                indexRBActor;                                             // 0x00F4(0x0004) (Transient)
	class UBLRadialBlurComponent*                      RBCompAttachedActor;                                      // 0x00F8(0x0008) (ExportObject, Transient, Component, EditInline)
	float                                              RadialBlurMaxBlurAmountScale;                             // 0x0100(0x0004) (Edit)
	float                                              RadialBlurMaxBlurAmountOpacity;                           // 0x0104(0x0004) (Edit)
	struct FName                                       MaterialPath;                                             // 0x0108(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BroadwayRadialBlurResource");
		return ptr;
	}


	void EndPlayResource(class UBLBroadwayPlayer* a_Player, int a_InstID);
	TEnumAsByte<EBroadwayErrorType> PlayResource(float a_Rate, class UBLBroadwayPlayer* a_Player, int a_NodeID, int a_InstIndex, int a_TargetNumber, bool bCheckHitCondition);
};


// Class BLGame.BroadwayShowEquipmentResource
// 0x000C (0x00F0 - 0x00E4)
class UBroadwayShowEquipmentResource : public UBroadwayBaseResource
{
public:
	unsigned long                                      bShow : 1;                                                // 0x00E4(0x0004) (Edit)
	TEnumAsByte<ECEEquipSlotType>                      EquipSlotType;                                            // 0x00E8(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x00E9(0x0003) MISSED OFFSET
	int                                                TargetPawnSid;                                            // 0x00EC(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BroadwayShowEquipmentResource");
		return ptr;
	}


	void EndPlayResource(class UBLBroadwayPlayer* a_Player, int a_InstID);
	TEnumAsByte<EBroadwayErrorType> PlayResource(float a_Rate, class UBLBroadwayPlayer* a_Player, int a_NodeID, int a_InstIndex, int a_TargetNumber, bool bCheckHitCondition);
};


// Class BLGame.BroadwaySoundResource
// 0x0018 (0x00FC - 0x00E4)
class UBroadwaySoundResource : public UBroadwayBaseResource
{
public:
	class UAkEvent*                                    AkSoundEvent;                                             // 0x00E4(0x0008) (Edit)
	unsigned long                                      bUseHitSet : 1;                                           // 0x00EC(0x0004) (Edit)
	TEnumAsByte<EMaterialOffenceType>                  OffenceType;                                              // 0x00F0(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x00F1(0x0003) MISSED OFFSET
	struct FName                                       AkSoundPath;                                              // 0x00F4(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BroadwaySoundResource");
		return ptr;
	}


	TEnumAsByte<EBroadwayErrorType> PlayResource(float a_Rate, class UBLBroadwayPlayer* a_Player, int a_NodeID, int a_InstIndex, int a_TargetNumber, bool bCheckHitCondition);
};


// Class BLGame.BroadwayViewShakeResource
// 0x0020 (0x0104 - 0x00E4)
class UBroadwayViewShakeResource : public UBroadwayBaseResource
{
public:
	struct FName                                       CameraAnimPath;                                           // 0x00E4(0x0008)
	float                                              ShakeRadius;                                              // 0x00EC(0x0004) (Edit)
	unsigned long                                      bUseBoneLocation : 1;                                     // 0x00F0(0x0004) (Edit)
	struct FName                                       BoneName;                                                 // 0x00F4(0x0008) (Edit)
	class UCameraShake*                                CameraShake;                                              // 0x00FC(0x0008) (Edit, ExportObject, NeedCtorLink, EditInline)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BroadwayViewShakeResource");
		return ptr;
	}


	float CalcShakeScale(const struct FVector& InSrcCenter, const struct FVector& InDestCenter, float InnerRadius, float OuterRadius, float Falloff);
	TEnumAsByte<EBroadwayErrorType> PlayResource(float a_Rate, class UBLBroadwayPlayer* a_Player, int a_NodeID, int a_InstIndex, int a_TargetNumber, bool bCheckHitCondition);
};


// Class BLGame.BroadwayWindResource
// 0x0024 (0x0108 - 0x00E4)
class UBroadwayWindResource : public UBroadwayBaseResource
{
public:
	unsigned long                                      bAttachActor : 1;                                         // 0x00E4(0x0004) (Edit)
	float                                              Radius;                                                   // 0x00E8(0x0004) (Edit)
	float                                              Strength;                                                 // 0x00EC(0x0004) (Edit)
	float                                              Speed;                                                    // 0x00F0(0x0004) (Edit)
	float                                              Pressure;                                                 // 0x00F4(0x0004) (Edit)
	float                                              SpreadSpeed;                                              // 0x00F8(0x0004) (Edit)
	class UTexture2D*                                  WindPattern;                                              // 0x00FC(0x0008) (Edit)
	float                                              Lifetime;                                                 // 0x0104(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BroadwayWindResource");
		return ptr;
	}


	void EndPlayResource(class UBLBroadwayPlayer* a_Player, int a_InstID);
	TEnumAsByte<EBroadwayErrorType> PlayResource(float a_Rate, class UBLBroadwayPlayer* a_Player, int a_NodeID, int a_InstIndex, int a_TargetNumber, bool bCheckHitCondition);
};


// Class BLGame.BroadwayGameInfo
// 0x002C (0x008C - 0x0060)
class UBroadwayGameInfo : public UObject
{
public:
	float                                              PlayRate;                                                 // 0x0060(0x0004) (Edit)
	int                                                BroadwayID;                                               // 0x0064(0x0004) (Edit, EditConst)
	struct FName                                       BroadwayName;                                             // 0x0068(0x0008) (Edit)
	struct FName                                       BroadwayNameK;                                            // 0x0070(0x0008) (Edit)
	TArray<class UBroadwayNode*>                       NodeList;                                                 // 0x0078(0x0010) (Edit, NeedCtorLink)
	unsigned long                                      bResourceLoaded : 1;                                      // 0x0088(0x0004) (Transient)
	unsigned long                                      bAccumulateTargetList : 1;                                // 0x0088(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BroadwayGameInfo");
		return ptr;
	}


	void LoadResource();
	float CalcTriggerTimeEx(class UBroadwayNode* a_Res, class ABLPawnBase* a_Owner, bool a_bUseBroadwayPlayRate);
	float CalcMaxRunningTimeEx(class ABLPawnBase* a_Owner, bool a_bUseBroadwayPlayRate);
	float GetAnimRunningTime(const struct FName& SeqName, class ABLPawnBase* a_Owner);
};


// Class BLGame.BroadwayInfo
// 0x00AC (0x010C - 0x0060)
class UBroadwayInfo : public UObject
{
public:
	class UBroadwayGameInfo*                           GameInfo;                                                 // 0x0060(0x0008) (Edit, ExportObject, NeedCtorLink, EditInline)
	class USkeletalMesh*                               PreviewMesh;                                              // 0x0068(0x0008) (Edit)
	TArray<class UAnimSet*>                            PreviewAnimSets;                                          // 0x0070(0x0010) (Edit, NeedCtorLink)
	TArray<class UAnimNotifySet*>                      PreviewAnimNotifySets;                                    // 0x0080(0x0010) (Edit, NeedCtorLink)
	class UPawnAsset*                                  PreviewPawnInfo;                                          // 0x0090(0x0008) (Edit)
	int                                                PreviewSkillCid;                                          // 0x0098(0x0004) (Edit)
	struct FVector                                     PreviewLocation;                                          // 0x009C(0x000C) (Edit)
	struct FRotator                                    PreviewRotation;                                          // 0x00A8(0x000C) (Edit)
	TArray<struct FPreviewTarget>                      PreviewTargets;                                           // 0x00B4(0x0010) (Edit, NeedCtorLink)
	TEnumAsByte<ECEAttackChanceType>                   HitCondition;                                             // 0x00C4(0x0001) (Edit)
	TEnumAsByte<EVisualMaterialDefenceType>            HitVFXMaterial;                                           // 0x00C5(0x0001) (Edit)
	TEnumAsByte<ESoundMaterialDefenceType>             HitSFXMaterial;                                           // 0x00C6(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x1];                                       // 0x00C7(0x0001) MISSED OFFSET
	struct FName                                       PreviewMeshPath;                                          // 0x00C8(0x0008)
	TArray<struct FName>                               PreviewAnimSetsPath;                                      // 0x00D0(0x0010) (NeedCtorLink)
	TArray<struct FName>                               PreviewAnimNotifySetsPath;                                // 0x00E0(0x0010) (NeedCtorLink)
	struct FName                                       PreviewPawnInfoPath;                                      // 0x00F0(0x0008)
	TArray<struct FName>                               PreviewTargetsPath;                                       // 0x00F8(0x0010) (NeedCtorLink)
	unsigned long                                      bResourceLoaded : 1;                                      // 0x0108(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BroadwayInfo");
		return ptr;
	}


	float GetAnimRunningTimeForEditor(const struct FName& SeqName);
	float CalcTriggerBaseTimeForEditor(class UBroadwayNode* a_Res, bool a_bUseBroadwayPlayRate);
	float CalcMaxRunningTimeForEditor(bool a_bUseBroadwayPlayRate);
	float CalcTriggerTimeForEditor(class UBroadwayNode* a_Res, bool a_bUseBroadwayPlayRate);
	void SetTransAndRotForPrimitiveComp(class UPrimitiveComponent* a_Prim, const struct FVector& a_Translation, const struct FRotator& a_Rotation);
	void SetRotationForPrimitiveComp(class UPrimitiveComponent* a_Prim, const struct FRotator& a_Rotation);
	void SetTranslationForPrimitiveComp(class UPrimitiveComponent* a_Prim, const struct FVector& a_Translation);
	void _LoadResource();
	void LoadResource();
};


// Class BLGame.BroadwayNode
// 0x00EC (0x014C - 0x0060)
class UBroadwayNode : public UObject
{
public:
	struct FName                                       ResName;                                                  // 0x0060(0x0008) (Edit, EditConst)
	struct FName                                       ParentName;                                               // 0x0068(0x0008) (Edit, EditConst)
	TEnumAsByte<EBAR_TriggerCondition>                 TriggerCondition;                                         // 0x0070(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0071(0x0003) MISSED OFFSET
	float                                              TimeOffset;                                               // 0x0074(0x0004) (Edit)
	struct FName                                       TriggerName;                                              // 0x0078(0x0008) (Edit)
	TArray<TEnumAsByte<EBAR_HitCondition>>             AcceptHitConditions;                                      // 0x0080(0x0010) (Edit, NeedCtorLink)
	class UBroadwayEmitterResource*                    EmitterGroup;                                             // 0x0090(0x0008) (Edit, ExportObject, NeedCtorLink, EditInline)
	class UBroadwayBeamTrailResource*                  BeamTrailGroup;                                           // 0x0098(0x0008) (Edit, ExportObject, NeedCtorLink, EditInline)
	class UBroadwayProjectileResource*                 ProjectileGroup;                                          // 0x00A0(0x0008) (Edit, ExportObject, NeedCtorLink, EditInline)
	class UBroadwayAnimResource*                       AnimGroup;                                                // 0x00A8(0x0008) (Edit, ExportObject, NeedCtorLink, EditInline)
	class UBroadwayDriverAnimResource*                 DriverAnimGroup;                                          // 0x00B0(0x0008) (Edit, ExportObject, NeedCtorLink, EditInline)
	class UBroadwayDecalResource*                      DecalGroup;                                               // 0x00B8(0x0008) (Edit, ExportObject, NeedCtorLink, EditInline)
	class UBroadwayImpactLightResource*                ImpactLightGroup;                                         // 0x00C0(0x0008) (Edit, ExportObject, NeedCtorLink, EditInline)
	class UBroadwaySoundResource*                      SoundGroup;                                               // 0x00C8(0x0008) (Edit, ExportObject, NeedCtorLink, EditInline)
	class UBroadwayViewShakeResource*                  ViewShakeGroup;                                           // 0x00D0(0x0008) (Edit, ExportObject, NeedCtorLink, EditInline)
	class UBroadwayRadialBlurResource*                 RadialBlurGroup;                                          // 0x00D8(0x0008) (Edit, ExportObject, NeedCtorLink, EditInline)
	class UBroadwayMaterialResource*                   MaterialGroup;                                            // 0x00E0(0x0008) (Edit, ExportObject, NeedCtorLink, EditInline)
	class UBroadwayDecorationEffectResource*           DecorationEffectGroup;                                    // 0x00E8(0x0008) (Edit, ExportObject, NeedCtorLink, EditInline)
	class UBroadwayShowEquipmentResource*              ShowEquipmentGroup;                                       // 0x00F0(0x0008) (Edit, ExportObject, NeedCtorLink, EditInline)
	class UBroadwayCameraFOVResource*                  CameraFOVGroup;                                           // 0x00F8(0x0008) (Edit, ExportObject, NeedCtorLink, EditInline)
	class UBroadwayPostProcessEffectResource*          PostProcessEffectGroup;                                   // 0x0100(0x0008) (Edit, ExportObject, NeedCtorLink, EditInline)
	class UBroadwayAnimFreezeResource*                 AnimFreezeGroup;                                          // 0x0108(0x0008) (Edit, ExportObject, NeedCtorLink, EditInline)
	class UBroadwayWindResource*                       WindGroup;                                                // 0x0110(0x0008) (Edit, ExportObject, NeedCtorLink, EditInline)
	class UBroadwayAnimResource*                       AnimRes;                                                  // 0x0118(0x0008) (Transient)
	class UBroadwayDriverAnimResource*                 DriverAnimRes;                                            // 0x0120(0x0008) (Transient)
	TArray<class UBroadwayBaseResource*>               Resources;                                                // 0x0128(0x0010) (Transient, NeedCtorLink)
	int                                                ParentID;                                                 // 0x0138(0x0004) (Transient)
	int                                                ChildID;                                                  // 0x013C(0x0004) (Transient)
	int                                                SiblingID;                                                // 0x0140(0x0004) (Transient)
	unsigned long                                      bMultiTarget : 1;                                         // 0x0144(0x0004) (Transient)
	unsigned long                                      bChange : 1;                                              // 0x0144(0x0004)
	struct FColor                                      ResColor;                                                 // 0x0148(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BroadwayNode");
		return ptr;
	}


	struct FColor GetResColor();
};


// Class BLGame.BLActionBarUIManager
// 0x0020 (0x0080 - 0x0060)
class UBLActionBarUIManager : public UObject
{
public:
	TArray<int>                                        LockedUISlotList;                                         // 0x0060(0x0010) (AlwaysInit, NeedCtorLink)
	class UGFxObject*                                  StanceUIObject_1;                                         // 0x0070(0x0008) (AlwaysInit)
	class UGFxObject*                                  StanceUIObject_2;                                         // 0x0078(0x0008) (AlwaysInit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLActionBarUIManager");
		return ptr;
	}


	void SetPCUIStanceCoolTime(int InStanceCid, float InCoolTime);
	void SetPCUIChangeStance(int InStanceCid);
	void SetPCUIStanceIcon(int InSlotIndex, int InStanceCid);
	void SetPCUIGearScore(const struct FString& InGearScore, bool InIsAniPlay);
	void SetPCUITacticsButton(int InUseTacticsIndex, int InUnlockSkillDeckSize, int InMaxSkillDeckSizeconst);
	void ShortcutChargingStackCount(int InSlotIndex, int InStackCount);
	void StartShortcutCharging(int InSlotIndex, float InRemainingTime, float InTotalTime);
	void StartCandidateShortcutCoolDown(int InSlotIndex, float InRemainingTime, float InTotalTime, int InCombatCid);
	void StartShortcutCoolDown(int InSlotIndex, float InRemainingTime, float InTotalTime, bool IsGlobalCoolDown);
	void ClearShortcutEffect(int InSlotIndex);
	void ActiveShortcutEffect(int InSlotIndex, TEnumAsByte<EActionBarIconEffect> InEffectType, bool isActive);
	void ActiveShortcutSlot(int InSlotIndex, bool isActive);
	void LockShortcutSlot(int InSlotIndex, bool bLock, bool IsShowAnimEffect, const struct FString& InLockString);
	void SetShortcutSlot(int SlotIndex, int shortcutType, int Cid, const struct FQWord& Uid, int IconIndex, bool bDisableMouseRightButton, int Quantity);
	void Init();
};


// Class BLGame.BLChatManager
// 0x00C0 (0x0120 - 0x0060)
class UBLChatManager : public UObject
{
public:
	int                                                ChatBlockTime;                                            // 0x0060(0x0004) (Config)
	int                                                ChatTextMinSize;                                          // 0x0064(0x0004) (Config)
	int                                                ChatTextMaxSize;                                          // 0x0068(0x0004) (Config)
	int                                                ChatTextDefaultSize;                                      // 0x006C(0x0004) (Config)
	int                                                ChatBgOpacityMin;                                         // 0x0070(0x0004) (Config)
	int                                                ChatBgOpacityMax;                                         // 0x0074(0x0004) (Config)
	int                                                ChatBgOpacityDefault;                                     // 0x0078(0x0004) (Config)
	int                                                ChatActiveBgOpacityDefault;                               // 0x007C(0x0004) (Config)
	TArray<struct FChattingTabSubscribeConfig>         DefaultTabConfig;                                         // 0x0080(0x0010) (Config, NeedCtorLink)
	struct FString                                     DefaultSettingTabName;                                    // 0x0090(0x0010) (Config, NeedCtorLink)
	struct FString                                     SaveDirectoryPath;                                        // 0x00A0(0x0010) (Config, NeedCtorLink)
	struct FString                                     ChatSaveFileName;                                         // 0x00B0(0x0010) (Config, NeedCtorLink)
	TArray<struct FChattingChannel>                    DefaultChannelConfig;                                     // 0x00C0(0x0010) (Config, NeedCtorLink)
	int                                                HistoryCount;                                             // 0x00D0(0x0004) (Config)
	struct FColor                                      JudgementFontColor;                                       // 0x00D4(0x0004) (Config)
	struct FColor                                      AttackFontColor;                                          // 0x00D8(0x0004) (Config)
	struct FColor                                      DamageFontColor;                                          // 0x00DC(0x0004) (Config)
	struct FColor                                      HealFontColor;                                            // 0x00E0(0x0004) (Config)
	struct FColor                                      StoryQuestFontColor;                                      // 0x00E4(0x0004) (Config)
	struct FString                                     LastWhisperTalkerName;                                    // 0x00E8(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<struct FString>                             ChattingHistory;                                          // 0x00F8(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	int                                                CurrentHistoryIndex;                                      // 0x0108(0x0004) (Transient)
	unsigned long                                      IsStressTest : 1;                                         // 0x010C(0x0004) (Transient)
	unsigned long                                      CachingIsDefault : 1;                                     // 0x010C(0x0004)
	int                                                SendCountPerTick;                                         // 0x0110(0x0004) (Transient)
	float                                              AccumTime;                                                // 0x0114(0x0004) (Transient)
	float                                              SendingTime;                                              // 0x0118(0x0004) (Transient)
	int                                                CachingTabIndex;                                          // 0x011C(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLChatManager");
		return ptr;
	}


	void Tick(float DeltaTime);
	struct FString ConvertChatMessageTypeToCommand(TEnumAsByte<EChatMessageType> InType);
	void OnDisableChatFocusMode();
	void OnEnableChatFocusMode();
	void OnSetChatFocusMode(bool InEnable);
	void OpenNameNotAvalibleDialog();
	void PrintLevelUPSystemMessage(struct FPawnParam1st* InPawnParam1st);
	void PrintUnEquipSystemMessage(TArray<struct FInventoryItemData> InItemDataListArray);
	void PrintEquipSystemMessage(TArray<struct FInventoryItemData> InItemDataListArray);
	void PrintStoryQuestSystemMessage(const struct FString& InPlotName, bool InIsStart);
	void PrintBattleSystemMessage(class ABLPawnBase* Attacker, class ABLPawnBase* Damager, TEnumAsByte<EBattleMessageType> BattleMessageType, int Amount);
	struct FString ConvertChatMessageType_EnumToString(TEnumAsByte<EChatMessageType> InEnum);
	TEnumAsByte<EChatMessageType> ConvertChatMessageType_StringToEnum(struct FString* InString);
	void ResetHistoryIndex();
	struct FString SearchHistory(int InRhs);
	void History(const struct FString& InMessage);
	struct FString GetLastWhisperTalker();
	void RecordWhisperTalker(const struct FString& InTalkerName);
	struct FString ToLinkedMessage(const struct FString& InMessage, TArray<struct FString> InLink);
	void ToFormatMessage(const struct FString& InSource, struct FString* OutMessage, TArray<struct FString>* OutLink);
	bool IsLinkedMessage(const struct FString& InSource);
	void RunHyperLink(const struct FString& InLink);
	struct FString MakeHyperLink(TEnumAsByte<EChatLinkType> InLinkType, const struct FString& InCoverText, TArray<int> InKeywordList);
	void OpenTalkerContextMenu(int TalkerSid, const struct FString& TalkerName);
	void CollectChatChannelData(TArray<class UGFxObject*>* OutData);
	class UGFxObject* CreateChatChannelData(TEnumAsByte<EChatMessageType> InType, int InSubjectType, const struct FString& InMessageCommandName);
	void OpenResetTabConfigDialog(int TabIndex);
	void CancelChatTabSetting();
	void ApplyChatTabSetting();
	void ChangeDefaultChatChannel(int InTabIndex, int InChatType);
	bool ChangeTabName(int InTabIndex, const struct FString& InTabName);
	void ChangeChatSubscribe(int InTabIndex, TEnumAsByte<EChatMessageType> InType, bool InIsSubscribe, int InChannelColor);
	void ChangeChatFontSize(int InTabIndex, int InFontSize);
	void SetChatTabOpenData(int InTabIndex, bool InIsDefault);
	void UpdateToUI_ChatTabConfigForOption();
	void UpdateToUI_SubjectList();
	void UpdateToUI_ChatTabList(int InSelectedTab);
	void UpdateToUI_ChatTabConfig(const struct FString& InKeyName);
	void SetTabIndex(const struct FString& InKeyName, int GeneratedTabIndex);
	void AddAllTab();
	struct FString GetKeyNameByTabName(const struct FString& InTabName);
	struct FColor GetChannelColor(TEnumAsByte<EChatMessageType> InType);
	struct FColor GetDefaultChannelColor(TEnumAsByte<EChatMessageType> InType);
	TArray<TEnumAsByte<EChatMessageType>> GetWritableChatChannelList();
	bool IsWritableChatChannel(TEnumAsByte<EChatMessageType> InType);
	struct FString GetChannelName(TEnumAsByte<EChatMessageType> InType);
	void ApplyInitializedChannelColor();
	int GetDefaultChatChannel(const struct FString& InKeyName);
	struct FChattingTabConfig GetDefaultSetting(TEnumAsByte<EChatUIIndex> UIIndex);
	void ApplyInitializedTabSetting();
	void OnRelease();
	void OnInitialize();
};


// Class BLGame.BLConquestUIManager
// 0x004C (0x00AC - 0x0060)
class UBLConquestUIManager : public UObject
{
public:
	unsigned long                                      bNeedOpenJoinOccupationWarDialog : 1;                     // 0x0060(0x0004)
	unsigned long                                      bExitButtonDisable : 1;                                   // 0x0060(0x0004)
	float                                              OccupationWarJoinRemainTime;                              // 0x0064(0x0004)
	struct FString                                     MatchingInfoFirstText;                                    // 0x0068(0x0010) (NeedCtorLink)
	struct FString                                     MatchingInfoSecondText;                                   // 0x0078(0x0010) (NeedCtorLink)
	class UBLTimerComponent*                           Timer;                                                    // 0x0088(0x0008) (ExportObject, Component, EditInline)
	struct FString                                     TimerSystemMessageCodeName;                               // 0x0090(0x0010) (NeedCtorLink)
	int                                                ScoreBoardLimitTime;                                      // 0x00A0(0x0004)
	int                                                WaitingLimitTime;                                         // 0x00A4(0x0004)
	int                                                BonusLimitTime;                                           // 0x00A8(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLConquestUIManager");
		return ptr;
	}


	void PostAkEvent(class UAkEvent* InAkEvent);
	void OpenChallengeTowerTotalResult(int InCompleteRound, int InElapsedTimeToSeconds, TArray<struct FChallengeTowerRoundResultInfoData>* InRoundResultDataList);
	void OpenChallengeTowerRoundResult(struct FChallengeTowerRoundResultInfoData* InRoundResultData);
	void StartRankingTabRewardMode(bool bIsVictory, int InRemainTime);
	void SetExitButtonDisable(bool bInDisable);
	void ClearSystemMessageTimer();
	void UpdateSystemMessageTimer(float InRemainTime, float InDuration);
	void SetSystemMessageTimer(int InRemainTime, const struct FString& InSystemMessageCodeName);
	void SetEventAfterPrintSystemMessage(class UObject* InTargetObj, const struct FName& InEndFuncName, const struct FString& InSystemMessageCodeName, TArray<struct FSystemMessageParamValueData>* InParamValueList);
	void UpdateContentInfoTokenCT(int InTokenCT);
	void UpdateContentInfoMonsterCount(int InRemainMonsterCount, int InMaxMonsterCount);
	void ClearBonusTime();
	void EndBonusTime();
	void UpdateBonusTime(float InRemainTime, float InDuration);
	void SetBonusTime(int InBonusTime, int InBonusLimitTime);
	void ClearWaitingTime();
	void EndWaitingTime();
	void UpdateWaitingTime(float InRemainTime, float InDuration);
	void SetWaitingTime(int InWaitingTime, int InWaitingLimitTime);
	void ClearTimerTime();
	void UpdateTimerTime(float InTotalPlayedTime);
	void SetTimerTime(int InTotalPlayedTime);
	void SetTimerType(TEnumAsByte<EBLTimerType> InTimerType);
	void SetTimerVisible(bool Invisible);
	void UpdateRewardExitTime(float InRemainTime, float InDuration);
	void SetRewardExitTime(int inTime);
	void HideRewardExitTime();
	void UpdateScoreBoardTime(float InRemainTime, float InDuration);
	void SetScoreBoardTime(int inTime, int InLimitTime);
	void StopScoreBoardTime();
	void SetScoreBoardVisible(bool Invisible);
	void UpdateOccupationWarScoreBoard(int InHieronScore, int InHieronFlagScore, int InUnionScore, int InUnionFlagScore);
	void OpenOccupationWarLeaveDaialog(int InOccupationWarCId);
	void OpenOccupationWarJoinCancelDaialog(int InOccupationWarCId);
	void ReOpenOccupationWarJoinDialog();
	void OpenOccupationWarJoinDialog(int InOccupationWarCId, int InDialogRemainTime);
	void OpenOccupationWarWaitingCancelDaialog(int InOccupationWarCId);
	void SetWarMatchingHUD(TEnumAsByte<ECEBattleFieldWarType> InWarType, bool bShow, bool bMatchingSuccess, int InStandNumber);
	void SetWarListUI_Button(class UBLConquest* InWar);
	void SetWarListUI_View(class UBLConquest* InWar);
	void SetWarListUI_DataList(class UBLConquest* InSelectWar, TArray<class UBLConquest*>* InWarList);
	void UpdateWarListUI(class UBLConquest* InSelectWar, TArray<class UBLConquest*>* InWarList);
	void Tick(float InDeltaTime);
};


// Class BLGame.BLDevGFxUIPlayer
// 0x0028 (0x020C - 0x01E4)
class UBLDevGFxUIPlayer : public UGFxMoviePlayer
{
public:
	class UGFxObject*                                  Target;                                                   // 0x01E4(0x0008)
	class UTeleportBookMarkCommon*                     BookMarkCommon;                                           // 0x01EC(0x0008)
	class UTeleportBookMarkLocal*                      BookMarkLocal;                                            // 0x01F4(0x0008)
	class UBLDevGFxUITeleportBookMark*                 TeleportBook;                                             // 0x01FC(0x0008)
	class UBLDevGFxUITeleportBookMark_Clik*            TeleportBook1;                                            // 0x0204(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLDevGFxUIPlayer");
		return ptr;
	}


	bool WidgetInitialized(const struct FName& WidgetName, const struct FName& WidgetPath, class UGFxObject* Widget);
	bool UAEscapeAction();
	struct FString GetBookMarkLabel(const struct FTeleportBookMark& inBookMark);
	class UGFxObject* GetBookMarkData(const struct FTeleportBookMark& inBookMark);
	class UGFxObject* GetBookMarkDataFromType(int Type);
	class UGFxObject* AUTeleportBookMarkTabDatas(int Type);
	class UGFxObject* AUTeleportBookMarkTabNames();
	bool AUExecTeleportFromBookMark(int MarkType, int Index);
	void TeleportBookMarkRefresh();
	bool AUDeleteTeleportBookMark(int MarkType, int Index);
	void AUAddTeleportBookMark(const struct FString& strName, const struct FString& Desc, bool bAutoSaveLocation, int XPos, int YPos, int zPos);
	void registerTeleportBook(class UBLDevGFxUITeleportBookMark* _TeleportBook);
	void AUInputEnd();
	void AUInputStart();
	struct FASValue BLUIHitTestPoint(int nX, int nY, bool ignoreInvisibleChildren);
	void BLCloseUI(const struct FString& UIName);
	void BLOpenUI(const struct FString& UIName);
	class UGFxObject* GetRoot();
	void Init(class ULocalPlayer* LocPlay);
};


// Class BLGame.BLHUDBase
// 0x000C (0x06EC - 0x06E0)
class ABLHUDBase : public AUDKHUD
{
public:
	unsigned long                                      bUIPlayerViewportSet : 1;                                 // 0x06E0(0x0004)
	struct FVector2D                                   ViewportSize;                                             // 0x06E4(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLHUDBase");
		return ptr;
	}


	void OnShowJavascriptDialog(int RequestID, int DialogFlags, const struct FString& Message, const struct FString& DefaultPrompt, const struct FString& FrameURL);
	void OnJavascriptConsoleMessage(const struct FString& Message, int LineNumber, const struct FString& Source);
	void OnChangeHistory(int BackCount, int ForwardCount);
	void OnDocumentReady(const struct FString& URL);
	void OnGetPageContents(const struct FString& InURL, const struct FString& Contents);
	void OnWebViewPluginCrashed(const struct FString& PlugInName);
	void OnWebViewCrashed();
	void OnReceiveTitle(const struct FString& Title, const struct FString& FrameName);
	void OnJavascriptCallback(const struct FString& ObjectName, const struct FString& CallbackName, TArray<struct FJSValue> Arguments);
	void OnFinishLoading();
	void OnBeginLoadingFrame(const struct FQWord& FrameID, const struct FString& URL, bool IsMainFrame, bool IsErrorPage);
	void PostRender();
	void PreCalcValues();
	struct FString GetBuildDateTime();
	void DrawHUD();
	void PostBeginPlay();
	void Init();
};


// Class BLGame.GameHUD
// 0x00E8 (0x07D4 - 0x06EC)
class AGameHUD : public ABLHUDBase
{
public:
	class UBLDevGFxUIPlayer*                           BLDevUI;                                                  // 0x06EC(0x0008)
	class UMaterialEffect*                             SplitScreenEffect;                                        // 0x06F4(0x0008) (Transient)
	class UMaterialInstance*                           SplitScreenMI;                                            // 0x06FC(0x0008) (Transient)
	float                                              SplitScreenTime;                                          // 0x0704(0x0004) (Transient)
	float                                              TotalSplitScreenTime;                                     // 0x0708(0x0004) (Transient)
	TEnumAsByte<EDrawNameMode>                         DrawNameMode;                                             // 0x070C(0x0001) (Transient)
	TEnumAsByte<ECutInState>                           CutInState;                                               // 0x070D(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x070E(0x0002) MISSED OFFSET
	unsigned long                                      bDrawPopup : 1;                                           // 0x0710(0x0004) (Transient)
	unsigned long                                      bShowCutIn : 1;                                           // 0x0710(0x0004) (Transient)
	float                                              MaxDrawOverlayDistance;                                   // 0x0714(0x0004) (Edit, Config)
	TArray<struct FTimeGapInfo>                        TimeGapInfoArray;                                         // 0x0718(0x0010) (NeedCtorLink)
	int                                                MaxTimeGapChannel;                                        // 0x0728(0x0004) (Const)
	int                                                TimeGapCountToPrint;                                      // 0x072C(0x0004) (Const)
	class ACutInCameraActor*                           CutInCam;                                                 // 0x0730(0x0008) (Transient)
	int                                                LastPingTime;                                             // 0x0738(0x0004) (Transient)
	class UMaterial*                                   CutInCaptureMat;                                          // 0x073C(0x0008)
	class UMaterialInstanceConstant*                   CutInCaptureMatInstance;                                  // 0x0744(0x0008) (Transient)
	struct FCameraAnimInfo                             CutInAnimInfo;                                            // 0x074C(0x0020) (Const)
	struct FLinearColor                                LC_White;                                                 // 0x076C(0x0010) (Const)
	struct FColor                                      GrayColor;                                                // 0x077C(0x0004) (Const)
	float                                              DamagePopupLifeTime;                                      // 0x0780(0x0004) (Const)
	float                                              HealPopupLifeTime;                                        // 0x0784(0x0004) (Const)
	float                                              ExpPopupLifeTime;                                         // 0x0788(0x0004) (Const)
	int                                                MaxDamagePopupItem;                                       // 0x078C(0x0004) (Const)
	int                                                MaxHealPopupItem;                                         // 0x0790(0x0004) (Const)
	int                                                MaxExpPopupItem;                                          // 0x0794(0x0004) (Const)
	TArray<struct FBLPopupString>                      DamageString;                                             // 0x0798(0x0010) (NeedCtorLink)
	TArray<struct FBLPopupString>                      HealString;                                               // 0x07A8(0x0010) (NeedCtorLink)
	TArray<struct FBLPopupString>                      ExpString;                                                // 0x07B8(0x0010) (NeedCtorLink)
	struct FDurabilityHUDInfo                          EquipmentDurabilityHUD;                                   // 0x07C8(0x000C) (Config)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.GameHUD");
		return ptr;
	}


	void TestPCParam();
	void ToggleCharInfo();
	void ToggleMinimap();
	void DrawCountDown();
	void DevUIOpen(const struct FString& UIName);
	class UBLDevGFxUIPlayer* GetDevUI();
	void ShowDebugInfo(float* out_YL, float* out_YPos);
	void DrawBuildDateTime();
	void STATIC_DrawBarGraph(float X, float Y, float Width, float MaxWidth, float Height, class UCanvas* DrawCanvas, const struct FColor& BarColor, const struct FColor& BackColor);
	void STATIC_DrawHealth(float X, float Y, float Width, float MaxWidth, float Height, class UCanvas* DrawCanvas, unsigned char Alpha);
	void DrawTextCentered(class UCanvas* Cav, const struct FString& Text);
	void DrawFX_CutIn();
	void DrawHUD();
	void Init();
	void Tick(float DeltaTime);
	void SplitScreen(float Time);
	void PlayCutIn(float PlayRate);
	void HandleCutInState(float DeltaTime);
	void HideCutIn();
	void PostBeginPlay();
	void NewExpPopupString(class ABLPawnBase* a_Target, int a_Exp, bool a_bHighLight);
	void NewHealPopupString(class ABLPawn* a_Target, int a_Damage, bool a_bHighLight, const struct FString& a_DamageDesc);
	void NewHealPopupStringByText(class ABLPawn* a_Target, const struct FString& a_Text, bool a_bHighLight);
	void NewDamagePopupString(class ABLPawn* a_Target, int a_Damage, bool a_bHighLight, const struct FString& a_DamageDesc);
	void NewDamagePopupStringByText(class ABLPawn* a_Target, const struct FString& a_Text, bool a_bHighLight);
	int GetExpPopupStringSlot();
	int GetHealPopupStringSlot();
	int GetDamagePopupStringSlot();
	void DrawPopupString();
	void ProcessPopupString(float a_Delta);
	bool CanDrawOverlay(const struct FVector& TargetLocation, const struct FVector& CameraPosition);
	bool IsValidDistanceForOverlay(float aDistance);
	void ToggleName();
	void InitPopupStringSystem();
};


// Class BLGame.LobbyHUD
// 0x0000 (0x06EC - 0x06EC)
class ALobbyHUD : public ABLHUDBase
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.LobbyHUD");
		return ptr;
	}


	void PostBeginPlay();
};


// Class BLGame.BLMinimapCaptureActor
// 0x0000 (0x0260 - 0x0260)
class ABLMinimapCaptureActor : public ASceneCapture2DActor
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLMinimapCaptureActor");
		return ptr;
	}

};


// Class BLGame.BLMinimapCaptureComponent
// 0x0014 (0x0184 - 0x0170)
class UBLMinimapCaptureComponent : public USceneCapture2DComponent
{
public:
	float                                              CaptureSize;                                              // 0x0170(0x0004) (Edit)
	struct FExportShowFlags_Mirror                     ShowFlagsCustom;                                          // 0x0174(0x0010) (Const)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLMinimapCaptureComponent");
		return ptr;
	}

};


// Class BLGame.BLQuestJournalUIManager
// 0x0000 (0x0060 - 0x0060)
class UBLQuestJournalUIManager : public UObject
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLQuestJournalUIManager");
		return ptr;
	}


	void SetGuideQuestSummary(const struct FString& Summary);
	void SetCompleteGuideList(int InStageID, TArray<class UGFxObject*> CompleteGuideList);
	void RemoveGuideQuest(int InQuestID, int InStageID);
	void AddGuideQuest(int InQuestID, int InStageID, int InQuestLevel, const struct FString& InQuestTitle, bool InIsCompleted, bool InIsFailed, bool InIsActive, float InQuestTimeLimit, bool IsDisable);
	void CompleteGuideQuestDetailInfo(int questId, class UGFxObject* QuestInfo, int InStageID, bool QuestAbandon, const struct FString& QuestContent, int QuestObjectiveType, int SelectiveCount, TArray<class UGFxObject*> Objectives, TArray<class UGFxObject*> BonusObjectives);
	void SetGuideQuestDetailInfo(int InQuestID, int InStageID, const struct FString& InQuestTitle, bool InQuestAbandon, bool InPositioningCheckDisabled, const struct FString& InQuestContent, int InTimeLimit, int InQuestObjectiveType, int InSelectiveCount, TArray<class UGFxObject*> InObjectives, TArray<class UGFxObject*> InBonusObjectives, TArray<class UGFxObject*> InUsableItems);
	void InitGuideQuestList(TArray<class UGFxObject*> Lists, int CurrentActiveQuest, int MaxActiveQuest);
	void AddGuideQuestStageInfo(int InGuideStageID, const struct FString& InName, bool InExtension, int InPrimary);
	void Set_Quest_DetailInfo(int questId, int QuestType, const struct FString& Title, const struct FString& Content, bool isCompleted, bool isFailed, bool onGoingLevel, bool abandon, int TimeLimit, int ObjectiveType, int SelectiveCount, TArray<class UGFxObject*> Objectives, TArray<class UGFxObject*> useItems, bool positioning);
	void SetPlotHistory(const struct FString& PlotHistory);
	void AddStoryPlot(int StoryID, class UGFxObject* StoryObject);
	void AddStory(class UGFxObject* StoryObject);
	void InitStoryInfo(TArray<class UGFxObject*> Lists);
	void InitQuestReward();
	void SetQuestReward2(int QuestType, TArray<class UGFxObject*> rewards);
	void SetRoyalQuestSummary(struct FString* Summary);
	void SetReceiveRewardInfo(int questId, int QuestType, const struct FString& Title, int RewardMoney, int RewardExp, TArray<class UGFxObject*> FixedRewards, TArray<class UGFxObject*> SelectiveRewards, class UGFxObject* ObjToken);
	void CompleteQuestDetailInfo(int questId, class UGFxObject* QuestInfo, int LocationID, bool QuestAbandon, const struct FString& QuestContent, int QuestObjectiveType, int SelectiveCount, TArray<class UGFxObject*> Objectives, TArray<class UGFxObject*> BonusObjectives);
	void SetQuestSummary(const struct FString& Summary);
	void SetQuestDetailInfo(int InQuestID, int InLocationId, const struct FString& InQuestTitle, bool InQuestAbandon, bool InPositioningCheckDisabled, const struct FString& InQuestContent, int InTimeLimit, int InQuestObjectiveType, int InSelectiveCount, TArray<class UGFxObject*> InObjectives, TArray<class UGFxObject*> InBonusObjectives, TArray<class UGFxObject*> InUsableItems);
	void SetCompleteEpisodeList(int InLocationId, TArray<class UGFxObject*> CompleteEpisodeList);
	void SetQuestReward(int questId, TEnumAsByte<ECEQuestType> QuestType, int RewardMoney, int RewardExp, bool isBonus, int BonusRewardMoney, int BonusRewardExp, TArray<class UGFxObject*> FixedRewards, TArray<class UGFxObject*> SeletiveRewards, class UGFxObject* tokenObject, bool IsShowReceiveRewardButton, bool IsGuideVisible, bool IsGuideDisable);
	void SetPlotInfo(class UGFxObject* PlotInfo, TArray<class UGFxObject*> Objectives, TArray<class UGFxObject*> UsableItems);
	void UpdateQuest(int InQuestID, TEnumAsByte<EActionScript_QuestType> InQuestType, int InLocationId, int InQuestLevel, const struct FString& InQuestTitle, bool InIsCompleted, bool InIsFailed, bool InIsActive, bool IsDisable);
	void InitRoyalQuest(TArray<class UGFxObject*> Quests);
	void StoryRefresh();
	void UpdateStoryQuest(int InStoryID, int InPlotIndex);
	void AddQuest(int InQuestID, int InLocationId, int InQuestLevel, const struct FString& InQuestTitle, bool InIsCompleted, bool InIsFailed, bool InIsActive, float InQuestTimeLimit);
	void RemoveLocationInfo(int InLocationId);
	void RemoveQuest(int InQuestID, int InLocationId);
	void AddLocationInfo(int InLocationId, const struct FString& InLocationName, bool InExtension, int InPrimary);
	void InitQuestList(TArray<class UGFxObject*> Lists, int CurrentActiveQuest, int MaxActiveQuest);
	class UBLUIPlayer* GetUI();
};


// Class BLGame.BLSkillDeckUIManager
// 0x0034 (0x0094 - 0x0060)
class UBLSkillDeckUIManager : public UObject
{
public:
	TEnumAsByte<EBLSkillDeckTabType>                   CurrentSelectTab;                                         // 0x0060(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	int                                                CurrentTacticsPage;                                       // 0x0064(0x0004)
	int                                                CurrentSelectStanceCid;                                   // 0x0068(0x0004)
	int                                                CurrentSelectNonStanceCid;                                // 0x006C(0x0004)
	TArray<struct FBLParamIncreaseUIData>              ParameterIcreaseDataList;                                 // 0x0070(0x0010) (NeedCtorLink)
	struct FQWord                                      TempGoldCost;                                             // 0x0080(0x0008)
	int                                                TacticsUnlockCount;                                       // 0x0088(0x0004)
	unsigned long                                      OpenerGemPieceCountInitialized : 1;                       // 0x008C(0x0004)
	int                                                OpenerGemPieceCount;                                      // 0x0090(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLSkillDeckUIManager");
		return ptr;
	}


	void OpenDialogAddGemOver(int InItemCid, TEnumAsByte<ECEGemType> InGemType);
	void OpenDialogAddGemPieceOver(int InItemCid);
	void SetOpenerCount(int InCount);
	int GetCurrentRemainParameterGem();
	int GetCurrentRemainNonStanceGem();
	int GetCurrentRemainStanceGem();
	bool IsCurrentTooltipGemNodeActivated(int InNodeCid);
	TEnumAsByte<EBLSkillDeckTabType> GetCurrentPageType();
	void OpenResetSkillTacticsDialog();
	bool OpenCloseUICautionDialog();
	bool OpenChangeTacticsCautionDialog(int InPageIndex);
	void OpenWithdrawGemDialog(int InStanceGem, int InNonStanceGem, int InParameterGem, const struct FQWord& InGold);
	void ChangeTab(int InTabIndex);
	void ChangeTacticsPage(int InPageIndex);
	bool OnClickGemWithdrawDialogButton();
	void OnClickResetTacticsDialogButton();
	void OnClickSelectiveParameterSkillGemNode(int InNodeCid, int InPageIndex, int InNodeIndex);
	void OnClickParameterSkillGemNode(int InNodeCid, int InPageIndex, int InNodeIndex);
	void OnClickNonStanceSkillGemNode(int InNonStanceSkillCid, int InNodeCid);
	void OnClickStanceSkillGemNode(int InStanceCid, int InNodeCid);
	void OnClickCancelSkillTacticsChange();
	void OnClickResetSkillTactics();
	void OnClickSaveSkillTactics();
	void OnClickUseSkillTactics();
	void OnClickSetShortCutButton(TEnumAsByte<EBLSkillShortCutUISlotIndex> InUISlotIndex, bool InAdd);
	void OnClickNonStanceTopListSlot(int InCid);
	void OnClickStanceTopListSlot(int InCid);
	void OnCloseUI();
	void OnOpenUI();
	void OnUILoadComplete();
	void SetClassType();
	void ResetChangedData();
	void UpdateTacticsPage(int InPageIndex);
	void UpdateSelectiveNodeUI(int InNodeCid, int InPageIndex, int InNodeIndex);
	void UpdateParameterStatList();
	void UpdateParameterDataList();
	void UpdateStanceSkillTree(int InStanceCid);
	void UpdateNonStanceSkillData(int InCid);
	void UpdateStanceSkillDataList(int InStanceCid);
	void UpdateNonStanceTopList();
	void UpdateStanceTopList();
	void UpdateSkillDeckShortCutData();
	void UpdateTacticsLock();
	void UpdateButtons();
	void UpdateGemText();
	void UpdateTacticsText(int InPageIndex);
	void UpdateCurrentPage();
	void CloseSkillDeckUI();
	void ClearUI();
	void Init();
	bool IsUseSkillGem();
	void MakeParameterSelectionGemNodeObject(const struct FBLSkillGemInfo& InGemInfo, bool OtherNodeActivaed, class UGFxObject** OutObject);
	void MakeParameterGemNodeObject(const struct FBLSkillGemInfo& InGemInfo, class UGFxObject** OutObject);
	void MakeShortCutNonStanceSkillSlotObject(TEnumAsByte<EBLSkillShortCutUISlotIndex> InSlotIndexType, int InCid, class UGFxObject** OutObject);
	void MakeShortCutStanceSkillSlotObject(TEnumAsByte<EBLSkillShortCutUISlotIndex> InSlotIndexType, int InCid, class UGFxObject** OutObject);
	void MakeShortCutStanceSlotObject(TEnumAsByte<EBLSkillShortCutUISlotIndex> InSlotIndexType, int InCid, class UGFxObject** OutObject);
};


// Class BLGame.BLUIManager
// 0x0544 (0x05A4 - 0x0060)
class UBLUIManager : public UObject
{
public:
	TArray<struct FName>                               MinimapTextures;                                          // 0x0060(0x0010) (Transient, NeedCtorLink)
	TArray<class UTexture2D*>                          ActiveMinimapTextures;                                    // 0x0070(0x0010) (Transient, NeedCtorLink)
	class UTexture2D*                                  DefaultMinimapTexture;                                    // 0x0080(0x0008) (Transient)
	class UTexture2D*                                  DefaultMinimapDoorTexture;                                // 0x0088(0x0008) (Transient)
	TArray<int>                                        DestroyedEquipSidList;                                    // 0x0090(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<int>                                        DestroyedInventorySidList;                                // 0x00A0(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<int>                                        LockInventorySlotSidList;                                 // 0x00B0(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<int>                                        LockEquipSlotIndexList;                                   // 0x00C0(0x0010) (AlwaysInit, NeedCtorLink)
	int                                                TalkNPCId;                                                // 0x00D0(0x0004)
	float                                              TalkButtonDelayTime;                                      // 0x00D4(0x0004) (Config)
	class UBLGameEngine*                               GameEngine;                                               // 0x00D8(0x0008)
	unsigned long                                      bForceCloseUIPlayer : 1;                                  // 0x00E0(0x0004)
	unsigned long                                      bNeedToCheckUIMode : 1;                                   // 0x00E0(0x0004)
	unsigned long                                      bCurrentUIMode : 1;                                       // 0x00E0(0x0004)
	unsigned long                                      bTutorialMode : 1;                                        // 0x00E0(0x0004)
	unsigned long                                      CreateSelectTrackingType : 1;                             // 0x00E0(0x0004)
	unsigned long                                      bBattleMessagePending : 1;                                // 0x00E0(0x0004)
	unsigned long                                      bActivatedAimTargeting : 1;                               // 0x00E0(0x0004)
	unsigned long                                      UseInsideWheel : 1;                                       // 0x00E0(0x0004)
	unsigned long                                      OpenerVisibleFlag : 1;                                    // 0x00E0(0x0004) (Config)
	unsigned long                                      bPendingUIWhenCinematicPlay : 1;                          // 0x00E0(0x0004)
	unsigned long                                      bIsOpenedCreditUI : 1;                                    // 0x00E0(0x0004)
	unsigned long                                      LootingDiceInitializeComplete : 1;                        // 0x00E0(0x0004)
	int                                                UI_LOAD_STATE;                                            // 0x00E4(0x0004)
	int                                                UI_STATE;                                                 // 0x00E8(0x0004)
	TEnumAsByte<EUIStateExtension>                     UIStateEX;                                                // 0x00EC(0x0001)
	TEnumAsByte<ECERealmType>                          CreateSelectRealmType;                                    // 0x00ED(0x0001)
	TEnumAsByte<ECERaceType>                           CreateSelectRaceType;                                     // 0x00EE(0x0001)
	TEnumAsByte<ECEClassType>                          CreateSelectClassType;                                    // 0x00EF(0x0001)
	TEnumAsByte<ECEGenderType>                         CreateSelectGenderType;                                   // 0x00F0(0x0001)
	TEnumAsByte<EMailBoxState>                         MailBoxState;                                             // 0x00F1(0x0001)
	TEnumAsByte<EMailWriteOpenType>                    MailWriteType;                                            // 0x00F2(0x0001)
	TEnumAsByte<ECEWorldMapType>                       PositionSendMapType;                                      // 0x00F3(0x0001)
	TEnumAsByte<EQuestErrorCode>                       StoryQuestState;                                          // 0x00F4(0x0001)
	TEnumAsByte<ECoinType>                             OpenedShopType;                                           // 0x00F5(0x0001)
	TEnumAsByte<EOrderSortType>                        OrderSortType;                                            // 0x00F6(0x0001)
	TEnumAsByte<EBLLumenaShopPreviewType>              LumenaShopPreviewType;                                    // 0x00F7(0x0001)
	TEnumAsByte<EEquipConvertResult_Mode>              EquipConvertResultMode;                                   // 0x00F8(0x0001)
	TEnumAsByte<EWebSessionType>                       CachingWebSessionType;                                    // 0x00F9(0x0001)
	TEnumAsByte<EWarRealmResult>                       WarRealmVictoryResult;                                    // 0x00FA(0x0001)
	unsigned char                                      UnknownData00[0x1];                                       // 0x00FB(0x0001) MISSED OFFSET
	struct FString                                     InvalidTempLoginID;                                       // 0x00FC(0x0010) (AlwaysInit, NeedCtorLink)
	struct FString                                     InvalidTempLoginPassword;                                 // 0x010C(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<struct FUIStateData>                        BLUIs;                                                    // 0x011C(0x0010) (NeedCtorLink)
	TArray<struct FString>                             RollBackVisibleUIs;                                       // 0x012C(0x0010) (NeedCtorLink)
	TArray<TEnumAsByte<EUIOpenerType>>                 CurrentDisabledOpeners;                                   // 0x013C(0x0010) (NeedCtorLink)
	TArray<TEnumAsByte<EUIOpenerType>>                 CurrentIconLockOpeners;                                   // 0x014C(0x0010) (NeedCtorLink)
	TArray<TEnumAsByte<EUIOpenerType>>                 CurrentAvailabledOpeners;                                 // 0x015C(0x0010) (NeedCtorLink)
	TArray<TEnumAsByte<EUIOpenerType>>                 TutorialDisableOpeners;                                   // 0x016C(0x0010) (NeedCtorLink)
	int                                                NewGoodsBoxCount;                                         // 0x017C(0x0004)
	int                                                NewExchangeItemCount;                                     // 0x0180(0x0004)
	struct FString                                     ActiveUIName;                                             // 0x0184(0x0010) (NeedCtorLink)
	int                                                SystemMessage_Celebrate_MinGrade;                         // 0x0194(0x0004)
	struct FPawnAbnormalGroupData                      MyPawnAbnormalGroupData;                                  // 0x0198(0x0048) (NeedCtorLink)
	struct FPawnAbnormalGroupData                      TargetPawnAbnormalGroupData;                              // 0x01E0(0x0048) (NeedCtorLink)
	TArray<struct FRealmDataInfo>                      CreateRealmInfo;                                          // 0x0228(0x0010) (AlwaysInit, NeedCtorLink)
	int                                                CreateSelectVoiceType;                                    // 0x0238(0x0004)
	int                                                CreateSelectTargetingMode;                                // 0x023C(0x0004)
	int                                                CreateSelectMoveControlType;                              // 0x0240(0x0004)
	int                                                CreateSelectKeyPresetType;                                // 0x0244(0x0004)
	TArray<struct FDialogData>                         ActiveDialogList;                                         // 0x0248(0x0010) (NeedCtorLink)
	TArray<struct FPendingDialogData>                  PendingDialogList;                                        // 0x0258(0x0010) (NeedCtorLink)
	TArray<struct FCustomDialogData>                   ActiveCustomDialogList;                                   // 0x0268(0x0010) (NeedCtorLink)
	struct FMailBoxEx                                  GeneralMailBox;                                           // 0x0278(0x0030) (NeedCtorLink)
	struct FMailBox                                    KeepMailBox;                                              // 0x02A8(0x0020) (NeedCtorLink)
	struct FMailBox                                    SendMailBox;                                              // 0x02C8(0x0020) (NeedCtorLink)
	int                                                NewMailCount;                                             // 0x02E8(0x0004)
	int                                                OverMailCount;                                            // 0x02EC(0x0004)
	int                                                LatestMailItemKey;                                        // 0x02F0(0x0004)
	int                                                ReturnMailIndex;                                          // 0x02F4(0x0004)
	int                                                PositionSendMapCID;                                       // 0x02F8(0x0004)
	struct FString                                     PositionSendZoneName;                                     // 0x02FC(0x0010) (NeedCtorLink)
	struct FVector                                     PositionSendLocation;                                     // 0x030C(0x000C)
	TArray<struct FSendMailItem>                       SendMailItems;                                            // 0x0318(0x0010) (AlwaysInit, NeedCtorLink)
	int                                                PawnExp;                                                  // 0x0328(0x0004)
	int                                                LevelExpRangeMin;                                         // 0x032C(0x0004)
	int                                                LevelExpRangeMax;                                         // 0x0330(0x0004)
	int                                                LocationCId;                                              // 0x0334(0x0004)
	struct FString                                     LocationName;                                             // 0x0338(0x0010) (NeedCtorLink)
	int                                                TradeRequesterSID;                                        // 0x0348(0x0004)
	int                                                NotEnoughLevel;                                           // 0x034C(0x0004)
	struct FString                                     EnvironmentText;                                          // 0x0350(0x0010) (NeedCtorLink)
	TArray<struct FBattleMessageData>                  BattleMessageBuffer;                                      // 0x0360(0x0010) (NeedCtorLink)
	int                                                DrawBattleMessageAccumTickCount;                          // 0x0370(0x0004)
	int                                                DrawBattleMessageCountOnTick;                             // 0x0374(0x0004)
	int                                                MaxBattleMessageBufferSize;                               // 0x0378(0x0004)
	int                                                DrawBattleMessageIntervalTickCount;                       // 0x037C(0x0004)
	struct FMap_Mirror                                 BattleMessageFloaterList;                                 // 0x0380(0x0048) (Native)
	float                                              BattleMessageDefaulScale;                                 // 0x03C8(0x0004)
	float                                              BattleMessageCustomScale;                                 // 0x03CC(0x0004)
	struct FVector2D                                   AimPos;                                                   // 0x03D0(0x0008)
	struct FVector2D                                   AweMouseOffset;                                           // 0x03D8(0x0008)
	struct FContentTokenExchangeCacheData              ContentTokenExchageUI_CachedData;                         // 0x03E0(0x0024)
	struct FContentTokenExchnageCachedDataV2           ContentTokenExchangeUI_CachedDataV2;                      // 0x0404(0x0028)
	TArray<struct FDungeonEntranceUIData>              DungeonEntranceUIDataList;                                // 0x042C(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<struct FPartyMatchingUIData>                PartyMatchingUIDataList;                                  // 0x043C(0x0010) (AlwaysInit, NeedCtorLink)
	int                                                CurrentPartyMatchingUIDungeonCid;                         // 0x044C(0x0004) (Transient)
	TArray<struct FRaidPartyFrameConfig>               DefaultRaidPartyFrameConfig;                              // 0x0450(0x0010) (Config, NeedCtorLink)
	int                                                OrderSelectedTabIndex;                                    // 0x0460(0x0004)
	int                                                CurTutorialOrderAlertCid;                                 // 0x0464(0x0004)
	int                                                MaxRankingPage;                                           // 0x0468(0x0004)
	int                                                CurrentRankingPage;                                       // 0x046C(0x0004)
	TArray<struct FChallengeTowerPersonalRecordData>   PersonalRecordDataList;                                   // 0x0470(0x0010) (NeedCtorLink)
	TArray<struct FChallengeTowerRankData>             ServerRecordDataList;                                     // 0x0480(0x0010) (NeedCtorLink)
	class UBLChatManager*                              ChatManager;                                              // 0x0490(0x0008) (Transient)
	class UBLDisplayItem*                              DisplayItem;                                              // 0x0498(0x0008) (Transient)
	struct FString                                     SaveCustomizeFileName;                                    // 0x04A0(0x0010) (NeedCtorLink)
	int                                                CustomizeSelectedIndex;                                   // 0x04B0(0x0004)
	struct FString                                     CustomizeTemporaryFile;                                   // 0x04B4(0x0010) (NeedCtorLink)
	float                                              DragIconSize;                                             // 0x04C4(0x0004) (Config)
	TArray<struct FChatData>                           DebugChatDataList;                                        // 0x04C8(0x0010) (Transient, NeedCtorLink)
	class UWICPromotion*                               WICPromotionData;                                         // 0x04D8(0x0008)
	TArray<struct FUIPendingData>                      PendingUIDatas;                                           // 0x04E0(0x0010) (NeedCtorLink)
	class UBLItemDurabilityHUD*                        ItemDurabilityHUD;                                        // 0x04F0(0x0008)
	class UBLItemRepair*                               ItemRepair;                                               // 0x04F8(0x0008)
	class UBLItemRecover*                              ItemRecover;                                              // 0x0500(0x0008)
	class UBLItemEquipUpgrade*                         ItemEquipUpgrade;                                         // 0x0508(0x0008)
	class UBLItemEvolution*                            ItemEvolution;                                            // 0x0510(0x0008)
	class UBLItemDesynthesis*                          ItemDesynthesis;                                          // 0x0518(0x0008)
	class UBLItemSucceed*                              ItemSucceed;                                              // 0x0520(0x0008)
	struct FDouble                                     GameUI_StartTime;                                         // 0x0528(0x0008) (Const, Transient)
	struct FDouble                                     GameUI_EndLoad_Time;                                      // 0x0530(0x0008) (Const, Transient)
	struct FDouble                                     GameUI_EndInit_Time;                                      // 0x0538(0x0008) (Const, Transient)
	int                                                LumenaShopItemCid;                                        // 0x0540(0x0004)
	int                                                CacheingToolTipType;                                      // 0x0544(0x0004)
	int                                                CacheingContainerType;                                    // 0x0548(0x0004)
	class UGFxObject*                                  CacheingToolTipData;                                      // 0x054C(0x0008)
	int                                                PrivateTradePlayerSid1;                                   // 0x0554(0x0004)
	int                                                PrivateTradePlayerSid2;                                   // 0x0558(0x0004)
	TArray<struct FBLLootingDiceData>                  LootingDiceDataPendingList;                               // 0x055C(0x0010) (AlwaysInit, NeedCtorLink)
	class UBLConquestUIManager*                        ConquestUIManager;                                        // 0x056C(0x0008)
	struct FString                                     WarRealmResultStr;                                        // 0x0574(0x0010) (NeedCtorLink)
	class UBLActionBarUIManager*                       ActionBarUIManager;                                       // 0x0584(0x0008)
	class UBLSkillDeckUIManager*                       SkillDeckUIManager;                                       // 0x058C(0x0008)
	class UBLSkillQTEHUDUIManager*                     SkillQTEHUDUIManager;                                     // 0x0594(0x0008)
	class UBLQuestJournalUIManager*                    QuestJournalUIManager;                                    // 0x059C(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLUIManager");
		return ptr;
	}


	void UpdateSetAvailableOpener(unsigned char InEOpenerType, bool bActive);
	void UpdateOpenerContentActive();
	TEnumAsByte<EUIJournalTabType> GetEUIJournalTabTypeByName(const struct FString& InUIJournalTabName);
	struct FString GetUIJournalTabTypeNameByEnum(TEnumAsByte<EUIJournalTabType> InEUIJournalTab);
	class UBLQuestJournalUIManager* GetQuestJournalUIManager();
	void SetEquipConvertResultMode(TEnumAsByte<EEquipConvertResult_Mode> InMode);
	void TalkSelectTalkChoice(int SelectionIndex, int selectiveRewardIndex);
	class UGFxObject* TalkMakeRewardItemGFxObject(const struct FString& RewardType, int RewardIndex, int ItemCid, int IconIndex, int Grade, const struct FString& ItemName, int Amount);
	void TalkSetQuestReward(struct FShowQuestRewardInfo* rewardInfo);
	void TalkEnd(int NpcSid);
	void TalkStart(TArray<struct FDialogTextInfo> TextInfoList, const struct FTalkerIDInfo& TalkInfo, float TextPlayTime, class ABLNpc** P, struct FPCDialogInfo* InDialogInfo);
	class UGFxObject* TalkMakeDialogTextPositionData(int XPos, int YPos, int NameXPos, int NameYPos, int NameFontSize, int NameWidth, int DialogXPos, int DialogYPos, int DialogFontSize, int DialogWidth, bool Border);
	void TalkInit();
	void PlayNextCreditMusic();
	void CloseCreditUI();
	void OpenCreditUI();
	void SetCreditData();
	void SetRankingChallengeTowerServerRecordData(int InMaxPageIndex, int InCurrentPageIndex, TArray<struct FChallengeTowerRankData>* InServerRecordDataList);
	void SetRankingChallengeTowerPersonalRecordData(TArray<struct FChallengeTowerPersonalRecordData>* InPersonalRecordDataList);
	class UGFxObject* MakeGfxObjectChallengeTowerRankingGroup(int InGroupIndex, struct FChallengeTowerRankData* InServerRecordData);
	void SetRankingChallengeTowerCurrentPage(int InCurrentPageIndex, bool IsForced);
	TEnumAsByte<EBLLumenaShopPreviewType> GetLumenaShopPreviewType();
	void SetLumenaShopPreviewType(TEnumAsByte<EBLLumenaShopPreviewType> InLumenaShopPreviewType);
	int GetLumenaShopPreviewCid();
	void SetLumenaShopPreviewCid(int InLumenaShopItemCid);
	void RotateRight_LumenaShop(bool InbStartRotate);
	void RotateLeft_LumenaShop(bool InbStartRotate);
	void SetLumenaShopPreview_FellowCostume(int LookCid);
	void SetLumenaShopPreview_PetCostume(int LookCid);
	void SetLumenaShopPreview_MountCostume(int LookCid);
	void SetLumenaShopPreview_PlayerCostume(TArray<int> CostumeItemCidList);
	void SetLumenaShopPreview(int Cid, bool bForce);
	void RotateRight_Equip(bool InbStartRotate);
	void RotateLeft_Equip(bool InbStartRotate);
	void SetEquipPreview(bool bForce);
	void RequestPreview();
	void SetZeroRotate(TEnumAsByte<EUIName> InUIName);
	void Fill_ItemStats(int InEvolutionLevel, int InUpgradeLevel, struct FItemInfoData* InItemInfoData, TArray<struct FStatData>* InStatdataList);
	void ShowExitAbnormalFallingFinalDialog();
	void ShowExitAbnormalFallingDialog();
	void RequestDisabledSlot_InInventoryTab();
	void ItemDevelopmentTick(float DeltaTime);
	void SetDestroyedEquipItemInEquipTab();
	void SetDestroyedEquipItemInInventoryTab();
	void CloseNeedlessItemUI();
	void OpenMessageBox(const struct FString& InMessage, bool InbUseGameStringInfo);
	void OpenDialogSkillTreeRecvResultError();
	void TutorialOrderUIActionCheck(const struct FString& UIName);
	void TutorialOrderCheck(const struct FString& CheckName);
	void OpenEventPromotionPage();
	void InitQuestAlert();
	void LoadQuestAlertFilter();
	void DisableAllEquipSlot();
	void EnableAllEquipSlot();
	void LockAllEquipSlot();
	void ClearLockedEquipSlot();
	void DestroyedEquipItem(int Sid, bool bLock);
	void LockEquipItem(int Sid, bool bLock);
	void OpenDialog_AlertBondingOnEquip(const struct FString& Sid, int Slot);
	class UGFxObject* MakeTutorialOrderGFxObject_Struct(struct FTutorialOrderData* TutorialOrderInfoData);
	class UGFxObject* MakeTutorialOrderGFxObject_Variable(int Cid, const struct FString& Category, const struct FString& Label, int Max, int Min, int Value, int Exp, TArray<struct FRewardItemData> RewardDatas, int CurState);
	void NextTutorialOrderGuide();
	void NextTutorialOrderAlarmi();
	void RequestTutorialOrderAlarmi();
	void RequestTutorialOrderGuide(int TutorialOrderId, bool bSendPackage);
	void RequestTutorialOrder();
	void SetNextOpenAlarmi(bool bOpenAlarmi);
	void SetCurTutorialOrderGuideID(int TutorialGuideId);
	void SetTutorialOrderAlarmi(int Cid, const struct FString& CategoryCodename, const struct FString& Description);
	void SetTutorialOrderGuide(const struct FString& Title, const struct FString& Description, const struct FString& ImageLink);
	void SetTutorialOrderStage(const struct FString& StageTitle, int MaxCount, int MinCount, int CurClearCount, TArray<struct FRewardItemData> RewardDatas);
	void SetTutorialOrderList(TArray<struct FTutorialOrderData>* TutorialOrderInfoDatas);
	void RequestOrderInfo(TEnumAsByte<EOrderType> TabIndex);
	void SortOrderList(TEnumAsByte<EOrderType> TabIndex, TArray<struct FOrderInfoData>* OrderInfoDatas);
	void SetOrderInfoList(bool Initialized, TArray<struct FOrderInfoData>* OrderInfoDatas);
	void SetWeeklyInfo(bool Initialized, int COUNT, int MaxCount, TEnumAsByte<EOrderStateType> EState, TArray<struct FRewardItemData> RewardData);
	void SetDailyInfo(bool Initialized, int COUNT, int MaxCount, TEnumAsByte<EOrderStateType> EState, TArray<struct FRewardItemData> RewardData);
	class UGFxObject* MakeOrderGFxObject(int Cid, TEnumAsByte<ECEOrderPeriodType> PeriodType, int SealCount, const struct FString& Label, int COUNT, int MaxCount, TEnumAsByte<EOrderStateType> EState, int Exp, TArray<struct FRewardItemData> RewardData);
	void UpdateOrder(const struct FOrderInfoData& UpdateOrderData);
	void RemoveOrder(TArray<int> RemoveOrderDatas);
	void AddOrder(TArray<struct FOrderInfoData>* AddOrderDatas);
	void SetRewardAlertCount(TEnumAsByte<EOrderType> TabIndex);
	void OpenDialog_AcceptDuel(const struct FString& InPlayerName);
	void LimitTextCnt(int LimitCnt, struct FString* OutMessage);
	TArray<class UGFxObject*> GetRaidFrameSetting();
	void ShowRaidFrame(bool bShow);
	class UGFxObject* MakeGFxObjectByCombatFlairData(const struct FCombatElementData& InCombatFlairData, int storageCountMax);
	void SetRaidCombatFlair(int partyId, int MemberIndex, const struct FString& MemberSid, TArray<struct FCombatElementData> CombatFlairDatas, int storageCountMax);
	class UGFxObject* GetCombatFlair(TEnumAsByte<ECEClassType> PawnClassType, TArray<struct FCombatFlairData> InDataList);
	class UGFxObject* MakeGFxObjectByRaidMemberData(class UPartyMemberData* InMemberData);
	void AddRaidMember(class UPartyMemberData* InMemberData);
	void SetRaidMember(int InPartyID, TArray<class UPartyMemberData*> InMemberDatas);
	void OpenDialog_RegistLimitedRankConfirm();
	void ShowChatEmptyTooltip();
	void ShowTooltipItemDataObject();
	void SetTooltipItemDataObject(int TooltipType, int ContainerType, class UGFxObject* InData);
	void ShowDisplayItemTooltip(int InCid, int nSid, class UBLItem* InInstItem);
	void DisplayItemLink(int InCid, int InSid);
	void OpenWareHouseItemSplitDialog(const struct FString& InTopText, const struct FString& InBottomText, int InMinNum, int InMaxNum, int InCurNum);
	void LockWarehouse(bool Lock);
	void LockWarehouseItem(int Sid, bool Lock);
	void OpenWarehouseUI();
	void CloseExchangeUIByNPC();
	void OpenExchangeUIByNPC();
	void ShowChattingHistory(int InRhs);
	void OpenTalkerPopupMenu(int TalkerSid, const struct FString& TalkerName, bool IsInviteToParty, bool IsFriend, bool IsBlock);
	void UpdateChatOptionActiveTab(int Index);
	void UpdateSubjectList(TArray<class UGFxObject*> InData);
	void UpdateChatOptionDialog(class UGFxObject* InData);
	void UpdateChatTabList(TArray<class UGFxObject*> InData, int InSelectedTab);
	void SetActiveTab(int TabIndex);
	void UpdateChatTabConfig(int TabIndex, class UGFxObject* InData);
	void RemoveChatTab(int TabIndex);
	void AddChatTab(const struct FString& TabName);
	bool ConvertToChatChannel(TEnumAsByte<EChatMessageType> ChatMessageType, TEnumAsByte<EChatChannel>* OutChatChannel);
	TEnumAsByte<EChatMessageType> ConvertToChatMessageType(TEnumAsByte<EChatChannel> ChatChannel);
	void ReplyLastWhisper();
	void SetChatMessage(const struct FString& InMessage, TEnumAsByte<EChatMessageType> InChannleType);
	void PrintChatMessage(TEnumAsByte<EChatChannel> InEChatChannelType, const struct FChatData& InData, bool IsMyWhisper);
	bool SendChatMessage(const struct FString& InMessage, TEnumAsByte<EChatMessageType> InChannelType, const struct FString& InRecieverName);
	void UpdateRaidFrameExtensionSetting(int InPartyID, bool extension);
	void UpdateRaidFramePositionSetting(int InPartyID, float ScaleX, float ScaleY);
	void ApplyInitializedRaidFrameSetting();
	void ReleaseUIRaidFrameCustomSetting();
	void InitializeUIRaidFrameCustomSetting();
	void ReleaseUICustomSetting();
	void InitializeUICustomSetting();
	void UpdateFixedChargeInfo();
	void DoUseItem_Add_Companion(int InItemSid, int InItemCid);
	void OpenDialog_CollectionBook_Term_MPF_Confirm(TEnumAsByte<EAddMPFType> InMPFType, int InItemSid, int InItemCid, int DurationDay, int DurationHour, int DurationMinute);
	void OpenDialog_AddLooting_Confirm(int InOwnerSid);
	void OpenShop_Lumena();
	void CloseResetReturnQuery();
	void OpenResetReturnQuery(int InReturnCoolTime);
	void GetFriendList(TArray<class UGFxObject*>* outFriendList);
	void OpenDialog_Friend_Delete_Confirm(const struct FString& InFriendUID, const struct FString& InFriendName);
	void OpenDialog_Friend_Add_Confirm(const struct FString& InPlayerName);
	void OpenDialog_Friend_Add();
	void OpenDialog_FriendAddImpossibility();
	void UpdateBlockList();
	void UpdateFriendData();
	void OpenLootingDice();
	void SetLootingDiceData(int InOwnerSid, int InTicket, int InItemCid, int InItemCount, bool InAuctionDisable, bool InGiveUpDisable);
	class UGFxObject* CreateLootingDiceItemObject(int InOwnerSid, int InTicket, int InItemCid, int InItemCount, float inTime, float InRemainingTime, bool InAuctionDisable, bool InGiveUpDisable);
	struct FString CreateLootingDiceLable(const struct FString& InItemName, TEnumAsByte<ECEItemGradeType> InGrade);
	void OpenDialog_Customizing_Load_Error();
	void OpenDialog_Customizing_Load_Confirm();
	void OpenDialog_Customizing_Save_Overwrite();
	void OpenDialog_Customizing_Load_TemporaryFile();
	void OpendDialog_Customizing_WrongFile();
	void OpendDialog_Customizing_Preset_Confirm(int controllerType, int CurIndex, int NewIndex);
	void OpendDialog_Customizing_Reset_Confirm(int controllerType);
	void OpenDialog_Customizing_LoadFile_Confirm();
	void OpenDialog_Customizing_Prev_Confirm();
	bool IsExistCustomizeFile(const struct FString& CheckFileName);
	void SaveCustomizeFile(const struct FString& SaveFileName);
	void OpenCustomizeSaveDialog(const struct FString& TempSaveFile);
	void PlayDialogCloseSound();
	void RestorePreset_Customizing(TEnumAsByte<ECustomizeActionScriptUIEnum> InCM_AS_UI, int InIndex);
	void SetPresetIndex_Customizing(TEnumAsByte<ECustomizeActionScriptUIEnum> InCM_AS_UI, int InIndex);
	void Reset_Customizing(TEnumAsByte<ECustomizeActionScriptMenuEnum> InCM_AS_UI);
	void LoadFile_Customizing();
	void UnregisterAllPartyMatching();
	void UpdatePartyMatchingUI(int IndungeonCId);
	bool GetPartyMatchingData(int IndungeonCId, int InIndex, struct FPartyMatchingPlayerData* OutData);
	void SetPartyMatchingData(int IndungeonCId, TArray<struct FDungeonPartyMatchingData>* IndungeonPartyMatchingDataList);
	void UnRegistCustomWaypoint(int InCid);
	void RegistCustomWaypoint(int UseItemCid);
	void TeleportToCustomWaypoint(int UseItemCid, int InCid);
	void TeleportToWaypoint(int UseItemCid, int InCid);
	void RequestActingPointChargeDialog();
	class UGFxObject* CreateDialogStyleObject(const struct FString& Text, int iValue, bool DisableFlag);
	TArray<class UGFxObject*> GetButtonDataByStyle(TEnumAsByte<EDialogStyle> DialogStyle, unsigned char ButtonFlags);
	void OpenDialog_ChangeOverlapGuildName_NotEnoughReusableGuildNameError(const struct FString& InRemainTime);
	void OpenDialog_ChangeOverlapGuildName_DuplicateNameError();
	void OpenDialog_ChangeOverlapGuildName_ForbidStringError(const struct FString& InForbidString);
	void OpenDialog_ChangeOverlapGuildName_InvalidStringError();
	void OpenChangeOverlapGuildName();
	void CloseChangeOverlapGuildName();
	void OpenUI_ChangeGuildNameError(TEnumAsByte<EGuildErrorCode> errCode, const struct FString& InErrorString);
	void OpenDialog_ChangeOverlapCharacterName_DuplicateNameError();
	void OpenDialog_ChangeOverlapCharacterName_ForbidStringError(const struct FString& InForbidString);
	void OpenDialog_ChangeOverlapCharacterName_InvalidStringError();
	void OpenChangeOverlapCharacterName();
	void CloseChangeOverlapCharacterName();
	void OpenUI_ChangePCNameError(TEnumAsByte<ECreateRemovePlayerErrorCode> ErrorCode, const struct FString& ForbidString);
	void OpenBotReportDialog(const struct FString& InTargetName);
	void OpenPartyMemberSummon_Summonee(int InSummonerSid, int InLocationCid);
	void OpenPartyMemberSummon_Summoner(int InSummoneeSid);
	void OpenRevivalConsumeLumenaDialog(const struct FString& InTopText, const struct FString& InLumena);
	void OpenInventoryItemSplitDialog(TEnumAsByte<EDialogType> InDialogType, const struct FString& InTopText, const struct FString& InBottomText, int InMinNum, int InMaxNum, int InCurNum);
	void OpenContentTokenNotEnoughDialog(const struct FString& InTopText);
	void OpenChargeLumenaDialog(TEnumAsByte<EDialogType> InDialogType, const struct FString& InTopText, const struct FString& InLumena);
	void OpenInventoryExpansionPurchaseDialog(const struct FString& InTopText, const struct FString& InBottomText, TArray<struct FString> InSelectionDatas);
	void MakeCreateCharacterPlayerEnv(TArray<struct FPlayerEnvironmentData>* OutList);
	void HidePropTooltip();
	void ShowPropTooltip(int InPropCid);
	void UpdateActingPoint();
	void OpenRestrictChargeActingPointDialog(const struct FString& InResetTimeString);
	void OpenChargeActingPointDialog(int InChargableActingPoint, int InCurrentChargeCount, int InMaxChargeCount, const struct FString& InLumena);
	void CloseEquipCustomDialog();
	void SetEquipCustomPotentialDisjointResult(int InCinis, int InGold);
	void StartEquipCustomPotentialDisjoint();
	void SetEquipCustomPotentialDisjointExpect(int InCinis, int InGold);
	void OpenEquipCustomPotentialDisjointDialog();
	void SetEquipCustomUpgradePotentialResult(bool IsSuccess, int MaterialConsumeCount, int MaterialHaveCount);
	void SetEquipCustomUpgradePotentialPage(TArray<struct FStatData> CurrentStat, TArray<struct FStatData> NextPotentialStat, int MaterialCid, int MaterialConsumeCount, int MaterialHaveCount);
	void StartEquipCustomSpecialResultRoulette(const struct FUIEquipCustomSpecialResultInfo& InResultInfo);
	void SetEquipCustomNormalResult(const struct FUIEquipCustomNormalResultInfo& InResultInfo);
	void SetEquipCustomSpecialPayment(const struct FString& InCurrentText, const struct FString& InLumena);
	void SetEquipCustomNormalPayment(int InGold, int InBP, int InDP, int InCP, int InLumena, bool bUseCinis);
	void SetEquipCustomItemParameter(TArray<struct FUIEquipCustomItemNormalParamInfo>* InNormalParamList, TArray<struct FUIEquipCustomItemSpecialParamInfo>* InSpecialParamList, TArray<struct FString>* InPotentialParamList);
	void ClearEquipCustomItem();
	void SetEquipCustomItem(const struct FUIEquipCustomItemSetInfo& InItemSetInfo);
	void InitEquipCustom();
	void SetSkillDeckCandidate(TArray<struct FUISkillDeckCandidateSlotInfo>* InSkillDeckCandidateSlotInfos);
	void SetSkillBook(int InSkillBookCategory, int InCurrentPage, int InMaxPage, TArray<struct FUISkillBookSlotInfo>* InSkillBookSlotInfos);
	void CloseDungeonInitializationAlertDialog();
	void OpenDungeonInitializationAlertDialog(int inTime);
	void UpdateDungeonWaitingState(int DungeonCid, bool bRegistered);
	void UpdateDungeonDisableState();
	class UGFxObject* CreateDungeonUIObject(int InIndex, const struct FDungeonEntranceUIData& InUIData);
	void InitDungeonUI();
	void InitDungeonEntranceData(TArray<struct FDungeonEntranceData> InInitDataList);
	void UpdateDungeonEntranceData(const struct FDungeonEntranceData& InData);
	int UpdateDungeonDifficulty(int InDungeonGroupCid, bool InIsHero);
	bool CreateDungeonEntranceUIData(int InDungeonEntranceGroupCid, struct FDungeonEntranceUIData* OutUIData);
	bool GetDungeonEntranceUIData(int InIndex, struct FDungeonEntranceUIData* OutData);
	void OpenDialogPartyMatchingTeleport(TEnumAsByte<EDialogType> InDialogType, const struct FString& InTopText, const struct FString& InLumena);
	void ClearExchangeCachedData2();
	void ClearExchangeCachedData();
	void UpdateContentTokenExchangeData(bool bUpdatedTargetValue);
	void OpenExchangeView();
	void AddHelpGuide(int Cid);
	bool HitTestHelpWindow();
	void OnUpdateCharInfo();
	void SetPVPType(bool bShow, TEnumAsByte<ECEPVPType> InPvpType);
	void CloseAimTargeting();
	void SetPositionAimTargeting(float PosX, float PosY);
	void OpenAimTargeting();
	void TargetCastingMountPrepare(float InTotalTime, float InRemainTime, int InMountCid);
	void TargetCastingSkillDeckSwap(float InTotalTime, float InRemainTime, const struct FString& InSkillDeckName);
	void TargetCastingSkill(class USkillAsset* pAsset, int Cid, int SkillType, float ServerCastingTime, float RemainCastingTime, bool ChargeSkill);
	void TargetCastingChargeSkillReset(class USkillAsset* a_SkillAsset, int a_SkillType, int SectionIndex, struct FSkillRequestInfo* InSkillReqInfo);
	void TargetCastingChargeSkillProgress(int ChargeStep, struct FSkillRequestInfo* InSkillInfo);
	void TargetCastingChargeSkillPrepare(struct FSkillRequestInfo* InSkillReqInfo);
	void TargetCastingStop(TEnumAsByte<ECastingStopType> InStopType);
	void TargetCastingCleanup();
	void CastingRuneSynthesize(const struct FString& InName, float InTotalTime, float InRemainTime);
	void CastingTaming(const struct FString& InText, float InTotalTime, float InRemainTime);
	void CastingCraft(const struct FString& InCraftName, float InTotalTime, float InRemainTime, int InCurrentStep, int InMaxStep);
	void CastingMountPrepare(float InTotalTime, float InRemainingTime, int InMountCid);
	void CastingSkillDeckSwap(float InTotalTime, float InRemainingTime, const struct FString& InSkillDeckName);
	void CastingInteraction(int InteractionType, const struct FString& InteractionName, float CastingTime, float RemainingTime);
	void CastingSkillStop(TEnumAsByte<ECastingStopType> InStopType);
	void CastingSkillHold();
	void HideCombatCastingGauge();
	void ShowCombatCastingGauge(int InSkillCid, bool bChargeSkill, float InRemainTime, float InTotalTime);
	void ShowCommonCastingGauge(bool bChargeSkill, int SkillType, float InRemainTime, float InCastingTime, struct FString* InSkillname);
	void CastingSkill(class USkillAsset* pAsset, int Cid, int SkillType, float ServerCastingTime, float RemainCastingTime, bool ChargeSkill);
	void CastingChargeSkillReset(class USkillAsset* a_SkillAsset, int a_SkillType, int SectionIndex, struct FSkillRequestInfo* InSkillReqInfo);
	void CastingChargeSkillProgress(int ChargeStep, struct FSkillRequestInfo* InSkillInfo);
	void CastingChargeSkillPrepare(struct FSkillRequestInfo* InSkillReqInfo);
	void CastingHold();
	void CastingStop(TEnumAsByte<ECastingStopType> InStopType);
	void CastingCleanup();
	void SetDungeonTimerType(TEnumAsByte<EBLTimerType> InTimerType);
	void SetDungeonTimerVisible(bool Invisible);
	void SetDungeonTimerTime(int InRemainSeconds, bool InIsAlertMode);
	void OpenRealmOwnershipBattleLeaveDialog();
	void SetRealmOwnershipResultSortingType(int InListIndex, int InButtonIndex, int InSortType);
	void SetRealmOwnershipResultRewardText(const struct FString& InReward);
	void SetRealmOwnershipResultCenterText(const struct FString& InAttackString, const struct FString& InDefenseString, const struct FString& InResultString);
	void OpenRealmOwnershipResultVictory();
	void SetRealmOwnershipResultVictory(TEnumAsByte<EWarRealmResult> InVictoryResult, const struct FString& InResultStr);
	void SetRealmOwnershipResultScore(int InLeftScore, int InRightScore);
	void SetRealmOwnershipResultRankingMyPosition(int InListIndex, int InIndex);
	void SetRealmOwnershipResultRankingList(int InIndex, TArray<struct FWarRankingInfo>* RankingList);
	void SetRealmOwnershipRegisterDefenseButton(bool bInJoinState, bool bInDisable);
	void SetRealmOwnershipRegisterAttackButton(bool bInJoinState, bool bInDisable);
	void SetRealmOwnershipRegisterCautionText(const struct FString& InText);
	void SetRealmOwnershipRegisterCapital(const struct FString& InCapitalName, const struct FString& InCapitalGuildName);
	void SetRealmOwnershipRegisterStartRemainDate(const struct FString& InDateString);
	void SetRealmOwnershipRegisterStartDate(const struct FString& InDateString);
	void SetRealmOwnershipRegisterAskRemainDate(const struct FString& InDateString);
	void SetRealmOwnershipRegisterAskDate(const struct FString& InDateString);
	void SetConquestResult(int InResult);
	void SetConquestScore(int InHieronScore, int InUnionScore);
	void SetConquestExitTimerTime(int InSeconds);
	void SetConquestExitTimerVisible(bool bInVisible);
	void StopConquestScoreBoardTime();
	void SetConquestScoreBoardTime(int InTimeSeconds, int InLimitTime);
	void SetWarConquestScoreBoardSetROColosseumScore(int InAttackerScore, int InDefenderScore, TEnumAsByte<EWarConquestScoreBoardType> InScoreBoardType);
	void SetWarConquestScoreBoardState(int InRealm, int InType);
	void SetConquestScoreBoardScore(int InHieronHP, int InUnionHP);
	void SetConquestScoreBoardVisible(bool bInVisible);
	class UBLConquestUIManager* GetConquestUIManager();
	void CloseDialogColosseumCancel();
	void OpenDialogColosseumCancel();
	void SetConquestColosseumScoreList(int InIndex, int InMyPlayerIndex, TArray<struct FColosseumScoreInfo>* ScoreList);
	void UpdateConquestColosseumJoinAttendee(int InAttendeeIndex, TEnumAsByte<EEColosseumMemberRegisterState> InState);
	void SetConquestColosseumJoinButtonDisable(bool bInDisable);
	void StartConquestColosseumJoinProgress();
	void SetConquestColosseumJoinProgressText(const struct FString& InText);
	void SetConquestColosseumJoinProgressTime(float InRemainTime, float InTotalTime);
	void CloseConquestSpecialWarDialog_All();
	void CloseConquestSpecialWarDialog_Join();
	void OpenConquestSpecialWarLeaveDialog(int InWarCid, bool bCompletedWar);
	void OpenConquestSpecialWarCancelWaitDialog(int InWarCid);
	void OpenConquestSpecialWarRejoinDialog(int InWarCid, int InTimeOutSeconds);
	void OpenConquestSpecialWarJoinDialog_ForBolter(int InWarCid, int InTimeOutSeconds, int LumenaCost, bool bInSuccessCondition);
	void OpenConquestSpecialWarJoinDialog_CheckCondition(int InWarCid, int InTimeOutSeconds, bool bInSuccessCondition);
	void OpenConquestSpecialWarJoinDialog(int InWarCid, int InTimeOutSeconds);
	void OpenConquestSpecialWarJoinReserveDialog(int InWarCid);
	void SetConquestVictoryEffectPlayCount(int InPlayCount);
	void SetConquestSpecialWarMedalList(TArray<struct FWarMedalInfo>* InMedalList);
	void SetConquestSpecialWarLogList(TArray<struct FWarLogInfo>* InLogList);
	void SetConquestSpecialWarSortingType(int InListIndex, int InButtonIndex, int InSortType);
	void SetConquestSpecialWarInfoText(bool bInVisible, int InCurrentUser, int InMaxUser, int InWaitUser);
	void SetConquestSpecialWarRankingList(int InIndex, int InMyPlayerIndex, TArray<struct FWarRankingInfo>* RankingList);
	void SendEnvironment();
	bool GetEnvironment(int CategoryType, TArray<int>* OutValue);
	void UpdateEnvironment(int CategoryType, const struct FString& InText);
	void InitializeEnvironment(const struct FString& InText);
	void ToggleWarp(bool bWarp);
	void OpenTransportConfirmDialog(const struct FString& DestName);
	void ToggleWayPoint(bool bVisible);
	class UGFxObject* MakeFilterDataGFxObject(const struct FString& Label, const struct FString& FilterType, bool FilterVisible);
	void SetWorldMapFilterDatas();
	void SetWorldMapFilter(int Index, bool Toggle);
	void ToggleWorldMap(bool bVisible);
	void ToggleWorldMapMode(TEnumAsByte<EWorldMapMode> Mode);
	void CloseFlashShopPurchaseItemDialog();
	void OpenFlashShopPurchaseAmountCheckDialog(TEnumAsByte<ECoinType> ItemCoinType, int UnitPrice, int ItemMinCount, int ItemMaxCount);
	void OpenFlashShopPurchaseItemDialog(const struct FString& InTopText, const struct FString& InLumenaText);
	void SetFlashShopCurrentLumena(int InLumena);
	void SetFlashShopDuration(int InSeconds);
	void SetFlashShopCategoryPage(int InMaxPage, int InCurrentPage);
	void SetFlashShopCategoryItemList(TArray<struct FUIFlashShopItemInfo> InItemInfoList);
	void SetFlashShopCategory(const struct FString& InShopTitle, const struct FString& InShopCategory);
	void CloseLumenaShopPurchaseItemDialog();
	void OpenLumenaShopPurchaseAmountCheckDialog(TEnumAsByte<ECoinType> ItemCoinType, int UnitPrice, int ItemMinCount, int ItemMaxCount);
	void OpenLumenaShopPurchaseItemDialog(TEnumAsByte<ECoinType> InCoinType, const struct FString& InTopText, const struct FString& InLumenaText);
	void SetLumenaShopCurrentContentToken(TEnumAsByte<ECoinType> InCoinType, int InToken);
	void SetLumenaShopCurrentLumena(int InLumena);
	void SetLumenaShopCategoryPage(int InMaxPage, int InCurrentPage);
	void SetLumenaShopCategoryItemList(TArray<struct FUILumenaShopItemInfo> InItemInfoList);
	void SetLumenaShopCategoryList(TArray<struct FUILumenaShopCategoryInfo> InCategoryInfoList);
	void OpenShopPurchaseAmountCheckDialog(TEnumAsByte<ECoinType> ItemCoinType, int UnitPrice, int ItemMinCount, int ItemMaxCount);
	void OpenShopPurchaseConfirmDialog(const struct FString& InTopString, const struct FString& InPriceString, TEnumAsByte<ECoinType> CoinType);
	void RequestShopPurchaseGiftItem();
	void OpenShopPurchaseGiftItemCheckDialog(int InItemCid, const struct FString& InReceiverName);
	void CloseShop();
	void OpenShop(TEnumAsByte<ECoinType> ShopCoinType);
	int GetNotEnoughLevel();
	TEnumAsByte<EQuestErrorCode> GetStoryQuestState();
	void SetStoryQuestState(TEnumAsByte<EQuestErrorCode> InQuestErrorCode, int InNotEnoughLevel);
	void SC_TradeFailedRep(TEnumAsByte<EItemTradeErrorCode> InErrorCode);
	void SC_TradeCompleteRep();
	void SC_TradeCanceled(TEnumAsByte<EItemTradeErrorCode> InReason);
	void SC_AddItemAckFailed(int ErrorCode, int ItemSid);
	void SC_AddItemAck(int InItemSid);
	class UGFxObject* GetPrivateTradeItemObject(int Index, const struct FItemData& ItemData);
	void SC_UpdateInfoRep(TArray<struct FItemTradeData> tradeDataList);
	void SC_StartTradeRep();
	void SetPrivateTradePlayer(int PlayerSid1, int PlayerSid2);
	void SC_TradeInvitedAck(TEnumAsByte<EItemTradeErrorCode> InResult, int InTargetID);
	void SC_TradeInvited(int RequesterSid);
	void CloseAllPrivateTradeDialog();
	bool IsGreaterThanMyGold(const struct FQWord& InGold);
	int GetTradeRequesterSID();
	void SetTradeRequesterSID(int Sid);
	void ShowPartyMemberSelectEffect(int Sid, bool bShow);
	void LogOutPartyMember(int InSid);
	void LoginPartyMember(int InPrevSID, int InMemberSID);
	void SetPartyMemberDeath(int Sid, bool IsDeath);
	void RemovePartyMember(TEnumAsByte<EPawnType> PawnType, const struct FString& Sid);
	void SetPartyCombatFlair(int Sid, int CombotFlairType, int CurStat, int MaxStat);
	void AddPartyMember(class UPartyMemberData* InMemberData);
	bool IsUIStateOpening();
	void SetLoginState();
	void OnServerConnectionError();
	void ClearNameTag();
	bool IsGetNameTag();
	void SetWorldTime(bool DaySymbol, float Time);
	void SetDayTime(int InDayTime);
	void InitMinimapClock();
	bool IsMinimapTexture(const struct FName& TextureName);
	void RemoveMinimapTextures(const struct FName& TextureName);
	void AddMinimapTextures(const struct FName& TextureName, class UTexture2D* pTexture);
	void MailWriteInitContents(bool bForce);
	void SwapSendItemSlot(int FromSlotIndex, int ToSlotIndex);
	int GetEmptySlotBySendMailItem();
	bool GetSendMailItem(int Sid, int* SlotIndex, struct FSendMailItem* MailItem);
	void ResetSendMailItem();
	void DeleteSendMailItem(int SlotIndex, int Sid);
	void SetSendMailItem(int SlotIndex, int Sid, bool Success);
	void RemoveSendMailItem(int SlotIndex, int Sid);
	void AddSendMailItemFromInventory(int TabIndex, int SlotIndex);
	void AddSendMailItem(int SlotIndex, int Sid);
	void RecvRemoveItemForSendMail(bool Success, int Sid, int SlotIndex);
	void RecvAddItemForSendMail(bool Success, int Sid, int SlotIndex);
	void EndPositionSendMode(TEnumAsByte<ECEWorldMapType> MapType, int MapCID, const struct FString& ZoneName, const struct FVector& InLocation);
	void SetPositionSendData(TEnumAsByte<ECEWorldMapType> MapType, int MapCID, const struct FString& ZoneName, const struct FVector& InLocation);
	int GetPositionSendMapCID();
	TEnumAsByte<ECEWorldMapType> GetPositionSendMapType();
	struct FVector GetPositionSendLocation();
	struct FString GetPositionSendZoneName();
	bool IsAttachedPosition();
	int GetReturnMailIndex();
	void SetReturnMailIndex(int MailIndex);
	TEnumAsByte<EMailWriteOpenType> GetMailWriteType();
	void SetMailWriteType(TEnumAsByte<EMailWriteOpenType> Type);
	void OpenMailWrite();
	void RequestPreservationMail(int MailIndex);
	bool IsWithDrawMail(TEnumAsByte<EMailBoxState> MBoxState, int MailIndex);
	void WithdrawMail(int MailIndex);
	void ReadMail(int MailIndex);
	void KeepMail(int MailIndex, bool KeepFlag);
	void RecvDeleteMail(int MailIndex);
	struct FString GetMailCountString(int CurrentCount, int MaxCount);
	int GetMaxMailPageIndex(int COUNT, int MaxCount);
	int GetMailCount(int COUNT, int MaxCount);
	void SetMailDataListOnUI(TEnumAsByte<EMailBoxState> State);
	void SetNewMailAndOverMailCount(int NewCount, int OverCount);
	int GetCurrentMailBoxPageIndex();
	void SetMailDataGFxObject(int Index, TEnumAsByte<EMailType> Type, int MailState, const struct FString& SendTime, const struct FString& Limit, const struct FString& SenderName, const struct FString& Title, const struct FString& Content, const struct FString& Gold, TArray<class UBLMailItem*> MailItems, class UGFxObject** Target);
	class UGFxObject* MakeMailDataGFxObject(const struct FCMailData& InData, int Index);
	class UBLMailItem* FindMailItem(int InKey);
	int GenerateMailItemKey();
	void FillClientMailData(struct FMailData* InServerData, struct FCMailData* outClientData);
	struct FString GetExpireTime(const struct FQWord& ExpireTime);
	struct FString GetSendTime(const struct FQWord& SendTime);
	int MakeMailState(TEnumAsByte<EMailStateType> Type, bool ReturnFlag);
	void PinFocusing(int MailIndex);
	bool GetMailData(TEnumAsByte<EMailBoxState> State, int MailIndex, struct FCMailData* OutData);
	void SetSendMailList(int PageIndex, TArray<struct FMailData> InMailDataList, int SendMailCount, int SendMailMax);
	void SetKeepMailList(int PageIndex, TArray<struct FMailData> InMailDataList, int KeepMailCount, int KeepMailMax);
	void SetMailList(int PageIndex, TArray<struct FMailData> InMailDataList, int NormalMailCount, int NormalMailMax, int GMMailCount, int GMMailMax, int SystemMailCount, int SystemMailMax, int ExpandMailMax);
	TEnumAsByte<EMailBoxState> GetMailBoxState();
	void SetMailBoxState(TEnumAsByte<EMailBoxState> State);
	void OnUpdateLocationName(int InCid, const struct FString& InLocationName);
	class UGFxObject* CreateGuildGFxObj(int InCid);
	struct FString GetLocationName();
	int GetLocationCID();
	void CheckInitJournal(bool bTutoral);
	void ClearDestroyedSlot();
	void LockAllInventorySlot();
	void ClearLockedInventorySlot();
	void RequestDestroyedInventoryItem();
	void RequestLockInventoryItem();
	bool DestroyedInventoryItem(int Sid, bool Lock);
	void LockInventory(bool bLock);
	void LockInventoryItem(int Sid, bool Lock);
	void SetPawnExpInfo(int InPawnExp, int InLevelExpRangeMin, int InLevelExpRangeMax, TEnumAsByte<EExpBarType> InBarType);
	void InitExpBar();
	bool RequestBanishFromParty(int Sid);
	bool RequestDissolveParty();
	bool RequestLeaveParty();
	void OpenDialog_LoginServerError_Preseason();
	void OpenDialog_StartEnterFailPreseason();
	void OpenDialog_KickOutSpecificServer(const struct FString& InComment, bool IsServerSelect);
	void OpenDialog_NoAvailableServer();
	void AuthDisconnectBeforeServerConnect();
	void UndefinedServerConnectionErr();
	void SocketBroken();
	void ClientIsBusy();
	void UserLimit();
	void AlreadyLogin();
	void WrongPassword();
	void UserNotDefined();
	void ServerIsBusy();
	void PingCheckError();
	void SocketError(int Id);
	void RejectPort();
	void ProtocolVersionDifferent(int CProtocol, int SProtocol);
	void ProtocolTypeVersionDifferent(int CProtocol, int SProtocol);
	void AdmissionRestrictionDialog();
	void FailRedirectAuthServerDialog();
	void ServerWaitingFullDialog();
	void FailLoginAuthServerDialog();
	void ServerLoginFailDialog(const struct FString& ServerName);
	void WaitServerDialog(const struct FString& ServerName, int WaitCount);
	void OpenServerConnectionErrorDialog(TEnumAsByte<EServerErrorMessageBoxType> InType, const struct FString& InSubString);
	void ForceCloseDialog(const struct FString& OwnerName);
	void CloseDialogWithType(TEnumAsByte<EDialogType> DialogType);
	void CloseDialogWithIndex(int DialogIndex, bool bRemoveList);
	struct FDialogData GetDialogDataWithType(TEnumAsByte<EDialogType> DialogType);
	struct FDialogData GetDialogDataWithIndex(int Idx);
	void ExecutePendindDialog(TEnumAsByte<EDialogType> DialogType);
	void AddPendindDialog(TEnumAsByte<EDialogType> DialogType, const struct FDialogData& InData, const struct FDialogDrawingParam& DrawingParam, const struct FDialogPositionParam& PositionParam);
	bool CheckOnlyOneDialog(TEnumAsByte<EDialogType> InType);
	bool IsExistDialog(TEnumAsByte<EDialogType> InType);
	bool FindCustomDialog(TEnumAsByte<EDialogType> InType, struct FCustomDialogData* OutData);
	void AddDialogData(int UniqueKey, const struct FDialogData& NewData);
	int CloseAllCustomDialog();
	int CloseAllDialog(bool bCheckUnescapableDialog);
	void OpenGuildDialog(TEnumAsByte<EGuildDialogOpenType> Type, class UGFxObject* GFxObj, bool IsModal);
	void ProcessCustomDialogEvent(const struct FCustomDialogEventData& InData);
	bool CloseCustomDialog(TEnumAsByte<EDialogType> InDialogType, bool bRemoveList, bool bProcessCloseEvent);
	void OpenCustomDialog(const struct FCustomDialogData& InData);
	void CloseDialog(const struct FDialogData& Data, bool bRemoveList);
	void OpenDialogEx(const struct FDialogData& Data, const struct FDialogDrawingParam& DrawingParam);
	void OpenDialog(const struct FDialogData& Data, const struct FDialogDrawingParam& DrawingParam, const struct FDialogPositionParam& PositionParam);
	void OnCreatePCFailed(int InErrCode, struct FString* InForbidString);
	void SetSelectRealmPhase();
	TArray<struct FRealmDataInfo> GetCreateRealmInfo();
	void SubtractRealmData(TEnumAsByte<ECERealmType> InRealm, TEnumAsByte<ECERaceType> InRace, TEnumAsByte<ECEClassType> InClass, TEnumAsByte<ECEGenderType> InGender);
	void AddRealmData(TEnumAsByte<ECERealmType> InRealm, TEnumAsByte<ECERaceType> InRace, TEnumAsByte<ECEClassType> InClass, TEnumAsByte<ECEGenderType> InGender);
	void OnDeathIsMember(int Sid);
	void ProcessBattleMessageFloater(float DeltaTime);
	void RemovePendingBattleMessageFloater(int Sid);
	void AddPendingBattleMessageFloater(int Sid, TEnumAsByte<EBattleMessageType> BattleMessageType, int Amount, TEnumAsByte<EPartyMemberType> InMemberType);
	void AddBattleMessageBuffer(TEnumAsByte<EBattleMessageTargetType> TargetType, TEnumAsByte<EBattleMessageType> BattleMessageType, int Amount, float Scale, float PosX, float PosY);
	void DrawBattleMessage_string(class ABLPawnBase* Pawn, TEnumAsByte<EBattleMessageType> BattleMessageType, const struct FString& Amount);
	void DrawBattleMessage(class ABLPawnBase* Pawn, TEnumAsByte<EBattleMessageType> BattleMessageType, int Amount, TEnumAsByte<EPartyMemberType> InMemberType);
	void SetBattleMessageConfig(int InDrawCountOnTick, int InMaxBufferSize, int InIntervalTickCount);
	void ProcessBattleMessage();
	void SetRestrictTradeMode(bool bRestrictMode);
	void LockActionBarItemSlot(int InItemCid, bool bLock);
	void UpdateAbnormalStatusCoolTimeUnit(float DeltaTime, const struct FPawnAbnormalGroupData& InPawnGroupData);
	void UpdateAbnormalStatusCoolTime(float DeltaTime);
	void UpdateRaidMemberAbnormalStatusOnUI(int InPartyID, int InMemberIndex, struct FPawnAbnormalGroupData* InPawnAbnormalGroupData);
	void UpdatePartyMemberAbnormalStatusOnUI(const struct FPawnAbnormalGroupData& InPawnAbnormalGroupData);
	void UpdateTargetAbnormalStatusOnUI();
	void UpdateMyAbnormalStatusOnUI();
	int CountValidAbnormalData(TArray<struct FAbnormalGroupData> AbnormalGroupDataList, TArray<struct FAbnormalGroupData>* TempAbnormalGroupDataList);
	void FillAbnormalStatusGFxObjectList(int InAbnormalPawnServerID, TEnumAsByte<EAbnormalCheckType> CheckType, TArray<struct FAbnormalGroupData>* InAbnormalGroupDataList, TArray<class UGFxObject*>* OutResultObjectList);
	bool CheckAbnormalUIShow(TEnumAsByte<EAbnormalCheckType> CheckType, TArray<struct FAbnormalData> AbnormalDataList);
	void UpdateTargetAbnormalStatus(class ABLPawnBase* inPawn, TArray<struct FAbnormalStatusData>* InAbnormalStatusDataList);
	void UpdateMyAbnormalStatus(class ABLPawnBase* inPawn, TArray<struct FAbnormalStatusData>* InAbnormalStatusDataList);
	void MergeAbnormalGroupData(TArray<struct FAbnormalGroupData>* InAbnormalGroupDataList, TArray<struct FAbnormalGroupData>* InAbnormalGroupDataList2, TArray<struct FAbnormalGroupData>* OutAbnormalGroupDataList);
	void FillAbnormalDataListFromGroupCid(int InGroupCid, TEnumAsByte<EPawnType> InPawnType, int InServerId, struct FAbnormalGroupData* ResultGroupData, TArray<struct FAbnormalData>* ResultDataList);
	void FillAbnormalGroupData(int InServerId, TEnumAsByte<EPawnType> InPawnType, TArray<struct FAbnormalStatusData> InAbnormalStatusDataList, struct FPawnAbnormalGroupData* OutGroupData);
	bool CheckGameExitState();
	bool CheckPlayerCombatMessage(const struct FString& SystemMessageCodeName);
	void UpdateCoin(TEnumAsByte<ECoinType> InCoinType, const struct FString& Coin);
	void OnCompletedLoadState();
	void OnChangedLoadState(int NewLoadState);
	class UGFxObject* MakeItemGFxObject(int Sid, int Cid, int Amount, bool Usable, int Grade, int EquipSlotType, int IconIndex);
	int GetMyTargetSID();
	int GetMyPawnSID();
	void UpdateContentActiveCondition(TEnumAsByte<EUIOpenerType> InEUIOpener);
	bool GetContidionByOpenerType(TEnumAsByte<EUIOpenerType> InEUIOpener, int* OutOpenLevel);
	void SetNewExchangeItemCount(int InCount);
	void SetNewGoodsBoxCount(int InCount);
	void SetOpenerNotificationCount(TEnumAsByte<EUIOpenerType> InEOpenerType, int InCount);
	void UpdateOpenerKeyBindingString();
	void UpdateOpenerAvailable();
	void UpdateOpenerDisable();
	void UpdateOpenerAlertCount();
	TEnumAsByte<EUIName> FindEUINameByEUIOpener(TEnumAsByte<EUIOpenerType> InEUIOpener);
	TArray<class UGFxObject*> GetOpenerAvailableData();
	TArray<class UGFxObject*> GetOpenerData();
	bool CheckDisableDailyWeeklyOrder();
	bool IsDisabledOpener(TEnumAsByte<EUIOpenerType> InEUIOpenerType);
	void SetTutorialMode(bool bEnableMode);
	void InitTutorialOpener();
	void InitNormalOpener();
	void InitOpener();
	void SetOpenLevel(TEnumAsByte<EUIOpenerType> InEUIOpenerType, int InOpenLevel);
	void SetAvailableOpener(TEnumAsByte<EUIOpenerType> InEUIOpenerType, bool bAvailable);
	void SetDisableOpener(TEnumAsByte<EUIOpenerType> InEUIOpenerType, bool bDisable, bool bIconLock);
	class UGFxObject* MakeIconSheetData(int MapIndex, const struct FString& SheetName, int PerLine, int IconWidth, int IconHeight);
	TArray<class UGFxObject*> GetIconSheetDatas();
	void ToggleUIPlayer();
	bool IsASInitialized(TEnumAsByte<EUIName> UIEnum);
	bool IsShowUIByName(const struct FString& UIName);
	bool IsShowUI(TEnumAsByte<EUIName> UIEnum);
	void CloseUI(TEnumAsByte<EUIName> UIEnum);
	void OpenUI(TEnumAsByte<EUIName> UIEnum);
	void SetWebSession(TEnumAsByte<EWebSessionType> InWebSession);
	void OpenWebPageUI();
	void ToggleUI(TEnumAsByte<EUIName> UIEnum);
	void OpenSteamStore();
	void ToggleAnimaUI();
	void ToggleGameOnWebEventUI();
	void ToggleLumenaSendingUI();
	void OpenWebPage(TEnumAsByte<EWebSessionType> InWebSession);
	void ToggleWebPage(TEnumAsByte<EWebSessionType> InWebSession);
	void ToggleWarColosseumUI();
	void ToggleHelpWindow(int InHelpPageCid);
	void ToggleMainHelpWindow();
	void ToggleOpener();
	void ToggleRanking();
	void ToggleDungeon();
	void ToggleFriend();
	void ToggleTokenExchange();
	void ToggleOrderUI();
	void ToggleRuneUI(int TabIndex);
	void TogglePartyMatchingRoleUI();
	void TogglePartyMatchingUI();
	void ToggleWebEvent();
	void ToggleExchangeUI();
	void ToggleGameOnWebShopUI();
	void ToggleGoodsBoxUI();
	void ToggleWebShopUI();
	void ToggleLumenaShopUI();
	void ToggleCollectionBookUI(int TabIndex);
	void ToggleMissionUI();
	void ToggleCraftUI();
	void ToggleMinimapExtensionUI();
	void ToggleCitadelOwnershipUI();
	void ToggleWarUI(TEnumAsByte<EUIOpenerType> InOpenerType);
	void ToggleGuildUI();
	void ToggleSkillBookUI();
	void ToggleMailUI();
	void ToggleSkillDeckUI();
	void ToggleInterfaceSettingUI();
	void ToggleSystemSettingUI();
	void ToggleJournal(int TabIndex);
	void ToggleInventoryUI();
	void ToggleCharStatUI();
	bool IsActiveWindowUI(TEnumAsByte<EUIName> TargetUI);
	void SetActiveUI(const struct FString& UIName);
	void PostVisibleAction(const struct FUIStateData& Data);
	bool IsVisibleUI(TEnumAsByte<EUIName> InUINameEnum);
	class UGFxObject* GetInfoData(const struct FString& UIName);
	void OnUIClose(const struct FString& UIName);
	void SetVisibleUI(const struct FString& UIName, bool bVisible);
	void PostUnLoadUIEvent(const struct FString& UIName);
	void UnLoadUI(const struct FString& UIName);
	void PostLoadUIEvent(const struct FString& UIName);
	void OnInitializedUI(const struct FString& UIName);
	void LoadUI(const struct FString& UIName, class UGFxObject* UIInfoData);
	void WithPmangLoginTest(const struct FString& LoginID, const struct FString& LoginPassword);
	void SetLobbyLogin();
	void Tick(float DeltaTime);
	class UBLActionBarUIManager* STATIC_GetActionBarUIManager();
	class UBLSkillDeckUIManager* STATIC_GetSkillDeckUIManager();
	class UBLSkillQTEHUDUIManager* STATIC_GetSkillQTEHUDUIManager();
	class UBLUIPlayer* GetUIPlayer();
	class APlayerController* GetPC();
	class UBlessLocalPlayer* GetLP();
	void DumpGameUILog();
	void SetGameUI_EndInit();
	void SetGameUI_EndLoad();
	void SetGameUI_Start();
	bool IsLoadedUI(TEnumAsByte<EUIName> InUIName);
	class UGFxObject* CreateArray();
	class UGFxObject* CreateObject(const struct FString& ASClass, class UClass* Type, TArray<struct FASValue> args);
	bool STATIC_GetInitialized(TEnumAsByte<EUIName> InEUIName);
	void STATIC_SetRollBackVisible(TEnumAsByte<EUIName> InEUIName, bool Value);
	bool STATIC_GetRollBackVisible(TEnumAsByte<EUIName> InEUIName);
	void STATIC_SetEscapeAction(TEnumAsByte<EUIName> InEUIName, bool Value);
	bool STATIC_GetEscapeAction(TEnumAsByte<EUIName> InEUIName);
	void STATIC_SetCheckUIMode(TEnumAsByte<EUIName> InEUIName, bool Value);
	bool STATIC_GetCheckUIMode(TEnumAsByte<EUIName> InEUIName);
	void STATIC_SetClearUIMode(TEnumAsByte<EUIName> InEUIName, bool Value);
	bool STATIC_GetClearUIMode(TEnumAsByte<EUIName> InEUIName);
	void STATIC_SetDepthGroup(TEnumAsByte<EUIName> InEUIName, int Value);
	int STATIC_GetDepthGroup(TEnumAsByte<EUIName> InEUIName);
	void STATIC_SetEnableUIState(TEnumAsByte<EUIName> InEUIName, int Value);
	int STATIC_GetEnableUIState(TEnumAsByte<EUIName> InEUIName);
	void STATIC_SetAlwayshud(TEnumAsByte<EUIName> InEUIName, bool Value);
	bool STATIC_GetAlwayshud(TEnumAsByte<EUIName> InEUIName);
	void STATIC_SetMovable(TEnumAsByte<EUIName> InEUIName, bool Value);
	bool STATIC_GetMovable(TEnumAsByte<EUIName> InEUIName);
	void STATIC_SetMiddleGroup(TEnumAsByte<EUIName> InEUIName, int Value);
	int STATIC_GetMiddleGroup(TEnumAsByte<EUIName> InEUIName);
	void STATIC_SetTopGroup(TEnumAsByte<EUIName> InEUIName, int Value);
	int STATIC_GetTopGroup(TEnumAsByte<EUIName> InEUIName);
	TEnumAsByte<EUIOpenerType> STATIC_GetEUIOpenerByName(const struct FString& InUIOpenerName);
	struct FString STATIC_GetUIOpenerNameByEnum(TEnumAsByte<EUIOpenerType> InEUIOpener);
	TEnumAsByte<EUIName> STATIC_GetEUINameByUIName(const struct FString& InUIName);
	struct FString STATIC_GetUINameByEnum(TEnumAsByte<EUIName> InEUIName);
	bool CheckUIModeByUIName(const struct FString& UIName);
	bool CheckUIModeByUIType(int UIType);
	bool CheckUIModeByUIState(int UIState);
	void CheckAllUIMode();
	bool IsUIModeAvailable();
	void AddRollBackUIVisible(TEnumAsByte<EUIName> UINameEnum);
	void checkRollBackQueue(TEnumAsByte<EUIName> UIName);
	bool CheckSaveNotUI(TEnumAsByte<EUIName> UIName);
	void LoadRollBackUIVisible();
	void SaveRollBackUIVisible();
	void SetOpeningPlay(bool bPlay);
	bool OpeningPlayed();
	void StartLogin();
	void StartOpening();
	void StartIntro(bool DisableUI);
	void SetUIStateExtionsion(TEnumAsByte<EUIStateExtension> InUIStateEX);
	bool IsGameState();
	bool IsLobbyState();
	int GetUIState();
	void SetUIState(int UIState);
	int GetLoadState();
	void SetLoadState(int LoadState);
	void SetForceCloseUI(bool bForce);
	bool IsForceCloseUI();
	void ReloadUIPlayer();
	void CloseUIPlaer();
	int GetInputFocus();
	class UBLUIManager* STATIC_GetUIManager();
	void Init(class UBLGameEngine* InGameEngine);
};


// Class BLGame.BLSkillQTEHUDUIManager
// 0x003C (0x009C - 0x0060)
class UBLSkillQTEHUDUIManager : public UObject
{
public:
	struct FBLGaugeTimerInfo                           GaugeTimerInfo;                                           // 0x0060(0x0008)
	unsigned long                                      bShowGaugeAni : 1;                                        // 0x0068(0x0004)
	unsigned long                                      bShowChainAni : 1;                                        // 0x0068(0x0004)
	unsigned long                                      bShowUsingSkillAni : 1;                                   // 0x0068(0x0004)
	unsigned long                                      bShowChainCountAni : 1;                                   // 0x0068(0x0004)
	unsigned long                                      bShowFinishAni : 1;                                       // 0x0068(0x0004)
	unsigned long                                      bShowCharge : 1;                                          // 0x0068(0x0004)
	class UGFxObject*                                  QTESlotObjectList[0x5];                                   // 0x006C(0x0008) (AlwaysInit)
	struct FBLChargeInfo                               ChargeInfo;                                               // 0x0094(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLSkillQTEHUDUIManager");
		return ptr;
	}


	void ShowQTEHUDExecuteSlot(TEnumAsByte<EBLQTEHUDExecuteSlotType> InSlotType, bool IsShow);
	void SetQTEHUDExecuteSlot(TEnumAsByte<EBLQTEHUDExecuteSlotType> InSlotType, int InCid, int InIconIndex, int InItemCount, struct FString* inDesc);
	void ConvertSlotTypetoShortCutString(TEnumAsByte<EBLQTEHUDExecuteSlotType> InSlotType, struct FString* outShortCutKeyString);
	TEnumAsByte<EBLQTEHUDExecuteSlotType> ConvertUISlotTypetoSlotType(int InUISlotType);
	int ConvertSlotTypetoUISlotType(TEnumAsByte<EBLQTEHUDExecuteSlotType> InSlotType);
	void InputQTEChainKey(int InCombatCid, int InSkillCid, bool bPress);
	void SetCurrentCharge(int InCurrentCharge);
	void SetMaxCharge(int InMaxCharge);
	void HideCharge();
	void ShowCharge();
	void HideFinishUI();
	void ShowFinishUI();
	void HideChangeStanceStateEffect();
	void ShowChangeStanceStateEffect();
	void HideChainCountUI();
	void ShowChainCountUI(int InChainCount);
	void HoldGaugeUI();
	void HideGaugeUI();
	void ShowGaugeUI(int InGaugePlayType, int InGaugeType, float InGaugeTime, float InGaugeTotalTime, bool bAutoHide);
	void HideQTEChainLineUI();
	void ShowQTEChainLineUI(TEnumAsByte<EBLQTESlotAniType> InQTESlotAniType);
	void HideUsingStanceSkillUI();
	void ShowUsingStanceSkillUI();
	void ShowStanceSkillEquip(bool bEnable);
	void ShowStanceSkillCoolDown(int InSlotIndex, float InRemainTime, float InTotalTime);
	void AddStanceSkillChainQTESlot(int InCombatCid, int InIconIndex, const struct FString& InKeyName, bool bHold, bool bLock, int InSlotOrder, const struct FString& InLockLevelString);
	void HideStanceSkillChainUI();
	void ShowStanceSkillChainUI();
	void SetGaugeTimerInfo(bool bAutoHide, float InGaugeTime);
	void Tick(float InDeltaTime);
	void Init();
};


// Class BLGame.BLSpeechBubbleComponent
// 0x004B (0x00D0 - 0x0085)
class UBLSpeechBubbleComponent : public UActorComponent
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x0085(0x0003) MISSED OFFSET
	TArray<struct FSpeechBubbleData>                   SpeechBubbleList;                                         // 0x0088(0x0010) (NeedCtorLink)
	struct FSpeechBubbleData                           ActiveSpeech;                                             // 0x0098(0x0020) (NeedCtorLink)
	class UGFxUI_NameTagObject*                        PawnNameTagMC;                                            // 0x00B8(0x0008)
	float                                              ShowTimeMin;                                              // 0x00C0(0x0004) (Edit, Config)
	float                                              ShowTimeMultiplyFactor;                                   // 0x00C4(0x0004) (Edit, Config)
	int                                                BubbleSpeechMaxStack;                                     // 0x00C8(0x0004) (Edit, Config)
	unsigned long                                      bHideSpeechBubble : 1;                                    // 0x00CC(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLSpeechBubbleComponent");
		return ptr;
	}


	void Tick(float DeltaTime);
	void UpdateSpeechBubbleList();
	void CloseSpeechBubble(int bubbleIndex);
	bool ProcessSpeechBubble(int bubbleIndex);
	void SetActiveSpeech(const struct FSpeechBubbleData& SBD);
	void SetBubbleSpeechMaxStack(int MaxStack);
	void SetSpeechBubble(const struct FString& Text, const struct FColor& TextColor, int ShowTimeInSeconds, bool IsEnemy);
	void Init(class UGFxUI_NameTagObject* inObj);
};


// Class BLGame.BLToolTipDataGenerator
// 0x071C (0x077C - 0x0060)
class UBLToolTipDataGenerator : public UObject
{
public:
	struct FColor                                      PropToolTipPropNameColor;                                 // 0x0060(0x0004) (Config)
	struct FColor                                      PropToolTipQuestNameColor;                                // 0x0064(0x0004) (Config)
	struct FColor                                      PropToolTipQuestObjectiveColor;                           // 0x0068(0x0004) (Config)
	int                                                PropToolTipPropNameSize;                                  // 0x006C(0x0004) (Config)
	int                                                PropToolTipPropDescriptionSize;                           // 0x0070(0x0004) (Config)
	int                                                PropToolTipQuestNameSize;                                 // 0x0074(0x0004) (Config)
	int                                                PropToolTipQuestObjectiveSize;                            // 0x0078(0x0004) (Config)
	struct FItemFontConfig                             ItemTooltip_Name;                                         // 0x007C(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             ItemTooltip_SlotType;                                     // 0x00A0(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             ItemTooltip_Duration;                                     // 0x00C4(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             ItemTooltip_WeightType;                                   // 0x00E8(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             ItemTooltip_MinLevel;                                     // 0x010C(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             ItemTooltip_PrimaryParam;                                 // 0x0130(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             ItemTooltip_1stParam;                                     // 0x0154(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             ItemTooltip_2ndParam;                                     // 0x0178(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             ItemTooltip_CustomizingCount;                             // 0x019C(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             ItemTooltip_EquipAbnomalStatus;                           // 0x01C0(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             ItemTooltip_LegendaryOptionTitle;                         // 0x01E4(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             ItemTooltip_LegendaryOptionDesc;                          // 0x0208(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             ItemTooltip_Description;                                  // 0x022C(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             ItemTooltip_UsableClass;                                  // 0x0250(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             ItemTooltip_EquipRecommendClass;                          // 0x0274(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             ItemTooltip_UsableRace;                                   // 0x0298(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             ItemTooltip_EnableSale;                                   // 0x02BC(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             ItemTooltip_Destroyable;                                  // 0x02E0(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             ItemTooltip_BoundingType;                                 // 0x0304(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             ItemTooltip_BoundingResult;                               // 0x0328(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             ItemTooltip_Trading_able_duration;                        // 0x034C(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             ItemTooltip_Cost;                                         // 0x0370(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             ItemTooltip_CraftingPCName;                               // 0x0394(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             ItemTooltip_Plus;                                         // 0x03B8(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             ItemTooltip_Minus;                                        // 0x03DC(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             ItemTooltip_Potential;                                    // 0x0400(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             ItemTooltip_setName;                                      // 0x0424(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             ItemTooltip_setItem_equip;                                // 0x0448(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             ItemTooltip_setItem_notequip;                             // 0x046C(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             ItemTooltip_seteffect_apply;                              // 0x0490(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             ItemTooltip_seteffect_notapply;                           // 0x04B4(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             ItemTooltip_RuneName;                                     // 0x04D8(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             ItemTooltip_RuneStats;                                    // 0x04FC(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             ItemTooltip_RuneCategory;                                 // 0x0520(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             ItemTooltip_Return;                                       // 0x0544(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             ItemTooltip_Durability;                                   // 0x0568(0x0024) (Config, NeedCtorLink)
	int                                                ContentsTokenToolTip_Name_Size;                           // 0x058C(0x0004) (Config)
	int                                                ContentsTokenToolTip_Description_Size;                    // 0x0590(0x0004) (Config)
	struct FColor                                      PropToolTipGatherInfoColor;                               // 0x0594(0x0004) (Config)
	int                                                PropToolTipGatherInfoSize;                                // 0x0598(0x0004) (Config)
	struct FItemFontConfig                             Gather_Craft_Level_tooltip_Name;                          // 0x059C(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             Gather_Craft_Level_tooltip_Description;                   // 0x05C0(0x0024) (Config, NeedCtorLink)
	int                                                CompanionTooltip_Name_Size;                               // 0x05E4(0x0004) (Config)
	int                                                CompanionTooltip_Mount_Lv_Grade_MountType_Size;           // 0x05E8(0x0004) (Config)
	int                                                CompanionTooltip_Mount_RideTime_Size;                     // 0x05EC(0x0004) (Config)
	int                                                CompanionTooltip_Mount_RunSpeed_Size;                     // 0x05F0(0x0004) (Config)
	int                                                CompanionTooltip_Mount_FlySpeed_Size;                     // 0x05F4(0x0004) (Config)
	int                                                CompanionTooltip_Mount_Skill_Name_Size;                   // 0x05F8(0x0004) (Config)
	int                                                CompanionTooltip_Mount_Skill_Description_Size;            // 0x05FC(0x0004) (Config)
	int                                                CompanionTooltip_Pet_Lv_Grade_Type_Size;                  // 0x0600(0x0004) (Config)
	int                                                CompanionTooltip_Pet_Stat_Size;                           // 0x0604(0x0004) (Config)
	int                                                CompanionTooltip_Pet_Skill_Name_Size;                     // 0x0608(0x0004) (Config)
	int                                                CompanionTooltip_Pet_Skill_Description_Size;              // 0x060C(0x0004) (Config)
	int                                                CompanionTooltip_Fellow_Lv_Grade_Type_Size;               // 0x0610(0x0004) (Config)
	int                                                CompanionTooltip_Fellow_Stat_Size;                        // 0x0614(0x0004) (Config)
	int                                                CompanionTooltip_Fellow_Skill_Name_Size;                  // 0x0618(0x0004) (Config)
	int                                                CompanionTooltip_Fellow_Skill_Description_Size;           // 0x061C(0x0004) (Config)
	int                                                CompanionTooltip_Foster_Available_Size;                   // 0x0620(0x0004) (Config)
	int                                                CompanionTooltip_Foster_Ingredient_Available_Size;        // 0x0624(0x0004) (Config)
	int                                                CompanionTooltip_Extraction_Available_Size;               // 0x0628(0x0004) (Config)
	struct FColor                                      CompanionTooltip_Fellow_Stat_Inc_Color;                   // 0x062C(0x0004) (Config)
	int                                                CompanionTooltip_GradeUp_Count_Size;                      // 0x0630(0x0004) (Config)
	int                                                CompanionTooltip_Fatigue_Size;                            // 0x0634(0x0004) (Config)
	struct FColor                                      CompanionTooltip_Color;                                   // 0x0638(0x0004) (Config)
	int                                                CompanionSkillTooltip_Name_Size;                          // 0x063C(0x0004) (Config)
	int                                                CompanionSkillTooltip_Description_Size;                   // 0x0640(0x0004) (Config)
	struct FColor                                      CompanionSkillTooltip_Name_Color;                         // 0x0644(0x0004) (Config)
	struct FColor                                      CompanionSkillTooltip_Description_Color;                  // 0x0648(0x0004) (Config)
	struct FColor                                      TeleportToolTipWaypointLocationNameColor;                 // 0x064C(0x0004) (Config)
	int                                                TeleportToolTipWaypointLocationNameSize;                  // 0x0650(0x0004) (Config)
	struct FItemFontConfig                             CompanionTooltip_Mount_Usable_Rank;                       // 0x0654(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             CompanionTooltip_Mount_Usable_conqueror;                  // 0x0678(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             CompanionTooltip_Pet_Usable_Rank;                         // 0x069C(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             CompanionTooltip_Pet_Usable_conqueror;                    // 0x06C0(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             CompanionTooltip_Fellow_Usable_Rank;                      // 0x06E4(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             CompanionTooltip_Fellow_Usable_conqueror;                 // 0x0708(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             ItemTooltip_AbnormalStatusTitle;                          // 0x072C(0x0024) (Config, NeedCtorLink)
	struct FItemFontConfig                             ItemTooltip_AbnormalStatusDesc;                           // 0x0750(0x0024) (Config, NeedCtorLink)
	class UBLUIPlayer*                                 UIPlayer;                                                 // 0x0774(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLToolTipDataGenerator");
		return ptr;
	}


	bool STATIC_GenerateActionBarFavoriteRightTooltip(struct FString* OutTooltipString);
	bool STATIC_GenerateActionBarFavoriteLeftTooltip(struct FString* OutTooltipString);
	bool STATIC_GenerateQuestAlertMinimizeTooltip(struct FString* OutTooltipString);
	bool STATIC_GenerateQuestAlertAutoPathFindTooltip(struct FString* OutTooltipString);
	bool STATIC_GenerateMinimapExtensionTooltip(struct FString* OutTooltipString);
	bool STATIC_GenerateMinimapTODTooltip(struct FString* OutTooltipString);
	void Chat_MPFContainerTooltip(int InCid, int InSid);
	void Chat_MPFItemTooltip(int InCid, int InSid);
	bool GenerateSkillGemTooltip(int InCid, struct FString* OutLabel, struct FString* OutDescription);
	bool GenerateSelectiveGemNodeTooltip(int InCid, class UGFxObject** OutSections);
	bool GenerateGemNodeTooltip(int InCid, class UGFxObject** OutSections);
	bool GenerateNonStanceSkillTooltip(int InCid, TArray<class UGFxObject*>* OutSections);
	bool GenerateStanceSkillTooltip(int InCid, TArray<class UGFxObject*>* OutSections);
	bool GenerateStanceTooltip(int InCid, TArray<class UGFxObject*>* OutSections);
	bool GenerateHUDIconLTTooltip(int InServiceLevel, struct FString* OutTooltipString);
	bool GenerateAppearanceChangeInfoTooltip(int InCharacterListIndex, struct FString* OutTooltipString);
	bool GenerateRandomMatchingCountTooltip(struct FString* OutTooltipString);
	bool GenerateCollectionBookGradeUpChanceTooltip(struct FString* OutTooltipString);
	bool GenerateSkillToolTipForSkillTreeStat(int InTreeCid, class UGFxObject** Sections);
	bool GenerateSkillToolTipForSkillTree(int InTreeCid, class UGFxObject** Sections);
	bool GenerateLevelUpParamString(struct FPawnParam1st* InPawnParam1st, struct FString* OutString);
	bool GenerateEquipmentCompareString(int InItemCid, int InEquipItemSid, int InUnequipItemSid, struct FString* OutString);
	bool GenerateInstanceRevivalPointTooltip(int InPointSid, struct FString* OutTitle, struct FString* OutDescription);
	bool GenerateCOZoneNameTooltip(int InCitadelCid, struct FString* OutTooltipString);
	bool GenerateGuildManagementHistoryToolTip(int InHistoryIndex, struct FString* OutTooltipString);
	bool GeneratePCUIGearScoreTooltip(struct FString* OutTitle, struct FString* OutDescription);
	bool GenerateDungeonGearScoreTooltip(int InDungeonGroupCid, struct FString* OutTooltipString);
	bool GenerateDungeonAvailableCntTooltip(int InDungeonGroupCid, struct FString* OutTooltipString);
	bool GeneratePartyMatchingTooltip(TEnumAsByte<ETooltipType> InToolTipType, struct FString* OutTooltipString);
	bool GenerateDuelResultTooltip(struct FString* OutTooltipString);
	bool GenerateOtherChannelToolTip(int InSid, struct FString* OutLabel);
	bool GenerateSkillDeckTabToolTip(int InCid, struct FString* OutLabel);
	bool GenerateMonsterBookRepeatTooltip(int InCid, struct FString* OutLabel);
	bool GenerateCraftLockTooltip(int InCid, struct FString* OutLabel);
	bool GenerateFellowSkillToolTip(int InCid, class UGFxObject** Sections);
	bool GeneratePetSkillToolTip(int InCid, class UGFxObject** Sections);
	bool GenerateMountPassiveSkillToolTip(int InCid, class UGFxObject** Sections);
	bool GenerateGatherCraftToolTip(TEnumAsByte<ETooltipType> InToolTipType, class UGFxObject** Sections);
	bool GenerateContentTokenTooltip(TEnumAsByte<ETooltipType> InToolTipType, class UGFxObject** Sections);
	bool GeneratePropTooltip(int InPropCid, struct FString* OutPropName, struct FString* OutPropDesc, TArray<class UGFxObject*>* OutQuestDatas, struct FString* OutGatherDesc);
	bool GenerateCollectionBookCountTooltip(struct FString* OutLabel);
	bool GenerateMPFFatigueTooltip(int InCompanionType, const struct FQWord& InUid, struct FString* OutLabel);
	bool GenerateMountTooltip(const struct FQWord& InMountUid, class UGFxObject** outTooltip);
	bool GenerateFellowTooltip(const struct FQWord& InFellowUid, class UGFxObject** outTooltip);
	bool GeneratePetTooltip(const struct FQWord& InPetUid, class UGFxObject** outTooltip);
	bool GenerateItemToolTipImpl(TEnumAsByte<ETooltipType> InToolTipType, int InCid, int InSid, class UBLItem* InInstItem, bool InShowCompare, class UGFxObject** Sections);
	bool GenerateItemToolTip(TEnumAsByte<ETooltipType> InToolTipType, int InCid, int InSid, bool InShowCompare, class UGFxObject** Sections);
	bool GenerateLumenaShopAddLumenaToolTip(struct FString* OutText);
	struct FString GenerateTeleportUIWaypointToolTip(const struct FString& InText);
	bool GenerateMissionRefreshToolTip(struct FString* OutText);
	bool GenerateItemLegendOptionTooltip(int InCid, struct FString* OutLabel);
	bool GenerateInventoryLockTooltip(int InTabIndex, int InSlotCompIndex, struct FString* OutLabel);
	bool GeneratePCEnergyMountTooltip(class ABLPlayer* InPCPlayer, struct FString* OutLabel, struct FString* OutDesc);
	bool GenerateVoluntaryActionTooltip(int InCid, struct FString* OutLabel, struct FString* OutDesc);
	bool GetPCStatusTooltipText(TEnumAsByte<ETooltipType> Type, struct FString* OutLabel, struct FString* OutDesc);
	bool GenerateCraftUIToolTip(TEnumAsByte<ETooltipType> InToolTipType, struct FString* Desc);
	bool GenerateElementGuageToolTip(struct FString* OutLabel, struct FString* OutDescription);
	bool GenerateAbnormalStatusGroupToolTip(TEnumAsByte<EPawnType> InPawnType, int InServerId, int InCid, TArray<class UGFxObject*>* Sections);
	bool GenerateAbnormalStatusToolTip(int InCid, TArray<class UGFxObject*>* Sections);
	bool GenerateSpecialWarMedalToolTip(int InCid, TArray<class UGFxObject*>* Sections);
	bool GenerateMountSkillToolTip(int InCid, TArray<class UGFxObject*>* Sections);
	bool GenerateSkillToolTip(int InCid, bool IsUseTactic, TArray<class UGFxObject*>* Sections);
	bool GenerateActionBarSkillToolTip(int InCid, TArray<class UGFxObject*>* Sections);
	void SetUIPlayer(class UBLUIPlayer* InUIPlayer);
	class UGFxObject* CreateToolTipSectionAbnormalStatusList(TArray<struct FAbnormalData> InAbnormalDataList);
	class UGFxObject* CreateToolTipSectionGold(int InGold);
	class UGFxObject* CreateToolTipSectionRemainingTime();
	class UGFxObject* CreateToolTipSectionDesc2(const struct FString& inDesc);
	class UGFxObject* CreateToolTipSectionDesc1(const struct FString& inDesc);
	class UGFxObject* CreateToolTipSectionMain();
};


// Class BLGame.GFxObjectBase
// 0x0010 (0x00B0 - 0x00A0)
class UGFxObjectBase : public UGFxObject
{
public:
	class UBLUIPlayer*                                 UIPlayer;                                                 // 0x00A0(0x0008)
	class UGFxObject*                                  ContainerObject;                                          // 0x00A8(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.GFxObjectBase");
		return ptr;
	}


	bool GetVisible();
	bool IsVisible();
	void Init(class UBLUIPlayer* Player);
};


// Class BLGame.GFxUI_Minimap
// 0x1170 (0x1220 - 0x00B0)
class UGFxUI_Minimap : public UGFxObjectBase
{
public:
	TArray<struct FMinimapScaleFactor>                 ZoomScaleFactor;                                          // 0x00B0(0x0010) (Config, NeedCtorLink)
	float                                              ShowZUpper;                                               // 0x00C0(0x0004) (Config)
	float                                              ShowZLower;                                               // 0x00C4(0x0004) (Config)
	unsigned long                                      bShow : 1;                                                // 0x00C8(0x0004)
	float                                              UpdateCheckTime;                                          // 0x00CC(0x0004)
	int                                                UpdateCheckTickCount;                                     // 0x00D0(0x0004)
	float                                              UpdateIntervalTime;                                       // 0x00D4(0x0004)
	int                                                UpdateIntervalTickCount;                                  // 0x00D8(0x0004)
	int                                                MinimapFilterBit;                                         // 0x00DC(0x0004)
	TArray<unsigned long>                              MinimapFilterList;                                        // 0x00E0(0x0010) (NeedCtorLink)
	TArray<TEnumAsByte<EMinimapFilter>>                NPCTypeToMinimapFilter;                                   // 0x00F0(0x0010) (NeedCtorLink)
	struct FString                                     GfxMinimapPath;                                           // 0x0100(0x0010) (NeedCtorLink)
	struct FName                                       DefaultMinimapTexturePath;                                // 0x0110(0x0008)
	struct FName                                       DefaultMinimapDoorTexturePath;                            // 0x0118(0x0008)
	TArray<struct FName>                               MinimapTextures;                                          // 0x0120(0x0010) (Transient, NeedCtorLink)
	TArray<struct FName>                               MinimapDoorTextures;                                      // 0x0130(0x0010) (Transient, NeedCtorLink)
	int                                                CurrentWorldCid;                                          // 0x0140(0x0004)
	int                                                CurrentQuadrant;                                          // 0x0144(0x0004)
	struct FIntPoint                                   CurrentDivisionIndex;                                     // 0x0148(0x0008)
	TArray<struct FQuadrantData>                       QuadrantDatas;                                            // 0x0150(0x0010) (NeedCtorLink)
	class UGFxObject*                                  PlayerIcon;                                               // 0x0160(0x0008)
	class UGFxObject*                                  PlayerView;                                               // 0x0168(0x0008)
	class UGFxObject*                                  PlayerDeadMC;                                             // 0x0170(0x0008)
	struct FMinimapIcon                                PlayerDeadBodyIcon;                                       // 0x0178(0x0014)
	class UGFxObject*                                  RevivalContainerMC;                                       // 0x018C(0x0008)
	class UGFxObject*                                  RevivalPointRegisteredContainerMC;                        // 0x0194(0x0008)
	class UGFxObject*                                  RevivalPointGuildContainerMC;                             // 0x019C(0x0008)
	class UGFxObject*                                  RevivalPointPartyContainerMC;                             // 0x01A4(0x0008)
	class UGFxObject*                                  RevivalPointPersonalContainerMC;                          // 0x01AC(0x0008)
	class UGFxObject*                                  PartyMemberMC;                                            // 0x01B4(0x0008)
	TArray<struct FMinimapIcon>                        PartyMemberIcons;                                         // 0x01BC(0x0010) (NeedCtorLink)
	TArray<struct FMinimapIcon>                        RaidMemberIcons;                                          // 0x01CC(0x0010) (NeedCtorLink)
	TArray<class UGFxObject*>                          MinimapDoorMCList;                                        // 0x01DC(0x0010) (NeedCtorLink)
	class UGFxObject*                                  QuestContianerMC;                                         // 0x01EC(0x0008)
	class UGFxObject*                                  StoryQuestMarkerMC;                                       // 0x01F4(0x0008)
	class UGFxObject*                                  GuideQuestMarkerMC;                                       // 0x01FC(0x0008)
	class UGFxObject*                                  RoyalQuestMarkerMC;                                       // 0x0204(0x0008)
	class UGFxObject*                                  QuestCompleteMarkerMC;                                    // 0x020C(0x0008)
	class UGFxObject*                                  QuestAreaIndexMC;                                         // 0x0214(0x0008)
	class UGFxObject*                                  QuestAcceptableMarkerMC;                                  // 0x021C(0x0008)
	class UGFxObject*                                  AutoPathMC;                                               // 0x0224(0x0008)
	class UGFxObject*                                  FieldRaidMC;                                              // 0x022C(0x0008)
	class UGFxObject*                                  RoyalQuestMC;                                             // 0x0234(0x0008)
	class UGFxObject*                                  DungeonMC;                                                // 0x023C(0x0008)
	class UGFxObject*                                  ExchangeMC;                                               // 0x0244(0x0008)
	class UGFxObject*                                  ROManagerMC;                                              // 0x024C(0x0008)
	class UGFxObject*                                  GuildMC;                                                  // 0x0254(0x0008)
	class UGFxObject*                                  MerchantMC;                                               // 0x025C(0x0008)
	class UGFxObject*                                  WarehouseMC;                                              // 0x0264(0x0008)
	class UGFxObject*                                  SkillMC;                                                  // 0x026C(0x0008)
	class UGFxObject*                                  RetrunMC;                                                 // 0x0274(0x0008)
	class UGFxObject*                                  WayPointMC;                                               // 0x027C(0x0008)
	class UGFxObject*                                  CraftChoiceMC;                                            // 0x0284(0x0008)
	class UGFxObject*                                  CraftMasterMC;                                            // 0x028C(0x0008)
	class UGFxObject*                                  RepairNPCMC;                                              // 0x0294(0x0008)
	class UGFxObject*                                  EquipLvUpNPCMC;                                           // 0x029C(0x0008)
	class UGFxObject*                                  DesynthesisNPCMC;                                         // 0x02A4(0x0008)
	class UGFxObject*                                  PortalMC;                                                 // 0x02AC(0x0008)
	class UGFxObject*                                  LimitedRankMC;                                            // 0x02B4(0x0008)
	class UGFxObject*                                  UnderAttackMC;                                            // 0x02BC(0x0008)
	class UGFxObject*                                  ConquestNpcMC;                                            // 0x02C4(0x0008)
	class UGFxObject*                                  ConquestGhostMC;                                          // 0x02CC(0x0008)
	class UGFxObject*                                  ConquestTreeGhostMC;                                      // 0x02D4(0x0008)
	class UGFxObject*                                  ConquestTreeMC;                                           // 0x02DC(0x0008)
	class UGFxObject*                                  ConquestGateMC;                                           // 0x02E4(0x0008)
	class UGFxObject*                                  ConquestStoneMC;                                          // 0x02EC(0x0008)
	class UGFxObject*                                  OccupationWarNormalBaseMC;                                // 0x02F4(0x0008)
	class UGFxObject*                                  OccupationWarSpecialBaseMC;                               // 0x02FC(0x0008)
	class UGFxObject*                                  OccupationWarItemMC;                                      // 0x0304(0x0008)
	class UGFxObject*                                  DeathPointMC;                                             // 0x030C(0x0008)
	class UGFxObject*                                  ROBaseMC;                                                 // 0x0314(0x0008)
	class UGFxObject*                                  ROFinalBaseMC;                                            // 0x031C(0x0008)
	class UGFxObject*                                  ROWeaponMC;                                               // 0x0324(0x0008)
	class UGFxObject*                                  ROCastleDoorMC;                                           // 0x032C(0x0008)
	class UGFxObject*                                  ChallengeTowerMC;                                         // 0x0334(0x0008)
	class UGFxObject*                                  QuestAreaMC;                                              // 0x033C(0x0008)
	class UGFxObject*                                  PartyIconScaleMapMC;                                      // 0x0344(0x0008)
	class UGFxObject*                                  DoorScaleMapMC;                                           // 0x034C(0x0008)
	class UGFxObject*                                  QuestIconScaleMapMC;                                      // 0x0354(0x0008)
	class UGFxObject*                                  ScaleMinimapMC;                                           // 0x035C(0x0008)
	class UGFxObject*                                  PartyIconPosMapMC;                                        // 0x0364(0x0008)
	class UGFxObject*                                  DoorPosMapMC;                                             // 0x036C(0x0008)
	class UGFxObject*                                  QuestIconPosMapMC;                                        // 0x0374(0x0008)
	class UGFxObject*                                  PosMinimapMC;                                             // 0x037C(0x0008)
	class UGFxObject*                                  LocationMC;                                               // 0x0384(0x0008)
	class UGFxObject*                                  LocationNameTextField;                                    // 0x038C(0x0008)
	TArray<class UGFxObject*>                          MinimapMCList;                                            // 0x0394(0x0010) (NeedCtorLink)
	class UGFxObject*                                  RevivalMC;                                                // 0x03A4(0x0008)
	class UGFxObject*                                  EventMC;                                                  // 0x03AC(0x0008)
	TArray<TEnumAsByte<EQuestMarker>>                  MarkerUpdateType;                                         // 0x03B4(0x0010) (Const, NeedCtorLink)
	TArray<TEnumAsByte<ECENPCCategory>>                NpcMinimapIconUpdateType;                                 // 0x03C4(0x0010) (Const, NeedCtorLink)
	TArray<TEnumAsByte<ECEPropInteractType>>           PropMinimapIconUpdateType;                                // 0x03D4(0x0010) (Const, NeedCtorLink)
	TArray<TEnumAsByte<ECEQuestType>>                  IndexIconUpdateType;                                      // 0x03E4(0x0010) (Const, NeedCtorLink)
	TArray<TEnumAsByte<ECEInstantRevivalPointType>>    InstacneRevivalPointUpdateType;                           // 0x03F4(0x0010) (Const, NeedCtorLink)
	struct FMinimapIconInfo                            QuestMarkerInfos[0x7];                                    // 0x0404(0x0020) (NeedCtorLink)
	struct FMinimapIconInfo                            NpcMinimapIconInfos[0x4C];                                // 0x04E4(0x0020) (NeedCtorLink)
	struct FMinimapIconInfo                            PropMinimapIconInfos[0x8];                                // 0x0E64(0x0020) (NeedCtorLink)
	struct FMinimapIconInfo                            QuestAreaIndexInfos[0x4];                                 // 0x0F64(0x0020) (NeedCtorLink)
	struct FMinimapIconInfo                            QuestAreaInfos;                                           // 0x0FE4(0x0020) (NeedCtorLink)
	struct FMinimapIconInfo                            UnderAttackAlertInfos;                                    // 0x1004(0x0020) (NeedCtorLink)
	struct FMinimapIconInfo                            DeathPointAlertInfos;                                     // 0x1024(0x0020) (NeedCtorLink)
	struct FMinimapIconInfo                            AutoPathInfos;                                            // 0x1044(0x0020) (NeedCtorLink)
	struct FMinimapIconInfo                            FieldRaidInfos;                                           // 0x1064(0x0020) (NeedCtorLink)
	struct FMinimapIconInfo                            InstanceRevivalPointInfos[0x3];                           // 0x1084(0x0020) (NeedCtorLink)
	struct FMinimapIconInfo                            RegistedInstanceRevivalPointInfos[0x3];                   // 0x10E4(0x0020) (NeedCtorLink)
	class UQuestManager*                               QuestManager;                                             // 0x1144(0x0008)
	class UQuestJournalManager*                        QuestJournalManager;                                      // 0x114C(0x0008)
	class UQuestNPCManager*                            QuestNPCMgr;                                              // 0x1154(0x0008)
	class UAlertManager*                               AlertManager;                                             // 0x115C(0x0008)
	TArray<int>                                        MinimapQuestMarkOrder;                                    // 0x1164(0x0010) (Const, NeedCtorLink)
	TArray<int>                                        MinimapNPCOrder;                                          // 0x1174(0x0010) (Const, NeedCtorLink)
	int                                                MinimapDefaultZoomgrade;                                  // 0x1184(0x0004) (Config)
	int                                                CurrentZoomStep;                                          // 0x1188(0x0004)
	int                                                NUM_MINIMAP_TEXTURE;                                      // 0x118C(0x0004) (Const)
	int                                                NUM_PARTY_ICON;                                           // 0x1190(0x0004) (Const)
	int                                                RAID_ICON_MAX;                                            // 0x1194(0x0004) (Const)
	float                                              MINIMAP_UI_WIDTH;                                         // 0x1198(0x0004) (Const)
	float                                              MINIMAP_UI_HEIGHT;                                        // 0x119C(0x0004) (Const)
	float                                              MINIMAP_PIXEL_SIZE;                                       // 0x11A0(0x0004) (Const)
	float                                              QUEST_AREA_PIXEL_SIZE;                                    // 0x11A4(0x0004) (Const)
	int                                                MINIMAP_CENTER_INDEX;                                     // 0x11A8(0x0004) (Const)
	float                                              QUEST_AREA_INDEX_POS_RATIO;                               // 0x11AC(0x0004) (Const)
	int                                                RECT_OUT_ALPHA;                                           // 0x11B0(0x0004) (Const)
	int                                                QUEST_DROPZONE_BEGIN;                                     // 0x11B4(0x0004) (Const)
	int                                                STORY_NORMAL_ICON;                                        // 0x11B8(0x0004) (Const)
	int                                                STORY_DROPZONE_ICON;                                      // 0x11BC(0x0004) (Const)
	struct FString                                     POS_MAP_PATH;                                             // 0x11C0(0x0010) (Const, NeedCtorLink)
	struct FString                                     MINIMAP_PACKAGE_PATH;                                     // 0x11D0(0x0010) (Const, NeedCtorLink)
	struct FString                                     MINIMAP_DOOR_PACKAGE_PATH;                                // 0x11E0(0x0010) (Const, NeedCtorLink)
	struct FString                                     MINIMAP_RENDER_TARGET_NAME;                               // 0x11F0(0x0010) (Const, NeedCtorLink)
	struct FString                                     MINIMAP_DOOR_RENDER_TARGET_NAME;                          // 0x1200(0x0010) (Const, NeedCtorLink)
	struct FScriptDelegate                             __OnClick__Delegate;                                      // 0x1210(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x1210(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.GFxUI_Minimap");
		return ptr;
	}


	void ClearAlertIcons();
	struct FString GetFilterGameString(TEnumAsByte<EMinimapFilter> Filter);
	TArray<class UGFxObject*> AU_Minimap_Get_Filter_Data();
	void AU_Minimap_Check_Option_Info(int checkedIndex, bool Selected);
	void UA_Minimap_Set_Option_Info(TArray<unsigned long> checkInfos);
	void GameSessionEnd();
	bool GetTooltipData(TArray<class UGFxObject*>* RequestedTooltipInfoList, TArray<class UGFxObject*>* outToolTipDataList);
	int GetNPCCategoryOrder(TEnumAsByte<ECENPCCategory> InNPCCategoryType);
	int GetQuestMarkerOrder(TEnumAsByte<EQuestMarker> InMarkerType);
	void InitNpcMinimapTooltipInfo(struct FNpcMinimapTooltipInfo* outNpcMinimapTooltipInfo);
	void InitQuestMinimapTooltipInfo(struct FQuestMinimapTooltipInfo* outQuestMinimapTooltipInfo);
	void SortInstanceRevivalPointMinimapTooltipList(TArray<struct FInstanceRevivalPointMinimapTooltipInfo>* OutList);
	void SortQuestMinimapTooltipList(TArray<struct FQuestMinimapTooltipInfo>* OutList);
	void SortNpcMinimapTooltipList(TArray<struct FNpcMinimapTooltipInfo>* OutList);
	void SetRevivalPenel(bool bVisible, TEnumAsByte<ECERevivalType> Type);
	void OnClickReturn(const struct FEventData& ev);
	void SetRevivalButtonData(TEnumAsByte<ECERevivalType> Type);
	void Update(float InDeltaTime);
	bool GetIconPosition(const struct FVector& Target, struct FVector2D* IconPos, int* RectOut);
	void UpdateQuestAreaIndex(TArray<struct FQuestAreaInfo>* AreaInfos);
	void UpdateQuestArea(TArray<struct FQuestAreaInfo>* AreaInfos);
	void UpdateLocationName(const struct FString& LocationName);
	void UpdateIcons();
	void UpdateIconsByInstanceRevivalPoint(class UBlessLocalPlayer* InPlayer, class ABlessPC* InController, class ABLPawn* InPCPawn, float InScale);
	void UpdateIconsByFieldRaid(class UBlessLocalPlayer* InPlayer, class ABlessPC* InController, class ABLPawn* InPCPawn, float InScale);
	void UpdateIconsByAutoPath(class UBlessLocalPlayer* InPlayer, class ABlessPC* InController, class ABLPawn* InPCPawn, float InScale);
	void UpdateIconsByDeathPointAlert(class UBlessLocalPlayer* InPlayer, class ABlessPC* InController, class ABLPawn* InPCPawn, float InScale);
	void UpdateIconsByUnderAttackAlert(class UBlessLocalPlayer* InPlayer, class ABlessPC* InController, class ABLPawn* InPCPawn, float InScale);
	void UpdateIconsByProp(class UBlessLocalPlayer* InPlayer, class ABlessPC* InController, class ABLPawn* InPCPawn, float InScale);
	void UpdateIconsByNPC(class UBlessLocalPlayer* InPlayer, class ABlessPC* InController, class ABLPawn* InPCPawn, float InScale);
	void UpdateIconsByDeadBody(class UBlessLocalPlayer* InPlayer, class ABlessPC* InController, class ABLPawn* InPCPawn, float InScale);
	void UpdateIconsByRaidMember(class UBlessLocalPlayer* InPlayer, class ABlessPC* InController, class ABLPawn* InPCPawn, float InScale);
	void UpdateIconsByPartyMember(class UBlessLocalPlayer* InPlayer, class ABlessPC* InController, class ABLPawn* InPCPawn, float InScale);
	void UpdateIconsByQuest(class UBlessLocalPlayer* InPlayer, class ABlessPC* InController, class ABLPawn* InPCPawn, float InScale);
	bool GetNPCLocation(int InExistNpcCid, struct FVector* OutNPCLocation);
	void SetShowZByNPCCid(class UGFxObject* mcShowZ, int InExistNpcCid);
	void SetShowZ(class UGFxObject* mcShowZ, float TargetLocationZ);
	void SetDefaultDisplayInfo(struct FASDisplayInfo* DisplayInfo);
	void ClearDisplayInfo(struct FASDisplayInfo* DInfo);
	bool CheckPropFilter(TEnumAsByte<ECEPropInteractType> PropInteractType);
	bool CheckNPCFilter(TEnumAsByte<ECENPCCategory> NPCType);
	void UpdatePlayerPosition();
	void UpdateMinimapTexture();
	bool GetSectorInfo(const struct FVector& InLocation, struct FVector2D* OutSectorPos);
	void SetAdjacentMinimapTexture(const struct FIntPoint& DivisionIndex, int WorldMapCId, int Quadrant);
	void SetMinimapTexture(class UGFxObject* TargetMC, int MapIndex, const struct FString& TargetName, class UTexture2D* TargetTexture, const struct FVector2D& pos);
	class UGFxObject* GetMinimapDoorMC(int MapIndex);
	class UGFxObject* GetMinimapMC(int MapIndex);
	void SetMinimapDefaultTexture();
	bool SetTooltipData(class UGFxObject* TargetObject, int TargetCid, TEnumAsByte<ETooltipType> Type, const struct FString& TooltipDesc);
	void SetTooltipDataFast(class UGFxObject* TargetObject, int TargetCid, TEnumAsByte<ETooltipType> Type, const struct FString& TooltipDesc);
	void UA_Remove_Tooltip_Event(TArray<class UGFxObject*> MarkerObjects);
	void RemoveMinimapIconTootipEvent(TArray<struct FMinimapIcon> MinimapIcons);
	void AddTooltipEvent(class UGFxObject* MarkerObject);
	void UA_Add_Click_Event(class UGFxObject* QuestIcon);
	void CreateRegistedInstanceRevivalPointIcon(TEnumAsByte<ECEInstantRevivalPointType> InType, int CreateNum);
	void CreateInstanceRevivalPointIcon(TEnumAsByte<ECEInstantRevivalPointType> InType, bool InIsRegisted, int CreateNum);
	void CreateFieldRaidIcon(int CreateNum);
	void CreateAutoPathIcon(int CreateNum);
	void CreateDeathPointAlertIcon(int CreateNum);
	void CreateUnderAttackAlertIcon(int CreateNum);
	void CreateQuestAreaIndex(TEnumAsByte<ECEQuestType> IndexType, int CreateNum);
	void CreateQuestArea(int CreateNum);
	void CreatePropMinimapIcon(TEnumAsByte<ECEPropInteractType> IconType, int CreateNum);
	void CreateNpcMinimapIcon(TEnumAsByte<ECENPCCategory> IconType, int CreateNum);
	void CreateQuestMarker(TEnumAsByte<EQuestMarker> MarkerType, int CreateNum);
	void CreateMinimapIconMC(class UGFxObject* ParentMC, int CreateNum, const struct FString& MiddleName, struct FMinimapIconInfo* IconInfo);
	void UA_Set_Minimap_Zoom_Step(int ZoomStep, int ZoomMaxStep);
	float AU_Get_Minimap_Tooltip_Delay();
	struct FString AU_Get_Minimap_Zoom_Scale(int ZoomStep);
	void Toggle();
	void Unload();
	void InitMinimapFilter();
	void Init(class UBLUIPlayer* Player);
	void OnClick();
};


// Class BLGame.GFxUI_MinimapExtension
// 0x1918 (0x19C8 - 0x00B0)
class UGFxUI_MinimapExtension : public UGFxObjectBase
{
public:
	unsigned long                                      bShow : 1;                                                // 0x00B0(0x0004)
	unsigned long                                      ChangDungeon : 1;                                         // 0x00B0(0x0004)
	unsigned long                                      bUpdateMap : 1;                                           // 0x00B0(0x0004)
	unsigned long                                      MoveMode : 1;                                             // 0x00B0(0x0004)
	unsigned long                                      ExpandMapDefaultValue : 1;                                // 0x00B0(0x0004) (Config)
	class UGFxObject*                                  ScaleIconMinimapMC;                                       // 0x00B4(0x0008)
	class UGFxObject*                                  ScaleMinimapMC;                                           // 0x00BC(0x0008)
	class UGFxObject*                                  PosMinimapMC;                                             // 0x00C4(0x0008)
	class UGFxObject*                                  TitleBarMC;                                               // 0x00CC(0x0008)
	class UGFxObject*                                  BGMC;                                                     // 0x00D4(0x0008)
	class UGFxObject*                                  PlayerIcon;                                               // 0x00DC(0x0008)
	class UGFxObject*                                  PlayerView;                                               // 0x00E4(0x0008)
	class UGFxObject*                                  PosIconMinimapMC;                                         // 0x00EC(0x0008)
	class UGFxObject*                                  PlayerDeadMC;                                             // 0x00F4(0x0008)
	class UGFxObject*                                  PlayerDeadBodyIcon;                                       // 0x00FC(0x0008)
	class UGFxObject*                                  RevivalContainerMC;                                       // 0x0104(0x0008)
	class UGFxObject*                                  RevivalPointRegisteredContainerMC;                        // 0x010C(0x0008)
	class UGFxObject*                                  RevivalPointGuildContainerMC;                             // 0x0114(0x0008)
	class UGFxObject*                                  RevivalPointPartyContainerMC;                             // 0x011C(0x0008)
	class UGFxObject*                                  RevivalPointPersonalContainerMC;                          // 0x0124(0x0008)
	class UGFxObject*                                  PartyMemberMC;                                            // 0x012C(0x0008)
	class UGFxObject*                                  QuestContianerMC;                                         // 0x0134(0x0008)
	class UGFxObject*                                  StoryQuestMarkerMC;                                       // 0x013C(0x0008)
	class UGFxObject*                                  GuideQuestMarkerMC;                                       // 0x0144(0x0008)
	class UGFxObject*                                  RoyalQuestMarkerMC;                                       // 0x014C(0x0008)
	class UGFxObject*                                  QuestCompleteMarkerMC;                                    // 0x0154(0x0008)
	class UGFxObject*                                  QuestAreaIndexMC;                                         // 0x015C(0x0008)
	class UGFxObject*                                  QuestAcceptableMarkerMC;                                  // 0x0164(0x0008)
	class UGFxObject*                                  AutoPathMC;                                               // 0x016C(0x0008)
	class UGFxObject*                                  FieldRaidMC;                                              // 0x0174(0x0008)
	class UGFxObject*                                  RoyalQuestMC;                                             // 0x017C(0x0008)
	class UGFxObject*                                  DungeonMC;                                                // 0x0184(0x0008)
	class UGFxObject*                                  ExchangeMC;                                               // 0x018C(0x0008)
	class UGFxObject*                                  ROManagerMC;                                              // 0x0194(0x0008)
	class UGFxObject*                                  GuildMC;                                                  // 0x019C(0x0008)
	class UGFxObject*                                  MerchantMC;                                               // 0x01A4(0x0008)
	class UGFxObject*                                  WarehouseMC;                                              // 0x01AC(0x0008)
	class UGFxObject*                                  SkillMC;                                                  // 0x01B4(0x0008)
	class UGFxObject*                                  RetrunMC;                                                 // 0x01BC(0x0008)
	class UGFxObject*                                  WayPointMC;                                               // 0x01C4(0x0008)
	class UGFxObject*                                  CraftChoiceMC;                                            // 0x01CC(0x0008)
	class UGFxObject*                                  CraftMasterMC;                                            // 0x01D4(0x0008)
	class UGFxObject*                                  RepairNPCMC;                                              // 0x01DC(0x0008)
	class UGFxObject*                                  EquipLvUpNPCMC;                                           // 0x01E4(0x0008)
	class UGFxObject*                                  DesynthesisNPCMC;                                         // 0x01EC(0x0008)
	class UGFxObject*                                  PortalMC;                                                 // 0x01F4(0x0008)
	class UGFxObject*                                  LimitedRankMC;                                            // 0x01FC(0x0008)
	class UGFxObject*                                  UnderAttackMC;                                            // 0x0204(0x0008)
	class UGFxObject*                                  ConquestNpcMC;                                            // 0x020C(0x0008)
	class UGFxObject*                                  ConquestGhostMC;                                          // 0x0214(0x0008)
	class UGFxObject*                                  ConquestTreeGhostMC;                                      // 0x021C(0x0008)
	class UGFxObject*                                  ConquestTreeMC;                                           // 0x0224(0x0008)
	class UGFxObject*                                  ConquestGateMC;                                           // 0x022C(0x0008)
	class UGFxObject*                                  ConquestStoneMC;                                          // 0x0234(0x0008)
	class UGFxObject*                                  QuestAreaMC;                                              // 0x023C(0x0008)
	class UGFxObject*                                  OccupationWarNormalBaseMC;                                // 0x0244(0x0008)
	class UGFxObject*                                  OccupationWarSpecialBaseMC;                               // 0x024C(0x0008)
	class UGFxObject*                                  OccupationWarItemMC;                                      // 0x0254(0x0008)
	class UGFxObject*                                  DeathPointMC;                                             // 0x025C(0x0008)
	class UGFxObject*                                  ROBaseMC;                                                 // 0x0264(0x0008)
	class UGFxObject*                                  ROFinalBaseMC;                                            // 0x026C(0x0008)
	class UGFxObject*                                  ROWeaponMC;                                               // 0x0274(0x0008)
	class UGFxObject*                                  ROCastleDoorMC;                                           // 0x027C(0x0008)
	class UGFxObject*                                  ChallengeTowerMC;                                         // 0x0284(0x0008)
	class UGFxObject*                                  DungeonMapMC;                                             // 0x028C(0x0008)
	TArray<class UGFxObject*>                          MinimapMCList;                                            // 0x0294(0x0010) (NeedCtorLink)
	TArray<class UGFxObject*>                          PartyMemberIcons;                                         // 0x02A4(0x0010) (NeedCtorLink)
	TArray<class UGFxObject*>                          RaidMemberIcons;                                          // 0x02B4(0x0010) (NeedCtorLink)
	int                                                CurrentQuadrant;                                          // 0x02C4(0x0004)
	struct FIntPoint                                   CurrentDivisionIndex;                                     // 0x02C8(0x0008)
	int                                                CurrentDungeonCID;                                        // 0x02D0(0x0004)
	float                                              MapScaleValue;                                            // 0x02D4(0x0004)
	float                                              MapMoveOffeSet;                                           // 0x02D8(0x0004)
	struct FString                                     GfxMinimapPath;                                           // 0x02DC(0x0010) (NeedCtorLink)
	struct FName                                       DefaultMinimapTexturePath;                                // 0x02EC(0x0008)
	TArray<struct FName>                               MinimapTextures;                                          // 0x02F4(0x0010) (Transient, NeedCtorLink)
	TArray<struct FName>                               MinimapExtensionTextures;                                 // 0x0304(0x0010) (Transient, NeedCtorLink)
	class UQuestManager*                               QuestManager;                                             // 0x0314(0x0008)
	class UQuestJournalManager*                        QuestJournalManager;                                      // 0x031C(0x0008)
	class UQuestNPCManager*                            QuestNPCMgr;                                              // 0x0324(0x0008)
	class UAlertManager*                               AlertManager;                                             // 0x032C(0x0008)
	class UBLWorldManager*                             WorldManger;                                              // 0x0334(0x0008) (Transient)
	TArray<TEnumAsByte<EQuestMarker>>                  MarkerUpdateType;                                         // 0x033C(0x0010) (Const, NeedCtorLink)
	TArray<TEnumAsByte<ECENPCCategory>>                NpcMinimapIconUpdateType;                                 // 0x034C(0x0010) (Const, NeedCtorLink)
	TArray<TEnumAsByte<ECEPropInteractType>>           PropMinimapIconUpdateType;                                // 0x035C(0x0010) (Const, NeedCtorLink)
	TArray<TEnumAsByte<ECEQuestType>>                  IndexIconUpdateType;                                      // 0x036C(0x0010) (Const, NeedCtorLink)
	TArray<TEnumAsByte<ECEInstantRevivalPointType>>    InstacneRevivalPointUpdateType;                           // 0x037C(0x0010) (Const, NeedCtorLink)
	struct FExtensionMinimapIconInfo                   QuestMarkerInfos[0x7];                                    // 0x038C(0x0034) (NeedCtorLink)
	struct FExtensionMinimapIconInfo                   NpcMinimapIconInfos[0x4C];                                // 0x04F8(0x0034) (NeedCtorLink)
	struct FExtensionMinimapIconInfo                   PropMinimapIconInfos[0x8];                                // 0x1468(0x0034) (NeedCtorLink)
	struct FExtensionMinimapIconInfo                   QuestAreaIndexInfos[0x4];                                 // 0x1608(0x0034) (NeedCtorLink)
	struct FExtensionMinimapIconInfo                   QuestAreaInfos;                                           // 0x16D8(0x0034) (NeedCtorLink)
	struct FExtensionMinimapIconInfo                   UnderAttackAlertInfos;                                    // 0x170C(0x0034) (NeedCtorLink)
	struct FExtensionMinimapIconInfo                   DeathPointAlertInfos;                                     // 0x1740(0x0034) (NeedCtorLink)
	struct FExtensionMinimapIconInfo                   AutoPathInfos;                                            // 0x1774(0x0034) (NeedCtorLink)
	struct FExtensionMinimapIconInfo                   FieldRaidInfos;                                           // 0x17A8(0x0034) (NeedCtorLink)
	struct FExtensionMinimapIconInfo                   InstanceRevivalPointInfos[0x3];                           // 0x17DC(0x0034) (NeedCtorLink)
	struct FExtensionMinimapIconInfo                   RegistedInstanceRevivalPointInfos[0x3];                   // 0x1878(0x0034) (NeedCtorLink)
	TArray<struct FQuadrantData>                       QuadrantDatas;                                            // 0x1914(0x0010) (NeedCtorLink)
	int                                                CurrentZoomStep;                                          // 0x1924(0x0004)
	float                                              MinimapExtensionWidth;                                    // 0x1928(0x0004)
	float                                              MinimapExtensionHeight;                                   // 0x192C(0x0004)
	float                                              IconScaleRatio;                                           // 0x1930(0x0004)
	int                                                MapSizeStep;                                              // 0x1934(0x0004)
	int                                                NUM_MINIMAP_TEXTURE;                                      // 0x1938(0x0004) (Const)
	int                                                NUM_PARTY_ICON;                                           // 0x193C(0x0004) (Const)
	int                                                RAID_ICON_MAX;                                            // 0x1940(0x0004) (Const)
	float                                              MINIMAP_PIXEL_SIZE;                                       // 0x1944(0x0004) (Const)
	float                                              QUEST_AREA_PIXEL_SIZE;                                    // 0x1948(0x0004) (Const)
	int                                                MINIMAP_CENTER_INDEX;                                     // 0x194C(0x0004) (Const)
	float                                              QUEST_AREA_INDEX_POS_RATIO;                               // 0x1950(0x0004) (Const)
	int                                                RECT_OUT_ALPHA;                                           // 0x1954(0x0004) (Const)
	int                                                QUEST_DROPZONE_BEGIN;                                     // 0x1958(0x0004) (Const)
	int                                                STORY_NORMAL_ICON;                                        // 0x195C(0x0004) (Const)
	int                                                STORY_DROPZONE_ICON;                                      // 0x1960(0x0004) (Const)
	struct FString                                     POS_MAP_PATH;                                             // 0x1964(0x0010) (Const, NeedCtorLink)
	struct FString                                     MINIMAP_PACKAGE_PATH;                                     // 0x1974(0x0010) (Const, NeedCtorLink)
	struct FString                                     MINIMAP_EXTENSION_PACKAGE_PATH;                           // 0x1984(0x0010) (Const, NeedCtorLink)
	struct FString                                     MINIMAP_RENDER_TARGET_NAME;                               // 0x1994(0x0010) (Const, NeedCtorLink)
	struct FString                                     MINIMAP_RENDER_TARGET_DUNGEON_NAME;                       // 0x19A4(0x0010) (Const, NeedCtorLink)
	int                                                MINIMAP_RENDER_TARGET_DUNGEON_NUMBER;                     // 0x19B4(0x0004) (Const)
	float                                              UpdateCheckTime;                                          // 0x19B8(0x0004)
	int                                                UpdateCheckTickCount;                                     // 0x19BC(0x0004)
	float                                              UpdateIntervalTime;                                       // 0x19C0(0x0004)
	int                                                UpdateIntervalTickCount;                                  // 0x19C4(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.GFxUI_MinimapExtension");
		return ptr;
	}


	void ClearAlertIcons();
	void UA_MinimapExtension_Set_Move_Mode(bool bMoveMode);
	void UA_MinimapExtension_Set_Loaction(const struct FString& Location);
	void UA_MinimapExtension_Set_Size(float Width, float Height, int Step);
	void SetBGAlpha(float Alpha);
	void SetTextureAlpha(float Alpha);
	void SetMinimapExtensionSize(float Width, float Height, int Step);
	void SetMinimapExtensionSizeStep(int Step);
	void GameSessionEnd();
	struct FString GetFrameName(TEnumAsByte<ECENPCCategory> InCategory);
	void Update(float InDeltaTime);
	bool GetIconPosition(const struct FVector2D& Target, struct FVector2D* IconPos, int* RectOut);
	void SetDefaultDisplayInfo(struct FASDisplayInfo* DisplayInfo);
	void UpdateQuestAreaIndex(TArray<struct FQuestAreaInfo>* AreaInfos);
	void UpdateQuestArea(TArray<struct FQuestAreaInfo>* AreaInfos);
	void UpdateIcons();
	bool CheckMinimapFilter(TEnumAsByte<EMinimapFilter> FilterType);
	void UpdatePlayerPosition();
	void UpdateMinimapTexture();
	bool GetSectorInfo(const struct FVector& InLocation, struct FVector2D* OutSectorPos, struct FVector2D* OutSectorSize);
	void SetDungeonMinimapTexture(const struct FIntPoint& DivisionIndex, int WorldMapCId);
	void SetAdjacentMinimapTexture(const struct FIntPoint& DivisionIndex, int WorldMapCId, int Quadrant);
	void SetMinimapTexture(int MapIndex, const struct FString& TargetName, class UTexture2D* TargetTexture, const struct FVector2D& pos);
	void SetMinimapDefaultTexture();
	void CreateRegistedInstanceRevivalPointIcon(TEnumAsByte<ECEInstantRevivalPointType> InType, int CreateNum);
	TArray<class UGFxObject*> CreateInstanceRevivalPointIcon(TEnumAsByte<ECEInstantRevivalPointType> InType, bool InIsRegisted, int COUNT);
	TArray<class UGFxObject*> CreateFieldRaidIcon(int COUNT);
	TArray<class UGFxObject*> CreateAutoPathIcon(int COUNT);
	TArray<class UGFxObject*> CreateDeathPointAlertIcon(int COUNT);
	TArray<class UGFxObject*> CreateUnderAttackAlertIcon(int COUNT);
	TArray<class UGFxObject*> CreateQuestAreaIndex(TEnumAsByte<ECEQuestType> IndexType, int COUNT);
	TArray<class UGFxObject*> CreateQuestArea(int COUNT);
	TArray<class UGFxObject*> CreatePropMinimapIcon(TEnumAsByte<ECEPropInteractType> IconType, int IconNum);
	TArray<class UGFxObject*> CreateNpcMinimapIcon(TEnumAsByte<ECENPCCategory> IconType, int IconNum);
	TArray<class UGFxObject*> CreateQuestMarker(TEnumAsByte<EQuestMarker> MarkerType, int MarkerNum);
	TArray<class UGFxObject*> CreateMinimapIconMC(class UGFxObject* ParentMC, const struct FString& ClipName, int ClipNum, const struct FString& MiddleName, int* CurrentCount);
	void SetShowFlag(bool Flag);
	void Unload();
	bool GetMoveMode();
	int GetFGOpacity();
	int GetBGOpacity();
	int GetSizeStep();
	void Init(class UBLUIPlayer* Player);
};


// Class BLGame.GFxUI_NameTagObject
// 0x0124 (0x01D4 - 0x00B0)
class UGFxUI_NameTagObject : public UGFxObjectBase
{
public:
	class UGFxObject*                                  OverlayNameTextField;                                     // 0x00B0(0x0008)
	class UGFxObject*                                  NameTextField;                                            // 0x00B8(0x0008)
	class UGFxObject*                                  BackNameTextField;                                        // 0x00C0(0x0008)
	class UGFxObject*                                  NameTagBGMC;                                              // 0x00C8(0x0008)
	class UGFxObject*                                  HPUnitMC;                                                 // 0x00D0(0x0008)
	class UGFxObject*                                  HPBarMC;                                                  // 0x00D8(0x0008)
	class UGFxObject*                                  HPBarEffectMC;                                            // 0x00E0(0x0008)
	class UGFxObject*                                  QuestMarkMC;                                              // 0x00E8(0x0008)
	class UGFxObject*                                  SignIconMC;                                               // 0x00F0(0x0008)
	class UGFxObject*                                  GuildSymbolMC;                                            // 0x00F8(0x0008)
	class UGFxObject*                                  GuildWarMarkMC;                                           // 0x0100(0x0008)
	TArray<class UGFxObject*>                          SpeechBubbleMCList;                                       // 0x0108(0x0010) (NeedCtorLink)
	int                                                MaxSpeechBubble;                                          // 0x0118(0x0004) (Const)
	float                                              MinNameTagVisibleDistance;                                // 0x011C(0x0004) (Config)
	float                                              MaxNameTagVisibleDistance;                                // 0x0120(0x0004) (Config)
	float                                              MinNameTagScalableDistance;                               // 0x0124(0x0004) (Config)
	float                                              MaxNameTagScalableDistance;                               // 0x0128(0x0004) (Config)
	float                                              MinNameTagScale;                                          // 0x012C(0x0004) (Config)
	float                                              MaxNameTagScale;                                          // 0x0130(0x0004) (Config)
	float                                              MinNameTagAlphaChangableDistance;                         // 0x0134(0x0004) (Config)
	float                                              MaxNameTagAlphaChangableDistance;                         // 0x0138(0x0004) (Config)
	float                                              MinNameTagAlpha;                                          // 0x013C(0x0004) (Config)
	float                                              MaxNameTagAlpha;                                          // 0x0140(0x0004) (Config)
	TArray<float>                                      SpeechBubbleAlpha;                                        // 0x0144(0x0010) (Config, NeedCtorLink)
	unsigned long                                      IsHpVisible : 1;                                          // 0x0154(0x0004)
	unsigned long                                      CurrentGuildSymbolVisible : 1;                            // 0x0154(0x0004)
	unsigned long                                      CurrentGuildWarMarkVisible : 1;                           // 0x0154(0x0004)
	unsigned long                                      CurrentOverlayNameVisible : 1;                            // 0x0154(0x0004)
	unsigned long                                      bNeedFirstUpdate : 1;                                     // 0x0154(0x0004)
	float                                              HPAlphaCount;                                             // 0x0158(0x0004)
	float                                              OverlayAlphaCount;                                        // 0x015C(0x0004)
	float                                              OverlayInc;                                               // 0x0160(0x0004)
	TEnumAsByte<EQuestMarker>                          QuestMarker;                                              // 0x0164(0x0001)
	TEnumAsByte<EPawnMeshRenderState>                  PawnMeshRenderState;                                      // 0x0165(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x0166(0x0002) MISSED OFFSET
	int                                                AVMVersion;                                               // 0x0168(0x0004)
	float                                              CurrentHPPercent;                                         // 0x016C(0x0004)
	struct FString                                     CurrentPawnName;                                          // 0x0170(0x0010) (NeedCtorLink)
	struct FString                                     CurrentOverlayPawnName;                                   // 0x0180(0x0010) (NeedCtorLink)
	struct FString                                     CurrentPawnTitle;                                         // 0x0190(0x0010) (NeedCtorLink)
	struct FString                                     CurrentPawnRankTitle;                                     // 0x01A0(0x0010) (NeedCtorLink)
	struct FColor                                      CurrentPawnNameColor;                                     // 0x01B0(0x0004)
	struct FColor                                      CurrentPawnHPColor;                                       // 0x01B4(0x0004)
	int                                                CurrentEnableBubbleStackStep;                             // 0x01B8(0x0004)
	int                                                CurrentSignIndex;                                         // 0x01BC(0x0004)
	int                                                CurrentCrownType;                                         // 0x01C0(0x0004)
	int                                                CurrentGuildSignIndex;                                    // 0x01C4(0x0004)
	int                                                CurrentGuildSignBGIndex;                                  // 0x01C8(0x0004)
	int                                                CurrentGuildGrade;                                        // 0x01CC(0x0004)
	int                                                CurrentGuildSymbolScale;                                  // 0x01D0(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.GFxUI_NameTagObject");
		return ptr;
	}


	void SetMeshRenderState(TEnumAsByte<EPawnMeshRenderState> NewRenderState);
	void SetQuestObjectiveProgress(const struct FString& COUNT);
	void SetOnHeadTagIcon(int Type, int Number);
	void SetEnableBubbleStack(int Step);
	void ShowHP();
	void HideHP();
	void ShowQuestMart();
	void HideQuestMark();
	void UnsetSpeechBubbleOnlyMode();
	void SetSpeechBubbleOnlyMode();
	bool IsOpenSpeechBubble(int bubbleIndex);
	void HideAllSpeechBubbles();
	void ShowSpeechBubble(int bubbleIndex, bool bVisible);
	void SetSpeechBubbleData(int bubbleIndex, const struct FString& Text, const struct FColor& TextColor, int Time, bool IsEnemy);
	void SetGuildWarMark(bool IsVisible);
	void SetGuildSymbol(bool IsVisible);
	void SetSpeechBubbleAlign(int NumSpeechBubbles);
	void SetDepths(int Depth);
	void Tick(float InDeltaTime);
	bool InitNameTag();
	void UpdateHPBarPos();
	void ShowName(bool bShow);
	bool SetName(const struct FString& PawnName, const struct FString& PawnTitle, const struct FColor& NameColor, const struct FString& PawnRankTitle);
	void SetOverlayName(const struct FString& PawnName, const struct FString& PawnTitle, const struct FColor& NameColor);
	void SetQuestMark(TEnumAsByte<EQuestMarker> QuestMarkType);
	void SetGuildSymbolData(int CrownType, int IconIndexSign, int IconIndexBG, int GuildGrade, int IconScale);
	void SetSign(int IconIndex);
	void SetHPVisible(bool HPVisible, bool IsImmediately);
	void SetHpAlpha(float HpAlpha);
	void SetHPColor(const struct FColor& HPColor);
	void SetHP(int PawnHP, int PawnMaxHP, bool bHPEffect);
	void SetNameTagDisplayInfo(int PosX, int PosY, float PawnDistance);
	void SetNameTag(TEnumAsByte<EPawnType> PawnType, const struct FString& PawnName, const struct FString& PawnTitle, int PawnHP, int PawnMaxHP, bool NameVisible, bool HPVisible, const struct FColor& PawnNameColor, const struct FColor& PawnHPColor, bool bInEnemyList, bool bIsGuildSymbolVisible, bool bIsGuildWarMarkVisible, const struct FString& PawnRankTitle);
};


// Class BLGame.GFxStream
// 0x0010 (0x0070 - 0x0060)
class UGFxStream : public UObject
{
public:
	TArray<struct FASValue>                            args;                                                     // 0x0060(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.GFxStream");
		return ptr;
	}


	void WriteLog();
	bool WriteProtocol(const struct FString& Protocol);
	bool WriteString(const struct FString& Data);
	bool WriteBoolean(bool Data);
	bool WriteFloat(float Data);
	bool WriteInt(int Data);
	void Clear();
};


// Class BLGame.IfTag
// 0x0000 (0x0068 - 0x0068)
class UIfTag : public UTranslatorTag
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.IfTag");
		return ptr;
	}


	struct FString Translate(const struct FString& InTagValue);
};


// Class BLGame.NameTagMesh
// 0x003B (0x0298 - 0x025D)
class ANameTagMesh : public AStaticMeshActor
{
public:
	unsigned char                                      UnknownData00[0x3];                                       // 0x025D(0x0003) MISSED OFFSET
	struct FVector                                     PawnLoc;                                                  // 0x0260(0x000C)
	class ABLPawn*                                     PCPawn;                                                   // 0x026C(0x0008)
	class ABLPawnBase*                                 OwnerPawn;                                                // 0x0274(0x0008)
	struct FVector                                     RotVector;                                                // 0x027C(0x000C)
	class ABlessPC*                                    PC;                                                       // 0x0288(0x0008)
	class UStaticMeshComponent*                        MeshComp;                                                 // 0x0290(0x0008) (Edit, Const, ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.NameTagMesh");
		return ptr;
	}


	void Tick(float fDeltaTime);
	void Init();
};


// Class BLGame.TeleportBookMarkCommon
// 0x0024 (0x0084 - 0x0060)
class UTeleportBookMarkCommon : public UObject
{
public:
	unsigned long                                      bInGameEdit : 1;                                          // 0x0060(0x0004)
	struct FString                                     strConfigPath;                                            // 0x0064(0x0010) (NeedCtorLink)
	TArray<struct FTeleportBookMark>                   Lists;                                                    // 0x0074(0x0010) (Config, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.TeleportBookMarkCommon");
		return ptr;
	}


	void IniLoadConfig();
	void IniSaveConfig();
	int GetTeleportBookMarkCount();
	bool GetTeleportBookMark(int Index, struct FTeleportBookMark* Mark);
	bool GetBookMarkLocation(int Index, struct FVector* Location);
	bool DeleteBookMark(int Index);
	void AddBookMark(const struct FString& strName, const struct FVector& Location, const struct FString& Desc);
	void Init();
};


// Class BLGame.TranslatorAbnormalStatusTag
// 0x0000 (0x0068 - 0x0068)
class UTranslatorAbnormalStatusTag : public UTranslatorTag
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.TranslatorAbnormalStatusTag");
		return ptr;
	}


	struct FString Translate(const struct FString& InTagValue);
};


// Class BLGame.TranslatorAuraTag
// 0x0000 (0x0068 - 0x0068)
class UTranslatorAuraTag : public UTranslatorTag
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.TranslatorAuraTag");
		return ptr;
	}


	struct FString Translate(const struct FString& InTagValue);
};


// Class BLGame.TranslatorContentInfoTag
// 0x0008 (0x0070 - 0x0068)
class UTranslatorContentInfoTag : public UTranslatorTag
{
public:
	class UClass*                                      ContentInfoClass;                                         // 0x0068(0x0008) (Const)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.TranslatorContentInfoTag");
		return ptr;
	}


	struct FString Translate(const struct FString& InTagValue);
};


// Class BLGame.TranslatorGameStringInfoTag
// 0x0000 (0x0070 - 0x0070)
class UTranslatorGameStringInfoTag : public UTranslatorContentInfoTag
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.TranslatorGameStringInfoTag");
		return ptr;
	}


	struct FString Translate(const struct FString& InTagValue);
};


// Class BLGame.TranslatorItemTag
// 0x0000 (0x0070 - 0x0070)
class UTranslatorItemTag : public UTranslatorContentInfoTag
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.TranslatorItemTag");
		return ptr;
	}


	struct FString Translate(const struct FString& InTagValue);
};


// Class BLGame.TranslatorMountSkillTag
// 0x0000 (0x0070 - 0x0070)
class UTranslatorMountSkillTag : public UTranslatorContentInfoTag
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.TranslatorMountSkillTag");
		return ptr;
	}


	struct FString Translate(const struct FString& InTagValue);
};


// Class BLGame.TranslatorSkillTag
// 0x0000 (0x0070 - 0x0070)
class UTranslatorSkillTag : public UTranslatorContentInfoTag
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.TranslatorSkillTag");
		return ptr;
	}


	struct FString Translate(const struct FString& InTagValue);
};


// Class BLGame.TranslatorVoluntaryActionTag
// 0x0000 (0x0070 - 0x0070)
class UTranslatorVoluntaryActionTag : public UTranslatorContentInfoTag
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.TranslatorVoluntaryActionTag");
		return ptr;
	}


	struct FString Translate(const struct FString& InTagValue);
};


// Class BLGame.TranslatorContentNameTag
// 0x0008 (0x0070 - 0x0068)
class UTranslatorContentNameTag : public UTranslatorTag
{
public:
	class UClass*                                      ContentInfoClass;                                         // 0x0068(0x0008) (Const)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.TranslatorContentNameTag");
		return ptr;
	}


	struct FString Translate(const struct FString& InTagValue);
};


// Class BLGame.TranslatorItemNameTag
// 0x0000 (0x0070 - 0x0070)
class UTranslatorItemNameTag : public UTranslatorContentNameTag
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.TranslatorItemNameTag");
		return ptr;
	}

};


// Class BLGame.TranslatorSkillNameTag
// 0x0000 (0x0070 - 0x0070)
class UTranslatorSkillNameTag : public UTranslatorContentNameTag
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.TranslatorSkillNameTag");
		return ptr;
	}


	struct FString Translate(const struct FString& InTagValue);
};


// Class BLGame.TranslatorEnumTag
// 0x0000 (0x0068 - 0x0068)
class UTranslatorEnumTag : public UTranslatorTag
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.TranslatorEnumTag");
		return ptr;
	}


	struct FString Translate(const struct FString& InTagValue);
};


// Class BLGame.TranslatorLocationTag
// 0x0000 (0x0068 - 0x0068)
class UTranslatorLocationTag : public UTranslatorTag
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.TranslatorLocationTag");
		return ptr;
	}


	struct FString Translate(const struct FString& InTagValue);
};


// Class BLGame.TranslatorNPCTag
// 0x0000 (0x0068 - 0x0068)
class UTranslatorNPCTag : public UTranslatorTag
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.TranslatorNPCTag");
		return ptr;
	}


	struct FString Translate(const struct FString& InTagValue);
};


// Class BLGame.TranslatorPCTag
// 0x0008 (0x0070 - 0x0068)
class UTranslatorPCTag : public UTranslatorTag
{
public:
	class ULocalPlayer*                                LP;                                                       // 0x0068(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.TranslatorPCTag");
		return ptr;
	}


	struct FString Translate(const struct FString& InTagValue);
	void Init(class ULocalPlayer* InLocalPlayer);
};


// Class BLGame.TranslatorPropTag
// 0x0000 (0x0068 - 0x0068)
class UTranslatorPropTag : public UTranslatorTag
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.TranslatorPropTag");
		return ptr;
	}


	struct FString Translate(const struct FString& InTagValue);
};


// Class BLGame.TranslatorQuestTag
// 0x0000 (0x0068 - 0x0068)
class UTranslatorQuestTag : public UTranslatorTag
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.TranslatorQuestTag");
		return ptr;
	}


	struct FString Translate(const struct FString& InTagValue);
};


// Class BLGame.TranslatorSocialActionTag
// 0x0000 (0x0068 - 0x0068)
class UTranslatorSocialActionTag : public UTranslatorTag
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.TranslatorSocialActionTag");
		return ptr;
	}


	struct FString Translate(const struct FString& InTagValue);
};


// Class BLGame.WICPromotion
// 0x0068 (0x00C8 - 0x0060)
class UWICPromotion : public UObject
{
public:
	struct FWICPromotionInfo                           WICPromotionKOR;                                          // 0x0060(0x0014) (Config, NeedCtorLink)
	struct FWICPromotionInfo                           WICPromotionRUS;                                          // 0x0074(0x0014) (Config, NeedCtorLink)
	struct FWICPromotionInfo                           WICPromotionJPN;                                          // 0x0088(0x0014) (Config, NeedCtorLink)
	struct FWICPromotionInfo                           WICPromotionUSA;                                          // 0x009C(0x0014) (Config, NeedCtorLink)
	struct FWICPromotionInfo                           WICPromotionCHN;                                          // 0x00B0(0x0014) (Config, NeedCtorLink)
	unsigned long                                      IsShowEventPromotionOnce : 1;                             // 0x00C4(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.WICPromotion");
		return ptr;
	}


	bool GetWICPromotionIsButtonShow();
	struct FString GetWICPromotionURL();
	bool GetWICPromotionIsPageOpen();
};


// Class BLGame.StatusEffectBase
// 0x0044 (0x00A4 - 0x0060)
class UStatusEffectBase : public UObject
{
public:
	class ABLPawnBase*                                 StatusEffectPawn;                                         // 0x0060(0x0008)
	TEnumAsByte<ESTATUS_EFFECT_PHASE>                  NowPhase;                                                 // 0x0068(0x0001)
	TEnumAsByte<ESTATUS_EFFECT_FAILED_PHASE>           FailPhase;                                                // 0x0069(0x0001)
	TEnumAsByte<EVFX_SCALE_TYPE>                       VFXScaleType;                                             // 0x006A(0x0001)
	unsigned char                                      UnknownData00[0x1];                                       // 0x006B(0x0001) MISSED OFFSET
	int                                                MITVKeyID;                                                // 0x006C(0x0004)
	int                                                MITVKeyStart;                                             // 0x0070(0x0004) (Const)
	TArray<class UParticleSystemComponent*>            PSCs;                                                     // 0x0074(0x0010) (ExportObject, Transient, Component, NeedCtorLink, EditInline)
	TArray<class ABLDecalActor*>                       MovableDecals;                                            // 0x0084(0x0010) (Transient, NeedCtorLink)
	TArray<struct FStatusParticleSoftAttachInfo>       SPSAInfos;                                                // 0x0094(0x0010) (Transient, Component, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.StatusEffectBase");
		return ptr;
	}


	void HideEffect(bool bHide);
	float CalcVFXScale(TEnumAsByte<EVFX_SCALE_TYPE> InType);
	void CalcSkelVertSurfSpawnCount(int* OutSpawnCount, float* OutScaleValue);
	float CalcCylinderSurfaceArea(float Inradius, float InHeight);
	void OnParticleSystemFinished(class UParticleSystemComponent* InPSC);
	void Cleanup();
	void ForceStop();
	void PlayEffect(const struct FStatusEffectInfo& EffectInfo, TEnumAsByte<ESTATUS_EFFECT_PHASE> InPhase);
	TEnumAsByte<ESTATUS_EFFECT_PHASE> GetNowPhase();
	void SetNowPhase(TEnumAsByte<ESTATUS_EFFECT_PHASE> InPhase);
};


// Class BLGame.AbnormalStatusBase
// 0x0014 (0x00B8 - 0x00A4)
class UAbnormalStatusBase : public UStatusEffectBase
{
public:
	int                                                AbnormalCid;                                              // 0x00A4(0x0004)
	class UAbnormalStatusAsset*                        AbnormalStatusAsset;                                      // 0x00A8(0x0008)
	int                                                CasterSID;                                                // 0x00B0(0x0004)
	unsigned long                                      bUseGuideVoluntary : 1;                                   // 0x00B4(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.AbnormalStatusBase");
		return ptr;
	}


	void UpdateGuideEffect();
	void Init(class ABLPawnBase* inPawn, class UAbnormalStatusAsset* InAsset, const struct FAbnormalStatusData& InData);
};


// Class BLGame.AbnormalStatusNormal
// 0x0004 (0x00BC - 0x00B8)
class UAbnormalStatusNormal : public UAbnormalStatusBase
{
public:
	unsigned long                                      bNeedEffect : 1;                                          // 0x00B8(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.AbnormalStatusNormal");
		return ptr;
	}


	void PeriodicEffect();
	void DisappearEffect();
	void OnGoingEffect();
	void AppearEffect();
	void SetNowPhase(TEnumAsByte<ESTATUS_EFFECT_PHASE> InPhase);
};


// Class BLGame.AbnormalStatusRestrict
// 0x001C (0x00D4 - 0x00B8)
class UAbnormalStatusRestrict : public UAbnormalStatusBase
{
public:
	TArray<struct FRestrictAbnormalStatusEvent>        EventList;                                                // 0x00B8(0x0010) (Component, AlwaysInit, NeedCtorLink)
	float                                              CheckTimer;                                               // 0x00C8(0x0004) (Transient)
	struct FName                                       AttachPrefixName;                                         // 0x00CC(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.AbnormalStatusRestrict");
		return ptr;
	}


	void OnParticleSystemFinished(class UParticleSystemComponent* InPSC);
	void ClearList();
	void ForceStop();
	void SetNowPhase(TEnumAsByte<ESTATUS_EFFECT_PHASE> InPhase);
	void Init(class ABLPawnBase* inPawn, class UAbnormalStatusAsset* InAsset, const struct FAbnormalStatusData& InData);
};


// Class BLGame.AuraBase
// 0x000C (0x00B0 - 0x00A4)
class UAuraBase : public UStatusEffectBase
{
public:
	int                                                AuraCid;                                                  // 0x00A4(0x0004)
	class UAuraAsset*                                  AuraAsset;                                                // 0x00A8(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.AuraBase");
		return ptr;
	}


	void Init(class ABLPawnBase* inPawn, class UAuraAsset* InAuraAsset, int InAuraCid);
};


// Class BLGame.AuraNormal
// 0x0004 (0x00B4 - 0x00B0)
class UAuraNormal : public UAuraBase
{
public:
	unsigned long                                      bNeedEffect : 1;                                          // 0x00B0(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.AuraNormal");
		return ptr;
	}


	void DisappearEffect();
	void OnGoingEffect();
	void AppearEffect();
	void SetNowPhase(TEnumAsByte<ESTATUS_EFFECT_PHASE> InPhase);
};


// Class BLGame.EquipItemEffectBase
// 0x000C (0x00B0 - 0x00A4)
class UEquipItemEffectBase : public UStatusEffectBase
{
public:
	class UItemAsset*                                  EquipItemAsset;                                           // 0x00A4(0x0008)
	int                                                ItemCid;                                                  // 0x00AC(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.EquipItemEffectBase");
		return ptr;
	}


	void Init(class ABLPawnBase* inPawn, class UItemAsset* InAsset, int InItemCid);
};


// Class BLGame.EquipItemEffectNormal
// 0x0004 (0x00B4 - 0x00B0)
class UEquipItemEffectNormal : public UEquipItemEffectBase
{
public:
	unsigned long                                      bNeedEffect : 1;                                          // 0x00B0(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.EquipItemEffectNormal");
		return ptr;
	}


	void DisappearEffect();
	void AppearEffect();
	void SetNowPhase(TEnumAsByte<ESTATUS_EFFECT_PHASE> InPhase);
};


// Class BLGame.BLCornerPathNode
// 0x0040 (0x0290 - 0x0250)
class ABLCornerPathNode : public AActor
{
public:
	struct FPathNodeActorIndex                         MyIndex;                                                  // 0x0250(0x000C) (Edit, EditConst)
	TArray<struct FPathNodeActorIndex>                 NeighborIndex;                                            // 0x025C(0x0010) (Edit, EditConst, NeedCtorLink)
	TArray<float>                                      Distance;                                                 // 0x026C(0x0010) (Edit, EditConst, NeedCtorLink)
	class UStaticMeshComponent*                        StaticMeshComponent;                                      // 0x027C(0x0008) (ExportObject, Component, EditInline)
	class USpriteComponent*                            MarkStartIcon;                                            // 0x0284(0x0008) (ExportObject, Component, EditInline)
	unsigned long                                      bMarkStartPoint : 1;                                      // 0x028C(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLCornerPathNode");
		return ptr;
	}

};


// Class BLGame.BLCornerPathNodeScout
// 0x0000 (0x0570 - 0x0570)
class ABLCornerPathNodeScout : public APawn
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLCornerPathNodeScout");
		return ptr;
	}

};


// Class BLGame.BLTeleporter
// 0x003C (0x028C - 0x0250)
class ABLTeleporter : public AActor
{
public:
	unsigned long                                      TeleporterEnabled : 1;                                    // 0x0250(0x0004) (Edit)
	TEnumAsByte<ETeleporterTarget>                     eTarget;                                                  // 0x0254(0x0001) (Edit)
	TEnumAsByte<ETeleporterMethod>                     eMethod;                                                  // 0x0255(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x2];                                       // 0x0256(0x0002) MISSED OFFSET
	struct FString                                     TargetTag;                                                // 0x0258(0x0010) (Edit, NeedCtorLink)
	int                                                TargetWorldType;                                          // 0x0268(0x0004) (Edit)
	int                                                TargetWorldCID;                                           // 0x026C(0x0004) (Edit)
	struct FVector                                     TargetLocation;                                           // 0x0270(0x000C) (Edit)
	class USpriteComponent*                            TeleporterSprite;                                         // 0x027C(0x0008) (ExportObject, Component, EditInline)
	class UMeshComponent*                              CollisionMesh;                                            // 0x0284(0x0008) (Edit, ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLTeleporter");
		return ptr;
	}


	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	int GetCurrentWorldCID();
	int GetCurrentWorldType();
	void DoTeleportation(int WorldType, int WorldCid, const struct FVector& vLocation);
	bool CanTeleport(class AActor* A);
};


// Class BLGame.BLDoor
// 0x0054 (0x02E0 - 0x028C)
class ABLDoor : public AVolume
{
public:
	int                                                Sid;                                                      // 0x028C(0x0004) (Transient)
	int                                                Cid;                                                      // 0x0290(0x0004) (Transient)
	TEnumAsByte<ECEDoorInteractType>                   DoorType;                                                 // 0x0294(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0295(0x0003) MISSED OFFSET
	struct FString                                     DoorName;                                                 // 0x0298(0x0010) (Edit, NeedCtorLink)
	struct FString                                     OpenMatineeName;                                          // 0x02A8(0x0010) (Edit, NeedCtorLink)
	struct FString                                     CloseMatineeName;                                         // 0x02B8(0x0010) (Edit, NeedCtorLink)
	unsigned long                                      bDoorOpen : 1;                                            // 0x02C8(0x0004) (Edit)
	unsigned long                                      bClientTestEnabled : 1;                                   // 0x02C8(0x0004) (Edit)
	unsigned long                                      bDoorOpened : 1;                                          // 0x02C8(0x0004) (Transient)
	unsigned long                                      bPlayedOnce : 1;                                          // 0x02C8(0x0004) (Transient)
	unsigned long                                      bPlayedClosingMatinee : 1;                                // 0x02C8(0x0004) (Transient)
	unsigned long                                      bPlayedOpeningMatinee : 1;                                // 0x02C8(0x0004) (Transient)
	struct FVector                                     EscapeLocation;                                           // 0x02CC(0x000C) (Edit)
	class USpriteComponent*                            DoorSprite;                                               // 0x02D8(0x0008) (ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLDoor");
		return ptr;
	}


	void UnTouch(class AActor* Other);
	void Touch(class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void Tick(float DeltaTime);
	void PostBeginPlay();
	void UpdateTags();
	void SetDoorCollision();
	void DoorClose();
	void DoorClosing();
	void DoorOpen();
	void DoorOpening();
	void ChangeDoorState(TEnumAsByte<ECEDoorStateType> State);
	void DoorInit();
};


// Class BLGame.BLLocalPlayerAgent
// 0x0010 (0x0070 - 0x0060)
class UBLLocalPlayerAgent : public UObject
{
public:
	TArray<int>                                        EnemyList;                                                // 0x0060(0x0010) (AlwaysInit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLLocalPlayerAgent");
		return ptr;
	}


	void SetEnemy(TArray<int>* InEnemyList);
	bool IsEnemy(int S_id);
	void AddEnemy(int S_id);
	void ClearEnemyList();
	void Init();
};


// Class BLGame.KeyBindAdopter
// 0x0000 (0x0060 - 0x0060)
class UKeyBindAdopter : public UObject
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.KeyBindAdopter");
		return ptr;
	}


	void Initialize();
};


// Class BLGame.NET
// 0x0000 (0x0060 - 0x0060)
class UNET : public UObject
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.NET");
		return ptr;
	}


	bool STATIC_CS_MAKE_CRAFT_REQ(int InCraftCId, int inAmount);
	bool STATIC_CS_WITHDRAW_MAIL_REQ(unsigned char InMailIndex);
	bool STATIC_CS_PC_TAKE_DOWN_REQ();
	bool STATIC_CS_TRY_NORMAL_ATTACK_ACTION_REP(int InTargetSid);
	bool STATIC_CS_EXIT_CHALLENGE_TOWER_REP();
	bool STATIC_CS_REPAIR_MAX_DURABILITY_BY_NPC_REQ(int InRepairItemSid, TArray<int>* InResourceItemSidList);
	bool STATIC_CS_PREPARE_INSERT_AUCTION_REQ(int InItemSid, int InItemAmount);
	bool STATIC_CS_LOOK_CHANGE_REQ(TEnumAsByte<ECEGenderType> InGender, struct FString* InPlayerName, struct FCustomizeData* InBasicCustomizeData);
	bool STATIC_CS_POSE_ACTION_REQ(TEnumAsByte<ECEStatePoseType> InStatePose, bool InStandingForce);
	bool STATIC_CS_CLOSE_REGISTER_RUNE_UI_REP();
	bool STATIC_CS_APPLY_PARTY_EFFECT_LIVING_REQ(int InPartyIndex, int InPartyEffectLivingCId);
	bool STATIC_CS_REWARD_QUEST_REQ(int InQuestID, int InoptionRewardIndex);
	bool STATIC_CS_MOUSE_OVER_PAWN_REP(int InPawnSID);
	bool STATIC_CS_CITADEL_OWNERSHIP_AUCTION_BID_REQ(int InCitadelCid, int InmyBidCP);
	bool STATIC_CS_SUMMONEE_CHANGE_STANCE_REQ(int InSummoneeSid, TEnumAsByte<ESummoneeStance> Instance);
	bool STATIC_CS_ALRIMI_ADD_REP(TEnumAsByte<ECEAlrimiType> InAlrimiType, int InfirstKey, int InsecondKey, bool InisNew);
	bool STATIC_CS_CANCEL_REGISTER_COLOSSEUM_REP(int InColosseum_cid);
	bool STATIC_CS_SELECT_PC_DATA_LIST_REQ();
	bool STATIC_CS_TELEPORT_PARTY_MATCHING_REQ(TEnumAsByte<ECEWorldMapType> InWorldMapType, int InworldMapWrapperCId);
	bool STATIC_CS_REGISTER_LIMITED_RANK_ACK(bool Inconfirm);
	bool STATIC_CS_REQUEST_REVIVAL_REP(int InSidCaster, TEnumAsByte<ECERevivalType> InRevivalType, bool Inaccept);
	bool STATIC_CS_ITEM_UPGRADE_LEVEL_REQ(int InUpgradeItem, int InResourceItemCid, int InSuccessChanceIncItemCid, int InProtectDurabilityItemCid, int InProtectUpgradeLevelItemCid);
	bool STATIC_CS_CANCEL_INSERT_AUCTION_REQ();
	bool STATIC_CS_BUY_LUMENA_SHOP_ITEM_REQ(struct FLumenaShopItemData* InItemData);
	bool STATIC_CS_STOP_WAYPOINT_REP(bool Inis_forcedlanding);
	bool STATIC_CS_AUTO_TARGETING_OFF_REP(int InPawnSID, bool Infriendly);
	bool STATIC_CS_CANCEL_WAR_MATCHMAKING_REP();
	bool STATIC_CS_MPF_ALL_SKILL_CHANGE_REQ(TEnumAsByte<ECECompanionType> InMPFType, int InSkillChangeItemSId, struct FLONGLONGWrapper* InTargetMPFUId);
	bool STATIC_CS_CITADEL_OWNERSHIP_UI_OPEN_REP();
	bool STATIC_CS_MOUSE_LEAVE_PAWN_REP(int InPawnSID);
	bool STATIC_CS_ASK_DELEGATION_GUILD_LEADER_REQ(struct FString* InnewLeaderName);
	bool STATIC_CS_GET_MY_AUCTION_LIST_REQ(int InPageIndex);
	bool STATIC_CS_READ_MAIL_REQ(unsigned char InMailIndex);
	bool STATIC_CS_REQUEST_COMPLETE_EPISODE_LIST_REQ(int InLocationCid);
	bool STATIC_CS_INTERACTION_CANCEL_REP(int InsidTarget);
	bool STATIC_CS_LOOTING_REQUEST_PICKINGITEMLIST_REP(int InSid, bool Inpickgold, TArray<struct FPickDropItemInfo>* InItemList, TArray<struct FPickDropContentTokenInfo>* InContentTokenList);
	bool STATIC_CS_CANCEL_ITEM_SUCCEED_CASTING_REP();
	bool STATIC_CS_BACK_SERVER_CHOICE_REQ();
	bool STATIC_CS_UPDATE_MPF_DATA_REQ(TArray<struct FUpdateMPFData>* InUpdateRequestLIst);
	bool STATIC_CS_GIVEUP_PARTY_DROPITEM_REP(int InSid);
	bool STATIC_CS_CHARGE_SKILL_PREPARE_STOP_REP(int InCid);
	bool STATIC_CS_REPORT_BOT_REP(struct FString* InTargetPlayerName);
	bool STATIC_CS_CREATE_PC_REQ(TEnumAsByte<ECERaceType> InRace, TEnumAsByte<ECEClassType> InClass, TEnumAsByte<ECEGenderType> InGender, struct FString* InPlayerName, struct FCustomizeData* InBasicCustomizeData, TArray<struct FCustomizingPurchaseItemData>* InCustomizingItemList, TArray<struct FPlayerEnvironmentData>* InEnvironmentList);
	bool STATIC_CS_EMERGENCY_ESCAPE_REP();
	bool STATIC_CS_ITEMTRADE_INVITE_REQ(int InTargetSid);
	bool STATIC_CS_RESTART_REQ();
	bool STATIC_CS_EXCHANGE_CONTENT_TOKEN_REQ(TEnumAsByte<ECEContentTokenType> InexchangeContentTokenType, struct FContentTokenData* IncontentTokenData);
	bool STATIC_CS_SELECT_REVIVAL_TYPE_REP(TEnumAsByte<ECERevivalType> InRevivalType);
	bool STATIC_CS_REMOVE_ABNORMAL_STATUS_BY_GROUP_CODE_REP(int InCasterSid, int InGroupCodeCid);
	bool STATIC_CS_REMOVE_GUILD_MEMBER_REQ(struct FString* InMemberName);
	bool STATIC_CS_RESTART_QUEST_REQ(int InQuestID);
	bool STATIC_CS_SERVERPING_ACK(struct FULONGLONGWrapper* InClientTime, struct FULONGLONGWrapper* InServerTime);
	bool STATIC_CS_DROPITEMBAG_CHOOOSE_ACQUIRER_ACK(int InItemBagID, int Inacquirer);
	bool STATIC_CS_V2MISSION_REWARD_REQ(int InLevelTabIndex);
	bool STATIC_CS_ADD_FRIEND_REQ(struct FString* InFriendName);
	bool STATIC_CS_CHANGE_TARGET_REQ(int InTargetID);
	bool STATIC_CS_REWARD_MISSION_REQ(int InMissionCID);
	bool STATIC_CS_PARTY_MEMBER_SUMMON_SUMMONEE_ACK(int InSummonerSid, bool InisSummon);
	bool STATIC_CS_UPDATE_ACTIONBAR_SLOT_REQ(int InslotIdx, TEnumAsByte<EActionBarSlotType> InActionBarSlotType, struct FLONGLONGWrapper* InActionBarId);
	bool STATIC_CS_CHANGE_DROP_ITEM_DICE_ROLLING_GRADE_REP(TEnumAsByte<ECEItemGradeType> InItemGrade);
	bool STATIC_CS_USE_ITEM_CID_REP(int InItemCid, int InTargetSid);
	bool STATIC_CS_SWAP_ACTIONBAR_SLOT_REQ(int InslotIdx0, int InslotIdx1);
	bool STATIC_CS_REGISTER_CUSTOM_WAYPOINT_REQ(int InUseItemCid);
	bool STATIC_CS_USE_POINT_SKILL_BY_ITEM_ACK(struct FVector* InLocation);
	bool STATIC_CS_REQUEST_AVAILABLE_WAYPOINT_LIST_REQ(int Indeparture_id);
	bool STATIC_CS_OCCUPATION_WAR_INFO_REQ();
	bool STATIC_CS_ITEMTRADE_CHANGE_GOLD_REP(struct FLONGLONGWrapper* InGold);
	bool STATIC_CS_ACTIONBAR_DATA_LIST_REQ();
	bool STATIC_CS_KEEP_MAIL_REQ(unsigned char InMailIndex, bool InKeepFlag);
	bool STATIC_CS_JOIN_SPECIAL_WAR_ACK(int InSpecialWarCid, bool InisAccept);
	bool STATIC_CS_V2MISSION_UNREGISTER_FELLOW_REQ(int InLevelTabIndex, int InMissionCID, TEnumAsByte<EV2MissionFellowPosition> InFellowPosition, struct FLONGLONGWrapper* InFellowUniqueID);
	bool STATIC_CS_LOGIN_REQ(struct FString* Inauthkey, struct FString* Inonetimekey);
	bool STATIC_CS_INVITE_GUILD_MEMBER_REQ(struct FString* InPlayerName);
	bool STATIC_CS_REPEAT_MONSTERBOOK_REQ(int InMonsterCid);
	bool STATIC_CS_UPDATE_GUILD_MARK_REQ(struct FGuildMarkData* InGuildMarkData);
	bool STATIC_CS_MPF_ACTIONBAR_DATA_LIST_REQ();
	bool STATIC_CS_CANCEL_ITEM_DESYNTHESIS_CASTING_REP();
	bool STATIC_CS_JOIN_OCCUPATION_WAR_ACK(bool InisAccept);
	bool STATIC_CS_EQUIP_RUNE_ITEM_REQ(int InItemSid, TEnumAsByte<ESocketIndexType> InsocketIndex, int InruneItemSId);
	bool STATIC_CS_DIVIDE_PERSONALINVEN_ITEM_REP(int InItemSid, int InCount);
	bool STATIC_CS_CHALLENGE_TOWER_ENTRANCE_VOLUME_TOUCHED_REP(int InChallengeTowerEntryVolumeCId);
	bool STATIC_CS_WEB_SESSION_REDIRECT_FOR_EXCHANGE_REQ(int InActId, int InItemSid);
	bool STATIC_CS_REGISTER_RECIPE_SLOT_REQ(unsigned char InSlotIndex, int InItemSid);
	bool STATIC_CS_SHOP_CLEARANCE_REQ(TArray<int>* InItemSidList);
	bool STATIC_CS_CANCEL_SWAP_SKILL_DECK_ACTION_REP();
	bool STATIC_CS_VOLUNTARY_ACTION_REQUEST_REP(int InVoluntaryActionCid, bool InIsStart);
	bool STATIC_CS_REFRESH_GUILD_MEMBER_LOCATION_REP();
	bool STATIC_CS_DESIGNATE_SIGN_REP(int InTargetSid, int InSignIdx);
	bool STATIC_CS_RECEIVE_SUB_CRAFT_QUEST_REP();
	bool STATIC_CS_V2MOUNT_MOUNT_REQ(struct FLONGLONGWrapper* Inmount_uid);
	bool STATIC_CS_FIELD_CHANNEL_LIST_REQ();
	bool STATIC_CS_TELEPORT_CUSTOM_WAYPOINT_REP(int InUseItemCid, int InwaypointCId, int IncustomWaypointUniqueID);
	bool STATIC_CS_MAKE_SURE_TO_CUSTOM_REVIVAL_IN_PERSIST_WORLD_ACK(bool InIsConfirm);
	bool STATIC_CS_WEB_SESSION_REDIRECT_REQ(int InActId);
	bool STATIC_CS_PARTY_MEMBER_SUMMON_REQ(int InsummoneeMemberSId);
	bool STATIC_CS_ITEMTRADE_CANCEL_REP();
	bool STATIC_CS_CLEAR_PARTY_EFFECT_LIVING_REQ(int InPartyIndex);
	bool STATIC_CS_SPRINT_START_REQ();
	bool STATIC_CS_REGISTER_DUNGEON_PARTY_MATCHING_REQ(int IndungeonCId);
	bool STATIC_CS_CLOSE_RECIPE_UI_REP();
	bool STATIC_CS_ADD_BLOCK_REQ(struct FString* InignorePlayerName);
	bool STATIC_CS_SELECT_PC_REQ(bool InStartTutorial, struct FString* InPlayerName);
	bool STATIC_CS_ITEMTRADE_ADD_ITEM_REQ(int InItemSid, int InSlotIndex);
	bool STATIC_CS_UPDATE_SUB_CRAFT_TYPE_REQ(TEnumAsByte<EV2SubCraftType> InV2SubCraftType);
	bool STATIC_CS_UPDATE_ENVIRONMENT_BINARY_REP(TArray<struct FPlayerEnvironmentData>* InEnvironmentList);
	bool STATIC_CS_GRANT_GUILD_RP_REQ(struct FString* InGuildName, struct FLONGLONGWrapper* InguildRP);
	bool STATIC_CS_DECIDE_STATS_EQUIP_ITEM_CUSTOM_REQ(int InItemSid, bool InisNew);
	bool STATIC_CS_WHISPER_REP(struct FString* Inreceiver, struct FString* InMessage);
	bool STATIC_CS_BUY_FLASH_SHOP_ITEM_REQ(struct FFlashShopItemData* InItemData);
	bool STATIC_CS_CHANGE_SKILL_TREE_REP(TArray<struct FSkillTreeNodeData>* InSkillTreeNodeList, struct FSkillDeckData* InSkillDeckData);
	bool STATIC_CS_MAKE_SURE_TO_STANDALONE_REVIVAL_IN_PERSIST_WORLD_ACK(bool InNeedFilling, bool InisAccept);
	bool STATIC_CS_LEAVE_GUILD_MEMBER_REQ();
	bool STATIC_CS_ITEMTRADE_START_CHANGE_GOLD_REP();
	bool STATIC_CS_V2MOUNT_UNMOUNT_REQ();
	bool STATIC_CS_PREPARE_SEND_MAIL_REQ();
	bool STATIC_CS_SUMMONEE_ATTACK_REQ(int InSummoneeSid, int InTargetSid);
	bool STATIC_CS_PARTY_MEMBER_SUMMON_SUMMONER_ACK(int InSummoneeSid, bool InisSummon);
	bool STATIC_CS_LEAVE_PARTY_REQ(int InPartyID, TEnumAsByte<EPartyType> InpartyType);
	bool STATIC_CS_SWAP_SKILL_DECK_ACTION_REP(int InSwapSkillDeckIndex);
	bool STATIC_CS_MAKE_RECIPE_REP(int InrecipeCId);
	bool STATIC_CS_SORT_INVENTORY_REQ(TEnumAsByte<ECEInventoryType> InInventoryTab);
	bool STATIC_CS_ASK_GUILD_JOIN_REQUEST_LIST_REQ(int InPage);
	bool STATIC_CS_DISSOLVE_PARTY_REQ(int InPartyID, TEnumAsByte<EPartyType> InpartyType);
	bool STATIC_CS_OCCUPATION_WAR_SCORE_INFO_REQ();
	bool STATIC_CS_UPDATE_MAIN_CRAFT_TYPE_REQ(TEnumAsByte<EV2MainCraftType> InV2MainCraftType);
	bool STATIC_CS_REMOVE_PERSONALINVEN_ITEM_REQ(int InItemSid, struct FLONGLONGWrapper* InCurrentGameGuardStatus);
	bool STATIC_CS_UNREGISTER_DUNGEON_PARTY_MATCHING_REQ(int IndungeonCId);
	bool STATIC_CS_DEL_FRIEND_REQ(struct FLONGLONGWrapper* InfriendUniqueID);
	bool STATIC_CS_REQUEST_WAYPOINT_ROUTE_INFO_REQ(int Inwaypoint_ticket_id, int Inarrived_id);
	bool STATIC_CS_DISBAND_GUILD_REQ();
	bool STATIC_CS_REQUEST_SHOW_COSTUME_CHANGE_REP(int InShowCostume);
	bool STATIC_CS_CHANGE_STANCE_START_REQ();
	bool STATIC_CS_MPF_MERGE_ACTION_REQ(TEnumAsByte<ECECompanionType> InMPFType, TEnumAsByte<ECEMPFActionType> InMPFActionType, struct FLONGLONGWrapper* InTargetMPFUId, TArray<int>* InMaterialItemList);
	bool STATIC_CS_CREATE_GUILD_REQ(struct FString* InGuildName);
	bool STATIC_CS_REFRESH_DUNGEON_PARTY_MATCHING_UI_REQ(int IndungeonCId);
	bool STATIC_CS_REFRESH_RESTRICT_REALM_INFO_REQ();
	bool STATIC_CS_CREATE_GUILD_ACCEPT_LIST_DIALOG_ACK(bool Inresponse);
	bool STATIC_CS_TALK_END_REQ(int InNpcID);
	bool STATIC_CS_SERVER_KICK_OUT_ACK_REP();
	bool STATIC_CS_LOOTING_REQUEST_ITEMLIST_REP(int InSid);
	bool STATIC_CS_INVITE_PARTY_BY_NAME_REP(struct FString* InTargetPlayerName);
	bool STATIC_CS_RAIDFIELD_EXIT_VOLUME_TOUCHED_REP(int InRaidFieldEntryVolumeCId);
	bool STATIC_CS_FIELD_CHANNEL_TRANSFER_REP(int InChannelID);
	bool STATIC_CS_PC_TAKE_OFF_REQ();
	bool STATIC_CS_CHANGE_PC_NAME_REQ(struct FString* InPlayerName, struct FString* InNewPlayerName);
	bool STATIC_CS_SUMMONEE_FOLLOW_REQ(int InSummoneeSid);
	bool STATIC_CS_TAMING_MINIGAME_HIT_REQ();
	bool STATIC_CS_CANCEL_SKILL_ACTION_REQ(int InCid, bool InIsToggle);
	bool STATIC_CS_REQUEST_RETURN_TO_REVIVAL_BASE_POINT_REP(TEnumAsByte<ECERevivalType> InRevivalType);
	bool STATIC_CS_SHOP_BUY_REQ(struct FShopTradeItemData* InItemData);
	bool STATIC_CS_REWARD_WEEKLY_ORDER_GOAL_REQ();
	bool STATIC_CS_SKILL_AUTO_FIRING_CHANGE_REP(int InSkillCid);
	bool STATIC_CS_MODIFY_GUILD_GRADE_NAME_REQ(TEnumAsByte<ECEGuildGradeType> InguildGrade, struct FString* InmodifyName);
	bool STATIC_CS_OPEN_CHARGE_ACTINGPOINT_DIALOG_REQ();
	bool STATIC_CS_CONFIRM_CREATE_GUILD_REQ();
	bool STATIC_CS_RAIDFIELD_ENTRANCE_VOLUME_TOUCHED_REP(int InRaidFieldEntryVolumeCId);
	bool STATIC_CS_UNREGISTER_CUSTOM_WAYPOINT_REQ(int IncustomWaypointUniqueID);
	bool STATIC_CS_ALRIMI_DEL_LIST_REP(TArray<struct FRequestDelAlrimiData>* InAlrimiData);
	bool STATIC_CS_OPEN_RESET_RETURN_TIME_UI_ACK(bool InisAccept);
	bool STATIC_CS_EXIT_COLOSSEUM_REP();
	bool STATIC_CS_REMOVE_ABNORMAL_STATUS_REP(int InCasterSid, int InAbnormalStatusCId);
	bool STATIC_CS_MAKE_V2CRAFT_REQ(int InPropSid, int InCraftCId, int inAmount, bool InuseOptionalItem);
	bool STATIC_CS_KEEP_ALIVE_ACK();
	bool STATIC_CS_ITEMTRADE_INVITE_BY_NAME_REP(struct FString* InTargetName);
	bool STATIC_CS_DECLARE_GUILDWAR_REQ(struct FString* IntargetGuildName);
	bool STATIC_CS_GET_KEEP_MAIL_LIST_REQ(int InPageIndex);
	bool STATIC_CS_FOSTER_GRADEUP_FELLOW_REQ(struct FLONGLONGWrapper* InTargetFellowUniqueID, struct FLONGLONGWrapper* Inoffer_UniqueID, TArray<struct FV2MPFItemData>* Inoffer_MaterialItemList);
	bool STATIC_CS_OUT_OCCUPATION_WAR_REP();
	bool STATIC_CS_UNEQUIP_ALL_RUNE_ITEM_REQ(int InItemSid);
	bool STATIC_CS_SORT_PERSONALINVENTORY_REQ();
	bool STATIC_CS_TAMING_INPUT_RESULT_REP(TArray<int>* InInputResult);
	bool STATIC_CS_OPEN_WAR_UI_REQ();
	bool STATIC_CS_V2MISSION_REGISTER_FELLOW_REQ(int InLevelTabIndex, int InMissionCID, TEnumAsByte<EV2MissionFellowPosition> InFellowPosition, struct FLONGLONGWrapper* InFellowUniqueID);
	bool STATIC_CS_APPLY_INSERT_AUCTION_REQ(TEnumAsByte<EAuctionLeftTimeType> InLeftTime, struct FLONGLONGWrapper* InAuctionPrice);
	bool STATIC_CS_RESERVE_RO_REQ(bool InIsAttacker);
	bool STATIC_CS_REGISTER_SLOT_EQUIP_ITEM_CUSTOM_REQ(int InItemSid);
	bool STATIC_CS_MODIFY_GUILD_NOTICE_REQ(struct FString* Innotice);
	bool STATIC_CS_START_WAYPOINT_WARP_ACK(struct FVector* InGoalLocation);
	bool STATIC_CS_SUMMONEE_MOVE_REQ(int InSummoneeSid, struct FVector* InTargetLocation);
	bool STATIC_CS_REMOVE_ITEM_FOR_SEND_MAIL_REQ(int InItemSid, unsigned char InSlotIndex);
	bool STATIC_CS_UPDATE_SUB_CRAFT_BOOKMARK_REQ(int InCraftCId, bool InbAdd);
	bool STATIC_CS_CANCEL_MOUNT_PREPARE_ACTION_REP();
	bool STATIC_CS_CANCEL_V2CRAFT_REP();
	bool STATIC_CS_REGISTER_SLOT_EQUIP_ITEM_REQ(int InItemSid);
	bool STATIC_CS_SWAP_MPF_ACTIONBAR_SLOT_REQ(int InslotIdx0, int InslotIdx1);
	bool STATIC_CS_CANCEL_NORMAL_ATTACK_ACTION_REP();
	bool STATIC_CS_COMBAT_SKILL_ACTION_REP(int InCid, int InTargetID, bool InExplicitInput, bool InIsStanceSkill, struct FVector* InTargetLocation);
	bool STATIC_CS_MOVE_PERSONALINVEN_TO_INVEN_ITEM_REQ(int InItemSid, int InTargetTabId, int InTargetSlotId);
	bool STATIC_CS_DROP_ITEM_DICE_ROLLING_ACK(int InDropBagOwnerSId, bool InChallenge, int InTicket);
	bool STATIC_CS_DIVIDE_INVEN_ITEM_REP(int InItemSid, int InCount);
	bool STATIC_CS_SUMMONEE_DESPAWN_REQ(int InSummoneeSid);
	bool STATIC_CS_ADD_ITEM_FOR_SEND_MAIL_REQ(int InItemSid, unsigned char InSlotIndex);
	bool STATIC_CS_ALRIMI_DEL_REP(TEnumAsByte<ECEAlrimiType> InAlrimiType, int InfirstKey, int InsecondKey);
	bool STATIC_CS_MAKE_NPC_CRAFT_REQ(int InactorSId, int InCraftCId, int inAmount);
	bool STATIC_CS_CHANGE_PARTY_DISTRIBUTEMETHOD_REQ(int InPartyID, TEnumAsByte<EPartyDistributeMethod> InDistributeMethod, int Indistributor);
	bool STATIC_CS_LEAVE_LOOT_ACTION_REQ(int InTargetSid, int InActionTicket);
	bool STATIC_CS_UNREGISTER_RANDOM_DUNGEON_MATCHING_REQ();
	bool STATIC_CS_UNEQUIP_RUNE_ITEM_REQ(int InItemSid, TEnumAsByte<ESocketIndexType> InsocketIndex);
	bool STATIC_CS_APPLY_PC_ACTION_REP(int InpcActionCid);
	bool STATIC_CS_UNREGISTER_FELLOW_TO_MISSION_REQ(int InMissionCID, struct FLONGLONGWrapper* InFellowUniqueID);
	bool STATIC_CS_CANCEL_WAIT_RO_REQ();
	bool STATIC_CS_GET_QUEST_REQ(int InQuestID);
	bool STATIC_CS_UPDATE_COMBAT_SKILL_TREE_REP(struct FCombatSkillTreeData* InCombatSkillTreeNodeList, struct FSkillDeckData* InSkillDeckData);
	bool STATIC_CS_LOOTING_BUY_ADDITIONAL_ITEM_LIST_REP(int InSid);
	bool STATIC_CS_MPF_SKILL_CHANGE_REQ(TEnumAsByte<ECECompanionGradeType> InMPFGradeType, TEnumAsByte<ECECompanionType> InMPFType, int InSkillChangeItemSId, struct FLONGLONGWrapper* InTargetMPFUId);
	bool STATIC_CS_DISMISS_PET_REP(struct FLONGLONGWrapper* InPetUniqueID);
	bool STATIC_CS_CANCEL_PC_TRACKING_REP();
	bool STATIC_CS_FOSTER_GRADEUP_MOUNT_REQ(struct FLONGLONGWrapper* InTargetMountUniqueID, struct FLONGLONGWrapper* Inoffer_UniqueID, TArray<struct FV2MPFItemData>* Inoffer_MaterialItemList);
	bool STATIC_CS_ITEM_DESYNTHESIS_REQ(int InDesynthesisItem, int InCount);
	bool STATIC_CS_UPDATE_ENVIRONMENT_STRING_REP(struct FString* InEnvironment);
	bool STATIC_CS_REQUEST_ITEM_DATA_REP(int InItemSid);
	bool STATIC_CS_RUNE_CARVE_REQ(int InItemSid, TEnumAsByte<EItemAdditionalEffectIndexType> InitemAdditionalEffectIndexType, int InruneItemSId);
	bool STATIC_CS_RESET_COMBAT_SKILL_TREE_REP(int InTreeIndex);
	bool STATIC_CS_CHANGE_STATE_SHEATHE_REQ(bool InstateSheathe);
	bool STATIC_CS_MOUNT_ACTIVE_SKILL_ACTION_REQUEST_REP(int InmountActiveSkillCId);
	bool STATIC_CS_ASK_GUILD_HISTORY_REQ(int InPage);
	bool STATIC_CS_CANCEL_NPC_CRAFT_REP();
	bool STATIC_CS_START_MISSION_REQ(int InMissionCID);
	bool STATIC_CS_UPDATE_MPF_ACTIONBAR_SLOT_REQ(int InslotIdx, TEnumAsByte<EMPFActionBarSlotType> InActionBarSlotType, struct FLONGLONGWrapper* InActionBarId);
	bool STATIC_CS_INVITE_PARTY_REQ(int InsidInvitee);
	bool STATIC_CS_CONFIRM_REGISTER_COLOSSEUM_REQ(int InColosseum_cid, bool Inconfirm);
	bool STATIC_CS_CHECK_MAIL_RECEIVER_REQ(struct FString* InReceiverName);
	bool STATIC_CS_CHANGE_PARTY_TO_RAID_REQ(int InPartyID, TEnumAsByte<EPartyType> InpartyType);
	bool STATIC_CS_UPDATE_PARTY_MATCHING_POSITION_REQ(TEnumAsByte<EPartyMatchingPositionType> InPosition);
	bool STATIC_CS_MOVE_PARTY_MEMBER_REQ(int InsidTarget, int Infrom, int Into);
	bool STATIC_CS_APPLY_SEND_MAIL_REQ(TEnumAsByte<EMailReceiverType> InMailReceiverType, TEnumAsByte<ECEWorldMapType> InWorldType, int InWorldWrapperCId, struct FString* InReceiverName, struct FString* InTitle, struct FString* InContent, struct FLONGLONGWrapper* InGold, struct FVector* InLocation);
	bool STATIC_CS_DEL_BLOCK_REQ(struct FString* InignorePlayerName);
	bool STATIC_CS_REGISTER_PARTY_MATCHING_REQ(TEnumAsByte<ECEWorldMapType> InWorldMapType, int InworldMapWrapperCId, TArray<struct FPartyMatchingPositionInfoData>* InMemberPositionInfo);
	bool STATIC_CS_CANCEL_ITEM_UPGRADE_LEVEL_CASTING_REP();
	bool STATIC_CS_UPDATE_FRIEND_LIST_REQ();
	bool STATIC_CS_SET_DUNGEON_ENTRANCE_REQ(struct FDungeonEntranceData* IndungeonEntranceData);
	bool STATIC_CS_REWARD_MONSTERBOOK_REQ(int InMonsterCid, int InStageIndex);
	bool STATIC_CS_GEM_EXCHANGE_REQ(int InGemPieceCount);
	bool STATIC_CS_PAYMENT_STATS_EQUIP_ITEM_CUSTOM_REQ(int InItemSid, TEnumAsByte<EPaymentType> InpaymentType);
	bool STATIC_CS_ALRIMI_ADD_LIST_REP(TArray<struct FRequestAddAlrimiData>* InAlrimiData);
	bool STATIC_CS_SURRENDER_GUILDWAR_REQ();
	bool STATIC_CS_OPEN_PARTY_MATCHING_UI_REQ();
	bool STATIC_CS_DUNGEON_EXIT_VOLUME_TOUCHED_REP(int InDungeonExitVolumeCid);
	bool STATIC_CS_TOUCH_DOOR_REP(int Indoor_sid, bool Inis_touch);
	bool STATIC_CS_NOTIFY_LOCATION_CHANGED_REP(int InCurrentLocationCId);
	bool STATIC_CS_KICK_PARTY_MEMBER_REQ(int InsidTarget);
	bool STATIC_CS_UNREGISTER_PARTY_MATCHING_REQ();
	bool STATIC_CS_OPEN_GRANT_GUILD_RP_DIALOG_REQ();
	bool STATIC_CS_DELETE_ENVIRONMENT_BINARY_REP(TArray<struct FPlayerEnvironmentData>* InEnvironmentList);
	bool STATIC_CS_SHOW_CHALLENGE_TOWER_RANK_INFO_REQ(int InPageIndex);
	bool STATIC_CS_OPEN_EXCHANGE_CONTENT_TOKEN_UI_REQ();
	bool STATIC_CS_CLEAR_PARTY_EFFECT_COMBAT_REQ(int InPartyIndex);
	bool STATIC_CS_TIME_REQ(int InKey, const struct FDouble& inTime);
	bool STATIC_CS_GAMEGUARD_AUTHENTICATION_CHECK_ACK(TArray<unsigned char>* InAuthenticationData);
	bool STATIC_CS_PING_REQ(struct FULONGLONGWrapper* InClientTime, struct FULONGLONGWrapper* InKnownServerTime, struct FULONGLONGWrapper* InRTTEstimation);
	bool STATIC_CS_REPAIR_DURABILITY_BY_NPC_REQ(TArray<int>* InRepairItemSidList);
	bool STATIC_CS_RO_ATTEND_INFO_REQ();
	bool STATIC_CS_OCCUPATIONWAR_SPRITMOVE_TO_STARTBASE_REP();
	bool STATIC_CS_V2MISSION_SWAP_FELLOW_REQ(int InLevelTabIndex, int InSourMissionCId, int InDestMissionCId, struct FV2MissionFellowData* InSourFellow, struct FV2MissionFellowData* InDestFellow);
	bool STATIC_CS_CINEMATIC_STOPPED_REP(int Incinematic_id);
	bool STATIC_CS_CHANGE_SIGN_AUTHORITY_REP(bool InPermit);
	bool STATIC_CS_REPLY_DUEL_ACK(bool InisAccept, struct FString* IninvitorName);
	bool STATIC_CS_CANCEL_WAIT_SPECIAL_WAR_REQ(int InSpecialWarCid);
	bool STATIC_CS_CHANGE_GUILD_NAME_REQ(struct FString* InGuildName);
	bool STATIC_CS_TAMING_CANCEL_REP();
	bool STATIC_CS_RELEASE_ALL_SIGN_REP();
	bool STATIC_CS_MPF_EXTRACTION_REQ(TEnumAsByte<ECECompanionType> InMPFType, int InCapsuleItemSId, struct FLONGLONGWrapper* InTargetMPFUId);
	bool STATIC_CS_SPECIAL_WAR_LOG_INFO_REQ(int InSpecialWarCid);
	bool STATIC_CS_V2MISSION_START_REQ(int InLevelTabIndex);
	bool STATIC_CS_CONFIRM_JOIN_GUILD_REQ();
	bool STATIC_CS_ITEM_EVOLUTION_REQ(int InEvolutionItemSid, int InResourceItemCid);
	bool STATIC_CS_CHALLENGE_TOWER_EXIT_VOLUME_TOUCHED_REP(int InChallengeTowerEntryVolumeCId);
	bool STATIC_CS_CREATE_GUILD_ACCEPT_DIALOG_ACK(int InRequesterSid, bool Inresponse);
	bool STATIC_CS_REQUEST_DUNGEON_INITIALIZE_REP();
	bool STATIC_CS_FOSTER_EXPUP_MOUNT_REQ(struct FLONGLONGWrapper* InTargetMountUniqueID, TArray<struct FLONGLONGWrapper>* Inoffer_UniqueIDList, TArray<struct FV2MPFItemData>* Inoffer_MaterialItemList);
	bool STATIC_CS_SHOP_SELL_REQ(int InItemSid, struct FLONGLONGWrapper* InCurrentGameGuardStatus);
	bool STATIC_CS_REWARD_ORDER_REQ(int InOrderCid);
	bool STATIC_CS_AUTOLOOTING_REQUEST_REP(TArray<int>* InLootingNPCSIdList);
	bool STATIC_CS_GET_TUTORIAL_ORDER_REQ(int IntutorialOrderCid);
	bool STATIC_CS_DUNGEON_ENTRANCE_VOLUME_TOUCHED_REP(int InDungeonEntranceVolumeCid);
	bool STATIC_CS_GET_AUCTION_LIST_REQ(int InPageIndex, struct FAuctionSearchData* InAuctionSearchData);
	bool STATIC_CS_BATTLEYE_DATA_CHECK_ACK(TArray<unsigned char>* InBattlEyeData);
	bool STATIC_CS_REPLY_DUNGEON_ENDURE_STAGE_SKIP_CONFIRM_REP(int IndungeonCId, bool Inaccept);
	bool STATIC_CS_REQUEST_DUEL_REQ(int IninviteeSid);
	bool STATIC_CS_GET_MAIL_LIST_REQ(int InPageIndex);
	bool STATIC_CS_REFRESH_MISSION_REQ();
	bool STATIC_CS_GM_COMMAND_REP(struct FString* Incommand);
	bool STATIC_CS_NOTIFY_WARP_FINISHED_REQ();
	bool STATIC_CS_PARTY_INVITATION_ACK(int InsidInvitor, bool Inresponse, TEnumAsByte<EPartyType> InpartyType);
	bool STATIC_CS_START_WAYPOINT_REQ(int Inwaypoint_ticket_id, int Ingoal_id, struct FLONGLONGWrapper* InCurrentGameGuardStatus);
	bool STATIC_CS_SHOP_REPURCHASE_REQ(struct FShopTradeItemData* InItemData);
	bool STATIC_CS_INVITE_PARTY_CANCLE_REQ(int InsidInvitee);
	bool STATIC_CS_FOSTER_GRADEUP_PET_REQ(struct FLONGLONGWrapper* InTargetPetUniqueID, struct FLONGLONGWrapper* Inoffer_UniqueID, TArray<struct FV2MPFItemData>* Inoffer_MaterialItemList);
	bool STATIC_CS_LOOK_CHANGE_ENTER_REQ(bool InIsEnterLookChangeMode, struct FString* InPlayerName);
	bool STATIC_CS_RELEASE_SIGN_REP(int InSignIdx);
	bool STATIC_CS_THROW_DICE_REP(int InRange);
	bool STATIC_CS_AUTO_TARGETING_ON_REP(int InPawnSID, bool Infriendly);
	bool STATIC_CS_CLOSE_EQUIP_ITEM_CUSTOM_UI_REP();
	bool STATIC_CS_XIGNCODE_DATA_CHECK_ACK(TArray<unsigned char>* InXignCodeData);
	bool STATIC_CS_DELETE_MAIL_REQ(unsigned char InMailIndex);
	bool STATIC_CS_EXCHANGE_CONTENT_TOKEN_TO_LUMENA_REQ(struct FContentTokenData* IncontentTokenData);
	bool STATIC_CS_CLOSE_TELEPORT_CUSTOM_WAYPOINT_UI_REP();
	bool STATIC_CS_SUMMONEE_SKILL_REQ(int InSummoneeSid, int InTargetSid, int InSkillCid, struct FVector* InTargetLocation);
	bool STATIC_CS_ADD_GUILD_GRADE_REQ();
	bool STATIC_CS_MOVE_INVEN_ITEM_REQ(int InItemSid, int InTargetTabId, int InTargetSlotId);
	bool STATIC_CS_DROP_QUEST_REQ(int InQuestID);
	bool STATIC_CS_UPDATE_MAIN_CRAFT_BOOKMARK_REQ(int InCraftCId, bool InbAdd);
	bool STATIC_CS_GET_SEND_MAIL_LIST_REQ(int InPageIndex);
	bool STATIC_CS_REQUEST_SOCIAL_ACTION_REP(int InCidSocialAction);
	bool STATIC_CS_COMMON_WAR_JOIN_REQ(int InWarCid, TEnumAsByte<ECEWorldMapType> InWorldType);
	bool STATIC_CS_MPF_HATCH_ANIMA_REQ(int InAnimaItemSId, int InItemCount);
	bool STATIC_CS_PAYMENT_LEGEND_OPT_EQUIP_ITEM_CUSTOM_REQ(int InItemSid);
	bool STATIC_CS_LOOTING_REQUEST_CLOSEWINDOW_REQ(int InSid);
	bool STATIC_CS_SPRINT_END_REP();
	bool STATIC_CS_OUT_SPECIAL_WAR_REQ(int InSpecialWarCid);
	bool STATIC_CS_MOVE_TO_LOCATION_ACK_REP(TEnumAsByte<EMoveToAckReason> InReason, int InActionTicket);
	bool STATIC_CS_PROMOTE_PARTY_LEADER_REQ(int InsidTarget);
	bool STATIC_CS_CANCEL_SEND_MAIL_REQ();
	bool STATIC_CS_CANCEL_ITEM_EVOLUTION_CASTING_REP();
	bool STATIC_CS_MOVE_PERSONALINVEN_ITEM_REQ(int InItemSid, int InTargetTabId, int InTargetSlotId);
	bool STATIC_CS_APPLY_PARTY_EFFECT_COMBAT_REQ(int InPartyIndex, int InPartyEffectCombatCId);
	bool STATIC_CS_ENTER_WORLD_REQ(struct FLONGLONGWrapper* InCurrentGameGuardStatus);
	bool STATIC_CS_MOUNT_ACTIVE_SKILL_ACTION_REQUEST_END_REP(int InmountActiveSkillCId);
	bool STATIC_CS_REWARD_TUTORIAL_ORDER_REQ(int IntutorialOrderCid);
	bool STATIC_CS_REGISTER_FELLOW_TO_MISSION_REQ(int InMissionCID, struct FLONGLONGWrapper* InFellowUniqueID);
	bool STATIC_CS_ITEMTRADE_REMOVE_ITEM_REP(int InItemSid);
	bool STATIC_CS_REPLY_DELEGATION_GUILD_LEADER_ACK(bool InisAccept);
	bool STATIC_CS_CITADEL_OWNERSHIP_UI_CLOSE_REP();
	bool STATIC_CS_BURDEN_DROP_REQ_REP();
	bool STATIC_CS_HANDLE_GUILD_JOIN_REQUEST_REQ(bool InisRecognition, struct FString* InPlayerName);
	bool STATIC_CS_REQUEST_DELEGATION_GUILD_LEADER_REQ(struct FString* InnewLeaderName);
	bool STATIC_CS_SUMMONEE_USE_ENERGY_SPHERE_REQ(int InSummoneeSid, int InUse);
	bool STATIC_CS_MODIFY_GUILD_GRADE_PRIORITY_REQ(TEnumAsByte<ECEGuildGradeType> InguildGrade, bool InisUP);
	bool STATIC_CS_BUY_AUCTION_REQ(TArray<unsigned char>* InAuctionIndexList);
	bool STATIC_CS_RESET_SKILL_TREE_REP(int InSkillTreePage);
	bool STATIC_CS_SKILL_ACTION_REP(int InCid, int InTargetID, bool InExplicitInput, struct FVector* InTargetLocation);
	bool STATIC_CS_SPECIAL_WAR_INFO_REQ(int InSpecialWarCid);
	bool STATIC_CS_IN_GAME_HELP_SEEN_REP(int IninGameHelpCid);
	bool STATIC_CS_FOSTER_EXPUP_PET_REQ(struct FLONGLONGWrapper* InTargetPetUniqueID, TArray<struct FLONGLONGWrapper>* Inoffer_UniqueIDList, TArray<struct FV2MPFItemData>* Inoffer_MaterialItemList);
	bool STATIC_CS_MODIFY_SKILL_DECK_REQ(struct FSkillDeckData* InSkillDeckData);
	bool STATIC_CS_MODIFY_GUILD_MEMBER_GRADE_REQ(TEnumAsByte<ECEGuildGradeType> InmodifyGuildGrade, struct FString* InMemberName);
	bool STATIC_CS_REGISTER_RANDOM_DUNGEON_MATCHING_REQ(struct FPartyMatchingPositionInfoData* InPositionInfo);
	bool STATIC_CS_CLOSE_RUNE_SYSTEM_UI_REP();
	bool STATIC_CS_FOSTER_EXPUP_FELLOW_REQ(struct FLONGLONGWrapper* InTargetFellowUniqueID, TArray<struct FLONGLONGWrapper>* Inoffer_UniqueIDList, TArray<struct FV2MPFItemData>* Inoffer_MaterialItemList);
	bool STATIC_CS_EQUIP_INVEN_ITEM_REQ(int InItemSid, TEnumAsByte<ECEEquipSlotType> InequipSlot);
	bool STATIC_CS_CLIENT_EXIT_REP();
	bool STATIC_CS_MOVE_TO_TARGET_ACK_REP(int InTargetID, TEnumAsByte<EMoveToAckReason> InReason, int InActionTicket);
	bool STATIC_CS_ACTION_REP(int InTargetID, bool InTrackingHold);
	bool STATIC_CS_REQUEST_SUMMON_PET_REP(struct FLONGLONGWrapper* InPetUniqueID);
	bool STATIC_CS_OPEN_DUNGEON_PARTY_MATCHING_UI_REQ(int IndungeonCId);
	bool STATIC_CS_SERVER_MOVE_REP(struct FMoveRepInfo* InMoveInfo);
	bool STATIC_CS_UPGRADE_POTENTIAL_LEVEL_REQ(int InItemSid);
	bool STATIC_CS_ITEMTRADE_APPROVE_REP();
	bool STATIC_CS_TAKEOFF_SLOT_ITEM_REQ(TEnumAsByte<ECEEquipSlotType> InSlotId, int InTargetTabId, int InTargetSlotId);
	bool STATIC_CS_REMOVE_INVEN_ITEM_REQ(int InItemSid, struct FLONGLONGWrapper* InCurrentGameGuardStatus);
	bool STATIC_CS_CHAT_REP(TEnumAsByte<EChatChannel> Inchannel, struct FString* InMessage);
	bool STATIC_CS_RECEIVE_MAIN_CRAFT_QUEST_REP();
	bool STATIC_CS_BUY_CRAFT_RECIPE_REQ(int IncraftRecipeCId);
	bool STATIC_CS_MOVE_INVEN_TO_PERSONALINVEN_ITEM_REQ(int InItemSid, int InTargetTabId, int InTargetSlotId);
	bool STATIC_CS_CHECK_GUILD_NAME_REQ(struct FString* InGuildName);
	bool STATIC_CS_SURROUNDING_WORLD_ENVIRONMENT_REQ();
	bool STATIC_CS_REWARD_DAILY_ORDER_GOAL_REQ();
	bool STATIC_CS_DISJOINT_POTENTIAL_EQUIP_ITEM_CUSTOM_REQ(int InItemSid);
	bool STATIC_CS_REGISTER_SLOT_RUNE_SYSTEM_REQ(int InItemSid);
	bool STATIC_CS_MODIFY_GUILD_GRADE_AUTHORITY_REQ(TEnumAsByte<ECEGuildGradeType> InguildGrade, int InmodifyAuthority);
	bool STATIC_CS_FALLING_ESCAPE_REQ(bool InIsCheckCoolTime);
	bool STATIC_CS_TALK_CHOOSE_SELECTION_REQ(int InNpcID, int InIndex, int InselectiveRewardIndex);
	bool STATIC_CS_ITEM_SUCCEED_REQ(int InSucceedItemSid, int InResourceItemSid, int InPerfectItemCid, int InKeepItemCid);
	bool STATIC_CS_LOGOFF_REQ(TEnumAsByte<EDisconnectReason> InReason);
	bool STATIC_CS_OPEN_UI_EXCHANGE_CONTENT_TOKEN_TO_LUMENA_REQ();
	bool STATIC_CS_REMOVE_GUILD_GRADE_REQ(TEnumAsByte<ECEGuildGradeType> InguildGrade);
	bool STATIC_CS_CHARGE_ACTINGPOINT_REQ(bool InAcceptCharge);
	bool STATIC_CS_REMOVE_PC_REQ(struct FString* InRemovePCName);
	bool STATIC_CS_USE_INVEN_ITEM_REP(int InItemSid, int InTargetSid);
	bool STATIC_CS_DELETE_AUCTION_REQ(TArray<unsigned char>* InAuctionIndex);
	bool STATIC_CS_CANCEL_CRAFT_REP();
	bool STATIC_CS_CANCEL_RECIPE_CASTING_ACTION_REP();
	bool STATIC_CS_GUILD_INVITATION_ACK(int IninvitorSId, bool Inresponse);
	bool STATIC_CS_MPF_LOCK_REQ(TEnumAsByte<ECECompanionType> InMPFType, bool InIsLock, struct FLONGLONGWrapper* InMPFUid);
	bool STATIC_CS_OUT_RO_REP(TEnumAsByte<ECERealmType> InRealmType);
	bool STATIC_CS_ITEMTRADE_INVITED_ACK(bool Inaccept, int InRequesterSid);
	bool STATIC_CS_GET_RECENT_AUCTION_LIST_REQ(int InItemCid);
	bool STATIC_CS_VERSION_ACK(int InSDLTypeVersion, int InProtocolVersion);
};


// Class BLGame.NETHandler
// 0x0000 (0x0060 - 0x0060)
class UNETHandler : public UObject
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.NETHandler");
		return ptr;
	}


	void SC_SPRINT_END_REP();
	void SC_REMOVE_FELLOW_REP(const struct FQWord& InFellowUid);
	void SC_MAKE_CRAFT_ACK(bool InbSuccess);
	void SC_WITHDRAW_MAIL_ACK(TEnumAsByte<EMailErrorCode> InErrCode, unsigned char InMailIndex);
	void SC_SKILL_ACTION_LAUNCHED_REP(int InCasterSid, int InSkillCid, int InTargetSid, int InPrepareTimeInMilliSeconds, struct FVector* InTargetLocation, struct FVector* InLocation, struct FRotator* InRotation);
	void SC_PC_TAKE_DOWN_ACK();
	void SC_PC_TAKE_DOWN_ACK_FAILED(int InErrorCode);
	void SC_UPDATE_PARTYMEMBER_ABNORMAL_STATUS_REP(int InPartyMemberSid, struct FAbnormalStatusData* InData);
	void SC_REPAIR_MAX_DURABILITY_BY_NPC_ACK(bool InIsSuccess);
	void SC_UPDATE_SP_LEVEL_REP(int InSPLevel);
	void SC_UPDATE_LUMENA_SHOP_ITEM_LIST_REP(TArray<struct FLumenaShopItemData>* InItemData);
	void SC_PREPARE_INSERT_AUCTION_ACK(TEnumAsByte<EAuctionErrorCode> InErrCode, TArray<int>* InLockItemSidList);
	void SC_SWAP_SKILL_DECK_ACTION_CASTING_REP(int InCasterSid, int InSwapSkillDeckIndex, int InSwapCastingSeconds, struct FString* InSwapSkillDeckName);
	void SC_SPAWN_SPECIAL_WAR_NPC_REP(bool InIsSpawn, struct FSpecialWarNPCData* InNPCData);
	void SC_CHANGE_TARGET_OF_TARGET_REP(int InsidTarget, int InsidTargetOfTarget);
	void SC_SUMMONEE_ENERGY_SPHERE_POINT_REP(int InOwnerSid, int InSummoneeSid, int InPoint);
	void SC_LOOK_CHANGE_ACK(TArray<struct FSelectPCData>* InPCDataList, struct FString* InPlayerName);
	void SC_LOOK_CHANGE_ACK_FAILED(int InErrorCode);
	void SC_V2MISSION_LIST_REP(int InUnlockedMissionLevel, TArray<struct FV2MissionLevelTabInfo>* InMissionTabList, TArray<struct FV2MissionData>* InMissionList);
	void SC_SPECIAL_WAR_ATTACK_ALERT_REP(bool InIsOn, struct FSpecialWarAttackAlertData* InNPCData);
	void SC_POSE_ACTION_ACK(TEnumAsByte<ECEStatePoseType> InStatePose, bool InStandingForce, bool InSuccess);
	void SC_APPLY_PARTY_EFFECT_LIVING_ACK(int InErrCode, int InPartyIndex, int InPartyEffectLivingCId);
	void SC_BURDEN_DROP_REP(int IncarryPlayerSid, int InburdenCid, bool InDropByClientRequest);
	void SC_REWARD_QUEST_ACK(int InQuestID);
	void SC_REWARD_QUEST_ACK_FAILED(int InErrorCode, int InQuestID);
	void SC_START_CHALLENGE_TOWER_REP();
	void SC_INITIAL_CITADEL_OWNER_GUILD_DATA_LIST_REP(TArray<struct FCitadelOwnerGuildData>* IncitadelOwnerGuildData);
	void SC_REVIVAL_WAITING_TIME_REP(int InPawnSID, TEnumAsByte<ECERevivalType> InRevivalType, int InWaitingTimeInMilliseconds);
	void SC_UPDATE_CROWD_CONTROL_STATE_REP(int InSid, bool InisApplied, TArray<struct FCrowdControlComponentData>* IncomponentArray);
	void SC_SHOW_WAYPOINT_UI_REP(int Inwaypoint_ticket_id, int Indeparture_id, TArray<int>* Inavailable_id_list, TArray<struct FWaypointRouteInfo>* Inroute_info);
	void SC_CITADEL_OWNERSHIP_AUCTION_BID_ACK(int InCitadelCid, int InmyBidCP);
	void SC_CITADEL_OWNERSHIP_AUCTION_BID_ACK_FAILED(int InErrorCode);
	void SC_SUMMONEE_CHANGE_STANCE_ACK(int InSummoneeSid, TEnumAsByte<ESummoneeStance> Instance, TEnumAsByte<ESummoneeResult> InresultCode);
	void SC_SET_SKILL_STACK_COUNT_REP(int InSkillCid, int InStackCount);
	void SC_USE_ITEM_RESULT_REP(TEnumAsByte<EItemUseErrorCode> InErrorCode, int InItemSid, int InItemCid);
	void SC_SELECT_PC_DATA_LIST_ACK(int InCharacterSlotExpansionCount, TArray<struct FSelectPCData>* InSelectPCDataArray);
	void SC_SELECT_PC_DATA_LIST_ACK_FAILED(int InErrorCode);
	void SC_UPDATE_ABNORMAL_STATUS_DURATION_REP(int InSidRPC, struct FAbnormalStatusDurationData* InData);
	void SC_INSIGHT_PROP_REP(struct FPropData* InPropData);
	void SC_TELEPORT_PARTY_MATCHING_ACK(TEnumAsByte<ECEWorldMapType> InWorldMapType, int InworldMapWrapperCId, bool InIsSuccess);
	void SC_CANCELED_SWAP_SKILL_DECK_ACTION_REP(int InCasterSid);
	void SC_POSE_ACTION_REP(int InSid, TEnumAsByte<ECEStatePoseType> InStatePose, bool InStandingForce);
	void SC_ATTACK_ACTION_APPLY_REP(int InAttackerSId, int InTargetSid, TEnumAsByte<ECEAttackChanceType> InAttackChance, int InDamage, int InApplyMomentInMilliSeconds);
	void SC_REGISTER_LIMITED_RANK_REQ();
	void SC_INTERACTION_POSSIBILITY_REP(int InSidProp, bool InIsPossible);
	void SC_ITEM_UPGRADE_LEVEL_ACK(bool InIsSuccess, int InUpgradeItem);
	void SC_CITADEL_OWNERSHIP_INFO_REP(const struct FQWord& InexpireRemainTime, TArray<struct FCitadelOwnershipInfoData>* IncitadelOwnershipInfoDataArray);
	void SC_CANCEL_INSERT_AUCTION_ACK(TEnumAsByte<EAuctionErrorCode> InErrCode);
	void SC_BUY_LUMENA_SHOP_ITEM_ACK(bool InbSuccess);
	void SC_SKILL_ENDED_NORMALLY_REP(int InCasterSid, int InSkill_Id);
	void SC_BURDEN_CARRY_END_REP(int IncarryPlayerSid, int InburdenCid);
	void SC_UPDATE_TUTORIAL_ORDER_STAGE_REP(int InstageCid);
	void SC_UPDATE_ENEMY_LIST_REP(TArray<int>* InEnemyList);
	void SC_MPF_ALL_SKILL_CHANGE_ACK(bool InbSuccess, const struct FQWord& InMPUId, int InChangeRareSkillCId, int InChangeEpicSkillCId, int InChangeLegendarySkillCId);
	void SC_ASK_DELEGATION_GUILD_LEADER_ACK(TEnumAsByte<EGuildErrorCode> InErrCode, struct FString* InnewLeaderName);
	void SC_GET_MY_AUCTION_LIST_ACK(int InPageIndex, int InMaxAuctionCount, TArray<struct FAuctionData>* InAuctionDataList);
	void SC_UPDATE_VIPLEVEL_REP(int InvipLevel, const struct FQWord& InvipExpireTime);
	void SC_READ_MAIL_ACK(TEnumAsByte<EMailErrorCode> InErrCode, unsigned char InMailIndex);
	void SC_ITEMTRADE_FAIL_REP(TEnumAsByte<EItemTradeErrorCode> InErrorCode);
	void SC_REQUEST_COMPLETE_EPISODE_LIST_ACK(int InLocationCid, TArray<int>* InCompleteEpisodeCid);
	void SC_CHANGE_STANCE_COMPLETE_REP(bool InIsSuccess, int InCurrentStanceCId, int InCandidateStanceCId, const struct FQWord& InSwapCoolTimeTick);
	void SC_ABNORMAL_STATUS_EFFECT_HIT_REP(int InSid, struct FAbnormalStatusEffectResult* InResult);
	void SC_RESPONSE_ITEM_DATA_REP(bool InSuccess, int InItemSid, struct FItemData* InItemData);
	void SC_UPDATE_DAUNGEON_LIMIT_COUNT_REP(TArray<struct FDungeonLimitedCountInfoData>* InDungoenLimitedInfo);
	void SC_UPDATE_PERSONALINVEN_ITEM_DATA_LIST_REP(TArray<struct FInventoryItemData>* InupdatedItemDataList);
	void SC_OPEN_EXCHANGE_UI_REP();
	void SC_UPDATE_OCCUPATION_WAR_REALM_PROP_REP(int InHieronPropCount, int InUnionPropCount);
	void SC_PARTY_MEMBER_POS_REP(int InPartyID, TArray<struct FPartyMemberPosData>* InPosDataList);
	void SC_BACK_SERVER_CHOICE_ACK(struct FString* Inonetimekey);
	void SC_BACK_SERVER_CHOICE_ACK_FAILED(int InErrorCode);
	void SC_REGISTER_CUSTOM_REVIVAL_REP(struct FCustomRevivalData* IncustomRevival);
	void SC_UPDATE_MPF_DATA_ACK(TArray<struct FV2MPFFatigue_N_ExpData>* InUpdateResponseLIst);
	void SC_UPDATE_COLOSSEUM_WAITCOUNT_REP(int InColosseum_cid, int Inwait_count);
	void SC_INSIGHT_ROGUILD_STATUE_REP(struct FROGuildStatueData* InROGuildStatueData);
	void SC_NOTIFY_GUILDWAR_DEATH_POINT_REP(int InDeathPoint);
	void SC_POSE_ACTION_CANCELED_REP(int InSid, TEnumAsByte<ECEStatePoseType> InStatePose);
	void SC_START_PC_TRACKING_REP(int InTargetSid, float InDistance, struct FVector* InTargetLocation);
	void SC_LOOTING_NOTIFY_EFFECTINFO_REP(int InServerId, TEnumAsByte<ECEItemGradeType> InLootableHighestGrade);
	void SC_CREATE_PC_ACK(bool InCanDirectEnterWorld, bool InCanDirectTutorial, TArray<struct FSelectPCData>* InPCDataList);
	void SC_CREATE_PC_ACK_FAILED(int InErrorCode, struct FString* InForbidString);
	void SC_V2MOUNT_PREPARE_ACTION_CASTING_REP(int InCasterSid, int InMountCid, int InCastingTime);
	void SC_UPDATE_MAIN_CRAFT_TYPE_REP(TEnumAsByte<EV2MainCraftType> InV2MainCraftType, int InLevel, int InExp);
	void SC_ITEMTRADE_INVITE_ACK(TEnumAsByte<EItemTradeErrorCode> InErrorCode, int InTargetSid);
	void SC_WAR_MATCHING_UNREGIST_REP();
	void SC_INSTANT_FIELD_STAGE_CHANGED_REP(int InplayerSId, int InInstantFieldCid);
	void SC_RESTART_ACK();
	void SC_RESTART_ACK_FAILED(int InErrorCode);
	void SC_APPLY_PARTY_EFFECT_LIVING_LIST_REP(TArray<struct FApplyPartyEffectInfo>* InApplyPartyEffectInfoList);
	void SC_OPEN_BUY_CRAFT_RECIPE_SMITH_UI_REP();
	void SC_ADD_ORDER_REP(TArray<struct FOrderProgressInfo>* InorderProgressInfoList);
	void SC_CLEAR_RIOT_CONTROL_STATE_REP(int InSid);
	void SC_NOTIFY_ITEM_BROADWAY_REP(int InCasterSid, int InSkillCid, bool InIsShowNextBroadWay);
	void SC_OUTOFSIGHT_PLACEABLE_OBJECT_VISION_SHARED_REP(int InPlaceableObjectSid);
	void SC_RO_TIME_REP(TEnumAsByte<EROStateType> InroState, int InRemainSeconds);
	void SC_UPDATE_GUILD_MEMBER_REP(struct FGuildMemberData* InguildMemberData);
	void SC_COMPLETE_TUTORIAL_REP();
	void SC_UNREGISTER_CUSTOM_REVIVAL_REP(int IncustomRevivalSid);
	void SC_UPDATE_PROP_VISIBLE_REP(int InPropSid, bool InIsVisible);
	void SC_PC_TAKE_OFF_REP(int InDriverSid);
	void SC_CHANGE_SKILL_TREE_RESULT_REP(TEnumAsByte<ESkillTreeErrorCode> InErrorCode);
	void SC_POSSIBLE_TELEPORT_PARTY_MATCHING_REP(TEnumAsByte<ECEWorldMapType> InWorldMapType, int InworldMapWrapperCId, bool InIsOpenUI);
	void SC_INVENTORY_EXPANSION_RESULT_REP(TEnumAsByte<EInventoryExpansionErrorCode> InErrCode, int InInventory_Expansion_Slot_Count);
	void SC_EXCHANGE_CONTENT_TOKEN_ACK(TEnumAsByte<EContentTokenExchangeErrorCode> InErrCode);
	void SC_PASSIVE_INVOKE_SKILL_TARGET_LIST_REP(int InCasterSid, int InSkillCid, int InSkillResultTicket, TArray<struct FSkillResultTargetInfo>* InTargetInfos);
	void SC_REMOVE_GUILD_MEMBER_ACK(TEnumAsByte<EGuildErrorCode> InErrCode);
	void SC_RESTART_QUEST_ACK(int InQuestID, struct FQuestProgressInfo* InquestInfo);
	void SC_RESTART_QUEST_ACK_FAILED(int InErrorCode, int InQuestID);
	void SC_MY_WHISPER_RESULT_REP(struct FChatData* InchatData);
	void SC_FIELD_CHANNEL_NOTIFY_REP(int InChannelID);
	void SC_SERVERPING_REQ(const struct FQWord& InServerTime);
	void SC_SHOW_CREATE_GUILD_UI_REP(int InNpcSid, int InCondition);
	void SC_DROPITEMBAG_CHOOOSE_ACQUIRER_REQ(int InItemBagID, int InItemID, int InCount, TArray<int>* InvalidAcquirerList);
	void SC_RESULT_ITEM_EVOLUTION_REP(TEnumAsByte<EItemEvolutionResultType> InResult, int InEvoutionItemSid);
	void SC_V2MISSION_REWARD_ACK(int InLevelTabIndex, TEnumAsByte<EMissionErrorCode> InErrCode);
	void SC_ADD_FRIEND_ACK(struct FFriendData* InfriendData);
	void SC_ADD_FRIEND_ACK_FAILED(int InErrorCode);
	void SC_SPAWN_WAR_PROP_REP(TArray<struct FWarNPCNPropData>* InPropData);
	void SC_TALK_START_REP(int InNpcID, int InsecondaryNpcId, struct FTalkDialogInfo* InDialogInfo);
	void SC_CHANGE_TARGET_ACK(bool InbSuccess, int InTargetID);
	void SC_REWARD_MISSION_ACK(int InMissionCID, TEnumAsByte<EMissionErrorCode> InErrCode);
	void SC_UPDATE_PARAM_STATE_REP(int InSid, TEnumAsByte<EParamStatusUpdateType> InType, int InValue);
	void SC_PARTY_MEMBER_SUMMON_SUMMONEE_REQ(int InSummonerSid, int InLocationCid);
	void SC_EXPIRE_DUNGEON_TIMER_REP();
	void SC_UPDATE_ACTIONBAR_SLOT_ACK(struct FActionBarData* InupdatedActionBar);
	void SC_UPDATE_ACTIONBAR_SLOT_ACK_FAILED(int InErrorCode);
	void SC_PET_MOVE_REP(int InPetSId, float InSpeed, bool InIsMoving, struct FVector* InLocation, struct FRotator* InRotation);
	void SC_CHAT_ON_WORLD_EMISSARY_REP(TArray<struct FChatData>* InChatDataList);
	void SC_SWAP_ACTIONBAR_SLOT_ACK(struct FActionBarData* InupdatedActionBar0, struct FActionBarData* InupdatedActionBar1);
	void SC_SWAP_ACTIONBAR_SLOT_ACK_FAILED(int InErrorCode);
	void SC_OPEN_REGISTER_CUSTOM_WAYPOINT_POPUP_REP(int InUseItemCid, int InLocationCid);
	void SC_START_COLOSSEUM_REP(int InColosseum_cid, int InUnion_count, int InHieron_count, const struct FQWord& InExpire_time);
	void SC_INSIGHT_TRAP_REP(struct FTrapData* InTrapData);
	void SC_PROGRESS_NPC_CRAFT_REP(int InCraftCId, int InCurrentIndex, int InMaxIndex);
	void SC_EXITED_FROM_CHALLENGE_TOWER_REP();
	void SC_REGISTER_CUSTOM_WAYPOINT_ACK(struct FCustomWaypointData* IncustomWaypointData);
	void SC_ALRIMI_ADD_LIST_REP(TArray<struct FAlrimiData>* InAlrimiData);
	void SC_SPECIAL_WAR_LIST_REP(TArray<struct FSpecialWarListData>* InSpecialWarDataList);
	void SC_PARTY_INVITATION_EXPIRE_REP(int InsidInvitor, int InsidInvitee);
	void SC_WEB_LAUNCHER_WIC_REP(struct FString* InParam);
	void SC_USE_POINT_SKILL_BY_ITEM_REQ(int InSkillCid);
	void SC_REQUEST_AVAILABLE_WAYPOINT_LIST_ACK(TArray<struct FWaypointRouteInfo>* Inavailable_list);
	void SC_OCCUPATION_WAR_INFO_ACK(bool InIsOpen, int InRemainPenaltySecond);
	void SC_ACTIONBAR_DATA_LIST_ACK(TArray<struct FActionBarData>* InActionBarDataList);
	void SC_ACTIONBAR_DATA_LIST_ACK_FAILED(int InErrorCode);
	void SC_KEEP_MAIL_ACK(TEnumAsByte<EMailErrorCode> InErrCode, unsigned char InMailIndex, bool InKeepFlag);
	void SC_UPDATE_MAIN_CRAFT_EXP_REP(int InExp);
	void SC_NOTI_CHAIN_INFO_REP(int InPreCombatSkillCid, int InChainCount, const struct FQWord& InChainStateTick, const struct FQWord& InQTEInputTick);
	void SC_RESULT_ITEM_SUCCEED_REP(TEnumAsByte<EItemSucceedResultType> InResult, int InSucceedItemSid);
	void SC_JOIN_SPECIAL_WAR_REQ(int InSpecialWarCid, int InRemainSeconds, TEnumAsByte<ESpecialWarJoinType> InspecialWarJoinType, bool InisFirstRequest, bool InisSuccessCondition);
	void SC_V2MISSION_UNREGISTER_FELLOW_ACK(const struct FQWord& InFellowUniqueID, TEnumAsByte<EMissionErrorCode> InErrCode);
	void SC_LOGIN_ACK(int InSid, const struct FQWord& InServerTime, const struct FQWord& InGameTime, float InRate, int InvipLevel, const struct FQWord& InvipExpireTime);
	void SC_LOGIN_ACK_FAILED(int InErrorCode);
	void SC_DESTINATION_INFO_REP(int InDestinationCid);
	void SC_ITEM_SUCCEED_CASTING_END_REP(bool InIsComplete);
	void SC_INVITE_GUILD_MEMBER_ACK(TEnumAsByte<EGuildErrorCode> InErrCode);
	void SC_WEB_OPEN_REP(struct FString* InURL);
	void SC_MAIN_CRAFT_BOOKMARK_LIST_REP(TArray<struct FCraftBookMarkData>* InCraftBookMarkList);
	void SC_UPDATE_MONSTERBOOK_HUNTING_INFO_REP(struct FMonsterHuntingProgressInfo* InmonsterbookInfo);
	void SC_STATUSHUD_REP(bool InEnable, struct FString* InHUDstring);
	void SC_CHAT_ON_WORLD_ZONE_REP(int InWorldZoneCid, TArray<struct FChatData>* InChatDataList);
	void SC_UPDATE_CRAFT_LEVEL_REP(int InLevel);
	void SC_UPDATE_SUB_CRAFT_LEVEL_REP(int InLevel);
	void SC_REPEAT_MONSTERBOOK_ACK(int InMonsterCid);
	void SC_REPEAT_MONSTERBOOK_ACK_FAILED(int InErrorCode, int InMonsterCid);
	void SC_NOTI_OCCUPATIONWAR_PRE_OUT_REP();
	void SC_UPDATE_GUILD_MARK_ACK(TEnumAsByte<EGuildErrorCode> InErrCode);
	void SC_MPF_ACTIONBAR_DATA_LIST_ACK(TArray<struct FMPFActionBarData>* InActionBarDataList);
	void SC_MPF_ACTIONBAR_DATA_LIST_ACK_FAILED(int InErrorCode);
	void SC_UPDATE_MODIFY_LEVEL_REP(int InmodifyCid, int InModifyLevel, bool InisModifyParamStatus);
	void SC_LEAVE_WORLD_REP(bool InisTeleport);
	void SC_V2MISSION_UPDATE_LEVEL_TAB_STATE_REP(struct FV2MissionLevelTabInfo* InMissionTabInfo);
	void SC_START_DUEL_REP();
	void SC_PARTY_INVITATION_RESPONSE_REP(int InsidInvitee, bool Inresponse);
	void SC_SWAP_SKILL_DECK_ACTION_APPLY_REP(int InCasterSid, int InSwapSkillDeckIndex);
	void SC_UPDATE_QUEST_INFO_REP(struct FQuestProgressInfo* InquestInfo);
	void SC_JOIN_OCCUPATION_WAR_REQ(int InOccupationWarCId, int InRemainSeconds);
	void SC_V2MOUNT_MOUNT_REP(int InDriverSid, int Inmount_cid, TEnumAsByte<ECECompanionGradeType> Inmount_grade);
	void SC_PROGRESS_V2CRAFT_REP(int InCraftCId, int InCurrentIndex, int InMaxIndex, int IncastingTimeInMilliSeconds);
	void SC_INSIGHT_NPC_REP(struct FNPCData* InNPCData);
	void SC_EQUIP_RUNE_ITEM_ACK(TEnumAsByte<ERuneSystemErrorCode> InErrCode);
	void SC_UPDATE_GUILD_REALM_OWNER_REP(bool InisRealmOwner);
	void SC_AVAILABLE_QUEST_LIST_REP(TArray<int>* InquestList);
	void SC_UPDATE_CRAFT_EXP_REP(int InExp);
	void SC_INITIALIZE_TUTORIAL_ORDER_REP(TArray<struct FTutorialOrderProgressInfo>* IntutorialOrderInfoList, TArray<unsigned char>* InrewardCompleteList);
	void SC_START_LOOTING_ACTION_REP(int InlooterSid, int InNpcSid);
	void SC_NOTIFY_RESET_GUILDWAR_SEASON_REP(struct FGuildWarSeasonData* InguildwarSeasonData, struct FGuildWarRecordData* InguildWarRecordData, struct FGuildWarRecordSeasonHistoryData* InguildwarRecordSeasonHistoryData);
	void SC_SUB_CRAFT_BOOKMARK_LIST_REP(TArray<struct FCraftBookMarkData>* InCraftBookMarkList);
	void SC_OPEN_UI_REP(TEnumAsByte<ECEOpenUIType> InUIType);
	void SC_WEB_SESSION_REDIRECT_FOR_EXCHANGE_ACK(bool InbSuccess, int InItemCid);
	void SC_REGISTER_RECIPE_SLOT_ACK(TEnumAsByte<ERecipeErrorCode> InErrCode, unsigned char InSlotIndex, int InItemSid);
	void SC_UPDATE_CURRENT_LIMITED_PVP_RANK_REP(int InplayerSId, int InCurrentRank);
	void SC_OUTOFSIGHT_PAWN_REP(int InServerId);
	void SC_SHOP_CLEARANCE_ACK(bool InSuccess);
	void SC_CLOSE_TELEPORT_CUSTOM_WAYPOINT_UI_REP();
	void SC_DEL_GUILD_HISTORY_REP(TArray<int>* InindexList);
	void SC_REGISTERED_PARTY_COLOSSEUM_REP(int InColosseum_cid, int Inwait_count);
	void SC_ATTACK_CANCELED_REP(int InSid);
	void SC_V2MOUNT_MOUNT_ACK(const struct FQWord& Inmount_uid, int Inmount_cid, float Incur_fatigue);
	void SC_V2MOUNT_MOUNT_ACK_FAILED(int InErrorCode, const struct FQWord& Inmount_uid, int Inmount_cid);
	void SC_FIELD_CHANNEL_LIST_ACK(TArray<struct FFieldChannelInfo>* InFieldChannelInfoList);
	void SC_CHARGE_SKILL_ACTION_LAUNCHED_REP(int InCasterSid, int InSkillCid, int InTargetSid, struct FVector* InTargetLocation, TArray<int>* InPrepareSectionTimeLineInMilliSeconds, struct FVector* InLocation, struct FRotator* InRotation);
	void SC_OUTOFSIGHT_DEADBODY_REP(int InServerId);
	void SC_MOVE_TO_TARGET_REQ_REP(int InTargetID, float InRange, int InActionTicket);
	void SC_CHANGE_ADJUST_LEVEL_REP(int InplayerSId, int InAdjustLevel);
	void SC_RAID_OPEN_REP(int InRaidCid);
	void SC_MAKE_SURE_TO_CUSTOM_REVIVAL_IN_PERSIST_WORLD_REQ(int InLocationCid, int InRemainRevivalCount);
	void SC_END_CHALLENGE_TOWER_PLAYER_OVER_COUNT_DOWN_REP();
	void SC_WEB_SESSION_REDIRECT_ACK(int InActId, int InCHId, struct FString* InToken, struct FString* InURL, int* InCSN);
	void SC_PARTY_MEMBER_SUMMON_ACK();
	void SC_PARTY_MEMBER_SUMMON_ACK_FAILED(int InErrorCode);
	void SC_UPDATE_EQUIPMENTS_REP(int InUserId, TArray<struct FEquipedItemData>* InEquipmentItemDataList);
	void SC_OUTOFSIGHT_ROGUILD_STATUE_REP(int InServerId);
	void SC_UPDATE_COLOSSEUM_PENALTY_TIME_REP(const struct FQWord& InpenaltySeconds, const struct FQWord& InincreasePenaltySeconds);
	void SC_RECIPE_CASTING_ACTION_START_REP();
	void SC_INITIAL_REALM_OWNER_GUILD_DATA_LIST_REP(TArray<struct FRealmOwnerGuildData>* InrealmOwnerGuildData);
	void SC_OPEN_BUY_CRAFT_RECIPE_HANDIWORK_UI_REP();
	void SC_CLEAR_PARTY_EFFECT_LIVING_ACK(int InErrCode, int InPartyIndex);
	void SC_UPDATE_COMBAT_FLAIR_DATA_REP(int InplayerSId, TArray<struct FCombatFlairData>* InData);
	void SC_SPRINT_START_ACK(bool Inis_succeeded);
	void SC_WAR_SCORE_REP(TArray<struct FSpecialWarRealmScoreData>* InOccupationWarrealmScoreDataList);
	void SC_REGISTER_DUNGEON_PARTY_MATCHING_ACK(TEnumAsByte<EDungeonPartyMatchingErrorCode> InErrorCode, int IndungeonCId);
	void SC_UPDATE_DROP_ITEM_DICE_ROLLING_GRADE_REP(TEnumAsByte<ECEItemGradeType> InDiceItemGrade);
	void SC_ADD_BLOCK_ACK(bool InIsSuccess);
	void SC_UPDATE_ACTIONBAR_REP();
	void SC_SELECT_PC_ACK(int InLoginCount, bool InTutorialMode, TArray<struct FInventoryItemData>* InItemDataListArray, TArray<struct FInventoryItemData>* InPersonalInvenItemDataListArray, TArray<int>* InSkillCidArray, struct FPCData* InPCData, TArray<struct FActionBarData>* InActionBarDataList, TArray<struct FContentTokenData>* InContentTokenDataList, TArray<struct FMPFActionBarData>* InMPFActionBarDataList);
	void SC_SELECT_PC_ACK_FAILED(int InErrorCode);
	void SC_ITEMTRADE_ADD_ITEM_ACK(int InItemSid);
	void SC_ITEMTRADE_ADD_ITEM_ACK_FAILED(int InErrorCode, int InItemSid);
	void SC_RESTRICT_TRADE_REP(bool InIsRestrict);
	void SC_CHALLENGE_TOWER_ROUND_PROCESS_INFO_REP(int InKillObjectCount);
	void SC_UPDATE_SUB_CRAFT_TYPE_ACK(bool InbSuccess, TEnumAsByte<EV2SubCraftType> InV2SubCraftType);
	void SC_GRANT_GUILD_RP_ACK(TEnumAsByte<EGuildErrorCode> InErrCode);
	void SC_NOTIFY_GUILDWAR_END_REP(const struct FQWord& InexpireStateTime, struct FGuildWarRecordData* InguildWarRecordData, struct FGuildWarHistoryData* InGuildWarHistoryData);
	void SC_DECIDE_STATS_EQUIP_ITEM_CUSTOM_ACK(TEnumAsByte<EEquipItemCustomErrorCode> InErrCode);
	void SC_LOGOUT_PARTY_MEMBER_REP(int InPartyID, int InMemberSID, int InSlotIndex);
	void SC_CREATE_GUILD_ACCEPT_EXPIRE_REP();
	void SC_UPDATE_PET_OWN_LIST_REP(TArray<struct FPetOwnData>* InPetList);
	void SC_BUY_FLASH_SHOP_ITEM_ACK(bool InbSuccess);
	void SC_MAKE_SURE_TO_STANDALONE_REVIVAL_IN_PERSIST_WORLD_REQ(bool InNeedFilling, int InNeedLumena);
	void SC_LEAVE_GUILD_MEMBER_ACK(TEnumAsByte<EGuildErrorCode> InErrCode);
	void SC_UPDATE_CITADEL_OWNER_GUILD_LEADER_NAME_REP(TArray<int>* InCitadelCid, struct FString* InguildLeaderName);
	void SC_UPDATE_WEEKLY_ORDER_GOAL_REP(int IncurruntGoalCount, int InmaxGoalCount, int InrewardCid, TEnumAsByte<EOrderStateType> InState);
	void SC_UPDATE_BATTLE_CONDITION_REP(int InColosseum_cid, int InUnion_count, int InHieron_count);
	void SC_V2MOUNT_UNMOUNT_ACK();
	void SC_V2MOUNT_UNMOUNT_ACK_FAILED(int InErrorCode);
	void SC_SPAWN_WAR_NPC_REP(TArray<struct FWarNPCNPropData>* InNPCData);
	void SC_UPDATE_DESIGNATED_SIGN_REP(struct FSignDataInfo* InSignDataInfo);
	void SC_DUNGEON_ENTRANCE_LIST_REP(TArray<struct FDungeonEntranceData>* IndungeonEntranceList);
	void SC_PREPARE_SEND_MAIL_ACK(TEnumAsByte<EMailErrorCode> InErrCode);
	void SC_OPEN_FLASH_SHOP_REP(int InFlashShopCid, const struct FQWord& InCloseTime, TArray<struct FFlashShopItemData>* InItemData);
	void SC_SUMMONEE_ATTACK_ACK(int InSummoneeSid, TEnumAsByte<ESummoneeResult> InresultCode);
	void SC_UPDATE_MAIN_CRAFT_LEVEL_REP(int InLevel);
	void SC_REMOVE_RP_PRODUCT_REP(TArray<int>* InproductIDList);
	void SC_INITIAL_PAWN_PARAM_REP(int InPawnSID, TArray<struct FParamData>* InDataList);
	void SC_KILLED_OTHER_PAWN_REP(int InCasterSid, int IndiedSid);
	void SC_UPDATE_GATHER_PLANTS_LEVEL_REP(int InLevel);
	void SC_PARTY_MEMBER_SUMMON_SUMMONER_REQ(int InSummoneeSid);
	void SC_CANCELED_REGISTER_COLOSSEUM_REP(int InColosseum_cid, bool Inreturned_queue);
	void SC_ENTER_ITEM_DESYNTHESIS_UI_REP();
	void SC_UPDATE_COLOSSEUM_SCHEDULE_INFO_REP(TArray<struct FColosseumScheduleInfo>* InscheduleInfoList);
	void SC_LEAVE_PARTY_ACK(int InErrCode, int InPartyID);
	void SC_REMOVE_EQUIP_ITEM_REP(TEnumAsByte<ECEEquipSlotType> InSlotId);
	void SC_WHISPER_REP(struct FChatData* InchatData);
	void SC_SORT_INVENTORY_ACK(bool InSuccess, TEnumAsByte<ECEInventoryType> InInventoryTab);
	void SC_MOUNT_ACTIVE_SKILL_ACTION_END_REP(int InplayerSId, int InmountActiveSkillCId);
	void SC_ASK_GUILD_JOIN_REQUEST_LIST_ACK(TEnumAsByte<EGuildErrorCode> InErrCode, TArray<struct FGuildJoinRequestData>* InjoinRequestList);
	void SC_UNREGISTER_ALL_DUNGEON_PARTY_MATCHING_REP();
	void SC_V2MOUNT_UNMOUNT_REP(int InDriverSid);
	void SC_DISSOLVE_PARTY_ACK(int InErrCode, int InPartyID);
	void SC_APPLY_PARTY_EFFECT_COMBAT_LIST_REP(TArray<struct FApplyPartyEffectInfo>* InApplyPartyEffectInfoList);
	void SC_OCCUPATION_WAR_SCORE_INFO_ACK(struct FOccupationWarData* InOccupationWarScoreData);
	void SC_UPDATE_MAIN_CRAFT_TYPE_ACK(bool InbSuccess, TEnumAsByte<EV2MainCraftType> InV2MainCraftType);
	void SC_OPEN_MAIN_CRAFT_CHOICE_UI_REP();
	void SC_MOUNT_SKILL_COOLTIME_INFO_REP(TArray<struct FMountCoolTimeData>* IncooltimeData);
	void SC_REMOVE_PERSONALINVEN_ITEM_ACK(struct FInventoryItemData* InremovedItemData);
	void SC_UNREGISTER_DUNGEON_PARTY_MATCHING_ACK(TEnumAsByte<EDungeonPartyMatchingErrorCode> InErrorCode, int IndungeonCId);
	void SC_UPDATE_GUILD_RP_REP(const struct FQWord& InRP);
	void SC_UPDATE_OCCUPATION_WAR_REVIVAL_TIME_REP();
	void SC_DEL_FRIEND_ACK(bool InIsSuccess, const struct FQWord& InfriendUniqueID);
	void SC_REQUEST_WAYPOINT_ROUTE_INFO_ACK(struct FWaypointRouteInfo* Inroute_info);
	void SC_DISBAND_GUILD_ACK(TEnumAsByte<EGuildErrorCode> InErrCode);
	void SC_UPDATE_SUB_CRAFT_TYPE_REP(TEnumAsByte<EV2SubCraftType> InV2SubCraftType, int InLevel, int InExp);
	void SC_CLOSE_DUEL_REPLY_UI_REP();
	void SC_UPDATE_GATHER_PLANTS_EXP_REP(int InExp);
	void SC_CHANGE_STANCE_START_ACK(bool InIsSuccess);
	void SC_MPF_MERGE_ACTION_ACK(bool InbSuccess, const struct FQWord& InMPFUid, TEnumAsByte<ECECompanionType> InMPFType, int InResultGradeUpCount, int InResultRemainGradeUpItemUseCnt, float InResultFatigue);
	void SC_CREATE_GUILD_ACK(TEnumAsByte<EGuildErrorCode> InErrCode);
	void SC_ITEM_DESYNTHESIS_CASTING_START_REP(int IncastingTimeInMilliSeconds);
	void SC_END_PC_TRACKING_REP();
	void SC_COLOSSEUM_SCORE_REP(int InUnionWinCount, int InHieronWinCount, TArray<struct FColosseumScoreData>* InUnionScoreDataList, TArray<struct FColosseumScoreData>* InHieronScoreDataList);
	void SC_LEAVE_GUILD_MEMBER_REP(struct FGuildMemberData* InguildMemberData);
	void SC_REFRESH_DUNGEON_PARTY_MATCHING_UI_ACK(TEnumAsByte<EDungeonPartyMatchingErrorCode> InErrCode, int IndungeonCId, TArray<struct FDungeonPartyMatchingData>* IndungeonPartyMatchingDataList);
	void SC_OPEN_TELEPORT_CUSTOM_WAYPOINT_UI_REP(int InUseItemCid, TArray<int>* InWaypointList);
	void SC_REFRESH_RESTRICT_REALM_INFO_ACK();
	void SC_REFRESH_RESTRICT_REALM_INFO_ACK_FAILED(int InErrorCode);
	void SC_CREATE_GUILD_ACCEPT_LIST_DIALOG_REQ(struct FString* InGuildName, TArray<struct FGuildRespondentData>* InrespondentDataList);
	void SC_TALK_END_ACK(int InNpcID, TEnumAsByte<ETalkEndType> InEndType);
	void SC_ACQUIRE_ITEM_REP(TArray<struct FInventoryItemData>* InacquireItemList);
	void SC_TAMING_CASTING_REP(int InOwnerPlayerSId, int InCastingTime, int InUseItemCid);
	void SC_ENTER_SHOP_REP(int InMerchantSid, int InShopCid, struct FShopData* InShopData);
	void SC_UPDATE_ITEM_UPGRADE_LEVEL_MILEAGE_REP(float Inmileage);
	void SC_SET_INDIVIDUAL_SKILL_COOLDOWN_LIST_REP(TArray<struct FIndividualCoolDownTime>* InIndividualCoolDownTimeList);
	void SC_PC_TAKE_OFF_ACK();
	void SC_PC_TAKE_OFF_ACK_FAILED(int InErrorCode);
	void SC_CHANGE_PC_NAME_ACK(TEnumAsByte<ECreateRemovePlayerErrorCode> InErrorCode, struct FString* InPrevPlayerName, struct FString* InNewPlayerName, struct FString* InForbidString);
	void SC_SUMMONEE_FOLLOW_ACK(int InSummoneeSid, TEnumAsByte<ESummoneeResult> InresultCode);
	void SC_TAMING_MINIGAME_HIT_ACK(int InOwnerPlayerSId);
	void SC_CANCEL_SKILL_ACTION_ACK(int InCid);
	void SC_SHOP_BUY_ACK(bool InSuccess);
	void SC_REWARD_WEEKLY_ORDER_GOAL_ACK();
	void SC_REWARD_WEEKLY_ORDER_GOAL_ACK_FAILED(int InErrorCode);
	void SC_UPDATE_GUILD_CITADEL_OWNER_REP(int InCitadelCid, bool InAcquire);
	void SC_TRAP_INVOKE_RESULT_INFO_REP(int InCasterSid, TArray<struct FSkillResult>* InResults);
	void SC_DUNGEON_INITIALIZE_DIALOG_REP(int InDungeonLeaveWatingTime);
	void SC_ON_SETTLE_RXP_REP(int InplayerSId, const struct FQWord& InRXP);
	void SC_MODIFY_GUILD_GRADE_NAME_ACK(TEnumAsByte<EGuildErrorCode> InErrCode);
	void SC_OPEN_CHARGE_ACTINGPOINT_DIALOG_ACK(int InChargeActingPoint, int InRequiredLumena, int InCurrentChargedCount, int InMaxChargeCount, int InResetActingPointChageCountTime);
	void SC_UPDATE_MISSION_REP(struct FMissionData* InMissionData);
	void SC_SKILL_APPLY_INFO_REP(int InCasterSid, int InSkill_Id, int InSkillResultTicket, TArray<struct FSkillApplyInfo>* InApplyInfos);
	void SC_RESULT_ITEM_DESYNTHESIS_REP(TEnumAsByte<EItemDesynthesisResultType> InResult, int InDesynthesisItemSid, int InRemainCount);
	void SC_DEBUG_HATE_LIST_REP(int InsidTarget, TArray<struct FHateActorData>* InhateList);
	void SC_REVIVAL_SATISFIED_DISTANCE_FROM_DEADBODY_REP(int InPawnSID, bool InIsTooFarAway);
	void SC_CONFIRM_CREATE_GUILD_ACK(TEnumAsByte<EGuildErrorCode> InErrCode);
	void SC_END_COLOSSEUM_REP(int InColosseum_cid, TEnumAsByte<EEColosseumResultType> InresultType, const struct FQWord& InExpire_time);
	void SC_LEAVE_ITEM_SUCCEED_UI_REP();
	void SC_UNREGISTER_CUSTOM_WAYPOINT_ACK(int IncustomWaypointUniqueID);
	void SC_UPDATE_RANDOM_DUNGEON_USE_COUNT_REP(int InUseCount, int InmaxAdditionalCount, int InuseAdditionalCount);
	void SC_REPLICATE_SOCIAL_ACTION_REP(int InPawnID, int InCidSocialAction);
	void SC_OPEN_RESET_RETURN_TIME_UI_REQ(const struct FQWord& InremainSkillCoolTime);
	void SC_START_CONFIRM_REGISTER_COLOSSEUM_REP(int InColosseum_cid, struct FColosseumConfirmRegisterInfo* Incolosseum_register_info);
	void SC_UPDATE_BLESSERSHIP_LEVEL_REP(int InLevel);
	void SC_CHANGE_DOOR_STATE_REP(int InSid, TEnumAsByte<ECEDoorStateType> InState);
	void SC_NOTIFY_GUILDWAR_COOLTIME_END_REP();
	void SC_MAKE_V2CRAFT_ACK(bool InbSuccess);
	void SC_INITIAL_GUILDWAR_REP(struct FGuildWarData* InguildWarData, struct FGuildWarRecordData* InguildWarRecordData, TArray<struct FGuildWarRecordSeasonHistoryData>* InguildwarRecordSeasonHistoryData, TArray<struct FGuildWarHistoryData>* InGuildWarHistoryData);
	void SC_MOUNTDATA_UPDATE_REP(struct FV2MountData* InMountData);
	void SC_KEEP_ALIVE_REQ();
	void SC_INSIGHT_DEADBODY_REP(struct FPCDeadBodyData* InPCDeadbodyData);
	void SC_FAIL_ENTER_COLOSSEUM_REP(int InColosseum_cid, const struct FQWord& InExpire_time);
	void SC_DECLARE_GUILDWAR_ACK(bool InSuccess);
	void SC_LEAVE_EXCHANGE_REP();
	void SC_PROGRESS_CRAFT_REP(int InCraftCId, int InCurrentIndex, int InMaxIndex, int IncastingTimeInMilliSeconds);
	void SC_GET_KEEP_MAIL_LIST_ACK(int InPageIndex, int InKeepMailCount, int InMaxKeepMailCount, TArray<struct FMailData>* InMailDataList);
	void SC_DEL_ORDER_REP(TArray<int>* InOrderCid);
	void SC_UPDATE_CONFIRM_REGISTER_COLOSSEUM_REP(int InColosseum_cid, struct FColosseumConfirmRegisterInfo* Incolosseum_register_info);
	void SC_START_CHALLENGE_TOWER_PLAYER_OVER_COUNT_DOWN_REP(int InRemainTimeToSeconds);
	void SC_FOSTER_GRADEUP_FELLOW_ACK(bool InIsSuccess, struct FFellowData* InResultPetData);
	void SC_FOSTER_GRADEUP_FELLOW_ACK_FAILED(int InErrorCode);
	void SC_ITEMTRADE_UPDATE_INFO_REP(TArray<struct FItemTradeData>* IntradeDataList);
	void SC_PARTY_INVITATION_CANCLE_REP(int InsidInvitor);
	void SC_INVINCIBLE_MODE_REP(int Inactor_sid, bool InMode);
	void SC_END_CRAFT_REP();
	void SC_CONDITION_PHASE_CHANGED_REP(int InPawnSID, TEnumAsByte<ECEConditionPhaseType> InPhaseType);
	void SC_UNEQUIP_ALL_RUNE_ITEM_ACK(TEnumAsByte<ERuneSystemErrorCode> InErrCode);
	void SC_INSIGHT_PROP_VISION_SHARED_REP(struct FPropData* InPropData);
	void SC_MOVE_TO_LOCATION_NPC_REP(int InPawnID, int InIsWalking, struct FVector* InNewLocation);
	void SC_ITEMTRADE_COMPLETE_REP();
	void SC_ADD_RP_PRODUCT_REP(TArray<struct FRPProductInfoData>* InrpProductInfoList);
	void SC_SORT_PERSONALINVENTORY_ACK(bool InSuccess);
	void SC_OPEN_WAR_UI_ACK(const struct FQWord& InpenaltySeconds, const struct FQWord& InincreasePenaltySeconds);
	void SC_OPEN_BUY_CRAFT_RECIPE_SMELT_UI_REP();
	void SC_CHARGE_SKILL_PROGRESS_SECTION_REP(int InCasterSid, int InSkillCid, int InSectionIndex);
	void SC_V2MISSION_REGISTER_FELLOW_ACK(const struct FQWord& InFellowUniqueID, TEnumAsByte<EMissionErrorCode> InErrCode);
	void SC_CHAT_ON_WORLD_REALM_REP(TArray<struct FChatData>* InChatDataList);
	void SC_PC_TAKE_DOWN_REP(int InDriverSid);
	void SC_APPLY_INSERT_AUCTION_ACK(TEnumAsByte<EAuctionErrorCode> InErrCode);
	void SC_DEBUG_BEHAVIOUR_LIST_REP(int InsidTarget, struct FString* InbehaviourName, TArray<struct FString>* InbtNodeList);
	void SC_OUTOFSIGHT_CHANGE_PLACEABLE_OBJECT_REP(int InPlaceableObjectSid, bool InAsInWorldObject);
	void SC_RESERVE_RO_ACK(TEnumAsByte<EROErrorCode> InErrCode, int InRemainModifyTime);
	void SC_REGISTER_SLOT_EQUIP_ITEM_CUSTOM_ACK(TEnumAsByte<EEquipItemCustomErrorCode> InErrCode);
	void SC_COMPLETE_ACHIEVEMENT_REP(int InachievementCId);
	void SC_MODIFY_GUILD_NOTICE_ACK(TEnumAsByte<EGuildErrorCode> InErrCode);
	void SC_START_WAYPOINT_WARP_REQ(float InGoalTime);
	void SC_POLYMORPH_REP(int InNpcSid, int InpolymorphCId);
	void SC_UPDATE_STORY_INFO_REP(struct FCurrentPCStoryInfo* IncurrentPcStoryInfo);
	void SC_SUMMONEE_MOVE_ACK(int InSummoneeSid, TEnumAsByte<ESummoneeResult> InresultCode);
	void SC_REGISTER_COLOSSEUM_REP(bool InSuccess, int InColosseum_cid, int Inwait_count);
	void SC_REMOVE_ITEM_FOR_SEND_MAIL_ACK(TEnumAsByte<EMailErrorCode> InErrCode, int InItemSid, unsigned char InSlotIndex);
	void SC_UPDATE_SUB_CRAFT_BOOKMARK_ACK(bool InbSuccess, int InCraftCId, const struct FQWord& InBookMarkTime, bool InbAdd);
	void SC_OPEN_NPC_CRAFT_UI_REP(int InactorSId);
	void SC_FELLOW_LIST_REP(TArray<struct FFellowData>* InFellowList);
	void SC_INVISIBLE_MODE_REP(int Inactor_sid, bool InMode);
	void SC_UPDATE_CITADEL_OWNER_GUILD_MARK_REP(TArray<int>* InCitadelCid, struct FGuildMarkData* InGuildMarkData);
	void SC_OPEN_BUY_CRAFT_RECIPE_COOK_UI_REP();
	void SC_RAID_CLOSE_REP(int InRaidCid);
	void SC_ACQUIRE_SKILL_REP(int InSkillCid);
	void SC_RECIPE_CASTING_ACTION_END_REP(bool InbComplete);
	void SC_UPDATE_GATHER_EXP_REP(int InExp);
	void SC_NPC_ESCORTOR_CHANGE_REP(int InNpcSid);
	void SC_ITEMTRADE_START_CHANGE_GOLD_REP();
	void SC_AURA_INFO_REP(int InPawnSID, int InAuraCid, bool InIsActive);
	void SC_UPDATE_SHOP_ITEM_REP(int InMerchantSid, int InShopCid, struct FShopItemData* InShopItemData);
	void SC_UNBIND_CUSTOM_REVIVAL_REP(TArray<int>* InunbindList);
	void SC_UPDATE_SKILL_GEM_REP(int InStanceGem, int InNonStanceGem, int InParameterGem);
	void SC_MISSION_LIST_REP(TArray<struct FMissionData>* InMissionList);
	void SC_UPDATED_GOLD_REP(const struct FQWord& InGold, const struct FQWord& Indelta);
	void SC_REGISTER_SLOT_EQUIP_ITEM_ACK(TEnumAsByte<ERuneCarveErrorCode> InErrCode, int InregisterItemSId);
	void SC_SWAP_MPF_ACTIONBAR_SLOT_ACK(struct FMPFActionBarData* InupdatedActionBar0, struct FMPFActionBarData* InupdatedActionBar1);
	void SC_SWAP_MPF_ACTIONBAR_SLOT_ACK_FAILED(int InErrorCode);
	void SC_BIND_CUSTOM_REVIVAL_REP(TArray<struct FCustomRevivalData>* InbindList);
	void SC_SPECIAL_WAR_DEATH_ALERT_REP(struct FVector* InLocation);
	void SC_CREATE_PARTY_REP(struct FPartyData* InPartyData);
	void SC_UPDATE_ACTING_POINT_REP(int InActingPoint);
	void SC_NOTIFY_GUILDWAR_WAIT_REP(struct FGuildWarData* InguildWarData);
	void SC_MONSTERBOOK_ALLCLEAR_REP(struct FAllClearMonsterBookInfo* InallclearInfo);
	void SC_MOVE_PERSONALINVEN_TO_INVEN_ITEM_ACK(TEnumAsByte<EItemAddErrorCode> InErrCode);
	void SC_ITEM_SUCCEED_CASTING_START_REP();
	void SC_DROP_ITEM_DICE_ROLLING_REQ(int InDropBagOwnerSId, int InItemCid, int InItemCount, int InTicket);
	void SC_V2MISSION_UPDATE_REP(struct FV2MissionData* InMissionData);
	void SC_UPDATE_TAMING_LEVELUP_REP(int InLevel, int InExp);
	void SC_SUMMONEE_DESPAWN_ACK(int InSummoneeSid, TEnumAsByte<ESummoneeResult> InresultCode);
	void SC_ADD_ITEM_FOR_SEND_MAIL_ACK(TEnumAsByte<EMailErrorCode> InErrCode, int InItemSid, unsigned char InSlotIndex);
	void SC_UPDATE_PARTY_MATCHING_INFO_REP(bool InIsParty, TEnumAsByte<EPartyMatchingUIStateType> InState, TEnumAsByte<ECEWorldMapType> InWorldMapType, int InworldMapWrapperCId, TArray<struct FPartyMatchingMemberInfoData>* InMemberPositionInfo);
	void SC_SUMMONEE_SKILL_LIST_REP(int InSummoneeSid, TArray<int>* InSkillCidArray);
	void SC_V2MOUNT_ACQUIRE_REP(struct FV2MountData* InV2MountData);
	void SC_SPECIAL_WAR_STATE_REP(int InSpecialWarCid, TEnumAsByte<ESpecialWarStateType> InspecialWarState);
	void SC_SPAWN_RO_WAR_NPC_REP(bool InIsSpawn, struct FRoWarNPCData* InNPCData);
	void SC_UPDATE_GAMETIME_REP(const struct FQWord& InGameTime, float InRate);
	void SC_MAKE_NPC_CRAFT_ACK(bool InbSuccess);
	void SC_CHANGE_PARTY_DISTRIBUTEMETHOD_ACK(int InErrCode, int InPartyID, TEnumAsByte<EPartyDistributeMethod> InDistributeMethod, int Indistributor);
	void SC_CHARGE_INVOKE_SKILL_TARGET_LIST_REP(int InCasterSid, int InLaunchSkillCid, int InInvokeSkillCid, int InSkillResultTicket, TArray<struct FSkillResultTargetInfo>* InTargetInfos);
	void SC_UPDATE_CHALLENGE_TOWER_PERSONAL_RECORD_INFO_REP(TArray<struct FChallengeTowerPersonalRecordData>* InPersonalRecordInfoArray);
	void SC_LEAVE_SHOP_REP(int InMerchantSid);
	void SC_LEAVE_LOOT_ACTION_ACK(int InTargetSid, int InActionTicket);
	void SC_UNREGISTER_RANDOM_DUNGEON_MATCHING_ACK(bool InIsSuccess);
	void SC_UNEQUIP_RUNE_ITEM_ACK(TEnumAsByte<ERuneSystemErrorCode> InErrCode);
	void SC_UPDATE_AUDIBLE_RANGE_REP(int InNpcSid, float InaudibleRange);
	void SC_INTERACTION_START_REP(int InSidInteractor, int InsidTarget, TEnumAsByte<ECEPropInteractType> InType, int IncastingTimeInMilliSeconds);
	void SC_PASSIVE_INVOKE_SKILL_FIRED_REP(int InCasterSid, int InSkillCid, int InFiringTimeInMilliSeconds, struct FVector* InLocation, struct FRotator* InRotation);
	void SC_CINEMATIC_END_REP(int Incinematic_id);
	void SC_UNREGISTER_FELLOW_TO_MISSION_ACK(int InMissionCID, const struct FQWord& InFellowUniqueID, TEnumAsByte<EMissionErrorCode> InErrCode);
	void SC_SPECIAL_WAR_JOIN_TYPE_REP(int InSpecialWarCid, TEnumAsByte<ESpecialWarJoinType> InspecialWarJoinType);
	void SC_UPDATE_GUILD_INFLUENCE_REP(const struct FQWord& InInfluence);
	void SC_SHOW_LETTER_REP(int InletterCid);
	void SC_REPLICATE_REMOTE_MOVE_REP(struct FMoveRepInfo* InMoveInfo);
	void SC_DUNGEON_LIMIT_COUNT_LIST_REP(TArray<struct FDungeonLimitedCountInfoData>* IndungoenLimitedInfoList);
	void SC_CANCEL_WAIT_RO_ACK(TEnumAsByte<EROErrorCode> InErrCode, int InRemainModifyTime);
	void SC_GET_QUEST_ACK(int InQuestID);
	void SC_GET_QUEST_ACK_FAILED(int InErrorCode, int InQuestID);
	void SC_RESULT_ITEM_UPGRADE_LEVEL_REP(TEnumAsByte<EItemUpgradeLevelResultType> InResult, int InUpgradeItemSid);
	void SC_LEAVE_ITEM_UPGRADE_LEVEL_UI_REP();
	void SC_MPF_SKILL_CHANGE_ACK(bool InbSuccess, const struct FQWord& InMPUId, int InChangeSkillCId, TEnumAsByte<ECECompanionGradeType> InChangeSkillGrade);
	void SC_NOTIFY_UPDATE_GUILDWAR_RECORD_SEASON_HISTORY_REP(struct FGuildWarRecordSeasonHistoryData* InguildwarRecordSeasonHistoryData);
	void SC_UPDATED_CONTENT_TOKEN_REP(TEnumAsByte<EContentTokenUpdateType> InupdateType, const struct FQWord& Indelta, struct FContentTokenData* IncontentTokenData);
	void SC_FOSTER_GRADEUP_MOUNT_ACK(bool InIsSuccess, struct FV2MountData* InResultMountData);
	void SC_FOSTER_GRADEUP_MOUNT_ACK_FAILED(int InErrorCode);
	void SC_V2MPF_FATIGUE_EXP_CHANGE_LIST_REP(TArray<struct FV2MPFFatigue_N_ExpData>* InfatigueList);
	void SC_MOVE_TO_LOCATION_REQ_REP(float InRange, int InActionTicket, struct FVector* InLocation);
	void SC_UPDATE_SPECIAL_WAR_NPC_REP(TArray<struct FSpecialWarNPCData>* InNPCData);
	void SC_ITEM_DESYNTHESIS_ACK(bool InIsComplete, int InDesynthesisItem);
	void SC_CHANGE_MOUNT_STAMINA_REP(int Instamina);
	void SC_TAMING_RESULT_REP(int InTargetSid, bool InIsSuccess);
	void SC_RUNE_CARVE_ACK(TEnumAsByte<ERuneCarveErrorCode> InErrCode);
	void SC_CHAT_ON_WORLD_HELP_REP(TArray<struct FChatData>* InChatDataList);
	void SC_CHANGE_STATE_SHEATHE_ACK(bool InstateSheathe, bool InSuccess);
	void SC_ASK_GUILD_HISTORY_ACK(TEnumAsByte<EGuildErrorCode> InErrCode, TArray<struct FGuildHistoryData>* InhistoryList);
	void SC_INSIGHT_PET_REP(struct FPetData* InPetData);
	void SC_RESTRICT_REALM_LIST_REP(bool InisRequest, TEnumAsByte<ECERealmType> InRecommendRealm, TArray<struct FRestrictRealmInfo>* InRestrictRealmArray);
	void SC_UPDATE_RANDOM_DUNGEON_STATE_PARTY_MEMBER_REP(int InPartyID, int InMemberSID, bool InisApplyRandomDungeon);
	void SC_CHANGEABLE_SKILL_CHANGED_REP(int InSkillFrom, int InSkillTo);
	void SC_START_MISSION_ACK(int InMissionCID, TEnumAsByte<EMissionErrorCode> InErrCode);
	void SC_UPDATE_MPF_ACTIONBAR_SLOT_ACK(TArray<struct FMPFActionBarData>* InupdatedActionBar);
	void SC_UPDATE_MPF_ACTIONBAR_SLOT_ACK_FAILED(int InErrorCode);
	void SC_JOIN_GUILD_MEMBER_REP(struct FGuildMemberData* InguildMemberData);
	void SC_INVITE_PARTY_ACK(int InErrCode, int InsidInvitee);
	void SC_SET_GLOBAL_SKILL_COOLDOWN_REP(int InRemainTimeInMilliseconds, int InTotalTimeInMilliseconds);
	void SC_CONFIRM_REGISTER_COLOSSEUM_ACK(bool InSuccess, int InColosseum_cid, bool InisWaitingStage);
	void SC_CHECK_MAIL_RECEIVER_ACK(TEnumAsByte<EMailErrorCode> InErrCode, struct FString* InReceiverName);
	void SC_CHANGE_PARTY_TO_RAID_ACK(int InErrCode, int InPartyID, TEnumAsByte<EPartyType> InpartyType);
	void SC_V2CRAFT_RESULT_REP(int InCraftCId, int InresultItemCId, TEnumAsByte<ECraftResultType> InSuccessType);
	void SC_UPDATE_PARTY_MATCHING_POSITION_ACK(bool InIsSuccess, TEnumAsByte<EPartyMatchingPositionType> InPosition);
	void SC_MOVE_PARTY_MEMBER_ACK(int InsidTarget, int Infrom, int Into);
	void SC_MOVE_PARTY_MEMBER_ACK_FAILED(int InErrorCode, int InsidTarget, int Infrom, int Into);
	void SC_APPLY_SEND_MAIL_ACK(TEnumAsByte<EMailErrorCode> InErrCode);
	void SC_LEAVE_AUCTION_REP();
	void SC_DEL_BLOCK_ACK(bool InIsSuccess, const struct FQWord& InignorePlayerUniqueID);
	void SC_REGISTER_PARTY_MATCHING_ACK(bool InIsSuccess, TEnumAsByte<ECEWorldMapType> InWorldMapType, int InworldMapWrapperCId);
	void SC_SKILL_INVOKE_COMBATFLAIR_MODIFY_REP(int InSkillCid, TArray<struct FSkillInvokeCombatFlairData>* InSkillInvokeCombatFlairDataList);
	void SC_CLOSE_SUB_CRAFT_CHOICE_UI_REP();
	void SC_UPDATE_FRIEND_LIST_ACK(bool InisInitial, TArray<struct FFriendData>* InfriendDataList);
	void SC_SET_DUNGEON_ENTRANCE_ACK(struct FDungeonEntranceData* IndungeonEntranceData);
	void SC_REWARD_MONSTERBOOK_ACK(int InMonsterCid, int InStageIndex);
	void SC_REWARD_MONSTERBOOK_ACK_FAILED(int InErrorCode, int InMonsterCid, int InStageIndex);
	void SC_REMOVE_PC_GUILD_INFO_REP(int InplayerSId);
	void SC_GEM_EXCHANGE_ACK(bool InIsSuccess, int InResultStanceGem, int InResultNonStanceGem, int InResultParameterGem, TArray<struct FGemExchangedItemData>* InResultItemList);
	void SC_SHOW_QUEST_ACCEPT_DIALOG_REP(int InQuestID);
	void SC_MISSION_PUSH_ALARM_REP(bool InIsActivateMissionOpenerUI, unsigned char InAlarmCount);
	void SC_PAYMENT_STATS_EQUIP_ITEM_CUSTOM_ACK(TEnumAsByte<EEquipItemCustomErrorCode> InErrCode, TArray<struct FStatData>* InnewStatDataList);
	void SC_CLOSE_PARTY_MATCHING_UI_REP();
	void SC_UPDATE_COMPANION_SLOT_REP(int InCompanionSlot);
	void SC_UPDATE_REPURCHASE_ITEM_REP(struct FItemData* InRemoveRepurchaseItem, struct FItemData* InAcquireRepurchaseItem);
	void SC_CRAFT_LIST_REP(TArray<unsigned char>* InHaveCraftList);
	void SC_NOTIFY_SHOW_COSTUME_REP(int InplayerSId, int InShowCostume);
	void SC_UPDATE_SUB_CRAFT_EXP_REP(int InExp);
	void SC_SURRENDER_GUILDWAR_ACK(bool InSuccess);
	void SC_ENTER_ITEM_SUCCEED_UI_REP();
	void SC_UPDATE_GUILD_NOTICE_REP(const struct FQWord& InnoticeDate, struct FString* Innotice);
	void SC_OPEN_PARTY_MATCHING_UI_ACK(bool InIsParty, TEnumAsByte<EPartyMatchingUIStateType> InState, TEnumAsByte<ECEWorldMapType> InWorldMapType, int InworldMapWrapperCId, TArray<struct FPartyMatchingMemberInfoData>* InMemberPositionInfo);
	void SC_NPC_OCCUPIER_CHANGE_REP(int InNpcSid, int InOccupierSid);
	void SC_UPDATE_LEVEL_REP(int InSidRPC, struct FPawnParam* InprevPawnParam, struct FPawnParam* InpawnParam);
	void SC_INSIGHT_DOOR_VISION_SHARED_REP(struct FDoorData* InDoorData);
	void SC_UPDATE_PARAM_LIST_REP(int InSidRPC, TArray<struct FParamData>* InParamDataList);
	void SC_END_CHALLENGE_TOWER_ROUND_REP(TEnumAsByte<EChallengeTowerEndRoundType> InEndRoundType, struct FChallengeTowerRoundResultInfoData* InRoundResultInfo);
	void SC_UPDATE_DAY_EXCHANGEABLE_LUMENA_REP(int InExchangeableLumena);
	void SC_KICK_PARTY_MEMBER_ACK(int InErrCode, int Insidkicked);
	void SC_UPDATE_BLOCK_LIST_REP(TArray<struct FIgnorePlayerData>* InignorePlayerDataList);
	void SC_UNREGISTER_PARTY_MATCHING_ACK(bool InIsSuccess, TEnumAsByte<ECEWorldMapType> InWorldMapType, int InworldMapWrapperCId);
	void SC_OPEN_GRANT_GUILD_RP_DIALOG_ACK(TEnumAsByte<EGuildErrorCode> InErrCode, TArray<struct FString>* InguildNameList);
	void SC_CITADEL_OWNERSHIP_START_REP();
	void SC_EXTEND_ATTACK_CHANCE_REP(TArray<struct FExtendAttackChanceInfo>* InAttackChanceInfoList);
	void SC_NOTIFY_GUILDWAR_KILL_POINT_REP(int InKillPoint);
	void SC_UPDATE_MONSTERBOOK_ALLCLEAR_INFO_REP(TArray<struct FAllClearMonsterBookInfo>* InallclearInfoList);
	void SC_UPDATE_PLAYER_PARTNER_TYPE_REP(TEnumAsByte<EPlayerPartnerType> InPlayerPartnerType);
	void SC_LOGIN_PARTY_MEMBER_REP(int InPartyID, int InPrevSID, struct FPartyMemberPCData* InMemberData);
	void SC_SHOW_CHALLENGE_TOWER_RANK_INFO_ACK(int InMaxPageIndex, int InPageIndex, TArray<struct FChallengeTowerRankData>* InTotalRankInfoArray);
	void SC_UPDATE_ORDER_INFO_REP(struct FOrderProgressInfo* InorderInfo);
	void SC_OPEN_EXCHANGE_CONTENT_TOKEN_UI_ACK(const struct FDouble& InexchangeLumena, TArray<struct FContentTokenExchangeData>* InexchangeDataList);
	void SC_CLEAR_PARTY_EFFECT_COMBAT_ACK(int InErrCode, int InPartyIndex);
	void SC_CANCEL_MOVE_TO_TARGET_REQ_REP(int InTargetID, int InActionTicket);
	void SC_DELETE_PARTY_REP(int InPartyID);
	void SC_ACQUIRE_FELLOW_REP(struct FFellowData* InFellowData);
	void SC_TIME_ACK(int InKey, const struct FDouble& inTime);
	void SC_OWN_DEADBODY_LOCATION_REP(int InPawnSID, TEnumAsByte<ECEWorldMapType> InWorldMapType, int InWorldWrapperCId, struct FVector* InLocation);
	void SC_NOTIFY_GUILDWAR_WARTIME_REP(const struct FQWord& InexpireStateTime);
	void SC_UPDATE_GUILD_LEVEL_REP(int InguildLevel);
	void SC_GAMEGUARD_AUTHENTICATION_CHECK_REQ(TArray<unsigned char>* InAuthenticationData);
	void SC_ITEM_UPGRADE_LEVEL_CASTING_END_REP(bool InIsComplete);
	void SC_PING_ACK(const struct FQWord& InClientTime, const struct FQWord& InServerTime);
	void SC_REPAIR_DURABILITY_BY_NPC_ACK(bool InIsSuccess);
	void SC_LEAVE_ITEM_DESYNTHESIS_UI_REP();
	void SC_INITIAL_RP_PRODUCT_REP(TArray<struct FRPProductInfoData>* InrpProductInfoList);
	void SC_RESTART_WAIT_COLOSSEUM_REP(int InColosseum_cid, const struct FQWord& InStart_time);
	void SC_CHANGE_STEALTH_DETECTION_REP(int InPawnSID, bool InisDetection);
	void SC_RO_ATTEND_INFO_ACK(TEnumAsByte<EROErrorCode> InErrCode, bool InIsReserved, bool InIsAttacker, bool InCanReserveAuth, int InRemainModifyTime, struct FROAttendInfoData* InROAttendInfoData);
	void SC_NOTIFY_OPEN_RAID_LIST_REP(TArray<int>* InOpenRaidCidList);
	void SC_V2MISSION_SWAP_FELLOW_ACK(TEnumAsByte<EMissionErrorCode> InErrCode);
	void SC_CHAT_REP(TEnumAsByte<EChatChannel> Inchannel, struct FChatData* InchatData);
	void SC_ALRIMI_DEL_LIST_REP(TArray<struct FAlrimiData>* InAlrimiData);
	void SC_REPLY_DUEL_REQ(struct FString* IninvitorName);
	void SC_SPAWN_PET_REP(struct FPetData* InPetData);
	void SC_UPDATE_PC_GUILD_CO_RO_REP(int InplayerSId, bool InIsCO, bool InIsRO);
	void SC_CLOSE_FLASH_SHOP_REP();
	void SC_CANCEL_WAIT_SPECIAL_WAR_ACK(TEnumAsByte<ESpecialWarErrorCode> InErrCode);
	void SC_ENVIRONMENT_REP(struct FString* InEnvironmentString, TArray<struct FPlayerEnvironmentData>* InEnvironmentList);
	void SC_BELONGING_SPIRITUAL_AWAKER_INFO_REP(int InSpiritualAwakerCid);
	void SC_CHANGE_GUILD_NAME_ACK(TEnumAsByte<EGuildErrorCode> InErrCode, struct FString* InErrString);
	void SC_SKILL_REDUCE_FIRING_TIME_REP(int InCasterSid, int InSkill_Id, int InReduceSeconds);
	void SC_NOTIFY_COUNT_RESET_GUILDWAR_SEASON_REP(struct FGuildWarSeasonData* InguildwarSeasonData);
	void SC_SHOW_DAMAGE_FLOATTER_REP(int InTargetSid, int InDamage);
	void SC_MPF_EXTRACTION_ACK(bool InbSuccess, int InResultContainerItemCId);
	void SC_SHOW_QUEST_RESTART_DIALOG_REP(int InQuestID);
	void SC_REPLY_BEING_SPIRIT_BY_SELF_REP(int InPawnSID, bool InSuccess, TEnumAsByte<ECERevivalType> InRevivalType);
	void SC_REPAIR_DURABILITY_BY_ITEM_REP(TEnumAsByte<ERepairResultType> InResult);
	void SC_AUCTION_MARKET_PRICE_REP(int InItemCid, const struct FQWord& InAvgMarketPrice, const struct FQWord& InYesterdayMarketPrice);
	void SC_RESERVE_SPECIAL_WAR_REP(TEnumAsByte<ESpecialWarErrorCode> InErrCode);
	void SC_SPECIAL_WAR_LOG_INFO_ACK(TEnumAsByte<ESpecialWarErrorCode> InErrCode, struct FSpecialWarPlayerWarLogData* InspecialWarPlayerWarLogData);
	void SC_UPDATE_GUILD_WAR_LAST_SEASON_WIN_COUNT_REP(int InGuildWarLastSeasonWinCount);
	void SC_V2MISSION_START_ACK(int InLevelTabIndex, TEnumAsByte<EMissionErrorCode> InErrCode);
	void SC_INTERACTION_END_REP(int InSidInteractor, int InsidTarget, TEnumAsByte<ECEPropInteractType> InType, bool InisCanceld);
	void SC_DUNGEON_ENDURE_STAGE_SKIP_CONFIRM_REP(int IndungeonCId);
	void SC_CONFIRM_JOIN_GUILD_ACK(TEnumAsByte<EGuildErrorCode> InErrCode);
	void SC_OPEN_WAREHOUSE_REP();
	void SC_OPEN_CHARGE_LUMENA_DIALOG_REP(int InChargeLumena);
	void SC_ENTER_COLOSSEUM_REP(int InColosseum_cid, const struct FQWord& InStart_time, TArray<struct FString>* Inunion_member_name, TArray<struct FString>* Inhieron_member_name);
	void SC_ITEM_EVOLUTION_ACK(bool InIsComplete, int InEvolutionItemSid);
	void SC_PETDATA_UPDATE_REP(struct FPetOwnData* InPetData);
	void SC_CHANGE_NPC_IDLE_STATE_REP(int InNpcSid, TEnumAsByte<ECENPCStateType> InIdleStateType);
	void SC_UPDATE_MPF_ACTIONBAR_REP();
	void SC_UPDATE_GUILD_MARK_REP(struct FGuildMarkData* InGuildMarkData);
	void SC_CREATE_GUILD_ACCEPT_DIALOG_REQ(int InRequesterSid, struct FString* InGuildName);
	void SC_UPDATE_GUILD_GRADE_REP(TArray<struct FGuildGradeData>* InguildGradeList);
	void SC_FOSTER_EXPUP_MOUNT_ACK(int InPreLevel, int InPreExp, struct FV2MountData* InResult);
	void SC_SHOP_SELL_ACK(bool InSuccess);
	void SC_REWARD_ORDER_ACK(int InOrderCid);
	void SC_REWARD_ORDER_ACK_FAILED(int InErrorCode, int InOrderCid);
	void SC_ENTER_REPAIR_UI_REP(TEnumAsByte<ERepairType> InRepairType, float InSuccessRate, float InWeight);
	void SC_UPDATE_GUILD_MEMBER_LIST_REP(TArray<struct FGuildMemberData>* InguildMemberList);
	void SC_ALRIMI_LIST_REP(TArray<struct FAlrimiData>* InalrimiList);
	void SC_RESULT_RECIPE_REP(TEnumAsByte<ERecipeErrorCode> InErrCode, TEnumAsByte<ECraftResultType> IncraftResultType, int InItemSid);
	void SC_NOTIFY_GIFTBOX_COUNT_REP(int InGiftBoxCount);
	void SC_GET_TUTORIAL_ORDER_ACK(bool InIsSuccess);
	void SC_SKILL_CANCELED_REP(int InSid, int InCid);
	void SC_LEAVE_CRAFT_REP();
	void SC_WORLD_INOUT_REP(int InplayerSId, TEnumAsByte<ECEWorldMapType> InWorldMapType, int InworldMapWrapperCId, bool InIsEnter);
	void SC_UPDATE_CURRENT_RXP_REP(const struct FQWord& InCurrentRXP);
	void SC_GET_AUCTION_LIST_ACK(int InPageIndex, int InMaxAuctionCount, TArray<struct FAuctionData>* InAuctionDataList);
	void SC_SKILL_TARGET_LIST_REP(int InCasterSid, int InSkill_Id, int InSkillResultTicket, TArray<struct FSkillResultTargetInfo>* InTargetInfos);
	void SC_CONFIRM_SKILL_TREE_REP(bool InByReq, TArray<struct FSkillTreeData>* InSkillTreeList);
	void SC_V2MOUNT_UPDAET_EXP_REP(const struct FQWord& InMountUid, int InExp);
	void SC_BATTLEYE_DATA_CHECK_REQ(TArray<unsigned char>* InBattlEyeData);
	void SC_REPLICATE_MOVE_LIST_REP(TArray<struct FMoveRepInfo>* InMoveInfoList);
	void SC_END_CHALLENGE_TOWER_WAITING_NEXT_ROUND_REP();
	void SC_PET_SUMMON_REP(const struct FQWord& InPetUniqueID, int InPetCid, bool InisSummon, float InPetFatigue);
	void SC_SKILL_FIRED_REP(int InCasterSid, int InSkillCid, int InFiringTimeInMilliSeconds, struct FVector* InLocation, struct FRotator* InRotation);
	void SC_REQUEST_DUEL_ACK(bool InIsSuccess);
	void SC_ITEMTRADE_CANCELED_REP(TEnumAsByte<EItemTradeErrorCode> InReason);
	void SC_ADD_GUILD_HISTORY_REP(struct FGuildHistoryData* InhistoryData);
	void SC_IN_GAME_HELP_TRIGGERED_REP(int IninGameHelpCid);
	void SC_COMPLETE_PARTY_MEMBER_SUMMONED_REP(int InSummoneeSid);
	void SC_GET_MAIL_LIST_ACK(int InPageIndex, int InNormalMailCount, int InGMMailCount, int InSystemMailCount, int InMaxNormalMailCount, int InMaxGMMailCount, int InMaxSystemMailCount, int InMaxExpandMailCount, TArray<struct FMailData>* InMailDataList);
	void SC_UPDATE_GATHER_LEVEL_REP(int InLevel);
	void SC_TAMING_SUCCESS_REP(TArray<struct FV2MPFItemData>* InResultItemList, struct FMPFRandomData* InResultMPFData);
	void SC_ACQUIRE_PET_REP(struct FPetOwnData* InPetData);
	void SC_INSIGHT_NPC_VISION_SHARED_REP(struct FNPCData* InNPCData);
	void SC_START_CHALLENGE_TOWER_ROUND_REP(int InRound);
	void SC_CHARGE_INVOKE_SKILL_FIRED_REP(int InCasterSid, int InLaunchSkillCid, int InInvokeSkillCid, int InFiringTimeInMilliSeconds, struct FVector* InLocation, struct FRotator* InRotation);
	void SC_ATTACK_ACTION_START_REP(int InAttackerSId, int InTargetSid, int InAttackPeriodInMilliSeconds, int InApplyMomentInMilliSeconds, int InSequenceNumber, TEnumAsByte<ECENormalAttackEquipType> InEquipType);
	void SC_REFRESH_MISSION_ACK(TEnumAsByte<EMissionErrorCode> InErrCode);
	void SC_ITEM_EVOLUTION_CASTING_END_REP(bool InIsComplete);
	void SC_SPECIAL_WAR_SCORE_REP(TArray<struct FSpecialWarRealmScoreData>* InSpecialWarRealmScoreDataList);
	void SC_SYSTEM_MESSAGE_REP(int Insystem_message_cid, TArray<struct FSystemMessageParamValueData>* InParamValueList);
	void SC_SYSTEM_DEBUG_MESSAGE_REP(TEnumAsByte<ESystemMessageChannel> Inchannel, struct FString* InMessage);
	void SC_INVEN_ITEM_COOLTIME_INFO_REP(TArray<struct FItemCoolTimeData>* IncooltimeData);
	void SC_NOTIFY_WARP_FINISHED_ACK();
	void SC_PLAY_DISPOSABLE_ANIMATION_REP(int InNpcSid, int InPlayAnimIndex, float InPlayTimeInSeconds);
	void SC_PARTY_INVITATION_REQ(int IninvitorSId, TEnumAsByte<EPartyType> InpartyType, struct FString* IninvitorName);
	void SC_BURDEN_CARRY_START_REP(int IncarryPlayerSid, int InburdenCid);
	void SC_MAIL_COUNT_REP(int InNewMailCount, int InOverMailCount);
	void SC_UPDATE_RO_WAR_NPC_REP(TArray<struct FRoWarNPCData>* InNPCData);
	void SC_START_WAYPOINT_ACK(bool Inis_succeeded);
	void SC_DEL_CRAFT_RECIPE_REP(int IncraftRecipeCId);
	void SC_SHOP_REPURCHASE_ACK(bool InSuccess);
	void SC_INVITE_PARTY_CANCLE_ACK(int InsidInvitee);
	void SC_FOSTER_GRADEUP_PET_ACK(bool InIsSuccess, struct FPetOwnData* InResultPetData);
	void SC_FOSTER_GRADEUP_PET_ACK_FAILED(int InErrorCode);
	void SC_UPDATE_LUMENA_SHOP_ITEM_REP(struct FLumenaShopItemData* InItemData);
	void SC_V2MOUNT_LIST_REP(TArray<struct FV2MountData>* InV2MountDataList);
	void SC_UPDATE_COMBAT_SKILL_TREE_NODE_REP(bool InUsingResetItem, TArray<struct FCombatSkillTreeData>* InCombatSkillTreeNodeList);
	void SC_UPDATE_REALM_OWNER_GUILD_LEADER_NAME_REP(TEnumAsByte<ECERealmType> InRealmType, struct FString* InnewGuildLeaderName);
	void SC_LOOTING_RESPONSE_ITEMLIST_REP(int InSid, const struct FQWord& InGold, bool IncanGiveUp, bool IncanAddLooting, TArray<struct FEachDropItemInfo>* InItemList, TArray<struct FEachDropContentTokenInfo>* InContentTokenList);
	void SC_LOOK_CHANGE_ENTER_ACK(bool InbSuccess);
	void SC_REVIVAL_REP(int InPawnSID, TEnumAsByte<ECERevivalType> InRevivalType, bool InAtDeadBodyPosition);
	void SC_LEAVE_REPAIR_UI_REP();
	void SC_END_LOOTING_ACTION_REP(int InlooterSid);
	void SC_UPDATE_GUILD_NAME_REP(struct FString* InGuildName);
	void SC_XIGNCODE_DATA_CHECK_REQ(TArray<unsigned char>* InXignCodeData);
	void SC_UPDATE_MINING_EXP_REP(int InExp);
	void SC_ADD_MONSTERBOOK_AVAILABLE_REWARD_REP(int InMonsterCid, int InStageIndex);
	void SC_UPDATE_CHALLENGE_TOWER_LIMIT_COUNT_REP(TArray<struct FChallengeTowerLimitedCountInfoData>* InLimitedInfo);
	void SC_DELETE_MAIL_ACK(TEnumAsByte<EMailErrorCode> InErrCode, unsigned char InMailIndex);
	void SC_EXCHANGE_CONTENT_TOKEN_TO_LUMENA_ACK(TEnumAsByte<EContentTokenExchangeErrorCode> InErrCode);
	void SC_VOLUME_CHANNEL_PVP_TYPE_NOTIFY_UI_REP(bool InisShow, TEnumAsByte<ECEPVPType> InPvpType);
	void SC_ITEM_UPGRADE_LEVEL_CASTING_START_REP();
	void SC_SUMMONEE_SKILL_ACK(int InSummoneeSid, TEnumAsByte<ESummoneeResult> InresultCode);
	void SC_ADD_GUILD_GRADE_ACK(TEnumAsByte<EGuildErrorCode> InErrCode);
	void SC_UPDATE_PARTY_MEMBER_PARTY_MATCHING_POSITION_REP(int InPartyMemberSid, TEnumAsByte<EPartyMatchingPositionType> InPosition);
	void SC_MOVE_INVEN_ITEM_ACK(TArray<struct FInventoryItemData>* InItemDataListArray);
	void SC_DROP_QUEST_ACK(int InQuestID);
	void SC_DROP_QUEST_ACK_FAILED(int InErrorCode, int InQuestID);
	void SC_INSIGHT_CHANGE_PLACEABLE_OBJECT_REP(int InPlaceableObjectSid, bool InAsInWorldObject);
	void SC_ENTER_ITEM_UPGRADE_LEVEL_UI_REP();
	void SC_UPDATE_MAIN_CRAFT_BOOKMARK_ACK(bool InbSuccess, int InCraftCId, const struct FQWord& InBookMarkTime, bool InbAdd);
	void SC_SKILL_COST_PARAM_MODIFY_REP(int InSkillCid, TEnumAsByte<ECESkillParamModifyType> InSkillParamModifyType, TArray<struct FSkillCostParamData>* InSkillCostParamDataList);
	void SC_UNABLE_QUEST_LIST_REP(TArray<int>* InquestList);
	void SC_SET_PC_GUILD_INFO_REP(int InplayerSId, struct FPCGuildData* InpcGuildData);
	void SC_END_V2CRAFT_REP();
	void SC_BROADCAST_UPDATE_LEVEL_REP(int InSid, struct FPawnParamData* InPawnParamData);
	void SC_UPDATE_SIGN_AUTHORITY_REP(bool InAllAuthority);
	void SC_GET_SEND_MAIL_LIST_ACK(int InPageIndex, int InSendMailCount, int InMaxSendMailCount, TArray<struct FMailData>* InMailDataList);
	void SC_UPDATE_SP_REP(int InTotalSP);
	void SC_DESPAWN_WAR_NPC_REP(TArray<struct FWarNPCNPropData>* InNPCData);
	void SC_UPDATE_GUILD_RANK_REP(int InguildRank);
	void SC_UPDATE_PC_GUILD_WAR_LAST_SEASON_WIN_COUNT_REP(int InplayerSId, int InGuildWarLastSeasonWinCount);
	void SC_COMMON_WAR_JOIN_ACK();
	void SC_UPDATE_WAR_NPC_REP(TArray<struct FWarNPCNPropData>* InNPCData);
	void SC_UPDATE_GUILD_EXP_REP(float InguildExp);
	void SC_MPF_HATCH_ANIMA_ACK(bool InbSuccess, TArray<struct FAnimaHatchMPFResult>* InMPFResultList, TArray<struct FV2MPFItemData>* InItemResultList, struct FAnimaHatchMPFResult* InBonusMPFResult);
	void SC_PAYMENT_LEGEND_OPT_EQUIP_ITEM_CUSTOM_ACK(TEnumAsByte<EEquipItemCustomErrorCode> InErrCode, int InlegendOptCId);
	void SC_SKILL_REVIVAL_BY_OTHER_REP(int InsidTarget, int InSidCaster, bool InAtDeadBodyPosition, struct FString* InName);
	void SC_LOOTING_REQUEST_CLOSEWINDOW_ACK(bool InIsSuccess);
	void SC_OPEN_MONSTERBOOK_LOCATION_LIST_REP(TArray<int>* InlocationCidList);
	void SC_CANCELED_MOUNT_PREPARE_ACTION_REP(int InCasterSid);
	void SC_CITADEL_OWNERSHIP_END_REP();
	void SC_LEAVE_ITEM_EVOLUTION_UI_REP();
	void SC_SKILL_DECK_LIST_REP(int InCurrentSkillDeckIndex, TArray<struct FSkillDeckData>* InSkillDeckDataList);
	void SC_INITIAL_GUILD_REP(struct FGuildData* InguildData, TArray<struct FGuildMemberData>* InguildMemberList, TArray<struct FGuildGradeData>* InguildGradeList, TArray<struct FGuildHistoryData>* InguildHistoryData, struct FGuildMarkData* InGuildMarkData);
	void SC_OUT_SPECIAL_WAR_ACK(TEnumAsByte<ESpecialWarErrorCode> InErrCode);
	void SC_REMOVE_PET_REP(const struct FQWord& InPetUid);
	void SC_WAYPOINT_TIME_REP(int Inplayer_sid, struct FWaypointProgressInfo* InWaypointInfo);
	void SC_TELEPORT_REP(struct UABLSDLTypes_FTeleport* Into);
	void SC_PROMOTE_PARTY_LEADER_ACK(int InErrCode, int InsidLeader);
	void SC_CANCEL_SEND_MAIL_ACK(TEnumAsByte<EMailErrorCode> InErrCode);
	void SC_NOTIFY_INITIAL_RECOGNITION_REP(int InNpcSid);
	void SC_OPEN_MONSTERBOOK_REP(int InMonsterBookCid);
	void SC_SWITCHING_SKILL_APPLY_INFO_REP(int InSwitchingSkillCid, bool InIsActivate);
	void SC_EXPIRE_GUILD_INVITATION_REP();
	void SC_OPEN_BUY_CRAFT_RECIPE_ALCHEMY_UI_REP();
	void SC_SKILL_AUTO_FIRING_NOTIFY_REP(int InSkillCid);
	void SC_CINEMATIC_PLAY_REP(int Incinematic_id);
	void SC_ENTER_RO_WORLD_REP(bool InIsAttacker, int InprocessTime);
	void SC_UPDATE_TUTORIAL_ORDER_REP(struct FTutorialOrderProgressInfo* IntutorialOrderInfo);
	void SC_GACHA_END_REP(bool InSuccess);
	void SC_MOVE_PERSONALINVEN_ITEM_ACK(TArray<struct FInventoryItemData>* InItemDataListArray);
	void SC_APPLY_PARTY_EFFECT_COMBAT_ACK(int InErrCode, int InPartyIndex, int InPartyEffectCombatCId);
	void SC_ENTER_WORLD_ACK(const struct FQWord& InGameTime, float InRate, struct FVector* InLocation, struct FRotator* InRotation);
	void SC_ENTER_WORLD_ACK_FAILED(int InErrorCode);
	void SC_TAMING_START_REP(int InOwnerPlayerSId, struct FTamingMiniGameData* InMiniGameData);
	void SC_UPDATE_DUEL_RESULT_REP(struct FDuelResultData* InduelResultData);
	void SC_DESPAWN_WAR_PROP_REP(TArray<struct FWarNPCNPropData>* InPropData);
	void SC_UPDATE_COMBAT_FLAIR_ACTIVATE_REP(int InplayerSId, TArray<struct FCombatFlairActivateData>* InActivateDataList);
	void SC_SKILL_PROJECTILE_FIRE_INFO_REP(int InTargetSid, int InApplyMoment, struct FVector* InLocation);
	void SC_MOUNT_ACTIVE_SKILL_ACTION_START_REP(int InplayerSId, int InmountActiveSkillCId);
	void SC_SHOW_MONOLOG_REP(int InNpcID, int InMonologID, int InshowTimeInSeconds);
	void SC_ITEM_EVOLUTION_CASTING_START_REP();
	void SC_SET_FLY_MODE_REP(bool InbEnabled);
	void SC_REWARD_TUTORIAL_ORDER_ACK(bool InisRewardSuccess, int IntutorialOrderCid);
	void SC_POSSIBLE_REVIVAL_TYPE_ON_DIE_REP(TEnumAsByte<ECERevivalType> InRevivalType, int InTimeInMilliSeconds, int InRevivalBeneficCnt, bool InIsVIP, bool InIsTutorial);
	void SC_OPEN_SUB_CRAFT_CHOICE_UI_REP();
	void SC_VOLUNTARY_ACTION_END_REP(int InplayerSId, int InVoluntaryActionCid);
	void SC_CLOSE_MAIN_CRAFT_CHOICE_UI_REP();
	void SC_UNLOCK_SKILL_DECK_REP(struct FSkillDeckUnlockData* InSkillDeckUnlockData);
	void SC_VOLUNTARY_ACTION_START_REP(int InplayerSId, int InVoluntaryActionCid);
	void SC_CUSTOM_WAYPOINT_LIST_REP(TArray<struct FCustomWaypointData>* IncustomWaypointList);
	void SC_FELLOWDATA_UPDATE_REP(struct FFellowData* InFellowData);
	void SC_REGISTER_FELLOW_TO_MISSION_ACK(int InMissionCID, const struct FQWord& InFellowUniqueID, TEnumAsByte<EMissionErrorCode> InErrCode);
	void SC_UPDATE_REALM_OWNER_GUILD_MARK_REP(TEnumAsByte<ECERealmType> InRealmType, struct FGuildMarkData* InGuildMarkData);
	void SC_REMOVE_PARTY_MEMBER_REP(int InPartyID, int InMemberSID, int InSlotIndex);
	void SC_REPLY_DELEGATION_GUILD_LEADER_REQ(struct FString* InleaderName);
	void SC_UPDATE_PARAM_REP(int InSidRPC, struct FParamData* InData);
	void SC_HANDLE_GUILD_JOIN_REQUEST_ACK(TEnumAsByte<EGuildErrorCode> InErrCode);
	void SC_REQUEST_DELEGATION_GUILD_LEADER_ACK(TEnumAsByte<EGuildErrorCode> InErrCode);
	void SC_SUMMONEE_USE_ENERGY_SPHERE_ACK(int InSummoneeSid, int InUse, TEnumAsByte<ESummoneeResult> InresultCode);
	void SC_MODIFY_GUILD_GRADE_PRIORITY_ACK(TEnumAsByte<EGuildErrorCode> InErrCode);
	void SC_BUY_AUCTION_ACK(TEnumAsByte<EAuctionErrorCode> InErrCode);
	void SC_SPECIAL_WAR_INFO_ACK(TEnumAsByte<ESpecialWarErrorCode> InErrCode, bool InIsBolterPlayer, struct FSpecialWarInfoData* InspecialWarInfoData);
	void SC_V2MOUNT_REMOVE_REP(const struct FQWord& InMountUid);
	void SC_PET_MOVE_TO_LOCATION_REP(int InPetSId, float InSpeed, struct FVector* InLocation);
	void SC_FOSTER_EXPUP_PET_ACK(int InPreLevel, int InPreExp, struct FPetOwnData* InResult);
	void SC_SET_SKILL_STACK_CHARGE_TIME_REP(int InSkillCid, int InRemainChargeMilliseconds, int InTotalChargeMilliseconds);
	void SC_END_NPC_CRAFT_REP();
	void SC_WAR_MATCHING_REGIST_REP();
	void SC_ACQUIRE_PERSONALINVEN_ITEM_REP(TArray<struct FInventoryItemData>* InacquireItemList);
	void SC_MODIFY_SKILL_DECK_ACK(TEnumAsByte<ESkillDeckErrorCode> InErrorCode, struct FSkillDeckData* InSkillDeckData);
	void SC_UPDATE_REMOVE_GUILD_REP();
	void SC_MODIFY_GUILD_MEMBER_GRADE_ACK(TEnumAsByte<EGuildErrorCode> InErrCode);
	void SC_REGISTER_RANDOM_DUNGEON_MATCHING_ACK(bool InIsSuccess);
	void SC_MOUNT_PREPARE_ACTION_CASTING_REP(int InCasterSid, int InMountCid, int InCastingTime);
	void SC_UPDATE_LOOK_CHANGE_INFO_REP(TEnumAsByte<ELookChangeType> InLookChangeType, const struct FQWord& InLookChangeExpireTime);
	void SC_RO_WAR_REMAIN_REVIVAL_TIME_REP(int InRemainTimeInSeconds);
	void SC_LOOTING_RESPONSE_CLOSEWINDOW_REP(int InSid);
	void SC_UPDATE_PARTY_DATA_REP(int InPartyID, int InLeaderSID, TEnumAsByte<EPartyDistributeMethod> InDistributeMethod, int InDistributorID);
	void SC_FOSTER_EXPUP_FELLOW_ACK(int InPreLevel, int InPreExp, struct FFellowData* InResult);
	void SC_EQUIP_INVEN_ITEM_ACK(TEnumAsByte<EItemEquipErrorCode> InErrorCode, TArray<struct FInventoryItemData>* InItemDataListArray);
	void SC_WAR_STATE_N_TIME_REP(TEnumAsByte<EWarStateType> InState, int InRemainSec);
	void SC_SERVER_KICK_OUT_REP(struct FString* InKickOutMsg);
	void SC_SPECIALWAR_REWARD_CP_LIST_REP(TArray<struct FSpecialWarRewardCPData>* InRewardCPData);
	void SC_PASSIVE_INVOKE_SKILL_APPLY_INFO_REP(int InCasterSid, int InSkillCid, int InSkillResultTicket, TArray<struct FSkillApplyInfo>* InApplyInfos);
	void SC_NOTIFY_EXCHANGE_ITEM_COUNT_REP(int InExchangeItemCount);
	void SC_CHARGE_INVOKE_SKILL_APPLY_INFO_REP(int InCasterSid, int InLaunchSkillCid, int InInvokeSkillCid, int InSkillResultTicket, TArray<struct FSkillApplyInfo>* InApplyInfos);
	void SC_INSIGHT_DOOR_REP(struct FDoorData* InDoorData);
	void SC_V2MISSION_UPDATE_CONTRACT_COUNT_REP(int InContractCount);
	void SC_SET_CONDITION_PHASE_VISIBILITY_REP(TEnumAsByte<ECEConditionPhaseType> InPhaseType, bool InIsVisible);
	void SC_UPDATE_PC_GUILD_MARK_REP(int InplayerSId, struct FGuildMarkData* InGuildMarkData);
	void SC_ENTER_ITEM_EVOLUTION_UI_REP();
	void SC_OPEN_DUNGEON_PARTY_MATCHING_UI_ACK(TEnumAsByte<EDungeonPartyMatchingErrorCode> InErrCode, int IndungeonCId, TArray<struct FDungeonPartyMatchingData>* IndungeonPartyMatchingDataList);
	void SC_RO_WAR_REALM_PLAYER_COUNT_REP(int InAttackerCount, int InDefenderCount);
	void SC_CREATE_GUILD_ACCEPT_RESPONSE_REP(int InrespondentSId, bool Inresponse);
	void SC_UPGRADE_POTENTIAL_LEVEL_ACK(TEnumAsByte<EEquipItemCustomErrorCode> InErrCode, unsigned char InPotentialLevel);
	void SC_OUTOFSIGHT_TRAP_REP(int InTrapSid);
	void SC_UPDATE_FLASH_SHOP_ITEM_REP(struct FFlashShopItemData* InItemData);
	void SC_RO_END_REP(struct FROResultData* InROResultData);
	void SC_CHANGE_TRAP_PHASE_REP(int InTrapSid, TEnumAsByte<ECETrapPhaseType> InPhase);
	void SC_TAKEOFF_SLOT_ITEM_ACK(TEnumAsByte<EItemEquipErrorCode> InErrorCode, TArray<struct FInventoryItemData>* InItemDataListArray);
	void SC_REMOVE_INVEN_ITEM_ACK(struct FInventoryItemData* InremovedItemData);
	void SC_DRAW_DEBUG_GEOMETRY_REP(TEnumAsByte<EGeometryType> InGeometry, int InColorR, int InColorG, int InColorB, int InSeconds, struct FVector* InLocation, struct FVector* InFactor);
	void SC_INITIAL_LUMENA_SHOP_REP(TArray<struct FLumenaShopItemData>* InItemData, struct FLumenaShopResetInfo* InLumenaShopResetInfo);
	void SC_OUTOFSIGHT_DOOR_REP(int InServerId, struct FDoorData* InDoorData);
	void SC_UPDATE_ABNORMAL_STATUS_REP(int InSidRPC, struct FAbnormalStatusData* InData);
	void SC_BUY_CRAFT_RECIPE_ACK(bool InbSuccess, int IncraftRecipeCId);
	void SC_MOVE_INVEN_TO_PERSONALINVEN_ITEM_ACK(TEnumAsByte<EItemAddErrorCode> InErrCode);
	void SC_CHECK_GUILD_NAME_ACK(TEnumAsByte<EGuildErrorCode> InErrCode, struct FString* InErrString);
	void SC_GACHA_START_REP();
	void SC_CHANGE_PROP_STATE_REP(int InSidProp, TEnumAsByte<ECEPropStateType> InOldState, TEnumAsByte<ECEPropStateType> InNewState);
	void SC_SPECIAL_WAR_TIME_REP(TEnumAsByte<ESpecialWarStateType> InspecialWarState, int InRemainSeconds);
	void SC_ENTER_AUCTION_REP();
	void SC_SURROUNDING_WORLD_ENVIRONMENT_ACK(struct FSurroundingWorldEnvironmentData* InEnvironmentData);
	void SC_SURROUNDING_WORLD_ENVIRONMENT_ACK_FAILED(int InErrorCode);
	void SC_REWARD_DAILY_ORDER_GOAL_ACK();
	void SC_REWARD_DAILY_ORDER_GOAL_ACK_FAILED(int InErrorCode);
	void SC_DISJOINT_POTENTIAL_EQUIP_ITEM_CUSTOM_ACK(TEnumAsByte<EEquipItemCustomErrorCode> InErrCode, bool InisGreatSuccess, int InItemCid, const struct FQWord& InCinis, const struct FQWord& InGold);
	void SC_REGISTER_SLOT_RUNE_SYSTEM_ACK(TEnumAsByte<ERuneSystemErrorCode> InErrCode, int InregisterItemSId);
	void SC_SPAWN_NPC_REP(struct FNPCData* InNPCData);
	void SC_STOP_MOVE_NPC_REP(int InPawnID, int InIsWalking, struct FVector* InStopLocation, struct FRotator* InStopRotation);
	void SC_MODIFY_GUILD_GRADE_AUTHORITY_ACK(TEnumAsByte<EGuildErrorCode> InErrCode);
	void SC_EXITED_FROM_COLOSSEUM_REP();
	void SC_FALLING_ESCAPE_ACK(TEnumAsByte<EFallingEscapeErrorCode> InErrCode);
	void SC_TALK_CHOOSE_SELECTION_ACK(int InNpcID, int InsecondaryNpcId, struct FTalkDialogInfo* InDialogInfo);
	void SC_ITEM_SUCCEED_ACK(bool InIsComplete, int InSucceedItemSid);
	void SC_LOGOFF_ACK();
	void SC_LOGOFF_ACK_FAILED(int InErrorCode);
	void SC_OPEN_UI_EXCHANGE_CONTENT_TOKEN_TO_LUMENA_ACK(int InCPtoLumena, int InDPtoLumena, int InExchangeableLumena, int InMaxExchangeCTtoLumena, int InaddtionalExchangeableLumena, int InLumenaExchangeResetTime);
	void SC_UPDATE_NPC_QUEST_INFO_REP(int InNpcSid, struct FNearNPCInfo* InnearNPCInfo);
	void SC_UPDATE_DAILY_ORDER_GOAL_REP(int IncurruntGoalCount, int InmaxGoalCount, int InrewardCid, TEnumAsByte<EOrderStateType> InState);
	void SC_TAMING_END_REP(int InOwnerPlayerSId, TEnumAsByte<ETamingEndState> InTamingEndState);
	void SC_INSIGHT_TRAP_VISION_SHARED_REP(struct FTrapData* InTrapData);
	void SC_UPDATE_ITEM_DATA_LIST_REP(TArray<struct FInventoryItemData>* InupdatedItemDataList);
	void SC_INSIGHT_PC_REP(struct FOtherPCData* InPCData);
	void SC_CHALLENGE_TOWER_ATTENTION_NPC_INFO_REP(TArray<struct FChallengeTowerAttentionNPCData>* InHolyNpcInfoArray);
	void SC_REMOVE_SKILL_REP(int InSkillCid);
	void SC_REMOVE_GUILD_GRADE_ACK(TEnumAsByte<EGuildErrorCode> InErrCode);
	void SC_SUGGEST_FIELD_CHANNEL_REP(int InChannelID, struct FString* InOtherPlayerName);
	void SC_MOVE_PARTY_MEMBER_REP(int InPartyID, int InSlotIndex, int InNewIndex);
	void SC_ADD_PARTY_MEMBER_REP(int InPartyID, struct FPartyMemberPCData* InMemberData);
	void SC_END_CHALLENGE_TOWER_REP(int InCompleteRound, int InElapsedTimeToSeconds, TArray<struct FChallengeTowerRoundResultInfoData>* InRoundResultInfoArray);
	void SC_UPDATE_MINING_LEVEL_REP(int InLevel);
	void SC_START_CHALLENGE_TOWER_WAITING_NEXT_ROUND_REP(int InRound);
	void SC_V2MISSION_UPDATE_UNLOCKED_MISSION_LEVEL_REP(int InUnlockedMissionLevel);
	void SC_ITEM_DESYNTHESIS_CASTING_END_REP(bool InIsComplete);
	void SC_CHARGE_ACTINGPOINT_ACK(bool InAcceptCharge, bool InbSuccess);
	void SC_REMOVE_PC_ACK(TArray<struct FSelectPCData>* InPCDataList);
	void SC_REMOVE_PC_ACK_FAILED(int InErrorCode, struct FString* InRemovePCName, struct FString* InErrString);
	void SC_NOTIFY_RO_ATTEND_START_REP(TEnumAsByte<ECERealmType> InRealmType);
	void SC_ITEMTRADE_START_TRADE_REP(int InPlayerSid1, int InPlayerSid2);
	void SC_DELETE_AUCTION_ACK(TEnumAsByte<EAuctionErrorCode> InErrCode);
	void SC_GUILD_INVITATION_REQ(int IninvitorSId, struct FString* IninvitorName, struct FString* InGuildName);
	void SC_NOTIFY_STOP_WAYPOINT_REP(int Inplayer_sid, int Ingoal_id, float InTimeInSeconds);
	void SC_SPECIALWAR_UPDATE_NPC_HP_RATIO_REP(int InNotiNPCCId, int InHPRatio);
	void SC_FIELD_CHANNEL_TRANSFER_RESULT_REP(int InChannelID, bool InSuccess, int InRemainTimeInMilliseconds);
	void SC_DRAW_DEBUG_AREA_SHAPE_REP(int InSeconds, struct FVector* InLocation, struct FRotator* InRotation, struct FAreaShapeData* InAreaShape, struct FColorData* InColor);
	void SC_UPDATE_MOUNT_PARAM_REP(const struct FQWord& InMPFUid, TArray<struct FMountParamData>* InMountParamList);
	void SC_MPF_LOCK_ACK(const struct FQWord& InMPFUid, bool InIsSuccess);
	void SC_CHARGE_ACTINGPOINT_COUNT_REP(int InCurrentChargedCount, int InMaxChargeCount);
	void SC_ITEMTRADE_INVITED_REQ(int InRequesterSid);
	void SC_GET_RECENT_AUCTION_LIST_ACK(TArray<struct FAuctionData>* InAuctionDataList);
	void SC_NOTIFY_DUNGEON_TIMER_REP(int InRemainTime, bool InisAlertState);
	void SC_NOTI_CHAIN_SWAP_COOLTIME_REP(const struct FQWord& InSwapCoolTimeTick);
	void SC_UPDATE_DAY_EXCHANGED_GEM_COUNT_REP(int Ingem_count);
	void SC_VERSION_REQ();
};


// Class BLGame.BLAnimInfo
// 0x0090 (0x00F0 - 0x0060)
class UBLAnimInfo : public UObject
{
public:
	TArray<struct FPCAnimationInfo>                    PCDefaultAnimSetInfoList;                                 // 0x0060(0x0010) (NeedCtorLink)
	TArray<struct FPCAnimationInfo>                    PCWeaponAnimSetInfoList;                                  // 0x0070(0x0010) (NeedCtorLink)
	TArray<struct FPCAnimationInfo>                    LegoNPCDefaultAnimSetInfoList;                            // 0x0080(0x0010) (NeedCtorLink)
	TArray<struct FPCAnimationInfo>                    LegoNPCCombatAnimSetInfoList;                             // 0x0090(0x0010) (NeedCtorLink)
	TArray<struct FPCAnimationInfo>                    LegoNPCSocialAnimSetInfoList;                             // 0x00A0(0x0010) (NeedCtorLink)
	TArray<struct FWeaponAnimSeqNamePair>              PCWeaponAnimSeqNamePairList;                              // 0x00B0(0x0010) (NeedCtorLink)
	TArray<struct FWeaponAnimSeqNamePair>              LegoNPCCombatAnimSeqNamePairList;                         // 0x00C0(0x0010) (NeedCtorLink)
	TArray<struct FString>                             NPCAnimSequenceNames;                                     // 0x00D0(0x0010) (NeedCtorLink)
	TArray<struct FNPCRequiredAnimSeqNames>            NPCAnimSeqNamesOfProductinCategory;                       // 0x00E0(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimInfo");
		return ptr;
	}


	struct FName STATIC_GetLegoNPCDefaultAnimSeqName(const struct FName& InWeaponAnimSeqName);
	struct FName STATIC_GetPCDefaultAnimSeqName(const struct FName& InWeaponAnimSeqName);
	struct FName STATIC_GetLegoNPCWeaponAnimSeqName(const struct FName& InDefaultAnimSeqName);
	struct FName STATIC_GetPCWeaponAnimSeqName(const struct FName& InDefaultAnimSeqName);
	void STATIC_GetNPCAnimSequenceNameListOfProductinCategory(TEnumAsByte<ECENPCProductionCategory> ProductionCategory, TArray<struct FString> OutAnimSeqNameList);
	void STATIC_GetNPCAnimSequenceNameList(TArray<struct FString> OutAnimSeqNameList);
	void STATIC_GetLegoNPCCombatAnimSeqNameList(TArray<struct FString> OutAnimSeqNameList);
	void STATIC_GetLegoNPCDefaultAnimSeqNameList(TArray<struct FString> OutAnimSeqNameList);
	void STATIC_GetPCWeaponAnimSeqNameList(TArray<struct FString> OutAnimSeqNameList);
	void STATIC_GetPCDefaultAnimSeqNameList(TArray<struct FString> OutAnimSeqNameList);
};


// Class BLGame.ContentInfo
// 0x0038 (0x0098 - 0x0060)
class UContentInfo : public UObject
{
public:
	int                                                Cid;                                                      // 0x0060(0x0004) (Const)
	struct FString                                     CodeName;                                                 // 0x0064(0x0010) (Const, NeedCtorLink)
	struct FString                                     LocalizedName;                                            // 0x0074(0x0010) (Const, NeedCtorLink)
	struct FString                                     Description;                                              // 0x0084(0x0010) (Const, NeedCtorLink)
	int                                                LocalizeOption;                                           // 0x0094(0x0004) (Config)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.ContentInfo");
		return ptr;
	}


	struct FString STATIC_GetString(const struct FString& XmlString);
};


// Class BLGame.AbnormalStatusGroupInfo
// 0x0000 (0x0098 - 0x0098)
class UAbnormalStatusGroupInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.AbnormalStatusGroupInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FAbnormalStatusGroupInfoData* OutInfoData);
};


// Class BLGame.AbnormalStatusInfo
// 0x0000 (0x0098 - 0x0098)
class UAbnormalStatusInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.AbnormalStatusInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FAbnormalStatusInfoData* OutInfoData);
};


// Class BLGame.AcceptableGuideInfo
// 0x0000 (0x0098 - 0x0098)
class UAcceptableGuideInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.AcceptableGuideInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FAcceptableGuideInfoData* OutInfoData);
};


// Class BLGame.AcquireFellowByItemInfo
// 0x0000 (0x0098 - 0x0098)
class UAcquireFellowByItemInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.AcquireFellowByItemInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FAcquireFellowByItemInfoData* OutInfoData);
};


// Class BLGame.AcquireFellowByTamingInfo
// 0x0000 (0x0098 - 0x0098)
class UAcquireFellowByTamingInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.AcquireFellowByTamingInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FAcquireFellowByTamingInfoData* OutInfoData);
};


// Class BLGame.AcquireMountByItemInfo
// 0x0000 (0x0098 - 0x0098)
class UAcquireMountByItemInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.AcquireMountByItemInfo");
		return ptr;
	}


	bool STATIC_FindInfoDataByName(struct FString* InName, struct FAcquireMountByItemInfoData* OutInfoData);
	bool STATIC_FindInfoData(int InCid, struct FAcquireMountByItemInfoData* OutInfoData);
};


// Class BLGame.AcquireMountByTamingInfo
// 0x0000 (0x0098 - 0x0098)
class UAcquireMountByTamingInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.AcquireMountByTamingInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FAcquireMountByTamingInfoData* OutInfoData);
};


// Class BLGame.AcquirePetByItemInfo
// 0x0000 (0x0098 - 0x0098)
class UAcquirePetByItemInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.AcquirePetByItemInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FAcquirePetByItemInfoData* OutInfoData);
};


// Class BLGame.AuraInfo
// 0x0000 (0x0098 - 0x0098)
class UAuraInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.AuraInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FAuraInfoData* OutInfoData);
};


// Class BLGame.BattlefieldApplicationUIInfo
// 0x0000 (0x0098 - 0x0098)
class UBattlefieldApplicationUIInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BattlefieldApplicationUIInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FBattlefieldApplicationUIInfoData* OutInfoData);
};


// Class BLGame.BattleFieldConstantInfo
// 0x0000 (0x0098 - 0x0098)
class UBattleFieldConstantInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BattleFieldConstantInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FBattleFieldConstantInfoData* OutInfoData);
};


// Class BLGame.BlessershipInfo
// 0x0000 (0x0098 - 0x0098)
class UBlessershipInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BlessershipInfo");
		return ptr;
	}

};


// Class BLGame.BurdenInfo
// 0x0000 (0x0098 - 0x0098)
class UBurdenInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BurdenInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FBurdenInfoData* OutInfoData);
};


// Class BLGame.CarryAnimInfo
// 0x0000 (0x0098 - 0x0098)
class UCarryAnimInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CarryAnimInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FCarryAnimInfoData* OutInfoData);
};


// Class BLGame.ChallengeTowerInfo
// 0x0000 (0x0098 - 0x0098)
class UChallengeTowerInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.ChallengeTowerInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FChallengeTowerInfoData* OutInfoData);
};


// Class BLGame.ChallengeTowerRankRewardInfo
// 0x0000 (0x0098 - 0x0098)
class UChallengeTowerRankRewardInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.ChallengeTowerRankRewardInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FChallengeTowerRankRewardInfoData* OutInfoData);
};


// Class BLGame.ChallengeTowerRefundInfo
// 0x0000 (0x0098 - 0x0098)
class UChallengeTowerRefundInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.ChallengeTowerRefundInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FChallengeTowerRefundInfoData* OutInfoData);
};


// Class BLGame.ChallengeTowerRoundInfo
// 0x0000 (0x0098 - 0x0098)
class UChallengeTowerRoundInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.ChallengeTowerRoundInfo");
		return ptr;
	}


	int STATIC_GetMaxRound();
	int STATIC_FindContentRewardByRank(int InRound, TEnumAsByte<ECEGradeType> InRank);
	bool STATIC_FindInfoData(int InCid, struct FChallengeTowerRoundInfoData* OutInfoData);
};


// Class BLGame.ChatChannelCommandInfo
// 0x0000 (0x0098 - 0x0098)
class UChatChannelCommandInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.ChatChannelCommandInfo");
		return ptr;
	}


	bool STATIC_FindInfoDataByName(struct FString* InName, struct FChatChannelCommandInfoData* OutInfoData);
	bool STATIC_FindInfoData(int InCid, struct FChatChannelCommandInfoData* OutInfoData);
};


// Class BLGame.ChattingCommandInfo
// 0x0000 (0x0098 - 0x0098)
class UChattingCommandInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.ChattingCommandInfo");
		return ptr;
	}


	bool STATIC_FindInfoDataByName(struct FString* InName, struct FChattingCommandInfoData* OutInfoData);
	bool STATIC_FindInfoData(int InCid, struct FChattingCommandInfoData* OutInfoData);
};


// Class BLGame.CinematicInfo
// 0x0000 (0x0098 - 0x0098)
class UCinematicInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CinematicInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FCinematicInfoData* OutInfoData);
};


// Class BLGame.CitadelConstBidInfo
// 0x0000 (0x0098 - 0x0098)
class UCitadelConstBidInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CitadelConstBidInfo");
		return ptr;
	}


	bool STATIC_GetInfoData(struct FCitadelConstBidInfoData* OutInfoData);
	bool STATIC_FindInfoData(int InCid, struct FCitadelConstBidInfoData* OutInfoData);
};


// Class BLGame.CitadelInfo
// 0x0000 (0x0098 - 0x0098)
class UCitadelInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CitadelInfo");
		return ptr;
	}


	void STATIC_ExportToArray(TArray<struct FCitadelOwnershipInfoData>* OutList);
	bool STATIC_FindInfoData(int InCid, struct FCitadelInfoData* OutInfoData);
};


// Class BLGame.CollectionBookConstInfo
// 0x0000 (0x0098 - 0x0098)
class UCollectionBookConstInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CollectionBookConstInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FCollectionBookConstInfoData* OutInfoData);
};


// Class BLGame.CollectionBookInfo
// 0x0000 (0x0098 - 0x0098)
class UCollectionBookInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CollectionBookInfo");
		return ptr;
	}


	bool STATIC_FindInfoDataBelongFellow(int InFellowCid, struct FCollectionBookInfoData* OutInfoData);
	bool STATIC_FindInfoDataBelongPet(int InPetCid, struct FCollectionBookInfoData* OutInfoData);
	bool STATIC_FindInfoDataBelongMount(int InMountCid, struct FCollectionBookInfoData* OutInfoData);
	bool STATIC_FindInfoData(int InCid, struct FCollectionBookInfoData* OutInfoData);
};


// Class BLGame.ColosseumWarInfo
// 0x0000 (0x0098 - 0x0098)
class UColosseumWarInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.ColosseumWarInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FColosseumWarInfoData* OutInfoData);
};


// Class BLGame.ContentActiveControlInfo
// 0x0000 (0x0098 - 0x0098)
class UContentActiveControlInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.ContentActiveControlInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FContentActiveControlInfoData* OutInfoData);
};


// Class BLGame.CraftBaseInfo
// 0x0000 (0x0098 - 0x0098)
class UCraftBaseInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CraftBaseInfo");
		return ptr;
	}

};


// Class BLGame.CraftInfo
// 0x0000 (0x0098 - 0x0098)
class UCraftInfo : public UCraftBaseInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CraftInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FCraftInfoBaseData* OutInfoData);
};


// Class BLGame.NPCCraftInfo
// 0x0000 (0x0098 - 0x0098)
class UNPCCraftInfo : public UCraftBaseInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.NPCCraftInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FCraftInfoBaseData* OutInfoData);
};


// Class BLGame.CraftChoiceUIInfo
// 0x0000 (0x0098 - 0x0098)
class UCraftChoiceUIInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CraftChoiceUIInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FCraftChoiceUIInfoData* OutInfoData);
};


// Class BLGame.CraftConstantInfo
// 0x0000 (0x0098 - 0x0098)
class UCraftConstantInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CraftConstantInfo");
		return ptr;
	}


	struct FCraftConstantInfoData STATIC_GetInfoData();
	bool STATIC_FindInfoData(int InCid, struct FCraftConstantInfoData* OutInfoData);
};


// Class BLGame.CraftLevelInfo
// 0x0000 (0x0098 - 0x0098)
class UCraftLevelInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CraftLevelInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InLevel, struct FV1CraftLevelInfoData* OutInfoData);
};


// Class BLGame.CraftSpotInfo
// 0x0000 (0x0098 - 0x0098)
class UCraftSpotInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CraftSpotInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InID, struct FCraftSpotInfoData* OutInfoData);
};


// Class BLGame.CraftUICategoryInfo
// 0x0000 (0x0098 - 0x0098)
class UCraftUICategoryInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CraftUICategoryInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FCraftUICategoryInfoData* OutInfoData);
};


// Class BLGame.CreditConstInfo
// 0x0000 (0x0098 - 0x0098)
class UCreditConstInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CreditConstInfo");
		return ptr;
	}

};


// Class BLGame.CreditInfo
// 0x001C (0x00B4 - 0x0098)
class UCreditInfo : public UContentInfo
{
public:
	struct FFontConfigSizeAndColor                     CreditPositionFont;                                       // 0x0098(0x0008) (Config)
	struct FFontConfigSizeAndColor                     CreditNameFont;                                           // 0x00A0(0x0008) (Config)
	struct FFontConfigSizeAndColor                     CreditESCFont;                                            // 0x00A8(0x0008) (Config)
	int                                                CreditSpaceSize;                                          // 0x00B0(0x0004) (Config)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CreditInfo");
		return ptr;
	}


	struct FString STATIC_GetCreditESCText();
	struct FString STATIC_GetCreditText();
	bool STATIC_FindInfoData(int InLine, struct FCreditInfoData* OutInfoData);
};


// Class BLGame.CustomizingBodyFatInfo
// 0x0000 (0x0098 - 0x0098)
class UCustomizingBodyFatInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CustomizingBodyFatInfo");
		return ptr;
	}

};


// Class BLGame.CustomizingCameraInfo
// 0x0000 (0x0098 - 0x0098)
class UCustomizingCameraInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CustomizingCameraInfo");
		return ptr;
	}

};


// Class BLGame.CustomizingColorInfo
// 0x0000 (0x0098 - 0x0098)
class UCustomizingColorInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CustomizingColorInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FCustomizingColorInfoData* OutInfoData);
};


// Class BLGame.CustomizingColorLimitInfo
// 0x0000 (0x0098 - 0x0098)
class UCustomizingColorLimitInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CustomizingColorLimitInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCustomizeType, struct FCustomizingColorLimitInfoData* OutInfoData);
};


// Class BLGame.CustomizingInfo
// 0x0000 (0x0098 - 0x0098)
class UCustomizingInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CustomizingInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCustomizeType, struct FCustomizingInfoData* OutData);
};


// Class BLGame.CustomizingMouseActionInfo
// 0x0000 (0x0098 - 0x0098)
class UCustomizingMouseActionInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CustomizingMouseActionInfo");
		return ptr;
	}

};


// Class BLGame.CustomizingPickingAreaInfo
// 0x0000 (0x0098 - 0x0098)
class UCustomizingPickingAreaInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CustomizingPickingAreaInfo");
		return ptr;
	}

};


// Class BLGame.CustomizingPresetInfo
// 0x0000 (0x0098 - 0x0098)
class UCustomizingPresetInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CustomizingPresetInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FCustomizingPresetInfoData* OutInfoData);
};


// Class BLGame.CustomizingPreviewEquipmentInfo
// 0x0000 (0x0098 - 0x0098)
class UCustomizingPreviewEquipmentInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CustomizingPreviewEquipmentInfo");
		return ptr;
	}

};


// Class BLGame.CustomizingRelatedPresetUIInfo
// 0x0000 (0x0098 - 0x0098)
class UCustomizingRelatedPresetUIInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CustomizingRelatedPresetUIInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FCustomizingRelatedPresetUIInfoData* OutInfoData);
};


// Class BLGame.CustomizingResourceInfo
// 0x0000 (0x0098 - 0x0098)
class UCustomizingResourceInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CustomizingResourceInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FCustomizingResourceInfoData* OutInfoData);
};


// Class BLGame.DefaultControlInfo
// 0x0000 (0x0098 - 0x0098)
class UDefaultControlInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.DefaultControlInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FDefaultControlInfoData* OutInfoData);
};


// Class BLGame.DefaultControlValue
// 0x0000 (0x0098 - 0x0098)
class UDefaultControlValue : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.DefaultControlValue");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FDefaultControlValueData* OutInfoData);
	bool STATIC_FindByInfoDataKey(struct FDefaultControlValueData* InInfoDataKey, struct FDefaultControlValueData* OutInfoData);
};


// Class BLGame.DestinationInfo
// 0x0000 (0x0098 - 0x0098)
class UDestinationInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.DestinationInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FDestinationInfoData* OutInfoData);
};


// Class BLGame.DialogInfo
// 0x0000 (0x0098 - 0x0098)
class UDialogInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.DialogInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InDialogID, struct FDialogInfoData* OutInfoData);
};


// Class BLGame.DungeonEntranceGroupInfo
// 0x0000 (0x0098 - 0x0098)
class UDungeonEntranceGroupInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.DungeonEntranceGroupInfo");
		return ptr;
	}


	bool STATIC_GetAllInfoDataList(TArray<struct FDungeonEntranceGroupInfoData>* outInfoDataList);
	bool STATIC_FindInfoData(int InCid, struct FDungeonEntranceGroupInfoData* OutInfoData);
};


// Class BLGame.EquipmentConstantInfo
// 0x0000 (0x0098 - 0x0098)
class UEquipmentConstantInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.EquipmentConstantInfo");
		return ptr;
	}

};


// Class BLGame.EquipmentLvUpgradeInfo
// 0x0000 (0x0098 - 0x0098)
class UEquipmentLvUpgradeInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.EquipmentLvUpgradeInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FEquipmentLvUpgradeInfoData* OutInfoData);
};


// Class BLGame.EquipSkillInfo
// 0x0000 (0x0098 - 0x0098)
class UEquipSkillInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.EquipSkillInfo");
		return ptr;
	}

};


// Class BLGame.EquipSlotInfo
// 0x0000 (0x0098 - 0x0098)
class UEquipSlotInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.EquipSlotInfo");
		return ptr;
	}


	bool STATIC_IsShowControlToggle(TEnumAsByte<ECEEquipSlotType> InSlotType);
	TEnumAsByte<ECEEquipSlotType> STATIC_ToEquip(TEnumAsByte<ECEEquipSlotType> InCostume);
	TEnumAsByte<ECEEquipSlotType> STATIC_ToCostume(TEnumAsByte<ECEEquipSlotType> InEquip);
	bool STATIC_FindInfoData(int InCid, struct FEquipSlotInfoData* OutInfoData);
};


// Class BLGame.FactionInfo
// 0x0000 (0x0098 - 0x0098)
class UFactionInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.FactionInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InSeasonID, struct FFactionInfoData* OutInfoData);
};


// Class BLGame.FellowConstInfo
// 0x0000 (0x0098 - 0x0098)
class UFellowConstInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.FellowConstInfo");
		return ptr;
	}

};


// Class BLGame.FellowExpInfo
// 0x0000 (0x0098 - 0x0098)
class UFellowExpInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.FellowExpInfo");
		return ptr;
	}


	void STATIC_FindLevelInfo(int InLevel, int* OutMinExp, int* OutMaxExp);
	bool STATIC_FindInfoData(int InLevel, struct FFellowExpInfoData* OutInfoData);
};


// Class BLGame.FellowGrowthValueInfo
// 0x0000 (0x0098 - 0x0098)
class UFellowGrowthValueInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.FellowGrowthValueInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FFellowGrowthValueInfoData* OutInfoData);
};


// Class BLGame.FellowInfo
// 0x0000 (0x0098 - 0x0098)
class UFellowInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.FellowInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FFellowInfoData* OutInfoData);
};


// Class BLGame.FellowIngredientExpInfo
// 0x0000 (0x0098 - 0x0098)
class UFellowIngredientExpInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.FellowIngredientExpInfo");
		return ptr;
	}


	int STATIC_GetCompanionIngredientExp(int InLevel, TEnumAsByte<ECECompanionGradeType> InGrade);
	bool STATIC_FindInfoData(int InLevel, struct FFellowIngredientExpInfoData* OutInfoData);
};


// Class BLGame.FellowLookInfo
// 0x0000 (0x0098 - 0x0098)
class UFellowLookInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.FellowLookInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, const struct FFellowLookInfoData& OutInfoData);
};


// Class BLGame.FellowSkillGroupInfo
// 0x0000 (0x0098 - 0x0098)
class UFellowSkillGroupInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.FellowSkillGroupInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FFellowSkillGroupInfoData* OutInfoData);
};


// Class BLGame.FellowSkillInfo
// 0x0000 (0x0098 - 0x0098)
class UFellowSkillInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.FellowSkillInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FFellowSkillInfoData* OutInfoData);
};


// Class BLGame.FellowSkillPoolInfo
// 0x0000 (0x0098 - 0x0098)
class UFellowSkillPoolInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.FellowSkillPoolInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FFellowSkillPoolInfoData* OutInfoData);
};


// Class BLGame.FieldInfo
// 0x0000 (0x0098 - 0x0098)
class UFieldInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.FieldInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FFieldInfoData* OutInfoData);
};


// Class BLGame.FixedChargeAdvInfo
// 0x0000 (0x0098 - 0x0098)
class UFixedChargeAdvInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.FixedChargeAdvInfo");
		return ptr;
	}

};


// Class BLGame.FlashShopInfo
// 0x0000 (0x0098 - 0x0098)
class UFlashShopInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.FlashShopInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FFlashShopInfoData* OutInfoData);
};


// Class BLGame.FobbidenKeyInfo
// 0x0000 (0x0098 - 0x0098)
class UFobbidenKeyInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.FobbidenKeyInfo");
		return ptr;
	}


	bool STATIC_IsUseCustomize(const struct FString& KeyName, TEnumAsByte<EBLTargetingMode> TargetingMode);
	bool STATIC_FindInfoData(int InCid, struct FFobbidenKeyInfoData* OutInfoData);
};


// Class BLGame.GameStringCharacterInfo
// 0x0000 (0x0098 - 0x0098)
class UGameStringCharacterInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.GameStringCharacterInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FGameStringCharacterInfoData* OutInfoData);
};


// Class BLGame.GameStringInfo
// 0x0000 (0x0098 - 0x0098)
class UGameStringInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.GameStringInfo");
		return ptr;
	}


	struct FString STATIC_GetGameStringWithCodeName(const struct FString& InCodeName);
	struct FString STATIC_GetGameString(int InCid);
	struct FString STATIC_FormatStringWIthCodeNameAndStringParam(const struct FString& InCodeName, const struct FString& InParamString);
	struct FString STATIC_FormatStringWithCodeName(const struct FString& InCodeName, TArray<struct FSystemMessageParamValueData>* InParamValueList);
	bool STATIC_FindInfoDataByName(const struct FString& InName, struct FGameStringInfoData* OutInfoData);
	bool STATIC_FindInfoData(int InCid, struct FGameStringInfoData* OutInfoData);
};


// Class BLGame.GatherCategoryInfo
// 0x0000 (0x0098 - 0x0098)
class UGatherCategoryInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.GatherCategoryInfo");
		return ptr;
	}

};


// Class BLGame.GatherConstantInfo
// 0x0000 (0x0098 - 0x0098)
class UGatherConstantInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.GatherConstantInfo");
		return ptr;
	}

};


// Class BLGame.GatherInfo
// 0x0000 (0x0098 - 0x0098)
class UGatherInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.GatherInfo");
		return ptr;
	}

};


// Class BLGame.GatherLevelInfo
// 0x0000 (0x0098 - 0x0098)
class UGatherLevelInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.GatherLevelInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InLevel, struct FGatherLevelInfoData* OutInfoData);
};


// Class BLGame.GemConstantInfo
// 0x0000 (0x0098 - 0x0098)
class UGemConstantInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.GemConstantInfo");
		return ptr;
	}

};


// Class BLGame.GempieceExchangeInfo
// 0x0000 (0x0098 - 0x0098)
class UGempieceExchangeInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.GempieceExchangeInfo");
		return ptr;
	}


	int STATIC_GetItemCount();
	int STATIC_GetParameterGemCount();
	int STATIC_GetNonStanceGemCount();
	int STATIC_GetStanceGemCount();
};


// Class BLGame.GuideStageInfo
// 0x0000 (0x0098 - 0x0098)
class UGuideStageInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.GuideStageInfo");
		return ptr;
	}


	int STATIC_GetGuideStageCidFromQuestCid(int InCid);
	bool STATIC_FindInfoData(int InCid, struct FGuideStageInfoData* OutInfoData);
};


// Class BLGame.GuildConstantInfo
// 0x0000 (0x0098 - 0x0098)
class UGuildConstantInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.GuildConstantInfo");
		return ptr;
	}


	int STATIC_GetWarRewardRank(int InWinCount);
};


// Class BLGame.GuildCreateInfo
// 0x0000 (0x0098 - 0x0098)
class UGuildCreateInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.GuildCreateInfo");
		return ptr;
	}

};


// Class BLGame.GuildGradeInfo
// 0x0000 (0x0098 - 0x0098)
class UGuildGradeInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.GuildGradeInfo");
		return ptr;
	}


	struct FString STATIC_GetGuildGradeName(TEnumAsByte<ECEGuildGradeType> grade_type);
	bool STATIC_FindInfoData(int InCid, struct FGuildGradeInfoData* OutInfoData);
};


// Class BLGame.GuildHistoryInfo
// 0x0000 (0x0098 - 0x0098)
class UGuildHistoryInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.GuildHistoryInfo");
		return ptr;
	}


	struct FString STATIC_FormatMessageByName(struct FString* InCodeName, TArray<struct FSystemMessageParamValueData>* InParamValueList);
	struct FString STATIC_FormatMessage(int InCid, TArray<struct FSystemMessageParamValueData>* InParamValueList);
	bool STATIC_FindInfoData(int InCid, struct FGuildHistoryInfoData* OutInfoData);
};


// Class BLGame.GuildJoinInfo
// 0x0000 (0x0098 - 0x0098)
class UGuildJoinInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.GuildJoinInfo");
		return ptr;
	}

};


// Class BLGame.GuildLevelInfo
// 0x0000 (0x0098 - 0x0098)
class UGuildLevelInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.GuildLevelInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FGuildLevelInfoData* OutInfoData);
};


// Class BLGame.GuildMarkBackgroundInfo
// 0x0000 (0x0098 - 0x0098)
class UGuildMarkBackgroundInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.GuildMarkBackgroundInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FGuildMarkBackgroundInfoData* OutInfoData);
};


// Class BLGame.GuildMarkSymbolInfo
// 0x0000 (0x0098 - 0x0098)
class UGuildMarkSymbolInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.GuildMarkSymbolInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FGuildMarkSymbolInfoData* OutInfoData);
};


// Class BLGame.GuildWarInfo
// 0x0000 (0x0098 - 0x0098)
class UGuildWarInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.GuildWarInfo");
		return ptr;
	}

};


// Class BLGame.GuildWarSeasonInfo
// 0x0000 (0x0098 - 0x0098)
class UGuildWarSeasonInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.GuildWarSeasonInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InSeasonID, struct FGuildWarSeasonInfoData* OutInfoData);
};


// Class BLGame.HelpInfo
// 0x0000 (0x0098 - 0x0098)
class UHelpInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.HelpInfo");
		return ptr;
	}


	bool STATIC_FindInfoDataByName(struct FString* InName, struct FHelpContentInfoData* OutInfoData);
	bool STATIC_FindInfoData(int InCid, struct FHelpContentInfoData* OutInfoData);
};


// Class BLGame.InstantDungeonConstInfo
// 0x0000 (0x0098 - 0x0098)
class UInstantDungeonConstInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.InstantDungeonConstInfo");
		return ptr;
	}


	bool STATIC_GetInfoData(struct FInstantDungeonConstInfoData* OutInfoData);
	bool STATIC_FindInfoData(int InCid, struct FInstantDungeonConstInfoData* OutInfoData);
};


// Class BLGame.InstantDungeonInfo
// 0x0000 (0x0098 - 0x0098)
class UInstantDungeonInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.InstantDungeonInfo");
		return ptr;
	}


	bool STATIC_FindInfoDataByName(struct FString* InName, struct FInstantDungeonInfoData* OutInfoData);
	bool STATIC_FindInfoData(int InCid, struct FInstantDungeonInfoData* OutInfoData);
};


// Class BLGame.InstantFieldInfo
// 0x0000 (0x0098 - 0x0098)
class UInstantFieldInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.InstantFieldInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FInstantFieldInfoData* OutInfoData);
};


// Class BLGame.InventoryConstantValueInfo
// 0x0000 (0x0098 - 0x0098)
class UInventoryConstantValueInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.InventoryConstantValueInfo");
		return ptr;
	}

};


// Class BLGame.InventoryExpansionInfo
// 0x0000 (0x0098 - 0x0098)
class UInventoryExpansionInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.InventoryExpansionInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FInventoryExpansionInfoData* OutInfoData);
};


// Class BLGame.InventoryTabInfo
// 0x0000 (0x0098 - 0x0098)
class UInventoryTabInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.InventoryTabInfo");
		return ptr;
	}


	TEnumAsByte<ECEInventoryType> STATIC_FindInventoryType(TEnumAsByte<ECEItemCategoryType> ItemCategoryType);
};


// Class BLGame.ItemActiveConstInfo
// 0x0000 (0x0098 - 0x0098)
class UItemActiveConstInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.ItemActiveConstInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FItemActiveConstInfoData* OutInfoData);
};


// Class BLGame.ItemCategoryInfo
// 0x0000 (0x0098 - 0x0098)
class UItemCategoryInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.ItemCategoryInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FItemCategoryInfoData* OutInfoData);
};


// Class BLGame.ItemDropTableInfo
// 0x0000 (0x0098 - 0x0098)
class UItemDropTableInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.ItemDropTableInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FItemDropTableInfoData* OutInfoData);
};


// Class BLGame.ItemEquipTypeInfo
// 0x0000 (0x0098 - 0x0098)
class UItemEquipTypeInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.ItemEquipTypeInfo");
		return ptr;
	}


	bool STATIC_FindByEquipType(TEnumAsByte<ECEItemEquipSlotType> InEquipType, struct FItemEquipTypeInfoData* OutInfoData);
	bool STATIC_FindInfoData(int InCid, struct FItemEquipTypeInfoData* OutInfoData);
};


// Class BLGame.ItemInfo
// 0x0000 (0x0098 - 0x0098)
class UItemInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.ItemInfo");
		return ptr;
	}


	struct FString STATIC_GetLocalizeStringWithGradeColor(bool WithBrackets, bool UseQuestItemColor, struct FItemInfoData* InData, class UBLItem** InItem);
	struct FString STATIC_FindPotentialDescription(int PotentialLevel);
	bool STATIC_FindInfoDataByName(struct FString* InName, struct FItemInfoData* OutInfoData);
	bool STATIC_FindInfoData(int InCid, struct FItemInfoData* OutInfoData);
};


// Class BLGame.ItemLegendOptionInfo
// 0x0000 (0x0098 - 0x0098)
class UItemLegendOptionInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.ItemLegendOptionInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FItemLegendOptionInfoData* OutInfoData);
};


// Class BLGame.ItemLegendOptionPoolInfo
// 0x0000 (0x0098 - 0x0098)
class UItemLegendOptionPoolInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.ItemLegendOptionPoolInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FItemLegendOptionPoolInfoData* OutInfoData);
};


// Class BLGame.LetterInfo
// 0x0000 (0x0098 - 0x0098)
class ULetterInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.LetterInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FLetterInfoData* OutInfoData);
};


// Class BLGame.LocationInfo
// 0x0000 (0x0098 - 0x0098)
class ULocationInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.LocationInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FLocationInfoData* OutInfoData);
};


// Class BLGame.LumenaShopInfo
// 0x0000 (0x0098 - 0x0098)
class ULumenaShopInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.LumenaShopInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FLumenaShopInfoData* OutInfoData);
};


// Class BLGame.LumenaShopProductInfo
// 0x0000 (0x0098 - 0x0098)
class ULumenaShopProductInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.LumenaShopProductInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FLumenaShopProductInfoData* OutInfoData);
};


// Class BLGame.MissionConstInfo
// 0x0000 (0x0098 - 0x0098)
class UMissionConstInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MissionConstInfo");
		return ptr;
	}

};


// Class BLGame.MissionInfo
// 0x0000 (0x0098 - 0x0098)
class UMissionInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MissionInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FMissionInfoData* OutInfoData);
};


// Class BLGame.MissionLevelInfo
// 0x0000 (0x0098 - 0x0098)
class UMissionLevelInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MissionLevelInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FMissionLevelInfoData* OutInfoData);
};


// Class BLGame.MissionOptionInfo
// 0x0000 (0x0098 - 0x0098)
class UMissionOptionInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MissionOptionInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FMissionOptionInfoData* OutInfoData);
};


// Class BLGame.MonologInfo
// 0x0000 (0x0098 - 0x0098)
class UMonologInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MonologInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InMonologID, struct FMonologInfoData* OutInfoData);
};


// Class BLGame.MonsterBookInfo
// 0x0000 (0x0098 - 0x0098)
class UMonsterBookInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MonsterBookInfo");
		return ptr;
	}


	int STATIC_GetTotalBookCountInLocation(int InLocationId, TEnumAsByte<ECERealmType> InRealmType);
	bool STATIC_FindInfoData(int InCid, struct FMonsterBookInfoData* OutInfoData);
};


// Class BLGame.MonsterBookMinimapInfo
// 0x0000 (0x0098 - 0x0098)
class UMonsterBookMinimapInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MonsterBookMinimapInfo");
		return ptr;
	}

};


// Class BLGame.MountActiveSkillInfo
// 0x0000 (0x0098 - 0x0098)
class UMountActiveSkillInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MountActiveSkillInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FMountActiveSkillInfoData* OutInfoData);
};


// Class BLGame.MountAnimInfo
// 0x0000 (0x0098 - 0x0098)
class UMountAnimInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MountAnimInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FMountAnimInfoData* OutInfoData);
};


// Class BLGame.MountExpInfo
// 0x0000 (0x0098 - 0x0098)
class UMountExpInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MountExpInfo");
		return ptr;
	}


	void STATIC_FindLevelInfo(int KeyLevel, int* OutMinExp, int* OutMaxExp);
	bool STATIC_FindInfoData(int KeyLevel, struct FMountExpInfoData* OutInfoData);
};


// Class BLGame.MountGradeFXInfo
// 0x0000 (0x0098 - 0x0098)
class UMountGradeFXInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MountGradeFXInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FMountGradeFXInfoData* OutInfoData);
};


// Class BLGame.MountGrowthValueInfo
// 0x0000 (0x0098 - 0x0098)
class UMountGrowthValueInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MountGrowthValueInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FMountGrowthValueInfoData* OutInfoData);
};


// Class BLGame.MountInfo
// 0x0000 (0x0098 - 0x0098)
class UMountInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MountInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FMountInfoData* OutInfoData);
};


// Class BLGame.MountIngredientExpInfo
// 0x0000 (0x0098 - 0x0098)
class UMountIngredientExpInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MountIngredientExpInfo");
		return ptr;
	}


	int STATIC_GetCompanionIngredientExp(int InLevel, TEnumAsByte<ECECompanionGradeType> InGrade);
	bool STATIC_FindInfoData(int InLevel, struct FMountIngredientExpInfoData* OutInfoData);
};


// Class BLGame.MountLookInfo
// 0x0000 (0x0098 - 0x0098)
class UMountLookInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MountLookInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FMountLookInfoData* OutInfoData);
};


// Class BLGame.MountPassiveSkillInfo
// 0x0000 (0x0098 - 0x0098)
class UMountPassiveSkillInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MountPassiveSkillInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FMountPassiveSkillInfoData* OutInfoData);
};


// Class BLGame.MountSkillGroupInfo
// 0x0000 (0x0098 - 0x0098)
class UMountSkillGroupInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MountSkillGroupInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FMountSkillGroupInfoData* OutInfoData);
};


// Class BLGame.MountSkillInfo
// 0x0000 (0x0098 - 0x0098)
class UMountSkillInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MountSkillInfo");
		return ptr;
	}


	struct FString STATIC_GetToolTip(int InCid);
	bool STATIC_FindInfoData(int InCid, struct FMountSkillInfoData* OutInfoData);
};


// Class BLGame.MountSkillPoolInfo
// 0x0000 (0x0098 - 0x0098)
class UMountSkillPoolInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MountSkillPoolInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FMountSkillPoolInfoData* OutInfoData);
};


// Class BLGame.MPFCompanionItemFixSlotInfo
// 0x0000 (0x0098 - 0x0098)
class UMPFCompanionItemFixSlotInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MPFCompanionItemFixSlotInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(TEnumAsByte<ECECompanionSlotType> InCompanionSlotType, struct FMPFCompanionItemFixSlotInfoData* OutInfoData);
};


// Class BLGame.NodeInfo
// 0x0000 (0x0098 - 0x0098)
class UNodeInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.NodeInfo");
		return ptr;
	}

};


// Class BLGame.NodeSelectionInfo
// 0x0000 (0x0098 - 0x0098)
class UNodeSelectionInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.NodeSelectionInfo");
		return ptr;
	}

};


// Class BLGame.NonStanceSkillInfo
// 0x0000 (0x0098 - 0x0098)
class UNonStanceSkillInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.NonStanceSkillInfo");
		return ptr;
	}

};


// Class BLGame.NPCAnimationSequenceInfo
// 0x0000 (0x0098 - 0x0098)
class UNPCAnimationSequenceInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.NPCAnimationSequenceInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FNPCAnimationSequenceInfoData* OutInfoData);
};


// Class BLGame.NPCInfo
// 0x0000 (0x0098 - 0x0098)
class UNPCInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.NPCInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FNPCInfoData* OutInfoData);
};


// Class BLGame.NPCMapInfo
// 0x0040 (0x00D8 - 0x0098)
class UNPCMapInfo : public UContentInfo
{
public:
	int                                                NPC_Sid;                                                  // 0x0098(0x0004) (Transient)
	TEnumAsByte<ECENPCCategory>                        NPCCategory;                                              // 0x009C(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x009D(0x0003) MISSED OFFSET
	struct FString                                     LevelName;                                                // 0x00A0(0x0010) (AlwaysInit, NeedCtorLink)
	struct FString                                     LevelCodeName;                                            // 0x00B0(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<struct FVector>                             Location;                                                 // 0x00C0(0x0010) (NeedCtorLink)
	int                                                WorldMapCId;                                              // 0x00D0(0x0004)
	int                                                CategoryAdditionalInfo;                                   // 0x00D4(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.NPCMapInfo");
		return ptr;
	}

};


// Class BLGame.OccupationWarInfo
// 0x0000 (0x0098 - 0x0098)
class UOccupationWarInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.OccupationWarInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FOccupationWarInfoData* OutInfoData);
};


// Class BLGame.OccupationWarPropInfo
// 0x0000 (0x0098 - 0x0098)
class UOccupationWarPropInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.OccupationWarPropInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FOccupationWarPropInfoData* OutInfoData);
};


// Class BLGame.OccupationWarRewardInfo
// 0x0000 (0x0098 - 0x0098)
class UOccupationWarRewardInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.OccupationWarRewardInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FOccupationWarRewardInfoData* OutInfoData);
};


// Class BLGame.OpenerAvailableInfo
// 0x0000 (0x0098 - 0x0098)
class UOpenerAvailableInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.OpenerAvailableInfo");
		return ptr;
	}


	bool STATIC_FindInfoDataByName(struct FString* InName, struct FOpenerAvailableInfoData* OutInfoData);
	bool STATIC_FindInfoData(int InCid, struct FOpenerAvailableInfoData* OutInfoData);
};


// Class BLGame.OpenerWindowInfo
// 0x0000 (0x0098 - 0x0098)
class UOpenerWindowInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.OpenerWindowInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FOpenerWindowInfoData* OutInfoData);
};


// Class BLGame.OrderConstInfo
// 0x0000 (0x0098 - 0x0098)
class UOrderConstInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.OrderConstInfo");
		return ptr;
	}


	bool STATIC_GetInfoData(struct FOrderConstInfoData* OutInfoData);
	bool STATIC_FindInfoData(int InOrderCid, struct FOrderConstInfoData* OutInfoData);
};


// Class BLGame.OrderInfo
// 0x0000 (0x0098 - 0x0098)
class UOrderInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.OrderInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InOrderCid, struct FOrderContentInfoData* OutInfoData);
};


// Class BLGame.OrderRewardInfo
// 0x0000 (0x0098 - 0x0098)
class UOrderRewardInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.OrderRewardInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FOrderRewardInfoData* OutInfoData);
};


// Class BLGame.ParameterConstInfo
// 0x0000 (0x0098 - 0x0098)
class UParameterConstInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.ParameterConstInfo");
		return ptr;
	}

};


// Class BLGame.ParameterDisplayInfo
// 0x0000 (0x0098 - 0x0098)
class UParameterDisplayInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.ParameterDisplayInfo");
		return ptr;
	}

};


// Class BLGame.ParameterGrowthInfo
// 0x0000 (0x0098 - 0x0098)
class UParameterGrowthInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.ParameterGrowthInfo");
		return ptr;
	}

};


// Class BLGame.ParameterUIInfo
// 0x0000 (0x0098 - 0x0098)
class UParameterUIInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.ParameterUIInfo");
		return ptr;
	}


	bool STATIC_FindInfoDataByKey(struct FParameterUIInfoKey* InKey, struct FParameterUIInfoData* OutInfoData);
};


// Class BLGame.PartyEffectCombatInfo
// 0x0068 (0x0100 - 0x0098)
class UPartyEffectCombatInfo : public UContentInfo
{
public:
	struct FPartyEffectCombatInfoData                  Info;                                                     // 0x0098(0x0068) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PartyEffectCombatInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FPartyEffectCombatInfoData* OutInfoData);
};


// Class BLGame.PartyEffectInfo
// 0x0068 (0x0100 - 0x0098)
class UPartyEffectInfo : public UContentInfo
{
public:
	struct FPartyEffectInfoData                        Info;                                                     // 0x0098(0x0068) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PartyEffectInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FPartyEffectInfoData* OutInfoData);
};


// Class BLGame.PartyEffectLivingInfo
// 0x0068 (0x0100 - 0x0098)
class UPartyEffectLivingInfo : public UContentInfo
{
public:
	struct FPartyEffectLivingInfoData                  Info;                                                     // 0x0098(0x0068) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PartyEffectLivingInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FPartyEffectLivingInfoData* OutInfoData);
};


// Class BLGame.PartyEffectUICategoryInfo
// 0x0034 (0x00CC - 0x0098)
class UPartyEffectUICategoryInfo : public UContentInfo
{
public:
	struct FPartyEffectUICategoryInfoData              InfoData;                                                 // 0x0098(0x0034) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PartyEffectUICategoryInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FPartyEffectUICategoryInfoData* OutInfoData);
};


// Class BLGame.PCActionInfo
// 0x0000 (0x0098 - 0x0098)
class UPCActionInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PCActionInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FPCActionInfoData* OutInfoData);
};


// Class BLGame.PCAnimationSequenceInfo
// 0x0000 (0x0098 - 0x0098)
class UPCAnimationSequenceInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PCAnimationSequenceInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FPCAnimationSequenceInfoData* OutInfoData);
};


// Class BLGame.PCClassConstantValueInfo
// 0x0000 (0x0098 - 0x0098)
class UPCClassConstantValueInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PCClassConstantValueInfo");
		return ptr;
	}


	bool STATIC_CanDispelAbnormalStatusGroup(TEnumAsByte<ECEClassType> InClassType, int InAbnormalStatusGroupCid);
	int STATIC_FindVoluntaryActionID(TEnumAsByte<ECEClassType> InClassType, int InIndex);
	bool STATIC_FindInfoData(int InCid, struct FPCClassConstantValueInfoData* OutInfoData);
};


// Class BLGame.PCCommonConstantValueInfo
// 0x0000 (0x0098 - 0x0098)
class UPCCommonConstantValueInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PCCommonConstantValueInfo");
		return ptr;
	}


	bool STATIC_GetInfoData(struct FPCCommonConstantValueInfoData* OutInfoData);
	bool STATIC_FindInfoData(int InCid, struct FPCCommonConstantValueInfoData* OutInfoData);
};


// Class BLGame.PCControlInfo
// 0x0000 (0x0098 - 0x0098)
class UPCControlInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PCControlInfo");
		return ptr;
	}


	void STATIC_ParseActionEnum(int InEnum, struct FName* OutAcitonName, TEnumAsByte<EBLTargetingMode>* OutTargetingMode);
	struct FName STATIC_EnumToActionName(int InEnum, TEnumAsByte<EBLTargetingMode> InTargetingMode);
	int STATIC_ActionNameToEnum(const struct FName& InActionName, TEnumAsByte<EBLTargetingMode> InTargetingMode);
	void STATIC_BuildActionNameToEnum();
	bool STATIC_GetKeyDataByCodeName(TEnumAsByte<EKeyDataType> InKeyType, struct FString* InCodeName, TArray<struct FKeyInputData>* OutData);
	bool STATIC_GetKeyData(TEnumAsByte<EKeyDataType> InKeyType, int InIndex, TArray<struct FKeyInputData>* OutData);
	bool STATIC_FindInfoData(int InCid, struct FPCControlInfoData* OutInfoData);
};


// Class BLGame.PCCreateInfo
// 0x0000 (0x0098 - 0x0098)
class UPCCreateInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PCCreateInfo");
		return ptr;
	}


	int STATIC_CalcPCCreateInfoId(TEnumAsByte<ECERaceType> InRaceType, TEnumAsByte<ECEGenderType> InGenderType, TEnumAsByte<ECEClassType> InClassType);
	bool STATIC_FindInfoData(int InCid, struct FPCCreateInfoData* OutInfoData);
};


// Class BLGame.PCGrowthValueInfo
// 0x0000 (0x0098 - 0x0098)
class UPCGrowthValueInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PCGrowthValueInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FPCGrowthValueInfoData* OutInfoData);
};


// Class BLGame.PCInfo
// 0x0000 (0x0098 - 0x0098)
class UPCInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PCInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FPCInfoData* OutInfoData);
	bool STATIC_FindInfoDataByKey(struct FPCInfoKey* InKey, struct FPCInfoData* OutInfoData);
};


// Class BLGame.PCLimitedRankGrowthValueInfo
// 0x0000 (0x0098 - 0x0098)
class UPCLimitedRankGrowthValueInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PCLimitedRankGrowthValueInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FPCLimitedRankGrowthValueInfoData* OutInfoData);
};


// Class BLGame.PCNormalAttackAnimInfo
// 0x0000 (0x0098 - 0x0098)
class UPCNormalAttackAnimInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PCNormalAttackAnimInfo");
		return ptr;
	}


	float STATIC_FindPCNormalAttackHittingTime(TEnumAsByte<ECEClassType> InClassType, TEnumAsByte<ECENormalAttackEquipType> InEquipType, int InSequenceNum);
	int STATIC_CalcPCNormalAttackAnimInfoIndex(TEnumAsByte<ECEClassType> InClassType, TEnumAsByte<ECENormalAttackEquipType> InEquipType, int InSequenceNum);
	bool STATIC_FindInfoData(int InCid, struct FPCNormalAttackAnimInfoData* OutInfoData);
};


// Class BLGame.PCRankConstantValueInfo
// 0x0000 (0x0098 - 0x0098)
class UPCRankConstantValueInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PCRankConstantValueInfo");
		return ptr;
	}


	bool STATIC_GetInfoData(struct FPCRankConstantValueInfoData* OutInfoData);
	bool STATIC_FindInfoData(int InCid, struct FPCRankConstantValueInfoData* OutInfoData);
};


// Class BLGame.PCRankGrowthValueInfo
// 0x0000 (0x0098 - 0x0098)
class UPCRankGrowthValueInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PCRankGrowthValueInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InRankID, struct FPCRankGrowthValueInfoData* OutInfoData);
};


// Class BLGame.PCReturnInfo
// 0x0000 (0x0098 - 0x0098)
class UPCReturnInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PCReturnInfo");
		return ptr;
	}


	bool STATIC_FindAcceptReturnData(int InReturnCoolTime, int* OutLumena, int* OutTime);
	bool STATIC_FindInfoData(int InCid, struct FPCReturnInfoData* OutInfoData);
};


// Class BLGame.PCVoiceCustomizingInfo
// 0x0000 (0x0098 - 0x0098)
class UPCVoiceCustomizingInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PCVoiceCustomizingInfo");
		return ptr;
	}


	bool STATIC_FindInfoDataByType(TEnumAsByte<ECERaceType> InRace, TEnumAsByte<ECEGenderType> InGender, struct FPCVoiceCustomizingInfoData* OutInfoData);
	bool STATIC_FindInfoData(int InCid, struct FPCVoiceCustomizingInfoData* OutInfoData);
};


// Class BLGame.PetAcquireByTamingInfo
// 0x0000 (0x0098 - 0x0098)
class UPetAcquireByTamingInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PetAcquireByTamingInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FPetAcquireByTamingInfoData* OutInfoData);
};


// Class BLGame.PetConstInfo
// 0x0000 (0x0098 - 0x0098)
class UPetConstInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PetConstInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FPetConstInfoData* OutInfoData);
};


// Class BLGame.PetExpInfo
// 0x0000 (0x0098 - 0x0098)
class UPetExpInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PetExpInfo");
		return ptr;
	}


	void STATIC_FindLevelInfo(int InLevel, int* OutMinExp, int* OutMaxExp);
	bool STATIC_FindInfoData(int InLevel, struct FPetExpInfoData* OutInfoData);
};


// Class BLGame.PetGradeFXInfo
// 0x0000 (0x0098 - 0x0098)
class UPetGradeFXInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PetGradeFXInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FPetGradeFXInfoData* OutInfoData);
};


// Class BLGame.PetGrowthValueInfo
// 0x0000 (0x0098 - 0x0098)
class UPetGrowthValueInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PetGrowthValueInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FPetGrowthValueInfoData* OutInfoData);
};


// Class BLGame.PetInfo
// 0x0000 (0x0098 - 0x0098)
class UPetInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PetInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FPetInfoData* OutInfoData);
};


// Class BLGame.PetIngredientExpInfo
// 0x0000 (0x0098 - 0x0098)
class UPetIngredientExpInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PetIngredientExpInfo");
		return ptr;
	}


	int STATIC_GetCompanionIngredientExp(int InLevel, TEnumAsByte<ECECompanionGradeType> InGrade);
	bool STATIC_FindInfoData(int InLevel, struct FPetIngredientExpInfoData* OutInfoData);
};


// Class BLGame.PetLookInfo
// 0x0000 (0x0098 - 0x0098)
class UPetLookInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PetLookInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FPetLookInfoData* OutInfoData);
};


// Class BLGame.PetSkillGroupInfo
// 0x0000 (0x0098 - 0x0098)
class UPetSkillGroupInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PetSkillGroupInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FPetSkillGroupInfoData* OutInfoData);
};


// Class BLGame.PetSkillInfo
// 0x0000 (0x0098 - 0x0098)
class UPetSkillInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PetSkillInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FPetSkillInfoData* OutInfoData);
};


// Class BLGame.PetSkillPoolInfo
// 0x0000 (0x0098 - 0x0098)
class UPetSkillPoolInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PetSkillPoolInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FPetSkillPoolInfoData* OutInfoData);
};


// Class BLGame.PhaseFieldInfo
// 0x0000 (0x0098 - 0x0098)
class UPhaseFieldInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PhaseFieldInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FPhaseFieldInfoData* OutInfoData);
};


// Class BLGame.PropAdditionalInfo
// 0x0010 (0x00A8 - 0x0098)
class UPropAdditionalInfo : public UContentInfo
{
public:
	TArray<struct FBLPropRelativeQuestInfo>            PropRelativeQuestInfoList;                                // 0x0098(0x0010) (AlwaysInit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PropAdditionalInfo");
		return ptr;
	}

};


// Class BLGame.PropInfo
// 0x0000 (0x0098 - 0x0098)
class UPropInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PropInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FPropInfoData* OutInfoData);
};


// Class BLGame.PropMapInfo
// 0x0000 (0x0098 - 0x0098)
class UPropMapInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PropMapInfo");
		return ptr;
	}

};


// Class BLGame.QuestAdditionalInfo
// 0x0000 (0x0098 - 0x0098)
class UQuestAdditionalInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.QuestAdditionalInfo");
		return ptr;
	}

};


// Class BLGame.QuestConstInfo
// 0x0000 (0x0098 - 0x0098)
class UQuestConstInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.QuestConstInfo");
		return ptr;
	}

};


// Class BLGame.QuestInfo
// 0x0000 (0x0098 - 0x0098)
class UQuestInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.QuestInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InQuestCid, struct FQuestInfoData* OutInfoData);
	bool STATIC_IsShowRewardWindow(struct FQuestInfoData* InInfoData);
	struct FString STATIC_GetPlotName(struct FQuestInfoData* InInfoData);
	struct FString STATIC_GetStoryName(struct FQuestInfoData* InInfoData);
};


// Class BLGame.QuestMinimapInfo
// 0x0030 (0x00C8 - 0x0098)
class UQuestMinimapInfo : public UContentInfo
{
public:
	TArray<struct FQuestNPCMarker>                     QuestGiverLocationInfo;                                   // 0x0098(0x0010) (Const, NeedCtorLink)
	TArray<struct FQuestNPCMarker>                     QuestRewarderLocationInfo;                                // 0x00A8(0x0010) (Const, NeedCtorLink)
	TArray<struct FQuestArea>                          ObjectiveQuestAreaInfo;                                   // 0x00B8(0x0010) (Const, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.QuestMinimapInfo");
		return ptr;
	}

};


// Class BLGame.QuestRaceStoryInfo
// 0x0000 (0x0098 - 0x0098)
class UQuestRaceStoryInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.QuestRaceStoryInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InQuestCid, struct FQuestRaceStoryInfoData* OutInfoData);
};


// Class BLGame.QuestStoryInfo
// 0x0000 (0x0098 - 0x0098)
class UQuestStoryInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.QuestStoryInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InQuestCid, struct FQuestStoryInfoData* OutInfoData);
};


// Class BLGame.RaceClassInfo
// 0x0000 (0x0098 - 0x0098)
class URaceClassInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.RaceClassInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InRaceType, struct FRaceClassInfoData* OutInfoData);
};


// Class BLGame.RaidFieldInfo
// 0x0000 (0x0098 - 0x0098)
class URaidFieldInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.RaidFieldInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FRaidFieldInfoData* OutInfoData);
};


// Class BLGame.RealmOwnerRewardInfo
// 0x0000 (0x0098 - 0x0098)
class URealmOwnerRewardInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.RealmOwnerRewardInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FRealmOwnerRewardInfoData* OutInfoData);
};


// Class BLGame.RealmOwnershipInfo
// 0x0000 (0x0098 - 0x0098)
class URealmOwnershipInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.RealmOwnershipInfo");
		return ptr;
	}


	bool STATIC_GetInfoData(struct FRealmOwnershipInfoData* OutInfoData);
};


// Class BLGame.RealmOwnerStatueInfo
// 0x0000 (0x0098 - 0x0098)
class URealmOwnerStatueInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.RealmOwnerStatueInfo");
		return ptr;
	}


	bool STATIC_GetInfoData(struct FRealmOwnerStatueInfoData* OutInfoData);
};


// Class BLGame.RealmRaceInfo
// 0x0000 (0x0098 - 0x0098)
class URealmRaceInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.RealmRaceInfo");
		return ptr;
	}


	TEnumAsByte<ECERealmType> STATIC_FindRealmByRace(TEnumAsByte<ECERaceType> InRaceType);
	bool STATIC_FindInfoData(int InRealmType, struct FRealmRaceInfoData* OutInfoData);
};


// Class BLGame.RecipeBookInfo
// 0x0000 (0x0098 - 0x0098)
class URecipeBookInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.RecipeBookInfo");
		return ptr;
	}


	void STATIC_GetAllInfoData(TArray<struct FRecipeBookInfoData>* OutRecipeBookInfoDataList);
	bool STATIC_FindInfoData(int InCid, struct FRecipeBookInfoData* OutInfoData);
};


// Class BLGame.RecipeCodeInfo
// 0x0000 (0x0098 - 0x0098)
class URecipeCodeInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.RecipeCodeInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FRecipeCodeInfoData* OutInfoData);
};


// Class BLGame.RecipeInfo
// 0x0000 (0x0098 - 0x0098)
class URecipeInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.RecipeInfo");
		return ptr;
	}


	void STATIC_GetAllInfoData(TArray<struct FRecipeInfoData>* OutRecipeInfoDataList);
	bool STATIC_FindInfoData(int InCid, struct FRecipeInfoData* OutInfoData);
};


// Class BLGame.RoFieldInfo
// 0x0000 (0x0098 - 0x0098)
class URoFieldInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.RoFieldInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FRoFieldInfoData* OutInfoData);
};


// Class BLGame.RoyalQuestRewardInfo
// 0x0000 (0x0098 - 0x0098)
class URoyalQuestRewardInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.RoyalQuestRewardInfo");
		return ptr;
	}

};


// Class BLGame.RuneInfo
// 0x0000 (0x0098 - 0x0098)
class URuneInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.RuneInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FRuneInfoData* OutInfoData);
};


// Class BLGame.RuneSocketInfo
// 0x0000 (0x0098 - 0x0098)
class URuneSocketInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.RuneSocketInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FRuneSocketInfoData* OutInfoData);
};


// Class BLGame.SetItemInfo
// 0x0000 (0x0098 - 0x0098)
class USetItemInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.SetItemInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FSetItemInfoData* OutInfoData);
};


// Class BLGame.SetSkillInfo
// 0x0000 (0x0098 - 0x0098)
class USetSkillInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.SetSkillInfo");
		return ptr;
	}

};


// Class BLGame.ShopInfo
// 0x0000 (0x0098 - 0x0098)
class UShopInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.ShopInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FShopInfoData* OutInfoData);
};


// Class BLGame.SkillAcquireLevelInfo
// 0x0000 (0x0098 - 0x0098)
class USkillAcquireLevelInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.SkillAcquireLevelInfo");
		return ptr;
	}


	bool STATIC_GetNonStanceSkillAcquireLevel(TEnumAsByte<ECEClassType> InClassType, int InCid, int* OutLevel, int* OutSPLevel);
	bool STATIC_GetStanceSkillAcquireLevel(TEnumAsByte<ECEClassType> InClassType, int InCid, int* OutLevel, int* OutSPLevel);
	bool STATIC_GetStanceAcquireLevel(TEnumAsByte<ECEClassType> InClassType, int InCid, int* OutLevel, int* OutSPLevel);
};


// Class BLGame.SkillChangeInfo
// 0x0000 (0x0098 - 0x0098)
class USkillChangeInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.SkillChangeInfo");
		return ptr;
	}

};


// Class BLGame.SkillGrowthInfo
// 0x0000 (0x0098 - 0x0098)
class USkillGrowthInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.SkillGrowthInfo");
		return ptr;
	}

};


// Class BLGame.SkillInfo
// 0x0000 (0x0098 - 0x0098)
class USkillInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.SkillInfo");
		return ptr;
	}

};


// Class BLGame.NPCSkillInfo
// 0x0000 (0x0098 - 0x0098)
class UNPCSkillInfo : public USkillInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.NPCSkillInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FNPCSkillInfoData* OutInfoData);
};


// Class BLGame.PCSkillInfo
// 0x0010 (0x00A8 - 0x0098)
class UPCSkillInfo : public USkillInfo
{
public:
	struct FString                                     DefaultTooltipTemplate;                                   // 0x0098(0x0010) (Const, AlwaysInit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PCSkillInfo");
		return ptr;
	}


	void STATIC_FillSkillMovableInfo(TEnumAsByte<ECESkillMobilityType> InMobilityType, struct FSkillMovableInfo* OutSkillMovableInfo);
	bool STATIC_FindInfoData(int InCid, struct FPCSkillInfoData* OutInfoData);
};


// Class BLGame.SkillLevelInfo
// 0x0000 (0x0098 - 0x0098)
class USkillLevelInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.SkillLevelInfo");
		return ptr;
	}


	int STATIC_GetLevelSpForLearn(int InCid, int InLevel);
	int STATIC_GetMaxLevel(int InCid);
	bool STATIC_FindInfoData(int InCid, struct FSkillLevelInfoData* OutInfoData);
};


// Class BLGame.SkillSwapTableInfo
// 0x0000 (0x0098 - 0x0098)
class USkillSwapTableInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.SkillSwapTableInfo");
		return ptr;
	}

};


// Class BLGame.SkillTreeInfo
// 0x0000 (0x0098 - 0x0098)
class USkillTreeInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.SkillTreeInfo");
		return ptr;
	}


	int STATIC_FindSkillTreeCidBySkillCid(int InSkillCid);
	int STATIC_FindStatCodeName(int InTreeCid);
	int STATIC_FindSkillCodeName(int InTreeCid);
	bool STATIC_FindInfoData(int InTreeCid, struct FSkillTreeInfoData* OutInfoData);
};


// Class BLGame.SkillTreeTierInfo
// 0x0000 (0x0098 - 0x0098)
class USkillTreeTierInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.SkillTreeTierInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(TEnumAsByte<ECEClassType> InClassType, int InTierLevel, struct FSkillTreeTierInfoData* OutInfoData);
};


// Class BLGame.SkillTreeUIInfo
// 0x0000 (0x0098 - 0x0098)
class USkillTreeUIInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.SkillTreeUIInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(TEnumAsByte<ECEClassType> InClassType, struct FSkillTreeUIInfoData* OutInfoData);
};


// Class BLGame.SocialActionInfo
// 0x0000 (0x0098 - 0x0098)
class USocialActionInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.SocialActionInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FSocialActionInfoData* OutInfoData);
};


// Class BLGame.SocketSetInfo
// 0x0000 (0x0098 - 0x0098)
class USocketSetInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.SocketSetInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FSocketSetInfoData* OutInfoData);
};


// Class BLGame.SpecialWarInfo
// 0x0000 (0x0098 - 0x0098)
class USpecialWarInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.SpecialWarInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FSpecialWarContentInfoData* OutInfoData);
};


// Class BLGame.SpecialWarLogInfo
// 0x0000 (0x0098 - 0x0098)
class USpecialWarLogInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.SpecialWarLogInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FSpecialWarLogInfoData* OutInfoData);
};


// Class BLGame.SpecialWarMedalInfo
// 0x0000 (0x0098 - 0x0098)
class USpecialWarMedalInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.SpecialWarMedalInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FSpecialWarMedalInfoData* OutInfoData);
};


// Class BLGame.SpecialWarPointInfo
// 0x0000 (0x0098 - 0x0098)
class USpecialWarPointInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.SpecialWarPointInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FSpecialWarPointInfoData* OutInfoData);
};


// Class BLGame.SpecialWarRankBonusInfo
// 0x0000 (0x0098 - 0x0098)
class USpecialWarRankBonusInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.SpecialWarRankBonusInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FSpecialWarRankBonusInfoData* OutInfoData);
};


// Class BLGame.SPLevelInfo
// 0x0000 (0x0098 - 0x0098)
class USPLevelInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.SPLevelInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FSPLevelInfoData* OutInfoData);
};


// Class BLGame.StanceGrowthInfo
// 0x0000 (0x0098 - 0x0098)
class UStanceGrowthInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.StanceGrowthInfo");
		return ptr;
	}

};


// Class BLGame.StanceInfo
// 0x0000 (0x0098 - 0x0098)
class UStanceInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.StanceInfo");
		return ptr;
	}

};


// Class BLGame.StanceSkillInfo
// 0x0000 (0x0098 - 0x0098)
class UStanceSkillInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.StanceSkillInfo");
		return ptr;
	}

};


// Class BLGame.StatLevelInfo
// 0x0000 (0x0098 - 0x0098)
class UStatLevelInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.StatLevelInfo");
		return ptr;
	}


	int STATIC_GetLevelSpForLearn(int InCid, int InLevel);
	int STATIC_GetMaxLevel(int InCid);
	struct FStatLevelParam STATIC_FindStatLevelParam(int InCid, int InLevel);
	bool STATIC_FindInfoData(int InCid, struct FStatLevelInfoData* OutInfoData);
};


// Class BLGame.StatsUpgradeInfo
// 0x0000 (0x0098 - 0x0098)
class UStatsUpgradeInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.StatsUpgradeInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FStatsUpgradeInfoData* OutInfoData);
};


// Class BLGame.SteamAchievementInfo
// 0x0000 (0x0098 - 0x0098)
class USteamAchievementInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.SteamAchievementInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InID, struct FSteamAchievementInfoData* OutInfoData);
};


// Class BLGame.SystemMailInfo
// 0x0000 (0x0098 - 0x0098)
class USystemMailInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.SystemMailInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InSystemMailID, struct FSystemMailInfoData* OutInfoData);
};


// Class BLGame.SystemMessageInfo
// 0x0000 (0x0098 - 0x0098)
class USystemMessageInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.SystemMessageInfo");
		return ptr;
	}


	void STATIC_Print(const struct FString& MessageCodeName, TArray<struct FSystemMessageParamValueData> InParamValueList, bool bInServerType);
	struct FString STATIC_FormatMessageByName(struct FString* InName, TArray<struct FSystemMessageParamValueData>* InParamValueList);
	struct FString STATIC_FormatMessage(int InCid, TArray<struct FSystemMessageParamValueData>* InParamValueList);
	bool STATIC_FindInfoDataByName(struct FString* InName, struct FSystemMessageInfoData* OutInfoData);
	bool STATIC_FindInfoData(int InCid, struct FSystemMessageInfoData* OutInfoData);
};


// Class BLGame.TamingConstInfo
// 0x0000 (0x0098 - 0x0098)
class UTamingConstInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.TamingConstInfo");
		return ptr;
	}

};


// Class BLGame.TamingLevelInfo
// 0x0000 (0x0098 - 0x0098)
class UTamingLevelInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.TamingLevelInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FTamingLevelInfoData* OutInfoData);
};


// Class BLGame.TamingTableInfo
// 0x0000 (0x0098 - 0x0098)
class UTamingTableInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.TamingTableInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FTamingTableInfoData* OutInfoData);
};


// Class BLGame.TODConstInfo
// 0x0000 (0x0098 - 0x0098)
class UTODConstInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.TODConstInfo");
		return ptr;
	}


	bool STATIC_GetInfoData(struct FTODConstInfoData* OutInfoData);
	bool STATIC_FindInfoData(int InCid, struct FTODConstInfoData* OutInfoData);
};


// Class BLGame.TrapInfo
// 0x0000 (0x0098 - 0x0098)
class UTrapInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.TrapInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FTrapInfoData* OutInfoData);
};


// Class BLGame.TutorialOrderGuideInfo
// 0x0000 (0x0098 - 0x0098)
class UTutorialOrderGuideInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.TutorialOrderGuideInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FTutorialOrderGuideInfoData* OutInfoData);
};


// Class BLGame.TutorialOrderInfo
// 0x0000 (0x0098 - 0x0098)
class UTutorialOrderInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.TutorialOrderInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FTutorialOrderInfoData* OutInfoData);
};


// Class BLGame.TutorialOrderStageInfo
// 0x0000 (0x0098 - 0x0098)
class UTutorialOrderStageInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.TutorialOrderStageInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FTutorialOrderStageInfoData* OutInfoData);
};


// Class BLGame.V2CraftInfo
// 0x0000 (0x0098 - 0x0098)
class UV2CraftInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.V2CraftInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FCraftInfoData* OutInfoData);
};


// Class BLGame.V2CraftLevelInfo
// 0x0000 (0x0098 - 0x0098)
class UV2CraftLevelInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.V2CraftLevelInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FCraftLevelInfoData* OutInfoData);
};


// Class BLGame.V2FellowChaserInfo
// 0x0000 (0x0098 - 0x0098)
class UV2FellowChaserInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.V2FellowChaserInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, const struct FV2FellowChaserInfoData& OutInfoData);
};


// Class BLGame.V2FellowConstInfo
// 0x0000 (0x0098 - 0x0098)
class UV2FellowConstInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.V2FellowConstInfo");
		return ptr;
	}


	int STATIC_GetMaxLevelOfGrade(TEnumAsByte<ECECompanionGradeType> InGrade);
	bool STATIC_FindInfoData(int InCid, struct FV2FellowConstInfoData* OutInfoData);
};


// Class BLGame.V2FellowInfo
// 0x0000 (0x0098 - 0x0098)
class UV2FellowInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.V2FellowInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, const struct FV2FellowInfoData& OutInfoData);
};


// Class BLGame.V2FellowKillerInfo
// 0x0000 (0x0098 - 0x0098)
class UV2FellowKillerInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.V2FellowKillerInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, const struct FV2FellowKillerInfoData& OutInfoData);
};


// Class BLGame.V2FellowOutlawInfo
// 0x0000 (0x0098 - 0x0098)
class UV2FellowOutlawInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.V2FellowOutlawInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, const struct FV2FellowOutlawInfoData& OutInfoData);
};


// Class BLGame.V2FellowPenitentInfo
// 0x0000 (0x0098 - 0x0098)
class UV2FellowPenitentInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.V2FellowPenitentInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, const struct FV2FellowPenitentInfoData& OutInfoData);
};


// Class BLGame.V2FellowRaceVocationInfo
// 0x0000 (0x0098 - 0x0098)
class UV2FellowRaceVocationInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.V2FellowRaceVocationInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, const struct FV2FellowRaceVocationInfoData& OutInfoData);
};


// Class BLGame.V2FellowShamanInfo
// 0x0000 (0x0098 - 0x0098)
class UV2FellowShamanInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.V2FellowShamanInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, const struct FV2FellowShamanInfoData& OutInfoData);
};


// Class BLGame.V2FellowSkillGroupInfo
// 0x0000 (0x0098 - 0x0098)
class UV2FellowSkillGroupInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.V2FellowSkillGroupInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FV2FellowSkillGroupInfoData* OutInfoData);
};


// Class BLGame.V2FellowSkillInfo
// 0x0000 (0x0098 - 0x0098)
class UV2FellowSkillInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.V2FellowSkillInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FV2FellowSkillInfoData* OutInfoData);
};


// Class BLGame.V2FellowSmithInfo
// 0x0000 (0x0098 - 0x0098)
class UV2FellowSmithInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.V2FellowSmithInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, const struct FV2FellowSmithInfoData& OutInfoData);
};


// Class BLGame.V2FellowTacticianInfo
// 0x0000 (0x0098 - 0x0098)
class UV2FellowTacticianInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.V2FellowTacticianInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, const struct FV2FellowTacticianInfoData& OutInfoData);
};


// Class BLGame.V2FellowWandererInfo
// 0x0000 (0x0098 - 0x0098)
class UV2FellowWandererInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.V2FellowWandererInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, const struct FV2FellowWandererInfoData& OutInfoData);
};


// Class BLGame.V2FellowWarriorInfo
// 0x0000 (0x0098 - 0x0098)
class UV2FellowWarriorInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.V2FellowWarriorInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, const struct FV2FellowWarriorInfoData& OutInfoData);
};


// Class BLGame.V2GatherLevelInfo
// 0x0000 (0x0098 - 0x0098)
class UV2GatherLevelInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.V2GatherLevelInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FV2GatherLevelInfoData* OutInfoData);
};


// Class BLGame.V2HelpInfo
// 0x0000 (0x0098 - 0x0098)
class UV2HelpInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.V2HelpInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FHelpInfoData* OutInfoData);
};


// Class BLGame.V2MissionConstInfo
// 0x0000 (0x0098 - 0x0098)
class UV2MissionConstInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.V2MissionConstInfo");
		return ptr;
	}


	bool STATIC_GetInfoData(struct FV2MissionConstInfoData* OutInfoData);
	bool STATIC_FindInfoData(int InCid, struct FV2MissionConstInfoData* OutInfoData);
};


// Class BLGame.V2MissionDifficultyTabInfo
// 0x0000 (0x0098 - 0x0098)
class UV2MissionDifficultyTabInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.V2MissionDifficultyTabInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FV2MissionDifficultyTabInfoData* OutInfoData);
};


// Class BLGame.V2MissionInfo
// 0x0000 (0x0098 - 0x0098)
class UV2MissionInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.V2MissionInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FV2MissionInfoData* OutInfoData);
};


// Class BLGame.V2MissionNameInfo
// 0x0000 (0x0098 - 0x0098)
class UV2MissionNameInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.V2MissionNameInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FV2MissionNameInfoData* OutInfoData);
};


// Class BLGame.V2MountAnimInfo
// 0x0000 (0x0098 - 0x0098)
class UV2MountAnimInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.V2MountAnimInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FV2MountAnimInfoData* OutInfoData);
};


// Class BLGame.V2MountConstInfo
// 0x0000 (0x0098 - 0x0098)
class UV2MountConstInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.V2MountConstInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FV2MountConstInfoData* OutInfoData);
};


// Class BLGame.V2MountInfo
// 0x0000 (0x0098 - 0x0098)
class UV2MountInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.V2MountInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FV2MountInfoData* OutInfoData);
};


// Class BLGame.V2PetConstInfo
// 0x0000 (0x0098 - 0x0098)
class UV2PetConstInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.V2PetConstInfo");
		return ptr;
	}


	int STATIC_GetMaxLevelOfGrade(TEnumAsByte<ECECompanionGradeType> InGrade);
	bool STATIC_FindInfoData(int InCid, struct FV2PetConstInfoData* OutInfoData);
};


// Class BLGame.V2PetInfo
// 0x0000 (0x0098 - 0x0098)
class UV2PetInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.V2PetInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FV2PetInfoData* OutInfoData);
};


// Class BLGame.V2PetSkillGroupInfo
// 0x0000 (0x0098 - 0x0098)
class UV2PetSkillGroupInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.V2PetSkillGroupInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FV2PetSkillGroupInfoData* OutInfoData);
};


// Class BLGame.V2PetSkillInfo
// 0x0000 (0x0098 - 0x0098)
class UV2PetSkillInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.V2PetSkillInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FV2PetSkillInfoData* OutInfoData);
};


// Class BLGame.VoiceInfo
// 0x0000 (0x0098 - 0x0098)
class UVoiceInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.VoiceInfo");
		return ptr;
	}


	bool STATIC_FindInfoDataByName(const struct FString& InCodeName, struct FVoiceInfoData* OutInfoData);
	bool STATIC_FindInfoData(int InCid, struct FVoiceInfoData* OutInfoData);
};


// Class BLGame.VolumeChannelInfo
// 0x0000 (0x0098 - 0x0098)
class UVolumeChannelInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.VolumeChannelInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FVolumeChannelInfoData* OutInfoData);
};


// Class BLGame.VoluntaryActionInfo
// 0x0000 (0x0098 - 0x0098)
class UVoluntaryActionInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.VoluntaryActionInfo");
		return ptr;
	}


	struct FString STATIC_GetToolTip(int InCid);
	bool STATIC_FindInfoData(int InCid, struct FVoluntaryActionInfoData* OutInfoData);
};


// Class BLGame.WaypointStringInfo
// 0x0000 (0x0098 - 0x0098)
class UWaypointStringInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.WaypointStringInfo");
		return ptr;
	}


	bool STATIC_FindInfoDataByName(struct FString* InName, struct FWaypointStringInfoData* OutInfoData);
};


// Class BLGame.WorldMapInfo
// 0x0000 (0x0098 - 0x0098)
class UWorldMapInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.WorldMapInfo");
		return ptr;
	}


	bool STATIC_FindInfoData(int InCid, struct FWorldMapInfoData* OutInfoData);
};


// Class BLGame.ContentInfoExtraDataToCook
// 0x0160 (0x01C0 - 0x0060)
class UContentInfoExtraDataToCook : public UObject
{
public:
	struct FPCInfoExtraDataCookedStructure             PCInfoExtraDataCooked;                                    // 0x0060(0x00A0) (NeedCtorLink)
	struct FSkillInfoExtraDataCookedStructure          SkillInfoExtraDataCooked;                                 // 0x0100(0x0080) (NeedCtorLink)
	struct FQuestInfoExtraDataCookedStructure          QuestInfoExtraDataCooked;                                 // 0x0180(0x0040) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.ContentInfoExtraDataToCook");
		return ptr;
	}

};


// Class BLGame.AssetInfoTable
// 0x0020 (0x0080 - 0x0060)
class UAssetInfoTable : public UObject
{
public:
	struct FGuid                                       PackageGuid;                                              // 0x0060(0x0010)
	TArray<struct FAssetInfo>                          AssetInfoList;                                            // 0x0070(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.AssetInfoTable");
		return ptr;
	}

};


// Class BLGame.BLCachedNPCAsset
// 0x003C (0x009C - 0x0060)
class UBLCachedNPCAsset : public UObject
{
public:
	int                                                COUNT;                                                    // 0x0060(0x0004) (Transient)
	int                                                CachedNPCID;                                              // 0x0064(0x0004) (Transient)
	int                                                InfoCid;                                                  // 0x0068(0x0004) (Transient)
	class UNPCAsset*                                   NPCAsset;                                                 // 0x006C(0x0008) (Transient)
	class UPawnAsset*                                  PawnAssetCaches;                                          // 0x0074(0x0008) (Transient)
	TArray<class USkillAsset*>                         SkillAssetCaches;                                         // 0x007C(0x0010) (Transient, NeedCtorLink)
	TArray<class UBLEquipmentItemEquipInfo*>           EquipCaches;                                              // 0x008C(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLCachedNPCAsset");
		return ptr;
	}

};


// Class BLGame.BodyInfo
// 0x0128 (0x0188 - 0x0060)
class UBodyInfo : public UObject
{
public:
	class UPhysicsAsset*                               PhysicsAsset;                                             // 0x0060(0x0008) (Edit, Const)
	class UAnimTree*                                   AnimTreeTemplate;                                         // 0x0068(0x0008) (Edit, Const)
	class UAnimTree*                                   FaceAnimTreeTemplate;                                     // 0x0070(0x0008) (Edit, Const)
	TArray<class UAnimSet*>                            AnimSets;                                                 // 0x0078(0x0010) (Edit, NeedCtorLink)
	TArray<class UAnimSet*>                            FaceAnimSets;                                             // 0x0088(0x0010) (Edit, NeedCtorLink)
	TArray<class UAnimNotifySet*>                      AnimNotifySets;                                           // 0x0098(0x0010) (Edit, NeedCtorLink)
	TArray<class UAnimNotifySet*>                      FaceAnimNotifySets;                                       // 0x00A8(0x0010) (Edit, NeedCtorLink)
	TArray<class UMorphTargetSet*>                     MorphSets;                                                // 0x00B8(0x0010) (Edit, NeedCtorLink)
	struct FName                                       DamageSocketName;                                         // 0x00C8(0x0008) (Edit, Const)
	TArray<struct FBasePartInfo>                       BasePartList;                                             // 0x00D0(0x0010) (Edit, Const, NeedCtorLink)
	TArray<class UHairAsset*>                          HairSets;                                                 // 0x00E0(0x0010) (Edit, NeedCtorLink)
	TArray<struct FBasePartInfo>                       NewFaceParts;                                             // 0x00F0(0x0010) (Edit, NeedCtorLink)
	TArray<struct FBasePartInfo>                       EarParts;                                                 // 0x0100(0x0010) (Edit, NeedCtorLink)
	TArray<struct FBasePartInfo>                       TailParts;                                                // 0x0110(0x0010) (Edit, NeedCtorLink)
	class UMorphTargetSet*                             FaceMorphSet;                                             // 0x0120(0x0008) (Edit)
	class USkeletalMesh*                               BoneReferenceMesh;                                        // 0x0128(0x0008) (Edit)
	class UBodyBoneDeformationTemplate*                BodyBoneDeformationTemplate;                              // 0x0130(0x0008) (Edit, ExportObject, NeedCtorLink, EditInline)
	class UHeadBoneDeformationTemplate*                HeadBoneDeformationTemplate;                              // 0x0138(0x0008) (Edit, ExportObject, NeedCtorLink, EditInline)
	class UMeshTexturePaintTemplate*                   FacePaintingTemplate;                                     // 0x0140(0x0008) (Edit, ExportObject, NeedCtorLink, EditInline)
	TArray<struct FMountRidingInfo>                    MountRidingInfoList;                                      // 0x0148(0x0010) (Edit, NeedCtorLink)
	TEnumAsByte<EMountVehicleType>                     TypeAsVehicle;                                            // 0x0158(0x0001) (Edit)
	unsigned char                                      EarInclude[0x5];                                          // 0x0159(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x2];                                       // 0x015E(0x0002) MISSED OFFSET
	struct FString                                     FilterWord;                                               // 0x0160(0x0010) (Edit, NeedCtorLink)
	TArray<struct FString>                             FilterWords;                                              // 0x0170(0x0010) (Edit, NeedCtorLink)
	class UBodyInfo*                                   FallbackBodyInfo;                                         // 0x0180(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BodyInfo");
		return ptr;
	}

};


// Class BLGame.GameAsset
// 0x0000 (0x0060 - 0x0060)
class UGameAsset : public UObject
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.GameAsset");
		return ptr;
	}

};


// Class BLGame.BLPickingAsset
// 0x0078 (0x00D8 - 0x0060)
class UBLPickingAsset : public UGameAsset
{
public:
	TArray<struct FBLPickingGeom>                      PickingGeometries;                                        // 0x0060(0x0010) (NeedCtorLink)
	TArray<class UBLPickingAsset*>                     GroupedPickingAssets;                                     // 0x0070(0x0010) (Transient, NeedCtorLink)
	struct FMap_Mirror                                 PickingGeometriesMap;                                     // 0x0080(0x0048) (Native, Transient)
	float                                              OffsetSize;                                               // 0x00C8(0x0004) (Transient)
	class UBLPickingAsset*                             SimilarlyPickingAsset;                                    // 0x00CC(0x0008)
	unsigned long                                      bHidden : 1;                                              // 0x00D4(0x0004) (Transient)
	unsigned long                                      bDrawPickingGeom : 1;                                     // 0x00D4(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLPickingAsset");
		return ptr;
	}


	class UBLPickingAsset* STATIC_FindAssetByName(const struct FString& InName);
};


// Class BLGame.BLSlicedVerticesAsset
// 0x0050 (0x00B0 - 0x0060)
class UBLSlicedVerticesAsset : public UGameAsset
{
public:
	TArray<int>                                        SlicedVertexIndices;                                      // 0x0060(0x0010) (NeedCtorLink)
	TArray<struct FPackedNormal>                       VertexNormals;                                            // 0x0070(0x0010) (NeedCtorLink)
	TArray<struct FPackedNormal>                       PerPixelNormals;                                          // 0x0080(0x0010) (NeedCtorLink)
	TArray<struct FPackedNormal>                       VertexTangents;                                           // 0x0090(0x0010) (NeedCtorLink)
	class USkeletalMesh*                               Mesh;                                                     // 0x00A0(0x0008) (Transient)
	unsigned long                                      bDisable : 1;                                             // 0x00A8(0x0004) (Transient, Config)
	unsigned long                                      bWeldVertice : 1;                                         // 0x00A8(0x0004) (Transient, Config)
	unsigned long                                      bDetail : 1;                                              // 0x00A8(0x0004) (Transient, Config)
	float                                              Epsilon;                                                  // 0x00AC(0x0004) (Transient, Config)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLSlicedVerticesAsset");
		return ptr;
	}


	class UBLSlicedVerticesAsset* STATIC_FindAssetByName(const struct FString& InName);
};


// Class BLGame.CachedNPCSpawnDataAsset
// 0x0020 (0x0080 - 0x0060)
class UCachedNPCSpawnDataAsset : public UGameAsset
{
public:
	TArray<struct FNPCSpawnData>                       InstantFieldNPCList;                                      // 0x0060(0x0010) (Edit, NeedCtorLink)
	TArray<class UBLCachedNPCAsset*>                   CachedNPCAssetList;                                       // 0x0070(0x0010) (Transient, AlwaysInit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CachedNPCSpawnDataAsset");
		return ptr;
	}


	void NPCOut(int CachedNPCID);
	void NPCIn(int CachedNPCID);
	void WorldInOut(TEnumAsByte<EBLWorldMapType> WorldMapType, int WorldID, bool bIsEnter);
	void AddNPCSpawnData(TArray<TEnumAsByte<EBLWorldMapType>> WorldMapType, TArray<int> WorldID, TArray<int> CachedNPCID);
	void Clear();
};


// Class BLGame.ContentAsset
// 0x0014 (0x0074 - 0x0060)
class UContentAsset : public UGameAsset
{
public:
	int                                                Cid;                                                      // 0x0060(0x0004) (Edit)
	class UClass*                                      RelatedInfoClass;                                         // 0x0064(0x0008) (Const)
	unsigned long                                      bAlwaysLoaded : 1;                                        // 0x006C(0x0004) (Const, Config)
	int                                                AssetCountPerCookedPackge;                                // 0x0070(0x0004) (Const, Config)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.ContentAsset");
		return ptr;
	}

};


// Class BLGame.AbnormalStatusAsset
// 0x0074 (0x00E8 - 0x0074)
class UAbnormalStatusAsset : public UContentAsset
{
public:
	TEnumAsByte<EABNORMAL_STATUS_CLASS>                AbnormalStatusClassType;                                  // 0x0074(0x0001) (Edit)
	TEnumAsByte<EABNORMAL_STATUS_VFX_SCALE_TYPE>       AbnormalStatusVFXScaleType;                               // 0x0075(0x0001) (Edit, EditConst, Deprecated)
	TEnumAsByte<EVFX_SCALE_TYPE>                       VFXScaleType;                                             // 0x0076(0x0001) (Edit)
	TEnumAsByte<EVisualMaterialDefenceType>            DefenceVisualMaterial;                                    // 0x0077(0x0001) (Edit)
	TEnumAsByte<ESoundMaterialDefenceType>             DefenceSoundMaterial;                                     // 0x0078(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0079(0x0003) MISSED OFFSET
	TArray<struct FStatusEffectInfo>                   AppearEffects;                                            // 0x007C(0x0010) (Edit, Const, NeedCtorLink)
	TArray<struct FStatusEffectInfo>                   PeriodicEffects;                                          // 0x008C(0x0010) (Edit, Const, NeedCtorLink)
	TArray<struct FStatusEffectInfo>                   DisappearEffects_Finish;                                  // 0x009C(0x0010) (Edit, Const, NeedCtorLink)
	TArray<struct FStatusEffectInfo>                   DisappearEffects_Remove;                                  // 0x00AC(0x0010) (Edit, Const, NeedCtorLink)
	TArray<struct FStatusEffectInfo>                   DisappearEffects_Crash;                                   // 0x00BC(0x0010) (Edit, Const, NeedCtorLink)
	unsigned long                                      bFreezeAnim : 1;                                          // 0x00CC(0x0004) (Edit)
	unsigned long                                      bUseGuideVoluntary : 1;                                   // 0x00CC(0x0004) (Edit)
	float                                              FreezeStartTime;                                          // 0x00D0(0x0004) (Edit)
	float                                              FreezeEndTime;                                            // 0x00D4(0x0004) (Edit)
	struct FScriptDelegate                             __OnLoadAsset__Delegate;                                  // 0x00D8(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData01[0x4];                                       // 0x00D8(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.AbnormalStatusAsset");
		return ptr;
	}


	bool GetInfoData(struct FAbnormalStatusInfoData* OutInfoData);
	void STATIC_LoadAssetAsync(int InCid, const struct FScriptDelegate& InLoadComplete);
	void OnLoadAsset(class UAbnormalStatusAsset* InAsset);
	class UAbnormalStatusAsset* STATIC_LoadAsset(int InCid);
	class UAbnormalStatusAsset* STATIC_FindAsset(int InCid);
};


// Class BLGame.AuraAsset
// 0x0044 (0x00B8 - 0x0074)
class UAuraAsset : public UContentAsset
{
public:
	TEnumAsByte<EVFX_SCALE_TYPE>                       VFXScaleType;                                             // 0x0074(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0075(0x0003) MISSED OFFSET
	TArray<struct FStatusEffectInfo>                   AppearEffects;                                            // 0x0078(0x0010) (Edit, NeedCtorLink)
	TArray<struct FStatusEffectInfo>                   DisappearEffects_Finish;                                  // 0x0088(0x0010) (Edit, NeedCtorLink)
	TArray<struct FStatusEffectInfo>                   DisappearEffects_Remove;                                  // 0x0098(0x0010) (Edit, NeedCtorLink)
	struct FScriptDelegate                             __OnLoadAsset__Delegate;                                  // 0x00A8(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData01[0x4];                                       // 0x00A8(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.AuraAsset");
		return ptr;
	}


	void STATIC_LoadAssetAsync(int InCid, const struct FScriptDelegate& InLoadComplete);
	void OnLoadAsset(class UAuraAsset* InAsset);
	class UAuraAsset* STATIC_LoadAsset(int InCid);
	class UAuraAsset* STATIC_FindAsset(int InCid);
	float GetRadiusRatio(float Inradius);
	float GetHeightRatio(float InHeight);
};


// Class BLGame.CarryObjectAsset
// 0x0018 (0x008C - 0x0074)
class UCarryObjectAsset : public UContentAsset
{
public:
	class USkeletalMesh*                               SkeletalMesh;                                             // 0x0074(0x0008) (Edit)
	struct FScriptDelegate                             __OnLoadAsset__Delegate;                                  // 0x007C(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x007C(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CarryObjectAsset");
		return ptr;
	}


	void STATIC_LoadAssetAsync(int InCid, const struct FScriptDelegate& InLoadComplete);
	void OnLoadAsset(class UCarryObjectAsset* InAsset);
	class UCarryObjectAsset* STATIC_LoadAsset(int InCid);
	class UCarryObjectAsset* STATIC_FindAsset(int InCid);
};


// Class BLGame.CustomizingParamAsset
// 0x0040 (0x00B4 - 0x0074)
class UCustomizingParamAsset : public UContentAsset
{
public:
	TEnumAsByte<ECECustomizeType>                      CustomizeType;                                            // 0x0074(0x0001) (Edit, EditConst)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0075(0x0003) MISSED OFFSET
	struct FCustomizingParamData                       DefaultParamData;                                         // 0x0078(0x001C) (Edit)
	TArray<struct FCustomizingParamData>               ParamDataList;                                            // 0x0094(0x0010) (Edit, NeedCtorLink)
	struct FScriptDelegate                             __OnLoadAsset__Delegate;                                  // 0x00A4(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData01[0x4];                                       // 0x00A4(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CustomizingParamAsset");
		return ptr;
	}


	void STATIC_LoadAssetAsync(int InCid, const struct FScriptDelegate& InLoadComplete);
	void OnLoadAsset(class UCustomizingParamAsset* InAsset);
	float GetParamDataMin(TEnumAsByte<ECERaceType> InRaceType, TEnumAsByte<ECEGenderType> InGenderType);
	float GetParamDataMax(TEnumAsByte<ECERaceType> InRaceType, TEnumAsByte<ECEGenderType> InGenderType);
	struct FCustomizingParamData GetCustomizingParamData(TEnumAsByte<ECERaceType> InRaceType, TEnumAsByte<ECEGenderType> InGenderType);
	class UCustomizingParamAsset* STATIC_LoadAsset(int InCid);
	class UCustomizingParamAsset* STATIC_FindAsset(int InCid);
};


// Class BLGame.CustomizingPresetAsset
// 0x0024 (0x0098 - 0x0074)
class UCustomizingPresetAsset : public UContentAsset
{
public:
	TEnumAsByte<ECECustomizeType>                      CustomizeType;                                            // 0x0074(0x0001) (Edit, EditConst)
	TEnumAsByte<ECERaceType>                           RaceType;                                                 // 0x0075(0x0001) (Edit, EditConst)
	TEnumAsByte<ECEGenderType>                         GenderType;                                               // 0x0076(0x0001) (Edit, EditConst)
	TEnumAsByte<ECEAppearanceType>                     AppearanceType;                                           // 0x0077(0x0001) (Edit, EditConst)
	TArray<struct FCustomizeUISettingInfo>             UISettingInfoList;                                        // 0x0078(0x0010) (Edit, NeedCtorLink)
	struct FScriptDelegate                             __OnLoadAsset__Delegate;                                  // 0x0088(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x0088(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CustomizingPresetAsset");
		return ptr;
	}


	void STATIC_LoadAssetAsync(int InCid, const struct FScriptDelegate& InLoadComplete);
	void OnLoadAsset(class UCustomizingPresetAsset* InAsset);
	class UCustomizingPresetAsset* STATIC_LoadAsset(int InCid);
	class UCustomizingPresetAsset* STATIC_FindAsset(int InCid);
	bool ImportPresetFromPresetFile(const struct FString& FilePath);
	bool ImportPresetFromJPG(const struct FString& FilePath);
};


// Class BLGame.CustomizingResourceAsset
// 0x0058 (0x00CC - 0x0074)
class UCustomizingResourceAsset : public UContentAsset
{
public:
	int                                                ConstCid;                                                 // 0x0074(0x0004)
	TEnumAsByte<ECECustomizeType>                      CustomizeType;                                            // 0x0078(0x0001) (Edit, EditConst)
	TEnumAsByte<ECERaceType>                           RaceType;                                                 // 0x0079(0x0001) (Edit, EditConst)
	TEnumAsByte<ECEGenderType>                         GenderType;                                               // 0x007A(0x0001) (Edit, EditConst)
	TEnumAsByte<ECEAppearanceType>                     AppearanceType;                                           // 0x007B(0x0001) (Edit, EditConst)
	TEnumAsByte<ECustomizingResoureType>               ResourceType;                                             // 0x007C(0x0001) (Edit, EditConst)
	unsigned char                                      UnknownData00[0x3];                                       // 0x007D(0x0003) MISSED OFFSET
	unsigned long                                      bUseTexture : 1;                                          // 0x0080(0x0004) (EditConst)
	unsigned long                                      bUseMultiTexture : 1;                                     // 0x0080(0x0004) (EditConst)
	unsigned long                                      bUseHair : 1;                                             // 0x0080(0x0004) (EditConst)
	unsigned long                                      bUseMesh : 1;                                             // 0x0080(0x0004) (EditConst)
	unsigned long                                      bUseMorphTarget : 1;                                      // 0x0080(0x0004) (EditConst)
	class UTexture2D*                                  TextureResource;                                          // 0x0084(0x0008) (Edit)
	TArray<struct FCustomzingMultiTextureResource>     MultiTextureResource;                                     // 0x008C(0x0010) (Edit, AlwaysInit, NeedCtorLink)
	class UHairAsset*                                  HairResource;                                             // 0x009C(0x0008) (Edit)
	class USkeletalMesh*                               SkeletalMeshResource;                                     // 0x00A4(0x0008) (Edit)
	struct FName                                       MorphTargetName;                                          // 0x00AC(0x0008) (Edit)
	class UTexture2D*                                  MorphTargetTextureResource;                               // 0x00B4(0x0008) (Edit)
	struct FScriptDelegate                             __OnLoadAsset__Delegate;                                  // 0x00BC(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData01[0x4];                                       // 0x00BC(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CustomizingResourceAsset");
		return ptr;
	}


	void STATIC_LoadAssetAsync(int InCid, const struct FScriptDelegate& InLoadComplete);
	void OnLoadAsset(class UCustomizingResourceAsset* InAsset);
	class UCustomizingResourceAsset* STATIC_LoadAsset(int InCid);
	class UCustomizingResourceAsset* STATIC_FindAsset(int InCid);
	TEnumAsByte<ECustomizingResoureType> GetCustomizingResourceType();
};


// Class BLGame.DialogAsset
// 0x007C (0x00F0 - 0x0074)
class UDialogAsset : public UContentAsset
{
public:
	class UAkEvent*                                    DialogStart;                                              // 0x0074(0x0008) (Edit)
	class UAkEvent*                                    DialogEnd;                                                // 0x007C(0x0008) (Edit)
	TArray<struct FDialogTalkInfo>                     TalkinfoList;                                             // 0x0084(0x0010) (Edit, NeedCtorLink)
	TEnumAsByte<EDialogCameraType>                     CameraType;                                               // 0x0094(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0095(0x0003) MISSED OFFSET
	struct FCustomCameraInfo                           CustomCamInfo;                                            // 0x0098(0x001C) (Edit)
	unsigned long                                      IsHideOtherPawn : 1;                                      // 0x00B4(0x0004) (Edit)
	class UFaceFXAnimSet*                              FaceFXAnimSet;                                            // 0x00B8(0x0008) (Edit)
	struct FString                                     GroupName;                                                // 0x00C0(0x0010) (Edit, NeedCtorLink)
	struct FString                                     AnimSeqName;                                              // 0x00D0(0x0010) (Edit, NeedCtorLink)
	struct FScriptDelegate                             __OnLoadAsset__Delegate;                                  // 0x00E0(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData01[0x4];                                       // 0x00E0(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.DialogAsset");
		return ptr;
	}


	void PreSave();
	void STATIC_LoadAssetAsync(int InCid, const struct FScriptDelegate& InLoadComplete);
	void OnLoadAsset(class UDialogAsset* InAsset);
	class UDialogAsset* STATIC_LoadAsset(int InCid);
	class UDialogAsset* STATIC_FindAsset(int InCid);
};


// Class BLGame.ItemAsset
// 0x0080 (0x00F4 - 0x0074)
class UItemAsset : public UContentAsset
{
public:
	class UBLEquipmentItemInfo*                        EquipmentInfo;                                            // 0x0074(0x0008) (Edit)
	int                                                LinkedDummyItemCId;                                       // 0x007C(0x0004) (Edit, EditConst, Deprecated)
	class UItemAsset*                                  LinkedDummyItemAsset;                                     // 0x0080(0x0008) (Edit)
	TEnumAsByte<ESoundMaterialDefenceType>             DefenceSoundMaterial;                                     // 0x0088(0x0001) (Edit)
	TEnumAsByte<EVFX_SCALE_TYPE>                       VFXScaleType;                                             // 0x0089(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x2];                                       // 0x008A(0x0002) MISSED OFFSET
	struct FStatusEffectInfo                           StatsMaxEffect;                                           // 0x008C(0x0068) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.ItemAsset");
		return ptr;
	}


	void PreSave();
	class UBLEquipmentItemInfo* GetEquipmentInfo();
	class UItemAsset* STATIC_LoadAsset(int InCid);
	class UItemAsset* STATIC_FindAsset(int InCid);
};


// Class BLGame.MonologAsset
// 0x0020 (0x0094 - 0x0074)
class UMonologAsset : public UContentAsset
{
public:
	class UAkEvent*                                    MonologSound;                                             // 0x0074(0x0008) (Edit)
	struct FName                                       monologAnimSeq;                                           // 0x007C(0x0008) (Edit)
	struct FScriptDelegate                             __OnLoadAsset__Delegate;                                  // 0x0084(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x0084(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MonologAsset");
		return ptr;
	}


	void PreSave();
	void STATIC_LoadAssetAsync(int InCid, const struct FScriptDelegate& InLoadComplete);
	void OnLoadAsset(class UMonologAsset* InAsset);
	class UMonologAsset* STATIC_LoadAsset(int InCid);
	class UMonologAsset* STATIC_FindAsset(int InCid);
};


// Class BLGame.MountGradeFXAsset
// 0x0060 (0x00D4 - 0x0074)
class UMountGradeFXAsset : public UContentAsset
{
public:
	TArray<struct FGradeFXData>                        CommonFXList;                                             // 0x0074(0x0010) (Edit, NeedCtorLink)
	TArray<struct FGradeFXData>                        UnommonFXList;                                            // 0x0084(0x0010) (Edit, NeedCtorLink)
	TArray<struct FGradeFXData>                        RareFXList;                                               // 0x0094(0x0010) (Edit, NeedCtorLink)
	TArray<struct FGradeFXData>                        EpicFXList;                                               // 0x00A4(0x0010) (Edit, NeedCtorLink)
	TArray<struct FGradeFXData>                        LegendFXList;                                             // 0x00B4(0x0010) (Edit, NeedCtorLink)
	struct FScriptDelegate                             __OnLoadAsset__Delegate;                                  // 0x00C4(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x00C4(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MountGradeFXAsset");
		return ptr;
	}


	void STATIC_LoadAssetAsync(int InCid, const struct FScriptDelegate& InLoadComplete);
	void OnLoadAsset(class UMountGradeFXAsset* InAsset);
	class UMountGradeFXAsset* STATIC_LoadAsset(int InCid);
	class UMountGradeFXAsset* STATIC_FindAsset(int InCid);
};


// Class BLGame.MountSkillAsset
// 0x0020 (0x0094 - 0x0074)
class UMountSkillAsset : public UContentAsset
{
public:
	class UBroadwayInfo*                               Broadway;                                                 // 0x0074(0x0008) (Edit)
	class UBroadwayInfo*                               NextBroadway;                                             // 0x007C(0x0008) (Edit)
	struct FScriptDelegate                             __OnLoadAsset__Delegate;                                  // 0x0084(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x0084(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MountSkillAsset");
		return ptr;
	}


	void STATIC_LoadAssetAsync(int InCid, const struct FScriptDelegate& InLoadComplete);
	void OnLoadAsset(class UMountSkillAsset* InAsset);
	class UMountSkillAsset* STATIC_LoadAsset(int InCid);
	class UMountSkillAsset* STATIC_FindAsset(int InCid);
};


// Class BLGame.PawnAsset
// 0x01B8 (0x022C - 0x0074)
class UPawnAsset : public UContentAsset
{
public:
	class UAnimTree*                                   OverrideAnimTreeTemplate;                                 // 0x0074(0x0008) (Edit, Const)
	class UAnimTree*                                   OverrideFaceAnimTreeTemplate;                             // 0x007C(0x0008) (Edit, Const)
	TArray<class UAnimNotifySet*>                      OverrideAnimNotifySets;                                   // 0x0084(0x0010) (Edit, Const, NeedCtorLink)
	TArray<class UAnimSet*>                            OverrideAnimSets;                                         // 0x0094(0x0010) (Edit, Const, NeedCtorLink)
	TArray<class UAnimNotifySet*>                      OverrideFaceAnimNotifySets;                               // 0x00A4(0x0010) (Edit, Const, NeedCtorLink)
	TArray<class UAnimSet*>                            OverrideFaceAnimSets;                                     // 0x00B4(0x0010) (Edit, Const, NeedCtorLink)
	struct FEquipSet                                   BasicEquipmentsInEditor;                                  // 0x00C4(0x00B4) (Edit)
	unsigned long                                      bCanBeGore : 1;                                           // 0x0178(0x0004) (Edit)
	unsigned long                                      bUseAnimTreeOverride : 1;                                 // 0x0178(0x0004) (Edit)
	float                                              MeshScale;                                                // 0x017C(0x0004) (Edit)
	float                                              GroundSpaceOffsetWithFeet;                                // 0x0180(0x0004) (Edit)
	float                                              OverrideTargetDecalRadius;                                // 0x0184(0x0004) (Edit)
	struct FName                                       BoneNameLeftFoot_1;                                       // 0x0188(0x0008) (Edit)
	struct FName                                       BoneNameRightFoot_2;                                      // 0x0190(0x0008) (Edit)
	struct FName                                       BoneNameLeftHand_3;                                       // 0x0198(0x0008) (Edit)
	struct FName                                       BoneNameRightHand_4;                                      // 0x01A0(0x0008) (Edit)
	TEnumAsByte<EFootStepSize>                         FootStepSize;                                             // 0x01A8(0x0001) (Edit)
	TEnumAsByte<EVisualMaterialDefenceType>            DefenceVisualMaterial;                                    // 0x01A9(0x0001) (Edit)
	TEnumAsByte<ESoundMaterialDefenceType>             DefenceSoundMaterial;                                     // 0x01AA(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x1];                                       // 0x01AB(0x0001) MISSED OFFSET
	float                                              FootStepWeight;                                           // 0x01AC(0x0004) (Edit)
	class UAkEvent*                                    FootStepOveridedEvent;                                    // 0x01B0(0x0008) (Edit)
	class USpawnEffectInfo*                            SpawnEffectInfo;                                          // 0x01B8(0x0008) (Edit)
	class UDecorationEffectInfo*                       DefaultDecoEffectInfo;                                    // 0x01C0(0x0008) (Edit)
	class UBroadwayInfo*                               DeathBroadway;                                            // 0x01C8(0x0008) (Edit)
	float                                              WalkingMotion_ToIdle;                                     // 0x01D0(0x0004) (Edit)
	float                                              WalkingMotion_ToWalk;                                     // 0x01D4(0x0004) (Edit)
	float                                              WalkingMotion_ToRun;                                      // 0x01D8(0x0004) (Edit)
	float                                              WalkingMotion_ToFullRun;                                  // 0x01DC(0x0004) (Edit)
	float                                              HitupHeight;                                              // 0x01E0(0x0004) (Edit)
	float                                              HitupExponential;                                         // 0x01E4(0x0004) (Edit)
	float                                              MoveAwayExponential;                                      // 0x01E8(0x0004) (Edit)
	float                                              ForceSheatheBlendTime;                                    // 0x01EC(0x0004) (Edit)
	class UBodyInfo*                                   BodyInfo;                                                 // 0x01F0(0x0008) (Edit)
	class UBLPickingAsset*                             PickingGeomAsset;                                         // 0x01F8(0x0008) (Transient)
	struct FBasePartInfo                               FacePart;                                                 // 0x0200(0x000C) (Edit, Const)
	class UHairAsset*                                  HairAsset;                                                // 0x020C(0x0008) (Edit, Const)
	struct FBasePartInfo                               EarPart;                                                  // 0x0214(0x000C) (Edit, Const)
	struct FBasePartInfo                               TailPart;                                                 // 0x0220(0x000C) (Edit, Const)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PawnAsset");
		return ptr;
	}


	TEnumAsByte<ECEClassType> GetClassType();
	class UBroadwayInfo* GetDeathBroadwayInfo();
	class UBodyInfo* GetBodyInfo();
	bool GetPawnMovePhysicsData(struct FPawnMovePhysicsData* OutData);
	float GetMaxStepHeight();
	float GetCollisionRadius();
	float GetCollisionHeight();
	class USkeletalMesh* GetPreviewMesh();
	class USkeletalMesh* GetBaseMesh();
	int GetBasePartList(TArray<struct FBasePartInfo>* OutBasePartList);
	class USkeletalMesh* GetHeadMesh(class UObject* OuterObj);
	class USkeletalMesh* GetEquippedBodyMesh(class UObject* OuterObj);
	TEnumAsByte<EEquipmentHelmetType> FindEquippedHelmetType();
	void GetEquipments(TArray<class UBLEquipmentItemEquipInfo*>* Equipments);
	void GetAllParts(TArray<struct FBasePartInfo>* BaseParts);
	class UAnimTree* GetFaceAnimTreeTemplate();
	class UAnimTree* GetAnimTreeTemplate();
	int GetFaceAnimSets(bool bWithPreviewWeapon, TArray<class UAnimSet*>* OutAnimSets);
	int GetFaceAnimNotifySets(bool bWithPreviewWeapon, TArray<class UAnimNotifySet*>* OutAnimNotifySets);
	int GetAnimSets(bool bWithPreviewWeapon, TArray<class UAnimSet*>* OutAnimSets);
	int GetAnimNotifySets(bool bWithPreviewWeapon, TArray<class UAnimNotifySet*>* OutAnimNotifySets);
};


// Class BLGame.NPCAsset
// 0x01C4 (0x03F0 - 0x022C)
class UNPCAsset : public UPawnAsset
{
public:
	TArray<struct FName>                               HitBreakBoneNames;                                        // 0x022C(0x0010) (Edit, NeedCtorLink)
	int                                                PercentToBreakBone;                                       // 0x023C(0x0004) (Edit)
	class UMaterialInterface*                          MaterialOverrideFace;                                     // 0x0240(0x0008) (Edit)
	class UMaterialInterface*                          MaterialOverrideEye;                                      // 0x0248(0x0008) (Edit)
	class UMaterialInterface*                          MaterialOverrideEyelash;                                  // 0x0250(0x0008) (Edit)
	class UMaterialInterface*                          MaterialOverrideEar;                                      // 0x0258(0x0008) (Edit)
	class UMaterialInterface*                          MaterialOverrideBody;                                     // 0x0260(0x0008) (Edit)
	float                                              MoveBlendBySpeed_BlendUpTime;                             // 0x0268(0x0004) (Edit)
	float                                              MoveBlendBySpeed_BlendDownTime;                           // 0x026C(0x0004) (Edit)
	float                                              MoveBlendBySpeed_BlendDownPerc;                           // 0x0270(0x0004) (Edit)
	TArray<struct FBLEquipItem>                        EquippedItems;                                            // 0x0274(0x0010) (Edit, NeedCtorLink)
	class UBLEquipmentItemInfo*                        RightWeapon;                                              // 0x0284(0x0008) (Edit)
	class UBLEquipmentItemInfo*                        LeftWeapon;                                               // 0x028C(0x0008) (Edit)
	struct FName                                       BoneNameToAttachRightWeapon;                              // 0x0294(0x0008) (Edit)
	unsigned long                                      FlipInRightHand : 1;                                      // 0x029C(0x0004) (Edit)
	unsigned long                                      FlipInLeftHand : 1;                                       // 0x029C(0x0004) (Edit)
	unsigned long                                      FlipAnimatedWeapon : 1;                                   // 0x029C(0x0004) (Edit)
	unsigned long                                      AlwaysUnsheathe : 1;                                      // 0x029C(0x0004) (Edit)
	unsigned long                                      bChangeRotationToTarget : 1;                              // 0x029C(0x0004) (Edit)
	unsigned long                                      bApproachAction : 1;                                      // 0x029C(0x0004) (Edit)
	unsigned long                                      bApproachRotation : 1;                                    // 0x029C(0x0004) (Edit)
	unsigned long                                      bApproachLoop : 1;                                        // 0x029C(0x0004) (Edit)
	unsigned long                                      bCraftAction : 1;                                         // 0x029C(0x0004) (Edit)
	unsigned long                                      bExceptionTargetingVFXLocation : 1;                       // 0x029C(0x0004) (Edit)
	unsigned long                                      CheckInsideGeometry : 1;                                  // 0x029C(0x0004) (Edit)
	struct FName                                       BoneNameToAttachLeftWeapon;                               // 0x02A0(0x0008) (Edit)
	class UBLEquipmentItemInfo*                        AnimatedWeapon;                                           // 0x02A8(0x0008) (Edit)
	struct FName                                       BoneNameToAttachAnimatedWeapon;                           // 0x02B0(0x0008) (Edit)
	TArray<struct FBoneDeformRelativeParameter>        BodyBoneDeformSet;                                        // 0x02B8(0x0010) (Edit, EditConst, NeedCtorLink)
	TArray<struct FBoneDeformRelativeParameter>        HeadBoneDeformSet;                                        // 0x02C8(0x0010) (Edit, EditConst, NeedCtorLink)
	TArray<class UAnimSet*>                            CombatAnimSets;                                           // 0x02D8(0x0010) (Edit, Const, NeedCtorLink)
	TArray<class UAnimNotifySet*>                      CombatAnimNotifySets;                                     // 0x02E8(0x0010) (Edit, Const, NeedCtorLink)
	TArray<class UAnimSet*>                            SocialAnimSets;                                           // 0x02F8(0x0010) (Edit, Const, NeedCtorLink)
	TArray<class UAnimNotifySet*>                      SocialAnimNotifySets;                                     // 0x0308(0x0010) (Edit, Const, NeedCtorLink)
	TArray<struct FAccessoryInfo>                      Accessories;                                              // 0x0318(0x0010) (Edit, NeedCtorLink)
	TArray<class UBroadwayInfo*>                       NormalAttackBroadways;                                    // 0x0328(0x0010) (Edit, NeedCtorLink)
	TEnumAsByte<ENPCWalkingType>                       NPCWalkingType;                                           // 0x0338(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0339(0x0003) MISSED OFFSET
	class UBroadwayInfo*                               TalkActionBroadway;                                       // 0x033C(0x0008) (Edit)
	class UAkEvent*                                    MonologueSound;                                           // 0x0344(0x0008) (Edit)
	struct FName                                       OverrideIdleP01;                                          // 0x034C(0x0008) (Edit)
	struct FName                                       OverrideIdleP02;                                          // 0x0354(0x0008) (Edit)
	struct FName                                       ApproachAnimSeqName;                                      // 0x035C(0x0008) (Edit)
	float                                              ApproachDistance;                                         // 0x0364(0x0004) (Edit)
	float                                              ApproachAngle;                                            // 0x0368(0x0004) (Edit)
	int                                                ApproachMonologID;                                        // 0x036C(0x0004) (Edit)
	TArray<struct FNPCConditionInteraction>            NPCConditionInteractions;                                 // 0x0370(0x0010) (Edit, NeedCtorLink)
	TArray<class UNPCInteractionAsset*>                NPCInteractionAssets;                                     // 0x0380(0x0010) (Edit, NeedCtorLink)
	class UNPCInteractionAsset*                        CurrentNPCInteractionAsset;                               // 0x0390(0x0008) (Transient)
	struct FName                                       CraftAnimSeqName;                                         // 0x0398(0x0008) (Edit)
	class UBroadwayInfo*                               DespawnDeadbodyBroadway;                                  // 0x03A0(0x0008) (Edit)
	TArray<struct FName>                               AI_IdleP_AnimList;                                        // 0x03A8(0x0010) (Edit, NeedCtorLink)
	TArray<struct FName>                               AI_DisposableAnimList;                                    // 0x03B8(0x0010) (Edit, NeedCtorLink)
	float                                              BodyShake_PlayTime_Multiplier;                            // 0x03C8(0x0004) (Edit)
	float                                              BodyShake_Scale_Multiplier;                               // 0x03CC(0x0004) (Edit)
	TArray<class UNPCAsset*>                           PolymorphAssetList;                                       // 0x03D0(0x0010) (Edit, NeedCtorLink)
	struct FScriptDelegate                             __OnLoadAsset__Delegate;                                  // 0x03E0(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData01[0x4];                                       // 0x03E0(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.NPCAsset");
		return ptr;
	}


	void PreSave();
	class UMaterialInterface* GetOverrideMaterial(class UMaterialInterface* InMI);
	void MaterialOverride(class USkeletalMeshComponent* InSkelMeshComp);
	void STATIC_LoadAssetAsync(int InCid, const struct FScriptDelegate& InLoadComplete);
	void OnLoadAsset(class UNPCAsset* InAsset);
	class UNPCAsset* STATIC_LoadAsset(int InCid);
	class UNPCAsset* STATIC_FindAsset(int InCid);
	class USkeletalMesh* GetHeadMesh(class UObject* OuterObj);
	class USkeletalMesh* GetEquippedBodyMesh(class UObject* OuterObj);
	bool HavingAnyItems();
	void GetNPCEquipments(class UBLEquipmentItemEquipInfo* OutLeftWeapon, class UBLEquipmentItemEquipInfo* OutRightWeapon, TArray<class UBLEquipmentItemEquipInfo*>* OutEquipmentList, TArray<struct FAccessoryInfo>* OutAccessories);
	class UNPCAsset* GetPolymorphAsset(int NpcCid);
	float GetMaxStepHeight();
	bool GetPawnMovePhysicsData(struct FPawnMovePhysicsData* OutData);
	void LoadEquipments(TArray<class UBLEquipmentItemEquipInfo*>* Equipments);
	void GetEquipments(TArray<class UBLEquipmentItemEquipInfo*>* Equipments);
	bool IsIncludeEar();
	TEnumAsByte<EEquipmentHelmetType> FindEquippedHelmetType();
	float GetCollisionRadius();
	float GetCollisionHeight();
	class UNPCInteractionAsset* NPCInteractionTick(float DeltaTime, class ABLNpc* Npc, class ABLPawn* Player);
};


// Class BLGame.PCAsset
// 0x00C4 (0x02F0 - 0x022C)
class UPCAsset : public UPawnAsset
{
public:
	struct FPCInfoKey                                  KeyValue;                                                 // 0x022C(0x0004) (Edit, Const)
	TArray<struct FAppearanceOverrideInfo>             AppearanceOverrideList;                                   // 0x0230(0x0010) (Edit, NeedCtorLink)
	float                                              StopMotion_ToNormalMotion;                                // 0x0240(0x0004) (Edit)
	float                                              StopMotion_ToStopMotion;                                  // 0x0244(0x0004) (Edit)
	float                                              JumpMotion_ToStart;                                       // 0x0248(0x0004) (Edit)
	float                                              JumpMotion_ToDown;                                        // 0x024C(0x0004) (Edit)
	float                                              JumpMotion_ToDownLoop;                                    // 0x0250(0x0004) (Edit)
	float                                              JumpMotion_ToLand;                                        // 0x0254(0x0004) (Edit)
	TArray<struct FNewSkillType>                       SkillOverriding;                                          // 0x0258(0x0010) (Edit, NeedCtorLink, Deprecated)
	float                                              ClimbUpHoppingDist;                                       // 0x0268(0x0004) (Edit)
	float                                              ClimbDownDropDist;                                        // 0x026C(0x0004) (Edit)
	float                                              ClimbSideStepDist;                                        // 0x0270(0x0004) (Edit)
	struct FVector2D                                   ClimbHandOffSet;                                          // 0x0274(0x0008) (Edit)
	float                                              ClimbHandRange;                                           // 0x027C(0x0004) (Edit)
	struct FVector2D                                   ClimbHangOffset;                                          // 0x0280(0x0008) (Edit)
	struct FVector2D                                   ClimbFootOffSet;                                          // 0x0288(0x0008) (Edit)
	float                                              ClimbFootRange;                                           // 0x0290(0x0004) (Edit)
	struct FVector2D                                   ClimbStandOffset;                                         // 0x0294(0x0008) (Edit)
	float                                              ClimbNudgeTime;                                           // 0x029C(0x0004) (Edit)
	TArray<struct FNormalAttackBroadway>               NormalAttackBroadways;                                    // 0x02A0(0x0010) (Edit, NeedCtorLink)
	TArray<struct FBasePartInfo>                       NudePartList;                                             // 0x02B0(0x0010) (Edit, Const, NeedCtorLink)
	class UNPCAsset*                                   TransformAsset;                                           // 0x02C0(0x0008) (Edit, Const)
	class UBroadwayInfo*                               SkillDeckSwapCastingBroadway;                             // 0x02C8(0x0008) (Edit)
	class UBroadwayInfo*                               SkillDeckSwapCompleteBroadway;                            // 0x02D0(0x0008) (Edit)
	class UBroadwayInfo*                               NPCCraftBroadway;                                         // 0x02D8(0x0008) (Edit)
	class UBroadwayInfo*                               PCCraftBroadway;                                          // 0x02E0(0x0008) (Edit)
	class UBroadwayInfo*                               RuneSynthesisBroadway;                                    // 0x02E8(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PCAsset");
		return ptr;
	}


	bool GetOverrideMorphTargetInfoList(TEnumAsByte<ECEAppearanceType> AppearanceType, TArray<struct FMorphTargetOverrideInfo>* OutMorphTargetInfoList);
	class UMaterialInterface* GetOverrideMaterial(TEnumAsByte<ECEAppearanceType> AppearanceType, class UMaterialInterface* InMI);
	TEnumAsByte<ECEClassType> GetClassType();
	class USkeletalMesh* GetHeadMesh(class UObject* OuterObj);
	class USkeletalMesh* GetEquippedBodyMesh(class UObject* OuterObj);
	class UPCAsset* STATIC_LoadAssetByKey(struct FPCInfoKey* InKey);
	class UPCAsset* STATIC_LoadAsset(int InCid);
	class UPCAsset* STATIC_FindAssetByKey(struct FPCInfoKey* InKey);
	class UPCAsset* STATIC_FindAsset(int InCid);
	bool GetPawnMovePhysicsData(struct FPawnMovePhysicsData* OutData);
	float GetMaxStepHeight();
	TEnumAsByte<EEquipmentHelmetType> FindEquippedHelmetType();
	float GetCollisionRadius();
	float GetCollisionHeight();
	void GetEquipments(TArray<class UBLEquipmentItemEquipInfo*>* Equipments);
};


// Class BLGame.PropAsset
// 0x0098 (0x02C4 - 0x022C)
class UPropAsset : public UPawnAsset
{
public:
	class UParticleSystem*                             DefaultPossibilityParticle;                               // 0x022C(0x0008)
	class UParticleSystem*                             DefaultStartingParticle;                                  // 0x0234(0x0008)
	class UParticleSystem*                             DefaultCompleteParticle;                                  // 0x023C(0x0008)
	class UStaticMesh*                                 DefaultEngineSM;                                          // 0x0244(0x0008)
	TArray<struct FBLPropPossibilityTrigger>           PossibliityTrigger;                                       // 0x024C(0x0010) (NeedCtorLink)
	TArray<struct FBLPropInteractionTrigger>           InteractionTrigger;                                       // 0x025C(0x0010) (NeedCtorLink)
	class UMaterialInterface*                          PersistentDecalMtrl;                                      // 0x026C(0x0008) (EditConst, Deprecated)
	float                                              PersistentDecalWidth;                                     // 0x0274(0x0004) (EditConst, Deprecated)
	float                                              PersistentDecalHeight;                                    // 0x0278(0x0004) (EditConst, Deprecated)
	float                                              PersistentDecalDespawnFadeOutTime;                        // 0x027C(0x0004) (EditConst, Deprecated)
	class UParticleSystem*                             PropEffect;                                               // 0x0280(0x0008) (EditConst, Deprecated)
	TEnumAsByte<EBLPropInteractionType>                InteractionType;                                          // 0x0288(0x0001) (Edit, Const)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0289(0x0003) MISSED OFFSET
	class UBroadwayInfo*                               CustomInteractionBroadway;                                // 0x028C(0x0008) (Edit)
	TArray<struct FPropEffectDataSet_Possibility>      PropEffectDataSets_Possibility;                           // 0x0294(0x0010) (Edit, NeedCtorLink)
	TArray<struct FPropEffectDataSet_InState>          PropEffectDataSets_InState;                               // 0x02A4(0x0010) (Edit, NeedCtorLink)
	TArray<struct FPropEffectDataSet_OnStart>          PropEffectDataSets_OnStart;                               // 0x02B4(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PropAsset");
		return ptr;
	}


	void PreSave();
	class UPropAsset* STATIC_LoadAsset(int InCid);
	class UPropAsset* STATIC_FindAsset(int InCid);
	float GetCollisionRadius();
	float GetCollisionHeight();
};


// Class BLGame.TrapAsset
// 0x001C (0x0248 - 0x022C)
class UTrapAsset : public UPawnAsset
{
public:
	class UStaticMesh*                                 DefaultEngineSM;                                          // 0x022C(0x0008)
	TArray<struct FBLPropEffectTrigger>                EffectTrigger;                                            // 0x0234(0x0010) (Edit, NeedCtorLink)
	unsigned long                                      bRemoveDecalAllWithDespawn : 1;                           // 0x0244(0x0004) (Edit)
	unsigned long                                      bAlwaysVisible : 1;                                       // 0x0244(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.TrapAsset");
		return ptr;
	}


	class UTrapAsset* STATIC_LoadAsset(int InCid);
	class UTrapAsset* STATIC_FindAsset(int InCid);
};


// Class BLGame.PetGradeFXAsset
// 0x0060 (0x00D4 - 0x0074)
class UPetGradeFXAsset : public UContentAsset
{
public:
	TArray<struct FGradeFXData>                        CommonFXList;                                             // 0x0074(0x0010) (Edit, NeedCtorLink)
	TArray<struct FGradeFXData>                        UnommonFXList;                                            // 0x0084(0x0010) (Edit, NeedCtorLink)
	TArray<struct FGradeFXData>                        RareFXList;                                               // 0x0094(0x0010) (Edit, NeedCtorLink)
	TArray<struct FGradeFXData>                        EpicFXList;                                               // 0x00A4(0x0010) (Edit, NeedCtorLink)
	TArray<struct FGradeFXData>                        LegendFXList;                                             // 0x00B4(0x0010) (Edit, NeedCtorLink)
	struct FScriptDelegate                             __OnLoadAsset__Delegate;                                  // 0x00C4(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x00C4(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PetGradeFXAsset");
		return ptr;
	}


	void STATIC_LoadAssetAsync(int InCid, const struct FScriptDelegate& InLoadComplete);
	void OnLoadAsset(class UPetGradeFXAsset* InAsset);
	class UPetGradeFXAsset* STATIC_LoadAsset(int InCid);
	class UPetGradeFXAsset* STATIC_FindAsset(int InCid);
};


// Class BLGame.PortraitCollectionAsset
// 0x008C (0x0100 - 0x0074)
class UPortraitCollectionAsset : public UContentAsset
{
public:
	unsigned long                                      bOverrideAnim : 1;                                        // 0x0074(0x0004) (Edit, EditConst)
	class UAnimSet*                                    AnimSet;                                                  // 0x0078(0x0008) (Edit, EditConst)
	struct FString                                     AnimSeqName;                                              // 0x0080(0x0010) (Edit, EditConst, NeedCtorLink)
	float                                              DirectionalLightBrightness;                               // 0x0090(0x0004) (Edit, EditConst)
	struct FColor                                      DirectionalLightColor;                                    // 0x0094(0x0004) (Edit, EditConst)
	struct FRotator                                    DirectionalLightDirection;                                // 0x0098(0x000C) (Edit, EditConst)
	float                                              SkyLightBrightness;                                       // 0x00A4(0x0004) (Edit, EditConst)
	struct FColor                                      SkyLightColor;                                            // 0x00A8(0x0004) (Edit, EditConst)
	float                                              SkyLightLowerBrightness;                                  // 0x00AC(0x0004) (Edit, EditConst)
	struct FColor                                      SkyLightLowerColor;                                       // 0x00B0(0x0004) (Edit, EditConst)
	float                                              FOVAngle;                                                 // 0x00B4(0x0004) (Edit, EditConst)
	struct FVector                                     CameraLocation;                                           // 0x00B8(0x000C) (Edit, EditConst)
	struct FRotator                                    CameraRotation;                                           // 0x00C4(0x000C) (Edit, EditConst)
	struct FVector                                     MayaCameraLookAt;                                         // 0x00D0(0x000C)
	struct FVector                                     MayaCameraZoom;                                           // 0x00DC(0x000C)
	struct FRotator                                    MayaCameraRotation;                                       // 0x00E8(0x000C)
	int                                                MonsterNPCAssetCid;                                       // 0x00F4(0x0004) (Edit, EditConst)
	class UNPCAsset*                                   NPCAsset;                                                 // 0x00F8(0x0008) (Edit, Transient, EditConst)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PortraitCollectionAsset");
		return ptr;
	}

};


// Class BLGame.FellowAsset
// 0x0000 (0x0100 - 0x0100)
class UFellowAsset : public UPortraitCollectionAsset
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.FellowAsset");
		return ptr;
	}

};


// Class BLGame.FellowLookAsset
// 0x0000 (0x0100 - 0x0100)
class UFellowLookAsset : public UPortraitCollectionAsset
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.FellowLookAsset");
		return ptr;
	}

};


// Class BLGame.MonsterBookAsset
// 0x0000 (0x0100 - 0x0100)
class UMonsterBookAsset : public UPortraitCollectionAsset
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MonsterBookAsset");
		return ptr;
	}

};


// Class BLGame.MountAsset
// 0x0020 (0x0120 - 0x0100)
class UMountAsset : public UPortraitCollectionAsset
{
public:
	class UAkEvent*                                    MountSound;                                               // 0x0100(0x0008) (Edit)
	class UAkEvent*                                    UnMountSound;                                             // 0x0108(0x0008) (Edit)
	struct FScriptDelegate                             __OnLoadAsset__Delegate;                                  // 0x0110(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x0110(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MountAsset");
		return ptr;
	}


	void STATIC_LoadAssetAsync(int InCid, const struct FScriptDelegate& InLoadComplete);
	void OnLoadAsset(class UMountAsset* InAsset);
	class UMountAsset* STATIC_LoadAsset(int InCid);
	class UMountAsset* STATIC_FindAsset(int InCid);
};


// Class BLGame.MountLookAsset
// 0x0020 (0x0120 - 0x0100)
class UMountLookAsset : public UPortraitCollectionAsset
{
public:
	class UAkEvent*                                    MountSound;                                               // 0x0100(0x0008) (Edit)
	class UAkEvent*                                    UnMountSound;                                             // 0x0108(0x0008) (Edit)
	struct FScriptDelegate                             __OnLoadAsset__Delegate;                                  // 0x0110(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x0110(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MountLookAsset");
		return ptr;
	}


	void STATIC_LoadAssetAsync(int InCid, const struct FScriptDelegate& InLoadComplete);
	void OnLoadAsset(class UMountLookAsset* InAsset);
	class UMountLookAsset* STATIC_LoadAsset(int InCid);
	class UMountLookAsset* STATIC_FindAsset(int InCid);
};


// Class BLGame.PetAsset
// 0x0010 (0x0110 - 0x0100)
class UPetAsset : public UPortraitCollectionAsset
{
public:
	class USpawnEffectInfo*                            SpawnEffectInfo;                                          // 0x0100(0x0008) (Edit)
	class USpawnEffectInfo*                            DespawnEffectInfo;                                        // 0x0108(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PetAsset");
		return ptr;
	}

};


// Class BLGame.PetLookAsset
// 0x0010 (0x0110 - 0x0100)
class UPetLookAsset : public UPortraitCollectionAsset
{
public:
	class USpawnEffectInfo*                            SpawnEffectInfo;                                          // 0x0100(0x0008) (Edit)
	class USpawnEffectInfo*                            DespawnEffectInfo;                                        // 0x0108(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PetLookAsset");
		return ptr;
	}

};


// Class BLGame.QuestAsset
// 0x0020 (0x0094 - 0x0074)
class UQuestAsset : public UContentAsset
{
public:
	TArray<struct FQuestTerritoryData>                 QuestRelativeTerritoryData;                               // 0x0074(0x0010) (NeedCtorLink)
	struct FScriptDelegate                             __OnLoadQuestAsset__Delegate;                             // 0x0084(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x0084(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.QuestAsset");
		return ptr;
	}


	void STATIC_LoadAssetAsync(int InCid, const struct FScriptDelegate& InLoadComplete);
	void OnLoadQuestAsset(class UQuestAsset* InAsset);
	struct FQuestInfoData GetInfoData();
	class UQuestAsset* STATIC_LoadAsset(int InCid);
	class UQuestAsset* STATIC_FindAsset(int InCid);
};


// Class BLGame.SkillAsset
// 0x00D0 (0x0144 - 0x0074)
class USkillAsset : public UContentAsset
{
public:
	int                                                Level;                                                    // 0x0074(0x0004) (Const, EditConst)
	class UClass*                                      SpecialMoveType;                                          // 0x0078(0x0008) (Edit)
	class UBSM_BaseParameter*                          SkillParameter;                                           // 0x0080(0x0008) (Edit, NoClear, EditInline)
	unsigned long                                      bHiddenCastingBar : 1;                                    // 0x0088(0x0004) (Edit)
	unsigned long                                      bAngleDivideType : 1;                                     // 0x0088(0x0004) (Edit)
	unsigned long                                      bRightToLeft : 1;                                         // 0x0088(0x0004) (Edit)
	unsigned long                                      bDistanceDivideType : 1;                                  // 0x0088(0x0004) (Edit)
	float                                              AngleDegree;                                              // 0x008C(0x0004) (Edit)
	int                                                DivideCount;                                              // 0x0090(0x0004) (Edit)
	TArray<float>                                      AngleDivideApplyTimes;                                    // 0x0094(0x0010) (Edit, NeedCtorLink)
	float                                              MaxDistance;                                              // 0x00A4(0x0004) (Edit)
	int                                                DistDivideCount;                                          // 0x00A8(0x0004) (Edit)
	TArray<float>                                      DistanceDivideApplyTimes;                                 // 0x00AC(0x0010) (Edit, NeedCtorLink)
	float                                              AddApplyTime;                                             // 0x00BC(0x0004) (Deprecated)
	float                                              MoveFiringUnableTime;                                     // 0x00C0(0x0004) (Edit)
	TEnumAsByte<ESkillChangeWeaponPostureType>         ChangeWeaponPosture;                                      // 0x00C4(0x0001) (Edit)
	TEnumAsByte<ESkillDecalAreaType>                   UseAreaDecalType;                                         // 0x00C5(0x0001) (Edit)
	TEnumAsByte<ESkillHitNotifyType>                   HitNotifyType;                                            // 0x00C6(0x0001) (Edit)
	unsigned char                                      UnknownData00[0x1];                                       // 0x00C7(0x0001) MISSED OFFSET
	struct FSkillDecal_Circular                        CircularDecalData;                                        // 0x00C8(0x0038) (Edit)
	struct FSkillDecal_Rectangle                       RectangleDecalData;                                       // 0x0100(0x0034) (Edit)
	TArray<struct FString>                             PCSkillAssetPackages;                                     // 0x0134(0x0010) (Config, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.SkillAsset");
		return ptr;
	}


	class USkillAsset* STATIC_LoadAsset(int InCid);
	class USkillAsset* STATIC_FindAsset(int InCid);
};


// Class BLGame.SocialActionAsset
// 0x0010 (0x0084 - 0x0074)
class USocialActionAsset : public UContentAsset
{
public:
	TArray<struct FSocialActionClassifiedBroadway>     ClassifiedBroadways;                                      // 0x0074(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.SocialActionAsset");
		return ptr;
	}


	void GetBroadwayInfo(class UBodyInfo* InBodyInfo, class UBroadwayInfo** OutBroadway);
	class USocialActionAsset* STATIC_LoadAsset(int InCid);
	class USocialActionAsset* STATIC_FindAsset(int InCid);
};


// Class BLGame.SystemMessageAsset
// 0x0018 (0x008C - 0x0074)
class USystemMessageAsset : public UContentAsset
{
public:
	class UAkEvent*                                    DefaultSound;                                             // 0x0074(0x0008) (Edit)
	TArray<struct FSystemMessageSoundSet>              SoundSets;                                                // 0x007C(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.SystemMessageAsset");
		return ptr;
	}


	class USystemMessageAsset* STATIC_LoadAsset(int InCid);
	class USystemMessageAsset* STATIC_FindAsset(int InCid);
};


// Class BLGame.VoiceAsset
// 0x0020 (0x0094 - 0x0074)
class UVoiceAsset : public UContentAsset
{
public:
	TArray<class UAkEvent*>                            CustomizingSamples;                                       // 0x0074(0x0010) (Edit, NeedCtorLink)
	TArray<struct FVoiceItem>                          VoiceItems;                                               // 0x0084(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.VoiceAsset");
		return ptr;
	}


	class UVoiceAsset* STATIC_LoadAsset(int InCid);
	class UVoiceAsset* STATIC_FindAsset(int InCid);
};


// Class BLGame.VoluntaryActionAsset
// 0x0020 (0x0094 - 0x0074)
class UVoluntaryActionAsset : public UContentAsset
{
public:
	class UBroadwayInfo*                               Broadway;                                                 // 0x0074(0x0008) (Edit)
	TArray<struct FVoluntaryClassifiedBroadway>        ClassifiedBroadways;                                      // 0x007C(0x0010) (Edit, NeedCtorLink)
	class UAkEvent*                                    EndSoundEvent;                                            // 0x008C(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.VoluntaryActionAsset");
		return ptr;
	}


	void GetBroadwayInfo(class UBodyInfo* InBodyInfo, TEnumAsByte<ECEItemEquipCategory> InMainItemCategory, class UBroadwayInfo** OutBroadway);
	bool GetInfoData(struct FVoluntaryActionInfoData* OutInfoData);
	class UVoluntaryActionAsset* STATIC_LoadAsset(int InCid);
	class UVoluntaryActionAsset* STATIC_FindAsset(int InCid);
};


// Class BLGame.CreditPlaylistAsset
// 0x0014 (0x0074 - 0x0060)
class UCreditPlaylistAsset : public UGameAsset
{
public:
	TArray<struct FBLCreditPlaylistItem>               CreditPlaylist;                                           // 0x0060(0x0010) (Edit, NeedCtorLink)
	int                                                CurrentItemIndex;                                         // 0x0070(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CreditPlaylistAsset");
		return ptr;
	}


	bool STATIC_GetNextPlaylistItem(struct FBLCreditPlaylistItem* OutCreditPlaylistItem);
	bool STATIC_GetPrevPlaylistItem(struct FBLCreditPlaylistItem* OutCreditPlaylistItem);
	bool STATIC_GetCurrentPlaylistItem(struct FBLCreditPlaylistItem* OutCreditPlaylistItem);
	class UCreditPlaylistAsset* STATIC_GetAsset();
};


// Class BLGame.CustomizingDefaultPresetAsset
// 0x0014 (0x0074 - 0x0060)
class UCustomizingDefaultPresetAsset : public UGameAsset
{
public:
	TEnumAsByte<ECECustomizeType>                      CustomizeType;                                            // 0x0060(0x0001) (Edit, EditConst)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	TArray<struct FCustomizingPresetData>              DefaultPresetList;                                        // 0x0064(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CustomizingDefaultPresetAsset");
		return ptr;
	}


	bool ImportDefaultPresetFromJPG(const struct FString& FilePath);
	bool STATIC_GetDefaultPreset(struct FUIInfoKey* InKey, struct FCustomizingPresetData* OutData);
	class UCustomizingDefaultPresetAsset* STATIC_GetAsset();
};


// Class BLGame.DeathEffectInfo
// 0x0028 (0x0088 - 0x0060)
class UDeathEffectInfo : public UGameAsset
{
public:
	class UMaterialInstanceTimeVarying*                DeathMITV;                                                // 0x0060(0x0008) (Edit)
	struct FName                                       DeathPPMaterialEffectName;                                // 0x0068(0x0008) (Edit)
	struct FName                                       DeadParamName;                                            // 0x0070(0x0008) (Edit)
	struct FName                                       SpiritParamName;                                          // 0x0078(0x0008) (Edit)
	float                                              DeadEffectInterpTime;                                     // 0x0080(0x0004) (Edit)
	float                                              SpiritEffectInterpTime;                                   // 0x0084(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.DeathEffectInfo");
		return ptr;
	}

};


// Class BLGame.DungeonSoundAsset
// 0x0010 (0x0070 - 0x0060)
class UDungeonSoundAsset : public UGameAsset
{
public:
	class UAkEvent*                                    DungeonTimerAlertSound;                                   // 0x0060(0x0008) (Edit)
	class UAkEvent*                                    DungeonTimerEndSound;                                     // 0x0068(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.DungeonSoundAsset");
		return ptr;
	}

};


// Class BLGame.HairAsset
// 0x0010 (0x0070 - 0x0060)
class UHairAsset : public UGameAsset
{
public:
	TArray<struct FHairPartUnit>                       HairSet;                                                  // 0x0060(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.HairAsset");
		return ptr;
	}

};


// Class BLGame.IconSheetAsset
// 0x0010 (0x0070 - 0x0060)
class UIconSheetAsset : public UGameAsset
{
public:
	TArray<struct FIconSheetData>                      IconSheets;                                               // 0x0060(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.IconSheetAsset");
		return ptr;
	}

};


// Class BLGame.InGameSoundAsset
// 0x0028 (0x0088 - 0x0060)
class UInGameSoundAsset : public UGameAsset
{
public:
	class UAkEvent*                                    PCDetectedEvent;                                          // 0x0060(0x0008) (Edit)
	class UAkEvent*                                    CombatSoundStartEvent;                                    // 0x0068(0x0008) (Edit)
	class UAkEvent*                                    CombatSoundEndEvent;                                      // 0x0070(0x0008) (Edit)
	class UAkEvent*                                    WarpIn;                                                   // 0x0078(0x0008) (Edit)
	class UAkEvent*                                    WarpOut;                                                  // 0x0080(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.InGameSoundAsset");
		return ptr;
	}

};


// Class BLGame.LoadingMessageAsset
// 0x0060 (0x00C0 - 0x0060)
class ULoadingMessageAsset : public UGameAsset
{
public:
	TArray<class UTexture*>                            FieldLoadingTextures;                                     // 0x0060(0x0010) (Edit, NeedCtorLink)
	TArray<struct FBLLoadingMessage>                   LoadingMessages;                                          // 0x0070(0x0010) (Edit, NeedCtorLink)
	TArray<struct FBLDungeonLoadingMessage>            DungeonLoadingMessages;                                   // 0x0080(0x0010) (Edit, NeedCtorLink)
	TArray<struct FString>                             FieldLoadingTexturePaths;                                 // 0x0090(0x0010) (NeedCtorLink)
	int                                                CurrentLevel;                                             // 0x00A0(0x0004) (Transient)
	unsigned char                                      CurrentRace;                                              // 0x00A4(0x0001) (Transient)
	unsigned char                                      CurrentClass;                                             // 0x00A5(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x2];                                       // 0x00A6(0x0002) MISSED OFFSET
	class UTexture*                                    CurrentTexture;                                           // 0x00A8(0x0008) (Transient)
	struct FString                                     CurrentLoadingMessage;                                    // 0x00B0(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.LoadingMessageAsset");
		return ptr;
	}


	class ULoadingMessageAsset* STATIC_GetAsset();
};


// Class BLGame.MinimapAsset
// 0x0010 (0x0070 - 0x0060)
class UMinimapAsset : public UGameAsset
{
public:
	TArray<struct FBLMinimapDivisionInfo>              Divisions;                                                // 0x0060(0x0010) (Edit, NeedCtorLink, EditInline)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MinimapAsset");
		return ptr;
	}


	class UMinimapAsset* STATIC_GetAsset();
	void InitializeTest();
	void InitializeMinimapInfo();
	bool GetDivisionInfo(const struct FIntPoint& Index, int WorldMapCId, struct FBLMinimapDivisionInfo* DI);
};


// Class BLGame.MountResourceAsset
// 0x0008 (0x0068 - 0x0060)
class UMountResourceAsset : public UGameAsset
{
public:
	class UBroadwayInfo*                               CastingBroadway;                                          // 0x0060(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MountResourceAsset");
		return ptr;
	}

};


// Class BLGame.NPCDeadBodyEffectInfo
// 0x0054 (0x00B4 - 0x0060)
class UNPCDeadBodyEffectInfo : public UGameAsset
{
public:
	struct FName                                       ParticleSocketName;                                       // 0x0060(0x0008) (Edit)
	float                                              ParticleDefaultRadius;                                    // 0x0068(0x0004) (Edit)
	class UParticleSystem*                             OtherItemParticle;                                        // 0x006C(0x0008) (Edit)
	class UParticleSystem*                             UncommonItemParticle;                                     // 0x0074(0x0008) (Edit)
	class UMaterialInstanceTimeVarying*                UncommonItemMITV;                                         // 0x007C(0x0008) (Edit)
	class UMaterialInstanceTimeVarying*                RareItemMITV;                                             // 0x0084(0x0008) (Edit)
	class UParticleSystem*                             RareItemParticle;                                         // 0x008C(0x0008) (Edit)
	class UMaterialInstanceTimeVarying*                EpicItemMITV;                                             // 0x0094(0x0008) (Edit)
	class UParticleSystem*                             EpicItemParticle;                                         // 0x009C(0x0008) (Edit)
	class UMaterialInstanceTimeVarying*                LegendaryItemMITV;                                        // 0x00A4(0x0008) (Edit)
	class UParticleSystem*                             LegendaryItemParticle;                                    // 0x00AC(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.NPCDeadBodyEffectInfo");
		return ptr;
	}


	class UNPCDeadBodyEffectInfo* STATIC_GetAsset();
};


// Class BLGame.PreloadingAsset
// 0x0010 (0x0070 - 0x0060)
class UPreloadingAsset : public UGameAsset
{
public:
	TArray<struct FPreloadingPawnData>                 PawnAssetList;                                            // 0x0060(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PreloadingAsset");
		return ptr;
	}

};


// Class BLGame.ROSoundAsset
// 0x0048 (0x00A8 - 0x0060)
class UROSoundAsset : public UGameAsset
{
public:
	class UAkEvent*                                    RealmOwnerWarTimeTriggerSound;                            // 0x0060(0x0008) (Edit)
	class UAkEvent*                                    RealmOwnerWarTimeFlashingSound;                           // 0x0068(0x0008) (Edit)
	class UAkEvent*                                    RealmOwnerWarTimeOverSound;                               // 0x0070(0x0008) (Edit)
	class UAkEvent*                                    RealmOwnerWarVictorySound;                                // 0x0078(0x0008) (Edit)
	class UAkEvent*                                    RealmOwnerWarDefeatSound;                                 // 0x0080(0x0008) (Edit)
	class UAkEvent*                                    RealmOwnerWarBaseOwnerAttackerToAttacker;                 // 0x0088(0x0008) (Edit)
	class UAkEvent*                                    RealmOwnerWarBaseOwnerAttackerToDefender;                 // 0x0090(0x0008) (Edit)
	class UAkEvent*                                    RealmOwnerWarBaseOwnerDefenderToAttacker;                 // 0x0098(0x0008) (Edit)
	class UAkEvent*                                    RealmOwnerWarBaseOwnerDefenderToDefender;                 // 0x00A0(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.ROSoundAsset");
		return ptr;
	}

};


// Class BLGame.UISoundAsset
// 0x03E0 (0x0440 - 0x0060)
class UUISoundAsset : public UGameAsset
{
public:
	class UAkEvent*                                    COAreaButtonOver;                                         // 0x0060(0x0008) (Edit)
	class UAkEvent*                                    COAreaButtonClick;                                        // 0x0068(0x0008) (Edit)
	class UAkEvent*                                    OnStealthBackground;                                      // 0x0070(0x0008) (Edit)
	class UAkEvent*                                    OffStealthBackground;                                     // 0x0078(0x0008) (Edit)
	class UAkEvent*                                    DetectStealth;                                            // 0x0080(0x0008) (Edit)
	class UAkEvent*                                    RPGrantUIopen;                                            // 0x0088(0x0008) (Edit)
	class UAkEvent*                                    RPGrantButtonAble;                                        // 0x0090(0x0008) (Edit)
	class UAkEvent*                                    RPGrantCheck;                                             // 0x0098(0x0008) (Edit)
	class UAkEvent*                                    RPGrantSuccess;                                           // 0x00A0(0x0008) (Edit)
	class UAkEvent*                                    RPGrantFail;                                              // 0x00A8(0x0008) (Edit)
	class UAkEvent*                                    InventoryLineUpButtonClick;                               // 0x00B0(0x0008) (Edit)
	class UAkEvent*                                    InventoryPackageSlotExtend;                               // 0x00B8(0x0008) (Edit)
	class UAkEvent*                                    InventoryLockIconClick;                                   // 0x00C0(0x0008) (Edit)
	class UAkEvent*                                    InventoryLumenaSlotExtend;                                // 0x00C8(0x0008) (Edit)
	class UAkEvent*                                    InventorySplitButtonClick;                                // 0x00D0(0x0008) (Edit)
	class UAkEvent*                                    InventorySlotExpansion;                                   // 0x00D8(0x0008) (Edit)
	class UAkEvent*                                    CraftUIopen;                                              // 0x00E0(0x0008) (Edit)
	class UAkEvent*                                    CraftUIclose;                                             // 0x00E8(0x0008) (Edit)
	class UAkEvent*                                    CraftCastingStart;                                        // 0x00F0(0x0008) (Edit)
	class UAkEvent*                                    CraftCastingEnd;                                          // 0x00F8(0x0008) (Edit)
	class UAkEvent*                                    Craft_Favorite_In;                                        // 0x0100(0x0008) (Edit)
	class UAkEvent*                                    Craft_Favorite_Out;                                       // 0x0108(0x0008) (Edit)
	class UAkEvent*                                    Craft_Spin_Up;                                            // 0x0110(0x0008) (Edit)
	class UAkEvent*                                    Craft_Spin_Down;                                          // 0x0118(0x0008) (Edit)
	class UAkEvent*                                    Craft_Max_Botton;                                         // 0x0120(0x0008) (Edit)
	class UAkEvent*                                    Craft_Lock_Exp;                                           // 0x0128(0x0008) (Edit)
	class UAkEvent*                                    Craft_Accept_Quest;                                       // 0x0130(0x0008) (Edit)
	class UAkEvent*                                    RecipeGet_RecipeGet;                                      // 0x0138(0x0008) (Edit)
	class UAkEvent*                                    CraftChoice_MouseOver_Smith;                              // 0x0140(0x0008) (Edit)
	class UAkEvent*                                    CraftChoice_MouseOver_Smelt;                              // 0x0148(0x0008) (Edit)
	class UAkEvent*                                    CraftChoice_MouseOver_Haniwork;                           // 0x0150(0x0008) (Edit)
	class UAkEvent*                                    CraftChoice_MouseOver_Cook;                               // 0x0158(0x0008) (Edit)
	class UAkEvent*                                    CraftChoice_MouseOver_Alchemy;                            // 0x0160(0x0008) (Edit)
	class UAkEvent*                                    CraftChoice_Skill_Select;                                 // 0x0168(0x0008) (Edit)
	class UAkEvent*                                    CraftChoice_Skill_Selected;                               // 0x0170(0x0008) (Edit)
	class UAkEvent*                                    LumenaShopUIOpen;                                         // 0x0178(0x0008) (Edit)
	class UAkEvent*                                    LumenaShopUIClose;                                        // 0x0180(0x0008) (Edit)
	class UAkEvent*                                    CompanionExpUp;                                           // 0x0188(0x0008) (Edit)
	class UAkEvent*                                    CompanionLevelUp;                                         // 0x0190(0x0008) (Edit)
	class UAkEvent*                                    ArenaJoin;                                                // 0x0198(0x0008) (Edit)
	class UAkEvent*                                    ArenaWin;                                                 // 0x01A0(0x0008) (Edit)
	class UAkEvent*                                    ArenaLose;                                                // 0x01A8(0x0008) (Edit)
	class UAkEvent*                                    ArenaMatch;                                               // 0x01B0(0x0008) (Edit)
	class UAkEvent*                                    ArenaEntry;                                               // 0x01B8(0x0008) (Edit)
	class UAkEvent*                                    LobbyDialogOpen;                                          // 0x01C0(0x0008) (Edit)
	class UAkEvent*                                    LobbyDialogClose;                                         // 0x01C8(0x0008) (Edit)
	class UAkEvent*                                    LootingDiceUIOpen;                                        // 0x01D0(0x0008) (Edit)
	class UAkEvent*                                    PotentialOpenClick;                                       // 0x01D8(0x0008) (Edit)
	class UAkEvent*                                    PotentialDisjointResult;                                  // 0x01E0(0x0008) (Edit)
	class UAkEvent*                                    PotentialDisjointResultGreat;                             // 0x01E8(0x0008) (Edit)
	class UAkEvent*                                    RuneWindowOpen;                                           // 0x01F0(0x0008) (Edit)
	class UAkEvent*                                    RuneWindowClose;                                          // 0x01F8(0x0008) (Edit)
	class UAkEvent*                                    RuneSynthesizeProgress;                                   // 0x0200(0x0008) (Edit)
	class UAkEvent*                                    RuneSynthesizeFail;                                       // 0x0208(0x0008) (Edit)
	class UAkEvent*                                    RuneSynthesizeSuccess;                                    // 0x0210(0x0008) (Edit)
	class UAkEvent*                                    RuneSynthesizeGreatSuccess;                               // 0x0218(0x0008) (Edit)
	class UAkEvent*                                    RuneEquipSuccess;                                         // 0x0220(0x0008) (Edit)
	class UAkEvent*                                    RuneUnEquipSuccess;                                       // 0x0228(0x0008) (Edit)
	class UAkEvent*                                    OrderCompleteDaily;                                       // 0x0230(0x0008) (Edit)
	class UAkEvent*                                    OrderCompleteWeekly;                                      // 0x0238(0x0008) (Edit)
	class UAkEvent*                                    OrderCompleteDailyGoal;                                   // 0x0240(0x0008) (Edit)
	class UAkEvent*                                    OrderCompleteWeeklyGoal;                                  // 0x0248(0x0008) (Edit)
	class UAkEvent*                                    QuestRewardReceive;                                       // 0x0250(0x0008) (Edit)
	class UAkEvent*                                    GradeUpAdd_Success;                                       // 0x0258(0x0008) (Edit)
	class UAkEvent*                                    FatigueRecovery_Success;                                  // 0x0260(0x0008) (Edit)
	class UAkEvent*                                    GradeUp_Success;                                          // 0x0268(0x0008) (Edit)
	class UAkEvent*                                    GradeUp_Fail;                                             // 0x0270(0x0008) (Edit)
	class UAkEvent*                                    MonsterBallExtraction_Success;                            // 0x0278(0x0008) (Edit)
	class UAkEvent*                                    SkillChange_RouletteRotation;                             // 0x0280(0x0008) (Edit)
	class UAkEvent*                                    SkillChange_Success;                                      // 0x0288(0x0008) (Edit)
	class UAkEvent*                                    NPC_Repair_Failed;                                        // 0x0290(0x0008) (Edit)
	class UAkEvent*                                    NPC_Repair_Success_Parts;                                 // 0x0298(0x0008) (Edit)
	class UAkEvent*                                    NPC_Repair_Item_Success;                                  // 0x02A0(0x0008) (Edit)
	class UAkEvent*                                    NPC_Repair_Item_Great_Success;                            // 0x02A8(0x0008) (Edit)
	class UAkEvent*                                    Recover_Equip_Slot_In;                                    // 0x02B0(0x0008) (Edit)
	class UAkEvent*                                    Recover_Equip_Slot_Out;                                   // 0x02B8(0x0008) (Edit)
	class UAkEvent*                                    Recover_Completed;                                        // 0x02C0(0x0008) (Edit)
	class UAkEvent*                                    Recover_Bar_Increasing;                                   // 0x02C8(0x0008) (Edit)
	class UAkEvent*                                    EquipUpgrade_Equip_Slot_In;                               // 0x02D0(0x0008) (Edit)
	class UAkEvent*                                    EquipUpgrade_Equip_Slot_Out;                              // 0x02D8(0x0008) (Edit)
	class UAkEvent*                                    EquipUpgrade_Progressing;                                 // 0x02E0(0x0008) (Edit)
	class UAkEvent*                                    EquipUpgrade_Great_Success;                               // 0x02E8(0x0008) (Edit)
	class UAkEvent*                                    EquipUpgrade_Success;                                     // 0x02F0(0x0008) (Edit)
	class UAkEvent*                                    EquipUpgrade_Fail;                                        // 0x02F8(0x0008) (Edit)
	class UAkEvent*                                    Disassemble_Slot_In;                                      // 0x0300(0x0008) (Edit)
	class UAkEvent*                                    Disassemble_Slot_Out;                                     // 0x0308(0x0008) (Edit)
	class UAkEvent*                                    Disassemble_Progressing;                                  // 0x0310(0x0008) (Edit)
	class UAkEvent*                                    Disassemble_Success;                                      // 0x0318(0x0008) (Edit)
	class UAkEvent*                                    Disassemble_GreatSuccess;                                 // 0x0320(0x0008) (Edit)
	class UAkEvent*                                    Taming_Game_Start;                                        // 0x0328(0x0008) (Edit)
	class UAkEvent*                                    Taming_Game_Critical_Start;                               // 0x0330(0x0008) (Edit)
	class UAkEvent*                                    Taming_Game_BGM;                                          // 0x0338(0x0008) (Edit)
	class UAkEvent*                                    Taming_Game_Critical_BGM;                                 // 0x0340(0x0008) (Edit)
	class UAkEvent*                                    Taming_Game_BGM_Stop;                                     // 0x0348(0x0008) (Edit)
	class UAkEvent*                                    Taming_Game_Critical_BGM_Stop;                            // 0x0350(0x0008) (Edit)
	class UAkEvent*                                    Taming_Game_Input_Success;                                // 0x0358(0x0008) (Edit)
	class UAkEvent*                                    Taming_Game_Miss;                                         // 0x0360(0x0008) (Edit)
	class UAkEvent*                                    Taming_Game_Success;                                      // 0x0368(0x0008) (Edit)
	class UAkEvent*                                    Taming_Game_Failed;                                       // 0x0370(0x0008) (Edit)
	class UAkEvent*                                    Mission_Unlock_New_Difficulty_Tab;                        // 0x0378(0x0008) (Edit)
	class UAkEvent*                                    Mission_Recieve_Reward;                                   // 0x0380(0x0008) (Edit)
	class UAkEvent*                                    ChallengeTower_Round_wait_sound;                          // 0x0388(0x0008) (Edit)
	class UAkEvent*                                    ChallengeTower_Round_start_sound;                         // 0x0390(0x0008) (Edit)
	class UAkEvent*                                    ChallengeTower_Round_clear_sound;                         // 0x0398(0x0008) (Edit)
	class UAkEvent*                                    ChallengeTower_Round_Reward_sound;                        // 0x03A0(0x0008) (Edit)
	class UAkEvent*                                    ChallengeTower_End_sound;                                 // 0x03A8(0x0008) (Edit)
	class UAkEvent*                                    ChallengeTower_End_Reward_sound;                          // 0x03B0(0x0008) (Edit)
	class UAkEvent*                                    ChallengeTower_BGM_base_sound;                            // 0x03B8(0x0008) (Edit)
	class UAkEvent*                                    ChallengeTower_BGM_wait_sound;                            // 0x03C0(0x0008) (Edit)
	class UAkEvent*                                    ChallengeTower_BGM_start_sound;                           // 0x03C8(0x0008) (Edit)
	class UAkEvent*                                    ChallengeTower_BGM_boss_sound;                            // 0x03D0(0x0008) (Edit)
	class UAkEvent*                                    ChallengeTower_BGM_stop_sound;                            // 0x03D8(0x0008) (Edit)
	class UAkEvent*                                    Credit_music_start;                                       // 0x03E0(0x0008) (Edit)
	class UAkEvent*                                    Credit_music_end;                                         // 0x03E8(0x0008) (Edit)
	class UAkEvent*                                    Stance_Change_Ready_sound;                                // 0x03F0(0x0008) (Edit)
	class UAkEvent*                                    Stance_Change_Complete_sound;                             // 0x03F8(0x0008) (Edit)
	class UAkEvent*                                    SkillGrowth_Node_Acquire;                                 // 0x0400(0x0008) (Edit)
	class UAkEvent*                                    SkillGrowth_Node_Remove;                                  // 0x0408(0x0008) (Edit)
	class UAkEvent*                                    SkillGrowth_Save;                                         // 0x0410(0x0008) (Edit)
	class UAkEvent*                                    SkillGrowth_Equip;                                        // 0x0418(0x0008) (Edit)
	class UAkEvent*                                    SkillGrowth_Clear;                                        // 0x0420(0x0008) (Edit)
	class UAkEvent*                                    SkillGrowth_GemChange_Success;                            // 0x0428(0x0008) (Edit)
	class UAkEvent*                                    SkillGrowth_Change_Cancel;                                // 0x0430(0x0008) (Edit)
	class UAkEvent*                                    SkillGrowth_Reset;                                        // 0x0438(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.UISoundAsset");
		return ptr;
	}

};


// Class BLGame.GameAssetDB
// 0x0000 (0x0060 - 0x0060)
class UGameAssetDB : public UObject
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.GameAssetDB");
		return ptr;
	}

};


// Class BLGame.PropGlobalAsset
// 0x0020 (0x0080 - 0x0060)
class UPropGlobalAsset : public UObject
{
public:
	struct FName                                       ParamName_OutLineOnOff;                                   // 0x0060(0x0008) (Edit)
	struct FName                                       ParamName_OutLineColor;                                   // 0x0068(0x0008) (Edit)
	struct FLinearColor                                OutLineColor;                                             // 0x0070(0x0010) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PropGlobalAsset");
		return ptr;
	}

};


// Class BLGame.BLBlockPlayer
// 0x0010 (0x0070 - 0x0060)
class UBLBlockPlayer : public UObject
{
public:
	TArray<struct FIgnorePlayerData>                   BlockList;                                                // 0x0060(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLBlockPlayer");
		return ptr;
	}


	void UpdateBlockListToUI();
	void SendToServer(const struct FString& InPlayerName, bool IsBlock);
	void OnUnblock(struct FMsgCommandArgData* InArgData);
	void OnBlock(struct FMsgCommandArgData* InArgData);
	void OpenBlockPlayerDialog();
	struct FString GetName(const struct FQWord& InUniqueID);
	bool IsInByUniqueID(const struct FQWord& InUniqueID);
	bool IsInByName(const struct FString& InPlayerName);
	void RemoveByUniqueID(const struct FQWord& InUniqueID);
	void Remove(const struct FString& InPlayerName);
	void Update(const struct FIgnorePlayerData& InData);
	void OnInitialize();
};


// Class BLGame.BLFriend
// 0x0018 (0x0078 - 0x0060)
class UBLFriend : public UObject
{
public:
	class UBlessLocalPlayer*                           LP;                                                       // 0x0060(0x0008)
	TArray<struct FFriendData>                         FriendDataList;                                           // 0x0068(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLFriend");
		return ptr;
	}


	bool GetFriendData(const struct FQWord& InFriendUID, struct FFriendData* OutFriendData);
	bool IsFriendByName(const struct FString& InName);
	bool IsFriend(int InSid);
	void GetUIFriendDataList(TArray<struct FUIFriendData>* outDataList);
	void Initialize(class UBlessLocalPlayer* InLP);
};


// Class BLGame.BLPlayerPostProcessController
// 0x0014 (0x0084 - 0x0070)
class UBLPlayerPostProcessController : public UComponent
{
public:
	TArray<struct FMaterialEffectPlayInfo>             MaterialEffectPlayInfoList;                               // 0x0070(0x0010) (NeedCtorLink)
	unsigned long                                      bPauseMaterialEffect : 1;                                 // 0x0080(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLPlayerPostProcessController");
		return ptr;
	}


	void ResumeMaterialEffect();
	void PauseMaterialEffect();
	class UMaterialInstanceTimeVarying* ReverseMaterialEffectMITV(const struct FName& MaterialEffectName, float Duration, float PlayRate);
	void ClearMaterialEffect(const struct FName& MaterialEffectName, const struct FName& SetterName, bool bForceClear);
	void ClearAllMaterialEffect();
	class UMaterialInstance* SetMaterialEffect(const struct FName& MaterialEffectName, class UMaterialInstance* MI, const struct FName& SetterName, float Duration);
	int FindMaterialEffectPlayInfo(const struct FName& MaterialEffectName);
	class UPostProcessChain* GetLocalPlayerPostProcessChain();
	void AddMaterialEffectPlayInfo(const struct FMaterialEffectPlayInfo& Info);
};


// Class BLGame.FieldRaidManager
// 0x0060 (0x00C0 - 0x0060)
class UFieldRaidManager : public UObject
{
public:
	class UBlessLocalPlayer*                           LP;                                                       // 0x0060(0x0008)
	TArray<int>                                        OpenedFieldRaidList;                                      // 0x0068(0x0010) (NeedCtorLink)
	struct FMap_Mirror                                 SpawnedPropMap;                                           // 0x0078(0x0048) (Const, Native)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.FieldRaidManager");
		return ptr;
	}


	void OnLeaveRaidField();
	void OnEnterRaidField();
	bool IsFieldRaidBoss(int InNPCCid);
	bool IsOpenFieldRaid(int InRaidCid);
	bool GetOpenedFieldRaidList(TArray<int>* OutOpenRaidCidList);
	void CloseFieldRaid(int InRaidCid);
	void OpenFieldRaid(int InRaidCid);
	void InitOpenFieldRaidList(TArray<int>* InOpenRaidCidList);
	void Initialize(class UBlessLocalPlayer* InLP);
};


// Class BLGame.BLNetHandlerBase
// 0x012C (0x018C - 0x0060)
class UBLNetHandlerBase : public UNETHandler
{
public:
	class UBLTcpClient*                                BLClient;                                                 // 0x0060(0x0008) (Transient)
	class UBLTcpClient*                                BLAuthClient;                                             // 0x0068(0x0008) (Transient)
	struct FString                                     ServerAddr;                                               // 0x0070(0x0010) (Config, NeedCtorLink)
	struct FString                                     AuthAddr;                                                 // 0x0080(0x0010) (Config, NeedCtorLink)
	TArray<struct FString>                             MyIPAddresses;                                            // 0x0090(0x0010) (Transient, NeedCtorLink)
	struct FString                                     DefaultLoginID;                                           // 0x00A0(0x0010) (Config, NeedCtorLink)
	struct FString                                     DefaultPassword;                                          // 0x00B0(0x0010) (Config, NeedCtorLink)
	struct FString                                     LauncherArgument;                                         // 0x00C0(0x0010) (Transient, NeedCtorLink)
	struct FString                                     OneTimeAuthKey;                                           // 0x00D0(0x0010) (Transient, NeedCtorLink)
	struct FString                                     OneTimeServerKey;                                         // 0x00E0(0x0010) (Transient, NeedCtorLink)
	struct FQWord                                      ServerTime;                                               // 0x00F0(0x0008) (Const)
	struct FQWord                                      ServerRTTAverage;                                         // 0x00F8(0x0008) (Const)
	struct FQWord                                      ServerTimeUpdateTime;                                     // 0x0100(0x0008) (Const)
	unsigned long                                      bPingEnabled : 1;                                         // 0x0108(0x0004) (Transient)
	unsigned long                                      bNpcDistributedProcessing : 1;                            // 0x0108(0x0004)
	unsigned long                                      RevisitAuth : 1;                                          // 0x0108(0x0004) (Transient)
	TArray<struct FCAWorldServerInfo>                  ServerList;                                               // 0x010C(0x0010) (NeedCtorLink)
	int                                                LastTryToConnectWorldServerID;                            // 0x011C(0x0004) (Transient)
	TEnumAsByte<EBLServerLocationBaseType>             ServerLocationBase;                                       // 0x0120(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0121(0x0003) MISSED OFFSET
	struct FMap_Mirror                                 PawnNameMap;                                              // 0x0124(0x0048) (Const, Native)
	TArray<struct FDoorCacheData>                      Doors;                                                    // 0x016C(0x0010) (Transient, NeedCtorLink)
	TArray<int>                                        PawnsToWaitingInitNameTag;                                // 0x017C(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLNetHandlerBase");
		return ptr;
	}


	void AddAuthBuildSchedule();
	struct FString GetLauncherArgument();
	bool ChangeServer(const struct FString& SelectedServerName, const struct FString& ServerIP);
};


// Class BLGame.BLPartyEffectManager
// 0x001C (0x007C - 0x0060)
class UBLPartyEffectManager : public UObject
{
public:
	TEnumAsByte<EPartyEffectCategoryType>              PartyEffectCategory;                                      // 0x0060(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	int                                                CurPartyTabIndex;                                         // 0x0064(0x0004)
	TArray<struct FAppliedPartyEffectInfo>             PartyEffectSettingList;                                   // 0x0068(0x0010) (Edit, NeedCtorLink)
	int                                                MAX_PARTY_COUNT;                                          // 0x0078(0x0004) (Const)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLPartyEffectManager");
		return ptr;
	}


	void SetActivePartyEffectList();
	void DeactivePartyEffect(int InCategoryType);
	void ClearPartyEffectData();
	void PartyEffectRaidFrame(int InPartyIndex, TEnumAsByte<EPartyEffectCategoryType> InCategoryType);
	void PartyEffectFrame(int InPartyIndex, TEnumAsByte<EPartyEffectCategoryType> InCategoryType);
	void SetPartyEffectFrame(TEnumAsByte<EPartyEffectCategoryType> InCategoryType);
	void SetApplyButtonState();
	void ApplyPartyEffectREQ();
	void SelectPartyEffectListItem(int InSelectedPartyEffectCid);
	void SelectPartyEffectType(int InSelectedType);
	void SelectPartyTabIndex(int InSelectPartyIndex);
	void SetPartyEffectCondition(const struct FPartyEffectCondition& InCondition, const struct FString& InDescriptionCondition);
	void SetPartyEffectConditionData();
	void SetPartyEffectInfo();
	void SetPartyMemberData();
	void SetPartyEffectListData();
	void SetPartyEffectData();
	void SetPartyIndexTabDisable();
	void UpdatePartyEffectUI();
	void ClosePartyEffectUI();
	void OpenPartyEffectUI();
	bool IsActivatePartyEffect(int Cid, const struct FPartyEffectCondition& InCondition);
	void ApplyPartyEffectLivingList(TArray<struct FApplyPartyEffectInfo> InApplyPartyEffectInfoList);
	void ApplyPartyEffectCombatList(TArray<struct FApplyPartyEffectInfo> InApplyPartyEffectInfoList);
	void ClearPartyEffectLivingACK(int InPartyIndex);
	void ClearPartyEffectCombatACK(int InPartyIndex);
	void ApplyPartyEffectLivingACK(int InPartyIndex, int InPartyEffectLivingCId);
	void ApplyPartyEffectCombatACK(int InPartyIndex, int InPartyEffectCombatCId);
};


// Class BLGame.BLPartyMatchingManager
// 0x0074 (0x00D4 - 0x0060)
class UBLPartyMatchingManager : public UObject
{
public:
	struct FMap_Mirror                                 DungeonGroupDataMap;                                      // 0x0060(0x0048) (Const, Native)
	TArray<struct FPartyMatchingMemberInfoData>        PartyMemberDataList;                                      // 0x00A8(0x0010) (AlwaysInit, NeedCtorLink)
	unsigned char                                      AvailablePosition;                                        // 0x00B8(0x0001)
	TEnumAsByte<EBLPartyMatchingState>                 MatchingState;                                            // 0x00B9(0x0001)
	TEnumAsByte<EPartyMatchingPositionType>            SelectedPartyPosition;                                    // 0x00BA(0x0001)
	unsigned char                                      UnknownData00[0x1];                                       // 0x00BB(0x0001) MISSED OFFSET
	unsigned long                                      bIsUIOpen : 1;                                            // 0x00BC(0x0004)
	unsigned long                                      bPartyMatchingButton : 1;                                 // 0x00BC(0x0004)
	unsigned long                                      bPartyMatchingCancelButton : 1;                           // 0x00BC(0x0004)
	unsigned long                                      bPartyRoleWindowButton : 1;                               // 0x00BC(0x0004)
	unsigned long                                      EquipLock : 1;                                            // 0x00BC(0x0004)
	int                                                SelectedDungeonGroupID;                                   // 0x00C0(0x0004)
	int                                                MatchingCompletedDungeonCid;                              // 0x00C4(0x0004)
	int                                                RandomUseCount;                                           // 0x00C8(0x0004)
	int                                                RandomAdditionalUseCount;                                 // 0x00CC(0x0004)
	int                                                RandomAdditionalMaxCount;                                 // 0x00D0(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLPartyMatchingManager");
		return ptr;
	}


	bool IsPartyMatching();
	void UpdatePartyMatchingRoleUI();
	int ConvertRoleForUI(TEnumAsByte<EPartyMatchingPositionType> InPositionType);
	void OpenDialogRandomDungeonMatchingCancel();
	bool IsEquipLock();
	void SetLockEquipmentUI(bool InLock);
	void UpdateDungeonOpener();
	void UpdateRandomMatchingButton();
	void UpdateRandomMatchingDungeonList();
	void UpdateRandomMatchingStatusPage();
	void UpdatePartyMatingTabButton();
	void OpenDialogPartyMatchingCancel();
	void OpenPartyMatchingTeleportDialog();
	void UpdateDungeonDifficulty(const struct FDungeonEntranceData& InDungeonData, bool InUpdate);
	void UpdateDungeonDifficultyList(TArray<struct FDungeonEntranceData> InDungeonDataList);
	void SetMatchingCompletedDungeonCid(int DungeonCid);
	void SetSelectedDungeonIndexByCid(int DungeonCid);
	bool IsAvailablePartyMatching();
	struct FDungeonData Get_SelectedDungeonByGroupCid(int DungeonGroupCid);
	int Get_DungeonGroupCid(int DungeonCid);
	struct FString Get_DungeonStringByCid(int DungeonCid);
	struct FString Get_SelectedDungeonString();
	void UpdatePartyMatchingUI();
	void Set_PartyMemberDataList(TArray<struct FPartyMatchingMemberInfoData> InMemberPositionInfo);
	void Set_ButtonState();
	void CloseUI();
	void OpenUI();
	void AU_CloseUI();
	void AU_OpenUI();
	void AU_PartyMatchingCancel();
	void AU_PartyMatchingStart();
	void AU_SelectDungeonType(int InDungeonIndex, int InDungeonType);
	void UA_Set_PartyMatchingRoleData();
	void UA_Set_DungeonDataInfo();
	void UA_Set_PositionButton();
	void CS_CancelRandomMatching();
	void CS_StartRandomMatching();
	void CS_TeleportDialogResult();
	void SC_OnUnregistRandomMatching();
	void SC_OnRegistRandomMatching();
	void SC_UpdateRandomDungeonCount(int InUseCount, int InAddtionalUseCount, int InAdditionalMaxCount);
	void SC_UpdateDungeonLimitCount(TArray<struct FDungeonLimitedCountInfoData> InDungoenLimitedInfo);
	void SC_OnDeleteParty();
	void SC_OnCreateParty();
	void SC_UpdatePartyMatchingInfo(bool InIsParty, TEnumAsByte<EPartyMatchingUIStateType> InPartyMatchingUIState, TArray<struct FPartyMatchingMemberInfoData> InMemberPositionInfo);
	void SC_ClosePartyMatchingUI();
	void SC_OpenPartyMatchingUI(bool InIsParty, TEnumAsByte<EPartyMatchingUIStateType> InPartyMatchingUIState, TArray<struct FPartyMatchingMemberInfoData> InMemberPositionInfo);
	void InitDungeonDataMap();
	void Initialize(const struct FPCData& InPCData);
};


// Class BLGame.BLPartyRaidManager
// 0x0028 (0x0088 - 0x0060)
class UBLPartyRaidManager : public UObject
{
public:
	int                                                PartyRaidID;                                              // 0x0060(0x0004)
	TEnumAsByte<EPartyType>                            PartyRaidType;                                            // 0x0064(0x0001)
	TEnumAsByte<ECEItemGradeType>                      DiceItemGrade;                                            // 0x0065(0x0001)
	TEnumAsByte<EPartyDistributeMethod>                distributeMethod;                                         // 0x0066(0x0001)
	unsigned char                                      UnknownData00[0x1];                                       // 0x0067(0x0001) MISSED OFFSET
	int                                                distributorId;                                            // 0x0068(0x0004)
	int                                                leaderSid;                                                // 0x006C(0x0004)
	TArray<class UParty*>                              PartyList;                                                // 0x0070(0x0010) (AlwaysInit, NeedCtorLink)
	unsigned long                                      Initialize : 1;                                           // 0x0080(0x0004)
	int                                                MyPartyID;                                                // 0x0084(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLPartyRaidManager");
		return ptr;
	}


	int GetPartyMemberCount(int InPartyIndex);
	void GetPartyMemberData(int InPartyIndex, class UGFxObject** OutPartyMemberDataList);
	void UpdateRandomDungeonPlayer(int InPawnSID, bool InApply);
	void UpdateMemberData(TArray<struct FPartyMemberPCData> InMemberDataList);
	void GetMemberPartyMatchingData(TArray<struct FPartyMatchingMemberInfoData>* OutInfoArray);
	void GetMemberPosition(TArray<struct FPartyMatchingPositionInfoData>* OutInfoArray);
	void GetMemberAbnormalDataBySID(int InPawnSID, int InGroupCid, struct FAbnormalGroupData* OutResultGroup, TArray<struct FAbnormalData>* OutResult);
	void UpdateChannelPartyMemberCount();
	int GetMemberCountInChannel(int InChannelID);
	void GetRaidMapIconInfo(TArray<struct FPartyMapIconInfo>* OutInfoArray);
	void GetPartyMapIconInfo(TArray<struct FPartyMapIconInfo>* OutInfoArray);
	bool IsEqualWorldCid(int InPawnSID, int InWorldCID);
	struct FVector GetPlayerLocation(int InPawnSID);
	void UpdatePartyLocation(TArray<struct FPartyMemberPosData>* InPosDataList);
	void OnUpdateCombatFlair(int InPawnSID, TArray<struct FCombatFlairData> InDataList);
	void OnUpdateLevel(int InPawnSID, const struct FPawnParamData& InParamData);
	void OnUpdateParam(int InPawnSID, const struct FParamData& InParamData);
	void OnUpdateParams(int InPawnSID, TArray<struct FParamData> InParamDatas);
	void UpdateAbnormalStatusList(int InMemberSID, TArray<struct FAbnormalStatusData>* InAbnormalStatusDataList);
	void UpdateAbnormalStatus(int InMemberSID, struct FAbnormalStatusData* InData);
	void UpdateAdjustLevel(int InPawnSID, int InAdjustLevel);
	void LogoutMember(int InMemberSID, int InSlotIndex);
	void LoginMember(int InPrevSID, const struct FPartyMemberPCData& InMemberData);
	int GetMemberChannel(int InMemberSID);
	int GetRaidMemberChannel(int InMemberSID);
	int GetPartyMemberChannel(int InMemberSID);
	TEnumAsByte<EPartyMemberType> IsMember(int InPawnSID);
	bool IsRaidMember(int InPawnSID);
	bool IsPartyMember(int InPawnSID);
	void MoveMember(int InPartyRaidID, int InTargetSid, int InPrevSlotIndex, int InNewSlotIndex);
	void RemoveMember(int InMemberSID);
	void AddMember(const struct FPartyMemberPCData& InMemberData);
	bool RemoveParty(int InPartyID);
	class UParty* AddParty(int InPartyID);
	void Update(int InLeaderSID, TEnumAsByte<EPartyDistributeMethod> InDistributeMethod, int InDistributorID);
	void CompleteLevelLoading(bool bShouldCreate);
	void Delete(int InPartyRaidID);
	bool Create(const struct FPartyData& InPartyData);
	bool IsDungeon(int InMemberSID);
	bool IsOtherSpace(int InMemberSID);
	bool IsOtherChannel(int InMemberSID);
	int GetMemberCountInRaidDungeon();
	bool IsMemberInRaidDungeon();
	bool IsRaidDungeon(int InMemberSID);
	int GetMemberCountInPartyDungeon();
	bool IsMemberInPartyDungeon();
	bool IsPartyDungeon(int InMemberSID);
	int GetMemberCount();
	int GetPartyIDBySID(int InSid);
	bool GetMemberDataByName(const struct FString& InMemberName, class UPartyMemberData** OutMemberData);
	bool GetMemberDataBySID(int InSid, class UPartyMemberData** OutMemberData);
	bool GetMemberNameBySid(int InSid, struct FString* OutMemberName);
	int GetMemberSidByName(const struct FString& InMemberName);
	bool IsLeader(int InPawnSID);
	bool IsPartyLeader(int InPawnSID, int InPartyID);
	TArray<int> GetRaidPlayerServerID();
	TArray<int> GetPartyPlayerServerID(int InPartyID);
	void SetMyPartyID(int InPartyID);
	int GetMyPartyID();
	bool IsRandomDungeonPlayer();
	bool IsPartyRaidGrouping();
	bool IsRaid();
	bool IsParty();
	class UParty* GetParty(int InPartyID);
	void SetLeaderSID(int InLeaderID);
	int GetLeaderSID();
	void SetDistributorID(int InDistributorID);
	int GetDistributorID();
	void SetDistributeMethod(TEnumAsByte<EPartyDistributeMethod> InDistributeMethod);
	TEnumAsByte<EPartyDistributeMethod> GetDistributeMethod();
	void SetDiceItemGrade(TEnumAsByte<ECEItemGradeType> InDiceItemGrade);
	TEnumAsByte<ECEItemGradeType> GetDiceItemGrade();
	void SetPartyRaidType(TEnumAsByte<EPartyType> InType);
	TEnumAsByte<EPartyType> GetPartyRaidType();
	void SetPartyRaidID(int InPartyRaidID);
	int GetPartyRaidID();
};


// Class BLGame.Party
// 0x001C (0x007C - 0x0060)
class UParty : public UObject
{
public:
	int                                                partyId;                                                  // 0x0060(0x0004)
	TEnumAsByte<EPartyType>                            partyType;                                                // 0x0064(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0065(0x0003) MISSED OFFSET
	TArray<class UPartyMemberData*>                    MemberList;                                               // 0x0068(0x0010) (AlwaysInit, NeedCtorLink)
	unsigned long                                      bChannelPartyMemberCountDirty : 1;                        // 0x0078(0x0004)
	unsigned long                                      bRemovePartyDirty : 1;                                    // 0x0078(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.Party");
		return ptr;
	}


	int GetPartyMemberCountByRaceTypeList(TArray<unsigned char> InRaceTypeArray);
	int GetPartyMemberCountByRaceType(unsigned char InRaceType);
	int GetPartyMemberCountByClassTypeList(TArray<unsigned char> InClassTypeArray);
	int GetPartyMemberCountByClassType(unsigned char InClassType);
	void GetMemberPartyMatchingData(TArray<struct FPartyMatchingMemberInfoData>* OutInfoArray);
	void GetMemberPosition(TArray<struct FPartyMatchingPositionInfoData>* OutInfoArray);
	void UpdateAllMemberAbnormal();
	void GetMemberAbnormalDataBySID(int InPawnSID, int InGroupCid, struct FAbnormalGroupData* OutResultGroup, TArray<struct FAbnormalData>* OutResult);
	void UpdateMemberAbnormalStatusToUI(class UPartyMemberData* InMemberData);
	void UpdateMemberParamToUI(class UPartyMemberData* InMemberData);
	int GetPartyMemberCountInChannel(int channelId);
	void GetPartyMapIconInfo(TArray<struct FPartyMapIconInfo>* InfoArray);
	bool IsEqualWorldCid(int InPawnSID, int InWorldCID);
	struct FVector GetPlayerLocation(int InPawnSID);
	void UpdatePartyLocation(TArray<struct FPartyMemberPosData>* NewPosDataList);
	void OnUpdateCombatFlair(int InPawnSID, TArray<struct FCombatFlairData> InDataList);
	void OnUpdateLevel(int InPawnSID, const struct FPawnParamData& InParamData);
	void OnUpdateParam(int InPawnSID, const struct FParamData& InParamData);
	void OnUpdateParams(int InPawnSID, TArray<struct FParamData> InParamDatas);
	void UpdateAbnormalStatusList(int InMemberSID, TArray<struct FAbnormalStatusData>* InAbnormalStatusDataList);
	void UpdateAbnormalStatus(int InMemberSID, const struct FAbnormalStatusData& InAbsData);
	void LogoutMember(int InMemberSID);
	void LoginMember(int InPrevSID, const struct FPartyMemberPCData& InMemberData);
	void SortPartyMembers();
	void UpdateAdjustLevel(int InPawnSID, int InAdjustLevel);
	void UpdateCombatFlairToUI(int InPawnSID, int InMemberIndex, TEnumAsByte<ECEClassType> PawnClassType, TArray<struct FCombatFlairData> InDataList);
	bool UpdateCombatFlair(int InPawnSID, TArray<struct FCombatFlairData> InDataList);
	int GetPartyMemberChannel(int InMemberSID);
	bool IsChannelPartyMemberCountDirty();
	void SetChannelPartyMemberCountDirty(bool bDirty);
	bool IsDungeon(int InMemberSID);
	bool IsOtherSpace(int InMemberSID);
	bool IsOtherChannel(int InMemberSID);
	int GetMemberCountInRaidDungeon();
	bool IsMemberInRaidDungeon();
	bool IsRaidDungeon(int InMemberSID);
	int GetMemberCountInPartyDungeon();
	bool IsMemberInPartyDungeon();
	bool IsPartyDungeon(int InMemberSID);
	TArray<int> GetPartyPlayerServerID();
	bool GetMemberDataBySlotIndex(int InSlotIndex, class UPartyMemberData** OutMemberData);
	bool GetMemberDataByName(const struct FString& InMemberName, class UPartyMemberData** OutMemberData);
	bool GetMemberDataBySID(int InMemberSID, class UPartyMemberData** OutMemberData);
	void ResetMemberAbnormalData(int InPawnSID);
	void ResetMemberData(int InPawnSID);
	bool IsMember(int InPawnSID);
	int GetMemberCount();
	bool UpdateMember(const struct FPartyMemberPCData& InMemberData, int InPrevID);
	void MoveMember(int InPrevSlotIndex, int InNewSlotIndex);
	void RemoveMemberToUI(int InPartyID, int InMemberIndex, int InMemberSID, bool bMoveParty);
	class UPartyMemberData* RemoveMemberData(int InMemberSID);
	void RemoveMember(int InMemberSID);
	void AddMemberList(TArray<struct FPartyMemberPCData> InMemberDataList);
	void AddMemberToUI(class UPartyMemberData* InMemberData);
	class UPartyMemberData* AddMemberData(const struct FPartyMemberPCData& InMemberData);
	bool IsRemovePartyDirty();
	void SetRemovePartyDirty(bool bDirty);
	void CompleteLevelLoading(bool bShouldCreate);
	void DeletePartyFromUI();
	void Destroy();
	bool IsMyParty();
	void SetPartyID(int InPartyID);
	int GetPartyID();
};


// Class BLGame.PartyMemberData
// 0x00B4 (0x0114 - 0x0060)
class UPartyMemberData : public UObject
{
public:
	int                                                SlotIndex;                                                // 0x0060(0x0004)
	unsigned long                                      Logout : 1;                                               // 0x0064(0x0004)
	unsigned long                                      RandomPartyPlayer : 1;                                    // 0x0064(0x0004)
	unsigned long                                      OtherChannel : 1;                                         // 0x0064(0x0004)
	unsigned long                                      OtherSpace : 1;                                           // 0x0064(0x0004)
	unsigned long                                      Dungeon : 1;                                              // 0x0064(0x0004)
	unsigned long                                      ParamDirty : 1;                                           // 0x0064(0x0004)
	unsigned long                                      AbnormalDirty : 1;                                        // 0x0064(0x0004)
	unsigned long                                      OtherChannelDirty : 1;                                    // 0x0064(0x0004)
	unsigned long                                      OtherSpaceDirty : 1;                                      // 0x0064(0x0004)
	unsigned long                                      DungeonDirty : 1;                                         // 0x0064(0x0004)
	unsigned long                                      MovePartyDirty : 1;                                       // 0x0064(0x0004)
	unsigned long                                      bNeedUpdateDeath : 1;                                     // 0x0064(0x0004)
	int                                                Sid;                                                      // 0x0068(0x0004)
	struct FString                                     MemberName;                                               // 0x006C(0x0010) (AlwaysInit, NeedCtorLink)
	TEnumAsByte<ECERaceType>                           Race;                                                     // 0x007C(0x0001)
	TEnumAsByte<ECEClassType>                          ClassType;                                                // 0x007D(0x0001)
	TEnumAsByte<EPartyMatchingPositionType>            PartyMatchingPosition;                                    // 0x007E(0x0001)
	TEnumAsByte<ECEWorldMapType>                       WorldType;                                                // 0x007F(0x0001)
	int                                                Level;                                                    // 0x0080(0x0004)
	int                                                MaxHP;                                                    // 0x0084(0x0004)
	int                                                HP;                                                       // 0x0088(0x0004)
	int                                                MaxMP;                                                    // 0x008C(0x0004)
	int                                                MP;                                                       // 0x0090(0x0004)
	TArray<struct FCombatFlairData>                    ComabatFlair;                                             // 0x0094(0x0010) (AlwaysInit, NeedCtorLink)
	struct FPawnAbnormalGroupData                      AbnormalStatusData;                                       // 0x00A4(0x0048) (NeedCtorLink)
	int                                                AdjustLevel;                                              // 0x00EC(0x0004)
	int                                                WorldMapCId;                                              // 0x00F0(0x0004)
	int                                                WorldMapWrapperCId;                                       // 0x00F4(0x0004)
	struct FVector                                     Location;                                                 // 0x00F8(0x000C)
	int                                                VolumeFieldCid;                                           // 0x0104(0x0004)
	int                                                channelId;                                                // 0x0108(0x0004)
	float                                              ParamUpdateIntervalTime;                                  // 0x010C(0x0004)
	float                                              AbrnomalUpdateIntervalTime;                               // 0x0110(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PartyMemberData");
		return ptr;
	}


	void SetRandomPartyPlayer(bool InRandomPartyPlayer);
	void SetAdjustLevel(int InAdjustLevel);
	bool IsEqualWorldCid(int InWorldCID);
	struct FVector GetLocation();
	void UpdateLocation(struct FPartyMemberPosData* NewPosData);
	void SetCombatFlairData(TArray<struct FCombatFlairData>* InCombatFlairData);
	void SortAbnormalStatusData();
	void FillAbnormalGroupData(const struct FAbnormalStatusInfoData& InAbsInfoData, TArray<struct FAbnormalGroupData>* TargetLists, struct FAbnormalStatusData* InAbnormalStatusData);
	void RemoveAbnormalStatus(struct FAbnormalStatusData* InAbnormalStatusData);
	void UpdateAbnormalStatus(struct FAbnormalStatusData* InAbnormalStatusData);
	void SetAbnormalStatusData(TArray<struct FAbnormalStatusData>* InAbnormalStatusDatas);
	void UpdatePawnParamData(struct FPawnParamData* InParamData);
	void UpdateParams(TArray<struct FParamData>* InParamDatas);
	void UpdateParam(struct FParamData* InParamData);
	void SetMemberPosData(struct FPartyMemberPosData* PosData);
	void ResetAbnormalData();
	void ResetData();
	bool IsNeedUpdateDeath();
	void SetNeedUpdateDeath(int OldHP, int NewHP);
	bool IsLogout();
	void SetLogout(bool bLogout);
	void SetMemberPCData(struct FPartyMemberPCData* InPCData);
	bool IsMovePartyDirty();
	bool IsDungeonDirty();
	bool IsOtherSpaceDirty();
	bool IsOtherChannelDirty();
	bool IsAbnormalDirty();
	bool IsParamDirty();
	void SetMovePartyDirty(bool InMovePartyDirty);
	void SetDungeonDirty(bool InDungeonDirty);
	void SetOtherSpaceDirty(bool InOtherSpaceDirty);
	void SetOtherChannelDirty(bool InOtherChannelDirty);
	void SetAbnormalDirty(bool InAbnormalDirty);
	void SetParamDirty(bool InParamDirty);
	bool IsDungeon();
	bool IsOtherSpace();
	bool IsOtherChannel();
	void SetDungeon(bool InDungeon);
	void SetOtherSpace(bool InOtherSpace);
	void SetOtherChannel(bool InOtherChannel);
	void SetSlotIndex(int InSlotIndex);
};


// Class BLGame.OrderManager
// 0x008C (0x00EC - 0x0060)
class UOrderManager : public UObject
{
public:
	struct FMap_Mirror                                 OrderList;                                                // 0x0060(0x0048) (Native)
	struct FOrderDailyComplateData                     OrderDailyComplate;                                       // 0x00A8(0x0020) (Native)
	struct FOrderWeeklyData                            OrderWeeklyStamp;                                         // 0x00C8(0x0020) (Native)
	int                                                RewardCount;                                              // 0x00E8(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.OrderManager");
		return ptr;
	}


	int GetOrderCount();
	void PlayOrderSound(TEnumAsByte<EOrderSoundType> InSoundType);
	bool CheckRewardOrder(int PrevState, int CurrentState);
	int GetRewardCount();
	void SortOrderList(TEnumAsByte<EOrderType> TabIndex);
	void RequestOrderInfo(TEnumAsByte<EOrderType> TabIndex);
	void UpdateOrderWeeklyInfo(int CurrentWeekly, int MaxWeekly, int RewardID, TEnumAsByte<EOrderStateType> WeeklyState);
	void UpdateOrderDailyInfo(int CurrentDaily, int MaxDaily, int RewardID, TEnumAsByte<EOrderStateType> DailyState);
	void UpdateOrder(struct FOrderProgressInfo* OrderInfo);
	void EmptyOrder();
	void RemoveOrder(TArray<int> OrderIDs);
	void AddOrder(TArray<struct FOrderProgressInfo> OrderProgressInfoList);
	void InitializeOrder(TArray<struct FOrderProgressInfo> OrderProgressInfoList);
};


// Class BLGame.QuestActionChecker
// 0x0058 (0x00B8 - 0x0060)
class UQuestActionChecker : public UObject
{
public:
	struct FMap_Mirror                                 QuestActionProgressMap;                                   // 0x0060(0x0048) (Native)
	TArray<int>                                        LockedActionList;                                         // 0x00A8(0x0010) (Native, AlwaysInit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.QuestActionChecker");
		return ptr;
	}


	void RemoveQuestOnProgressMap(int InQuestID);
	void RemoveActionQuestOnProgressMap(int InActionID, int InQuestID);
	void AddActionQuestToProgressMap(int InActionID, int InQuestID);
	void SendPackagePcAction(int InActionID);
	bool IsLockedAction(int InActionID);
	void CheckLockActionsToProgressMap();
	void UnLockActionObjective(int InActionID);
	void LockActionObjective(int InActionID);
	void CheckQuestActionObjective(const struct FString& PCActionName);
	void Initialize();
};


// Class BLGame.QuestAreaManager
// 0x0010 (0x0070 - 0x0060)
class UQuestAreaManager : public UObject
{
public:
	TArray<struct FQuestAreaInfo>                      QuestAreaInfoList;                                        // 0x0060(0x0010) (AlwaysInit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.QuestAreaManager");
		return ptr;
	}


	void GetQuestAreaInfos(TArray<struct FQuestAreaInfo>* AreaInfos);
	void GetQuestAreaInfosBelongQuestID(int questId, TArray<struct FQuestAreaInfo>* AreaInfos);
	class UQuestManager* GetQuestManager();
};


// Class BLGame.QuestJournalManager
// 0x0055 (0x00B5 - 0x0060)
class UQuestJournalManager : public UObject
{
public:
	TArray<struct FLocationEpisodeQuestInfo>           LocationQuestInfos;                                       // 0x0060(0x0010) (NeedCtorLink)
	TArray<struct FEpisodeExtension>                   EpisodeExtensions;                                        // 0x0070(0x0010) (Config, NeedCtorLink)
	TArray<struct FStoryExtension>                     StoryExtensions;                                          // 0x0080(0x0010) (Config, NeedCtorLink)
	TArray<int>                                        RoyalQuestIDs;                                            // 0x0090(0x0010) (NeedCtorLink)
	int                                                CacheingQuestID;                                          // 0x00A0(0x0004)
	TArray<int>                                        GuideQuestStages;                                         // 0x00A4(0x0010) (AlwaysInit, NeedCtorLink)
	TEnumAsByte<EUIJournalTabType>                     LastOpenedTabType;                                        // 0x00B4(0x0001)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.QuestJournalManager");
		return ptr;
	}


	void SetJournalOpenLevel();
	void SetCompleteGuideQuestInfo(int questId);
	void SetGuideQuestInfo(int questId);
	TArray<class UGFxObject*> MakeGuideQuestInfoGFxObject();
	void InitializeGuideQuest();
	void AUSetQuestInfo(int InQuestID);
	void AUSetCompleteQuestInfo(int InQuestID);
	struct FString GetPlotHistoryString(int StoryID, int PlotIndex);
	bool GetDungeonMapLocationByWorldLocation(struct FVector* WorldLocation, struct FVector2D* OutLocation);
	void GetQuestCountDownInfosBelongQuestID(int questId, struct FQuestCountDownInfo* CountDownInfo);
	void GetQuestAreaInfosBelongMonsterBookID(int MonsterBookID, TArray<struct FAreaElementInfo>* AreaElementInfos);
	void GetQuestAreaInfosBelongInstantDungeonID(int InstantDungeonCid, struct FString* QuestNames);
	void GetQuestCountDownInfos(TArray<struct FQuestCountDownInfo>* CountDownInfos);
	TArray<int> GetHasQuestNPCIDs();
	void RemoveQuest(int questId, bool bReward);
	void NotifyCompleteStoryPlot(int InStoryCid, int InPlotIndex);
	void NotifyStartStoryPlot(int InStoryCid, int InPlotIndex, int InCurrentOnGoingQuestCid);
	class UGFxObject* STATIC_MakeGFxObjectContentTokenRewards(TArray<struct FQuestRewardContentToken>* InRewards);
	class UGFxObject* MakeItemGFxObject(int InItemID, int InIconIndex, int InItemGrade, const struct FString& InItemName, int InQuantity, int InItemEquipType, bool InUsable);
	class UGFxObject* MakePlotGFxObject(int InPlotIndex, struct FString* InPlotName);
	class UGFxObject* MakeStoryGFxObject(int InStoryID, struct FString* InStoryName, struct FString* InCharacterName);
	class UGFxObject* MakeGFxObjective(const struct FString& InTitle, int InCount, int InTotalCount, bool InIsCompleted);
	void RemoveStoryExtension(int StoryID);
	void AddStoryExtension(int StoryID);
	bool IsStoryExtension(int InStoryID, struct FString* InCharacterName);
	bool IsStoryExtensionCharacterName(struct FString* InCharacterName);
	void SetStoryExtension(int StoryID, bool extension);
	void RemoveLocationExtension(int LocationID);
	void AddLocationExtension(int LocationID);
	bool IsLocationExtension(const struct FString& CharacterName, int LoactionID);
	void SetCompleteEpisodeList(int InLocationId, TArray<int>* InCompleteEpisodeList);
	void StoryQuestRefresh();
	void SetPlotInfo2(int StoryID, int PlotIndex);
	struct FString STATIC_GetQuestObjectiveListText(int questId, const struct FString& CompleteTag, const struct FString& OngoingTag, const struct FString& NoRegistTag, const struct FString& SubTitleTag);
	void UpdateStoryQuest(int StoryID, int PlotIndex);
	void AddStoryPlot(int StoryID, int PlotIndex);
	void AddStory();
	void InitializeStoryInfo();
	void InitializeMonsterBookUI();
	void SetRoyalQuestInfo(int questId);
	class UGFxObject* MakeRoyalQuestRewardGFxObject(const struct FString& InTitle, int InGold, TArray<struct FClientSystemMailItemInfo>* InItemInfoList);
	int ConvertQuestTypeClientToActionScript(TEnumAsByte<ECEQuestType> InClientType);
	void SetRewardWindowQuestInfo(int questId);
	void SetCompleteEpisodeQuestInfo(int questId);
	void SetEpisodeQuestInfo(int questId);
	void StoryQuestReStartDialog(int questId);
	void UpdateQuest(int questId, TEnumAsByte<ECEQuestType> QuestType, int LocationID, int QuestLevel, const struct FString& QuestTitle, bool isCompleted, bool isFailed, bool bJustObjectiveCompleted, bool bJustFailed);
	void SetActiveQuest(int questId);
	void AddQuest(int questId, TEnumAsByte<ECEQuestType> QuestType, int LocationID, int QuestLevel, const struct FString& QuestTitle, bool isCompleted, bool isFailed, float TimeLimit);
	void SetLocationExtension(int LocationID, bool extension);
	bool RemoveLocationQuestInfo(int LocationID, int questId, bool bReward);
	void UpdateRoyalQuestUI();
	void RemoveRoyalQuest(int InQuestID);
	void AddRoyalQuest(int InQuestID);
	void AddLocationQuestInfo(int LocationID, int questId, bool bForce);
	bool GetLocationQuestInfo(int LocationID, struct FLocationEpisodeQuestInfo* OutLocationQuestInfo);
	bool IsLocationQuestInfo(int LocationID);
	TArray<class UGFxObject*> MakeLocationQuestInfoGFxObject();
	void UpdateQuestList();
	void InitializeQuestList();
	class UBLQuestJournalUIManager* GetQuestJournalUIManager();
	class UQuestManager* GetQuestManager();
};


// Class BLGame.QuestManager
// 0x019C (0x01FC - 0x0060)
class UQuestManager : public UObject
{
public:
	struct FMap_Mirror                                 QuestOngoingMap;                                          // 0x0060(0x0048) (Native)
	struct FMultiMap_Mirror                            QuestAvailableMap;                                        // 0x00A8(0x0048) (Native)
	struct FMultiMap_Mirror                            QuestElementMap;                                          // 0x00F0(0x0048) (Native)
	class UQuestJournalManager*                        QuestJournalManager;                                      // 0x0138(0x0008) (ExportObject, NeedCtorLink, EditInline)
	class UQuestNPCManager*                            QuestNPCManager;                                          // 0x0140(0x0008) (ExportObject, NeedCtorLink, EditInline)
	class UQuestMonsterBook*                           QuestMonsterBook;                                         // 0x0148(0x0008) (ExportObject, NeedCtorLink, EditInline)
	class UQuestAreaManager*                           QuestAreaManager;                                         // 0x0150(0x0008) (ExportObject, NeedCtorLink, EditInline)
	class UQuestWorldMapManager*                       QuestWorldMapManager;                                     // 0x0158(0x0008) (ExportObject, NeedCtorLink, EditInline)
	class UQuestActionChecker*                         QuestActionChecker;                                       // 0x0160(0x0008) (ExportObject, NeedCtorLink, EditInline)
	struct FPCStoryInfo                                PCStoryInfo;                                              // 0x0168(0x0020) (NeedCtorLink)
	TArray<int>                                        AddQuestIDs;                                              // 0x0188(0x0010) (NeedCtorLink)
	TArray<int>                                        DeleteQuestIDs;                                           // 0x0198(0x0010) (NeedCtorLink)
	TArray<class UQuestAsset*>                         QuestAssetCaches;                                         // 0x01A8(0x0010) (NeedCtorLink)
	struct FIndirectArray_Mirror                       ResolvedQuestsBitFlag;                                    // 0x01B8(0x0010) (Const, Native)
	TArray<struct FQuestSortData>                      ActivateUseQTEQuest;                                      // 0x01C8(0x0010) (Transient, NeedCtorLink)
	unsigned long                                      LastQTESlotShowing : 1;                                   // 0x01D8(0x0004) (Transient)
	unsigned long                                      bIsChangedActivateUseQTEQuest : 1;                        // 0x01D8(0x0004) (Transient)
	int                                                GuideQuestNotificationCount;                              // 0x01DC(0x0004) (Transient)
	int                                                OngoingGuideQuestCount;                                   // 0x01E0(0x0004) (Transient)
	int                                                RoyalQuestNotificationCount;                              // 0x01E4(0x0004) (Transient)
	int                                                RoyalQuestCount;                                          // 0x01E8(0x0004)
	float                                              mapNPCIconRefreshPeriod;                                  // 0x01EC(0x0004) (Config)
	float                                              NPCIconUpdateCheckTime;                                   // 0x01F0(0x0004)
	int                                                CacheingQuestID;                                          // 0x01F4(0x0004)
	int                                                CacheingType;                                             // 0x01F8(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.QuestManager");
		return ptr;
	}


	void CountingOngoingQuestByType();
	void EmitAddGuideQuestEffect();
	void GetRoyalQuestInitializeTime(int* OutInitializeTime, int* OutInitializeRemainTime);
	bool IsRoyalQuestAcceptable();
	bool IsQuestConditionEqual(int Quest_CID, TEnumAsByte<ECEQuestConditionType> ConditionType, int ObjectiveIndex);
	bool IsUsableQuestItemToProp(int PropSID);
	void UpdateQTEQuestItem();
	void UpdateActivateUseQTEQuest();
	void UpdateSpecificQuestItem(const struct FOngoingQuestInfo& OngingQuestData);
	void BuildOngoingQuestByItemCID(int ItemCid, TArray<struct FOngoingQuestInfo>* OngingQuestList);
	struct FObjectiveNPCInfo FindObjectiveNPCInfo(int NpcCid);
	void ShowMonsterBookWorldMap(int MonsterBookID);
	void ShowQuestWorldMap(int questId, bool bFlickering);
	void MatchingQuestNPC(int NpcServerID, TArray<struct FNPCQuestInfo>* QuestStatusList);
	class UAlertManager* GetAlertManager();
	int GetActiveQTEQuestItemCID();
	class UBLUIPlayer* GetUI();
	void FillQuestElementData(struct FOngoingQuestInfo* OutOngoingQuestInfo);
	void MonsterBook_GetMonsterBookIDAll(TArray<int>* MonsterBookIDs);
	void MonsterBook_AllClear(int InMonsterBookCid, bool bIsAvailableRepeat);
	void MonsterBook_RewardMonsterBookAckFailed(int InErrorCode, int InMonsterCid, int InStageIndex);
	void MonsterBook_OpenMonsterBookLocation();
	void MonsterBook_RewardMonsterBookAck(int InMonsterCid, int InStageIndex);
	void MonsterBook_UpdateHuntingInfo(const struct FMonsterHuntingProgressInfo& InProgressInfo);
	void MonsterBook_AddAvailableRewardRep(int InMonsterCid, int InStageIndex);
	void MonsterBook_EnterWorld(const struct FMonsterBookProgressInfo& InInfo);
	void MonsterBook_OpenMonsterBookRep(int InMonsterBookId);
	void MonsterBook_OpenLocationRep(int InLocationCid);
	void RestartQuest(struct FQuestProgressInfo* OngoingQuestList);
	void UpdateQuest(struct FQuestProgressInfo* OngoingQuestList);
	struct FOngoingQuestInfo MakeOngoingQuestInfo(int questId, const struct FQuestProgressInfo& ProgressInfo);
	void ClearMonsterBookNotification();
	void ClearRoyalQuestNotification();
	void ClearGuideQuestNotification();
	void RemoveQuest(int questId, bool bReward);
	void RewardQuest(int questId);
	void AddQuest(int questId);
	struct FPCStoryInfo GetStoryInfo();
	void UpdateCompleteStoryCid(TArray<int> InCompleteStoryCid);
	bool IsCompletedStory(int StoryID);
	bool IsFirstQuestFromOldStoryPlot(const struct FCurrentPCStoryInfo& InCurrentStoryInfo, const struct FCurrentPCStoryInfo& InPreCurrentStoryInfo);
	bool IsAcceptedFirstStroy(const struct FCurrentPCStoryInfo& InCurrentStoryInfo, const struct FCurrentPCStoryInfo& InPreCurrentStoryInfo);
	void RefreshStoryQuest();
	void UpdateCurrentStoryInfo(const struct FCurrentPCStoryInfo& InCurrentStoryInfo);
	void InitializeStoryInfo(const struct FPCStoryInfo& InStoryInfo);
	void InitializeQuestList(TArray<struct FQuestProgressInfo>* OngoingQuestList);
	bool IsActivatedQuestUseItem(int QuestCid);
	bool GetOngoingQuestInfo(int questId, struct FOngoingQuestInfo* OutOngoingQuestInfo);
	void InitResolvedQuest(TArray<unsigned char>* ResolveQuestList);
	void AddResolvedQuest(int questId);
	void GetOngoingQuestInfoLists(TArray<struct FOngoingQuestInfo>* OngoingQuestInfoList);
	void GetQuestProgessInfoList(TArray<struct FQuestProgressInfo>* ProgressInfoArray);
	void UpdateQuestNaviOn(int questId);
	void InitializeAvailableMap();
	void EmptyQuestMap();
	bool RemoveQuestMap(int questId);
	bool SetQuestMap(int questId, const struct FOngoingQuestInfo& Info);
};


// Class BLGame.QuestMonsterBook
// 0x009C (0x00FC - 0x0060)
class UQuestMonsterBook : public UObject
{
public:
	float                                              TamingDifficulty1;                                        // 0x0060(0x0004) (Config)
	float                                              TamingDifficulty2;                                        // 0x0064(0x0004) (Config)
	float                                              TamingDifficulty3;                                        // 0x0068(0x0004) (Config)
	TArray<struct FQuestMonsterBookLocation>           Locations;                                                // 0x006C(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<int>                                        RewardAvailableMonsterIDs;                                // 0x007C(0x0010) (AlwaysInit, NeedCtorLink)
	int                                                ShowLocationID;                                           // 0x008C(0x0004) (Transient)
	int                                                SelectedMonsterBookCID;                                   // 0x0090(0x0004) (Transient)
	struct FMap_Mirror                                 RegistedMonsterBookData;                                  // 0x0094(0x0048) (Native)
	TArray<int>                                        UpdateMonsterLocationIDs;                                 // 0x00DC(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<int>                                        UpdateMonsterBookIDs;                                     // 0x00EC(0x0010) (AlwaysInit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.QuestMonsterBook");
		return ptr;
	}


	void ClearRewardAvailableMonsterIDsForOpener();
	void ClearRegistedMonsterBookData();
	bool IsRewardAvailableMonster(int MonsterID);
	bool RemoveRewardAvailableMonster(int MonsterID);
	bool AddRewardAvailableMonster(int MonsterID);
	void InitRewardAvailableMonsterCount();
	void SetupUI_StagePhase(int InSelectedMonsterBookId);
	bool IsStageComplete(const struct FQuestMonsterBookData& InBook, int InStageIndex);
	void BuildFellowSkillByTamingResult(int InCid, TArray<struct FQuestMonsterBookTamingSkill>* OutSkills);
	void BuildMountSkillByTamingResult(int InCid, TArray<struct FQuestMonsterBookTamingSkill>* OutSkills);
	void BuildPetSkillByTamingResult(int InCid, TArray<struct FQuestMonsterBookTamingSkill>* OutSkills);
	void BuildTamingSkills(struct FNPCInfoData* InNpcInfoData, TArray<struct FQuestMonsterBookTamingSkill>* OutObjList);
	void SetupUI_MonsterDetailedDescription(int InSelectedMonsterBookCid);
	void SetupUI_MonsterLocation(int InLocationId);
	void SetupUI_MonsterData(int InMonsterBookId);
	void SetupUI_MonsterList();
	void MoveToTopListByLocationId(int InLocationCid);
	void SortQuestMonsterBookLocationList(TArray<struct FQuestMonsterBookLocation>* OutList);
	struct FString GetObjectiveSummary(int InMonsterBookCid, int InStage, bool bPrintCount, bool bRepeatStage);
	struct FString GetStageSummary(int InMonsterBookCid, int InStageIndex);
	void GetMonsterAccumulatedCount(int InMonsterBookCid, int InStageIndex, int* OutCount, int* OutTotalCount);
	bool IsDropItemUnique(int InItemCid, TArray<int> InDropItems);
	void GetMonsterBookMonsterTotalCount(const struct FQuestMonsterBookLocation& InBookLocation, int* CurrentCount, int* TotalCount);
	int GetCurrentStageInProgress(TArray<struct FQuestBookstage> InStages);
	bool HasAvailableStageReward(TArray<struct FQuestBookstage>* InStages);
	void MakeCompleteByAvailableReward(bool InRewardNone);
	void UpdateMonsterCount(int monsterBookCId, int InStageIndex, TArray<int> ObjectiveCount);
	void MakeRewardCompleteStage(int monsterCid, int StageIndex);
	struct FQuestMonsterBookData FindMonsterBookById(int InMonsterBookId);
	int AddEmptyMonsterBook(int InMonsterBookId, bool InStageClearedAll, bool InExtendBook, bool InIsAvailableRepeat);
	void AddEmptyLocation(int InLocationId);
	bool IsMonsterBookAlreadyExist(int InMonsterBookId);
	void AddMonsterBookByLocationId(int InLocationId, bool InExtendBook, struct FQuestMonsterBookData* InBook);
	void SendNotifyComplete(class UBLUIPlayer* InUIPlayer, int InMonsterBook, int NextStageIndex, bool bSendForce);
	void SetCurrentHuntingStageIndex(int InMonsterBookCid, bool bAllCleared, int InStageIndex, bool bRepeatStage);
	bool MakeAvailableReward(int InMonsterBookCid, int InStageIndex);
	class UBLUIPlayer* GetUIPlayer();
	bool IsAddAlert(int RemoveCount, int AddCount);
	bool IsInQuestAlert(int InMonsterBookCid);
	void UpdateZoneChanged(TArray<int> InVolumeList);
	void AUSetMonsterLocationExtension(int LocationID, bool extension);
	void UpdateEnterWorld(const struct FMonsterBookProgressInfo& InInfo);
	void AUGetRewardMonsterQuest(int InMonsterBookId);
	void RewardMonsterBookAck(int InMonsterBookCid, int StageIndex);
	void OpenMonsterBook(int InMonsterBookId);
	void OpenLocation(int InLocationCid);
	void AllClear(int InMonsterBookCid, bool bIsAvailableRepeat);
	void UpdateHuntingInfo(const struct FMonsterHuntingProgressInfo& InHuntingInfo);
	void AUMonsterBookListSelected(int InMonsterBookCid);
	void AddAvailableRewardRep(int InMonsterBookCid, int InStageIndex);
	void GetDataForAlimi(int InMonsterBookCid, struct FString* OutTitle, struct FString* outSummary, int* bIsComplete, int* COUNT, int* TotalCount, int* HasReward);
	void ShowMonsterBookUI(int InMonsterBookId);
	int GetLocationIDByBookID(int BoolID);
	void GetMonsterBookIDAll(TArray<int>* OutMonsterBookIds);
	void InitializeUI();
};


// Class BLGame.QuestNPCManager
// 0x0020 (0x0080 - 0x0060)
class UQuestNPCManager : public UObject
{
public:
	TArray<struct FQuestNPCInfo>                       QuestNPCInfoList;                                         // 0x0060(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<struct FPointer>                            NPCMarkerList;                                            // 0x0070(0x0010) (Native)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.QuestNPCManager");
		return ptr;
	}


	class UQuestManager* GetQuestManager();
	bool FindQuestNPCInfo(int NpcCid, struct FQuestNPCInfo* outQuestNPCInfo, TArray<struct FQuestNPCMarker>* outQuestNPCMarker);
	void GetQuestNPCInfos(TArray<struct FQuestNPCInfo>* NPCInfos);
	bool GetQuestNPCMarkerLocation(int NpcCid, struct FVector* NPCMarkerLoc);
};


// Class BLGame.QuestVisualManager
// 0x0000 (0x0060 - 0x0060)
class UQuestVisualManager : public UObject
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.QuestVisualManager");
		return ptr;
	}

};


// Class BLGame.QuestWorldMapManager
// 0x0058 (0x00B8 - 0x0060)
class UQuestWorldMapManager : public UObject
{
public:
	struct FMultiMap_Mirror                            WorldMapQuestInfoMap;                                     // 0x0060(0x0048) (Native)
	TArray<class ABLWorldMapQuestAreaBase*>            WorldMapQuestAreaList;                                    // 0x00A8(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.QuestWorldMapManager");
		return ptr;
	}


	void RemoveQuestAreaElement(int AreaCID);
	void DeleteWorldMapQuestAreaInfo();
	void InitializeWorldMapQuestAreaInfo(TArray<class ABLWorldMapElement*>* WorldMapElements, TArray<class ABLWorldMapElement*>* OnGoingElements);
	void DeleteWorldMapQuestInfo();
	void InitializeWorldMapQuestInfo(TArray<class ABLWorldMapElement*>* WorldMapElements, TArray<class ABLWorldMapElement*>* OnGoingElements);
	class UQuestManager* GetQuestManager();
};


// Class BLGame.TutorialOrderManager
// 0x007C (0x00DC - 0x0060)
class UTutorialOrderManager : public UObject
{
public:
	struct FMap_Mirror                                 TutorialOrderInfoMap;                                     // 0x0060(0x0048) (Native)
	TArray<struct FTutorialOrderData>                  CanReceiveInfoList;                                       // 0x00A8(0x0010) (Native, AlwaysInit)
	TArray<struct FTutorialOrderData>                  ForceProgressInfoList;                                    // 0x00B8(0x0010) (Native, AlwaysInit)
	int                                                RewardCount;                                              // 0x00C8(0x0004)
	int                                                CurTutorialOrderGuideID;                                  // 0x00CC(0x0004)
	int                                                CurTutorialOrderAlarmiID;                                 // 0x00D0(0x0004)
	int                                                StageID;                                                  // 0x00D4(0x0004)
	unsigned long                                      bNextOpenAlarmi : 1;                                      // 0x00D8(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.TutorialOrderManager");
		return ptr;
	}


	int GetTutorialOrderCount();
	void SendPackageChangeState(int TutorialOrderId);
	void SendPackagePcAction(int PcActionCid);
	void UnLockAlarmiSendPackage(int TutorialOrderId);
	void LockAlarmiSendPackage(int TutorialOrderId);
	void UnLockObjectiveSendPackage(int TutorialOrderId);
	void LockObjectiveSendPackage(int TutorialOrderId);
	void SetNextOpenAlarmi(bool bOpenAlarmi);
	void NextTutorialOrderGuide();
	void SetCurTutorialOrderGuideID(int TutorialGuideId);
	void OpenTutorialGuide(int TutorialGuideId, const struct FString& GuideTitle);
	void SetTutorialGuide(int TutorialOrderId);
	void OpenTutorialOrderAlarmi(int Cid, const struct FString& CategoryCodename, const struct FString& Description);
	void SetTutorialOrderAlarmi();
	void NextTutorialOrderAlarmi();
	void CheckAlarmiTrigger_GetPCAction(const struct FString& PCActionName);
	void CheckTutorialOrderObjective_GetPCAction(const struct FString& PCActionName);
	bool CheckRewardTutorialOrder(int PrevState, int CurrentState);
	void RequestTutorialOrderAlarmi();
	void RequestTutorialOrderStage();
	void RequestTutorialOrderInfo();
	void UpdateTutorialOrderStage(int TutorialOrderStageId);
	void UpdateTutorialOrderInfo(struct FTutorialOrderProgressInfo* TutorialOrderInfo);
	void SortAlarmiInfo();
	void RemoveAlarmiInfo(struct FTutorialOrderData* InTutorialOrderData);
	void AddAlarmiInfo(struct FTutorialOrderData* InTutorialOrderData);
	void AddTutorialOrderInfo(TArray<struct FTutorialOrderProgressInfo> TutorialOrderProgressInfoList);
	void EmptyTutorialOrderInfo();
	void InitTutorialOrderInfo(TArray<struct FTutorialOrderProgressInfo> TutorialOrderProgressInfoList, TArray<unsigned char> rewardCompleteList);
	int GetTutorialOrderRewardCount();
};


// Class BLGame.BLWorldMapAutoPathManager
// 0x0010 (0x0070 - 0x0060)
class UBLWorldMapAutoPathManager : public UObject
{
public:
	TArray<int>                                        CompletedNodeList;                                        // 0x0060(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLWorldMapAutoPathManager");
		return ptr;
	}


	void RemovePopup();
	void ShowPopUp(bool bIsAutoPathMode, bool bIsOnDestinationIcon);
	void ArriveDestNode();
	void StartAutoMoving();
	void RemoveAutoPathElements();
	bool SetWorldMapAutoPathElementsWithRealDestination();
	bool SetWorldMapAutoPathElements();
	void UpdatePath();
	void CancelAutoPath();
	bool SetPathWithElement(class ABLWorldMapElement* InWorldMapElement);
	bool SetPath(const struct FVector& InDestLoc, bool InNeedToCheckTerrainZ);
	bool InitializeWorldMapAutoPathElements();
};


// Class BLGame.BLWorldMapElement
// 0x0064 (0x02B4 - 0x0250)
class ABLWorldMapElement : public AActor
{
public:
	TEnumAsByte<EWorldMapElementIconType>              IconType;                                                 // 0x0250(0x0001) (Transient)
	TEnumAsByte<EFiltering_Icon>                       IconFilter;                                               // 0x0251(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x0252(0x0002) MISSED OFFSET
	int                                                TemporaryPriority;                                        // 0x0254(0x0004) (Transient)
	int                                                Cid;                                                      // 0x0258(0x0004) (Transient)
	int                                                OffsetZ;                                                  // 0x025C(0x0004) (Transient)
	class UBLTranslucentSpriteComponent*               ElementComponent;                                         // 0x0260(0x0008) (ExportObject, Component, EditInline)
	struct FVector                                     OriginLocation;                                           // 0x0268(0x000C)
	struct FVector                                     GameWorldLocation;                                        // 0x0274(0x000C)
	float                                              defaultScale;                                             // 0x0280(0x0004)
	int                                                ElementIndex;                                             // 0x0284(0x0004)
	unsigned long                                      bShowTooltip : 1;                                         // 0x0288(0x0004)
	unsigned long                                      bFiltered : 1;                                            // 0x0288(0x0004)
	unsigned long                                      bIsFixedScale : 1;                                        // 0x0288(0x0004)
	unsigned long                                      bTemporaryIgnoreFilter : 1;                               // 0x0288(0x0004)
	struct FBox                                        ShowToolTipBox;                                           // 0x028C(0x001C) (Transient)
	float                                              FlickeringElapsedTime;                                    // 0x02A8(0x0004)
	float                                              FlickeringTime;                                           // 0x02AC(0x0004)
	int                                                NumFlickering;                                            // 0x02B0(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLWorldMapElement");
		return ptr;
	}


	void Flickering(float DeltaTime);
	void ElementDestroy();
	void InitializeScale();
	void HideTooltip();
	void ShowTooltip(int X, int Y);
	void InitWorldMapElement(int Type);
};


// Class BLGame.BLWorldMapAutoPathInfo
// 0x0008 (0x02BC - 0x02B4)
class ABLWorldMapAutoPathInfo : public ABLWorldMapElement
{
public:
	int                                                Type;                                                     // 0x02B4(0x0004)
	int                                                NodeIndex;                                                // 0x02B8(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLWorldMapAutoPathInfo");
		return ptr;
	}


	void InitWorldMapElement(int InType);
};


// Class BLGame.BLWorldMapCustomWaypointInfo
// 0x002C (0x02E0 - 0x02B4)
class ABLWorldMapCustomWaypointInfo : public ABLWorldMapElement
{
public:
	class ABLTransportWaypoint*                        WaypointInfo;                                             // 0x02B4(0x0008)
	struct FCustomWaypointData                         CustomWaypointInfo;                                       // 0x02BC(0x0018)
	int                                                Type;                                                     // 0x02D4(0x0004)
	class UBLTeleportManager*                          TeleportManager;                                          // 0x02D8(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLWorldMapCustomWaypointInfo");
		return ptr;
	}


	void DoTeleport();
	void ShowPopUp();
	void ShowTooltip(int X, int Y);
	void InitWorldMapElement(int InType);
};


// Class BLGame.BLWorldMapFieldRaidInfo
// 0x0044 (0x02F8 - 0x02B4)
class ABLWorldMapFieldRaidInfo : public ABLWorldMapElement
{
public:
	struct FFieldRaidMapInfo                           MapInfo;                                                  // 0x02B4(0x0044) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLWorldMapFieldRaidInfo");
		return ptr;
	}


	void ShowTooltip(int X, int Y);
	void InitWorldMapElement(int InType);
};


// Class BLGame.BLWorldMapInstanceRevivalPoint
// 0x0018 (0x02CC - 0x02B4)
class ABLWorldMapInstanceRevivalPoint : public ABLWorldMapElement
{
public:
	TEnumAsByte<ECEInstantRevivalPointType>            PointType;                                                // 0x02B4(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x02B5(0x0003) MISSED OFFSET
	struct FString                                     spawnerName;                                              // 0x02B8(0x0010) (NeedCtorLink)
	unsigned long                                      bRegisted : 1;                                            // 0x02C8(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLWorldMapInstanceRevivalPoint");
		return ptr;
	}


	void ShowTooltip(int X, int Y);
	void InitWorldMapElement(int InType);
};


// Class BLGame.BLWorldMapNPCIcon
// 0x0064 (0x0318 - 0x02B4)
class ABLWorldMapNPCIcon : public ABLWorldMapElement
{
public:
	struct FNPCFuncInfo                                NPCFuncInfo;                                              // 0x02B4(0x0060) (NeedCtorLink)
	int                                                ServerID;                                                 // 0x0314(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLWorldMapNPCIcon");
		return ptr;
	}


	void ShowTooltip(int X, int Y);
	void InitWorldMapElement(int Type);
};


// Class BLGame.BLWorldMapPinFocusingInfo
// 0x0000 (0x02B4 - 0x02B4)
class ABLWorldMapPinFocusingInfo : public ABLWorldMapElement
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLWorldMapPinFocusingInfo");
		return ptr;
	}


	void InitWorldMapElement(int Type);
};


// Class BLGame.BLWorldMapPlayerInfo
// 0x0008 (0x02BC - 0x02B4)
class ABLWorldMapPlayerInfo : public ABLWorldMapElement
{
public:
	int                                                ServerID;                                                 // 0x02B4(0x0004)
	int                                                Type;                                                     // 0x02B8(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLWorldMapPlayerInfo");
		return ptr;
	}


	void ShowTooltip(int X, int Y);
	void SetRaidMemberTexture();
	void SetDeadBodyTexture();
	void SetPartyTexture();
	void SetUserTexture();
	void InitWorldMapElement(int InType);
};


// Class BLGame.BLWorldMapPlayerPositioning
// 0x0000 (0x02B4 - 0x02B4)
class ABLWorldMapPlayerPositioning : public ABLWorldMapElement
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLWorldMapPlayerPositioning");
		return ptr;
	}

};


// Class BLGame.BLWorldMapPropIcon
// 0x0024 (0x02D8 - 0x02B4)
class ABLWorldMapPropIcon : public ABLWorldMapElement
{
public:
	struct FPropFuncInfo                               PropFuncInfo;                                             // 0x02B4(0x0024) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLWorldMapPropIcon");
		return ptr;
	}


	void ShowTooltip(int X, int Y);
	void InitWorldMapElement(int Type);
};


// Class BLGame.BLWorldMapQuestAreaBase
// 0x00C8 (0x037C - 0x02B4)
class ABLWorldMapQuestAreaBase : public ABLWorldMapElement
{
public:
	unsigned long                                      bTemporaryQuest : 1;                                      // 0x02B4(0x0004)
	struct FAreaElementInfo                            AreaInfo;                                                 // 0x02B8(0x00C4) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLWorldMapQuestAreaBase");
		return ptr;
	}

};


// Class BLGame.BLWorldMapQuestAreaIcon
// 0x0000 (0x037C - 0x037C)
class ABLWorldMapQuestAreaIcon : public ABLWorldMapQuestAreaBase
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLWorldMapQuestAreaIcon");
		return ptr;
	}


	void ShowTooltip(int X, int Y);
	void InitWorldMapElement(int Type);
};


// Class BLGame.BLWorldMapQuestAreaInfo
// 0x0000 (0x037C - 0x037C)
class ABLWorldMapQuestAreaInfo : public ABLWorldMapQuestAreaBase
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLWorldMapQuestAreaInfo");
		return ptr;
	}


	void ShowTooltip(int X, int Y);
	void InitWorldMapElement(int Type);
};


// Class BLGame.BLWorldMapQuestInfo
// 0x0098 (0x034C - 0x02B4)
class ABLWorldMapQuestInfo : public ABLWorldMapElement
{
public:
	struct FQuestNPCInfo                               QuestNPCInfo;                                             // 0x02B4(0x0098) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLWorldMapQuestInfo");
		return ptr;
	}


	void ShowTooltip(int X, int Y);
	void CompleteState();
	void InitWorldMapElement(int Type);
};


// Class BLGame.BLWorldMapUnderAttackInfo
// 0x0010 (0x02C4 - 0x02B4)
class ABLWorldMapUnderAttackInfo : public ABLWorldMapElement
{
public:
	float                                              RemainTime;                                               // 0x02B4(0x0004)
	float                                              ElapsedTime;                                              // 0x02B8(0x0004)
	float                                              BlinkTime;                                                // 0x02BC(0x0004)
	int                                                ServerID;                                                 // 0x02C0(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLWorldMapUnderAttackInfo");
		return ptr;
	}


	void InitWorldMapElement(int Type);
};


// Class BLGame.BLWorldMapWaypointInfo
// 0x001C (0x02D0 - 0x02B4)
class ABLWorldMapWaypointInfo : public ABLWorldMapElement
{
public:
	class ABLTransportWaypoint*                        WaypointInfo;                                             // 0x02B4(0x0008)
	int                                                Type;                                                     // 0x02BC(0x0004)
	TEnumAsByte<ECETransportType>                      transportationType;                                       // 0x02C0(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x02C1(0x0003) MISSED OFFSET
	unsigned long                                      bAvailable : 1;                                           // 0x02C4(0x0004)
	class UBLWorldMapWaypointManager*                  WPManager;                                                // 0x02C8(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLWorldMapWaypointInfo");
		return ptr;
	}


	bool RequestRouteInfo(struct FString* Cost);
	void HideTooltip();
	void ShowTooltip(int X, int Y);
	void InitWorldMapElement(int InType);
};


// Class BLGame.BLWorldMapZoneName
// 0x0024 (0x02D8 - 0x02B4)
class ABLWorldMapZoneName : public ABLWorldMapElement
{
public:
	class UGFxObject*                                  ZoneNameMC;                                               // 0x02B4(0x0008)
	class ABLZoneVolume*                               MatchingVolume;                                           // 0x02BC(0x0008)
	struct FString                                     ZoneName;                                                 // 0x02C4(0x0010) (NeedCtorLink)
	struct FColor                                      ZoneNameColor;                                            // 0x02D4(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLWorldMapZoneName");
		return ptr;
	}


	void ElementDestroy();
	float GetCalcOffsetX(float InFontSize);
	void SetZoneName(int InCitadelCid, const struct FString& InZoneName, const struct FColor& InZoneNameColor, int IconScale, int IconIndexSign, int IconIndexBG);
	void MakeElementComponet();
	void InitWorldMapElement(int Type);
};


// Class BLGame.BLWorldMapNPCManager
// 0x0108 (0x0168 - 0x0060)
class UBLWorldMapNPCManager : public UObject
{
public:
	struct FMap_Mirror                                 ExistFuncNPCMap;                                          // 0x0060(0x0048) (Native)
	struct FMap_Mirror                                 ConquestWarNPCInfoMap;                                    // 0x00A8(0x0048) (Native)
	struct FMultiMap_Mirror                            NpcCidToSidMappingMap;                                    // 0x00F0(0x0048) (Native)
	TArray<struct FNPCFuncInfo>                        GeneralNPCFuncInfoList;                                   // 0x0138(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<struct FNPCFuncInfo>                        CachedNPCFuncInfoList;                                    // 0x0148(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<struct FNpcMapIconInfo>                     CachedNPCMapIconInfoList;                                 // 0x0158(0x0010) (AlwaysInit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLWorldMapNPCManager");
		return ptr;
	}


	void GetNpcMapIconInfo(TArray<struct FNpcMapIconInfo>* OutInfoArray);
	void GetFuncNPCInfos(TArray<struct FNPCFuncInfo>* outNPCFuncInfos);
	bool GetNPCLocation(int InExistNpcCid, struct FVector* OutNPCLocation);
	int FindExistNpcSidByCid(int InNPCCid);
	void RemoveExistNpcSid(int InNPCCid, int InNpcSid);
	void AddExistNpcSid(int InNpcSid);
};


// Class BLGame.BLWorldMapPropManager
// 0x0048 (0x00A8 - 0x0060)
class UBLWorldMapPropManager : public UObject
{
public:
	struct FMap_Mirror                                 ExistFuncPropMap;                                         // 0x0060(0x0048) (Native)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLWorldMapPropManager");
		return ptr;
	}


	void GetPropMapIconInfo(TArray<struct FPropMapIconInfo>* InfoArray);
	void GetFuncPropInfos(TArray<struct FPropFuncInfo>* PropFuncInfos);
};


// Class BLGame.WaypointMap
// 0x0004 (0x0064 - 0x0060)
class UWaypointMap : public UObject
{
public:
	unsigned long                                      PartyIconFilterON : 1;                                    // 0x0060(0x0004)
	unsigned long                                      QuestIconFilterON : 1;                                    // 0x0060(0x0004)
	unsigned long                                      ShopIconFilterON : 1;                                     // 0x0060(0x0004)
	unsigned long                                      ReturnIconFilterON : 1;                                   // 0x0060(0x0004)
	unsigned long                                      SkillIconFilterON : 1;                                    // 0x0060(0x0004)
	unsigned long                                      DungeonIconFilterON : 1;                                  // 0x0060(0x0004)
	unsigned long                                      ROIconFilterON : 1;                                       // 0x0060(0x0004)
	unsigned long                                      TeleportIconFilterON : 1;                                 // 0x0060(0x0004)
	unsigned long                                      GuildNPCTrapIconFilterON : 1;                             // 0x0060(0x0004)
	unsigned long                                      CraftIconFilterON : 1;                                    // 0x0060(0x0004)
	unsigned long                                      RoyalQuestIconFilterON : 1;                               // 0x0060(0x0004)
	unsigned long                                      WarehouseIconFilterON : 1;                                // 0x0060(0x0004)
	unsigned long                                      RankIconFilterON : 1;                                     // 0x0060(0x0004)
	unsigned long                                      RaidIconFilterON : 1;                                     // 0x0060(0x0004)
	unsigned long                                      ExchangeIconFilterON : 1;                                 // 0x0060(0x0004)
	unsigned long                                      RepqirIconFilterON : 1;                                   // 0x0060(0x0004)
	unsigned long                                      StrengthenIconFilterON : 1;                               // 0x0060(0x0004)
	unsigned long                                      ChallengeTowerFilterON : 1;                               // 0x0060(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.WaypointMap");
		return ptr;
	}


	void SetSubtractFilter(bool FilterOnOff, TEnumAsByte<EFiltering_Icon> FilterIconIndex, int* IconFilter);
	int GetDefaultValueConvertBinary();
};


// Class BLGame.WorldMapManager
// 0x023C (0x029C - 0x0060)
class UWorldMapManager : public UObject
{
public:
	class UBLWorldMapNPCManager*                       NPCManager;                                               // 0x0060(0x0008)
	class UBLWorldMapPropManager*                      PropManager;                                              // 0x0068(0x0008)
	class UBLWorldMapWaypointManager*                  WaypointManager;                                          // 0x0070(0x0008)
	class UBLWorldMapAutoPathManager*                  AutoPathManager;                                          // 0x0078(0x0008)
	class UBlessLocalPlayer*                           LP;                                                       // 0x0080(0x0008)
	class UBLGameViewportClient*                       ViewportClient;                                           // 0x0088(0x0008)
	class ABLCamera*                                   Camera;                                                   // 0x0090(0x0008)
	int                                                WorldMapIconFilter;                                       // 0x0098(0x0004)
	int                                                WayPointMapIconFilter;                                    // 0x009C(0x0004)
	int                                                IconDepthStep;                                            // 0x00A0(0x0004)
	TArray<struct FWorldMapScaleFactor>                ZoomScaleFactor;                                          // 0x00A4(0x0010) (Config, NeedCtorLink)
	TArray<struct FZoneTextFactor>                     ZoneText;                                                 // 0x00B4(0x0010) (Config, NeedCtorLink)
	TArray<struct FZoneTextFactor>                     Subzone1Text;                                             // 0x00C4(0x0010) (Config, NeedCtorLink)
	TArray<struct FZoneTextFactor>                     Subzone2Text;                                             // 0x00D4(0x0010) (Config, NeedCtorLink)
	TArray<struct FZoneTextFactor>                     Subzone3Text;                                             // 0x00E4(0x0010) (Config, NeedCtorLink)
	struct FColor                                      ZoneColor;                                                // 0x00F4(0x0004) (Config)
	struct FColor                                      Subzone1Color;                                            // 0x00F8(0x0004) (Config)
	struct FColor                                      Subzone2Color;                                            // 0x00FC(0x0004) (Config)
	struct FColor                                      Subzone3Color;                                            // 0x0100(0x0004) (Config)
	float                                              PlayerIconScale;                                          // 0x0104(0x0004) (Config)
	float                                              PartyIconScale;                                           // 0x0108(0x0004) (Config)
	struct FEnvironmentCacheDataForWorldMapType        WorldMapEnvCache;                                         // 0x010C(0x0020) (NeedCtorLink)
	struct FName                                       WorldMapPlayerStartTagName;                               // 0x012C(0x0008)
	struct FVector                                     WorldMapPlayerStartDefaultLocation;                       // 0x0134(0x000C)
	TArray<class ABLWorldMapElement*>                  WorldMapElements;                                         // 0x0140(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<class ABLWorldMapElement*>                  TemporaryQuestElements;                                   // 0x0150(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<class ABLWorldMapElement*>                  MonsterBookElements;                                      // 0x0160(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<struct FUnderAttackInfo>                    UnderAttackInfoList;                                      // 0x0170(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<struct FDeathPointInfo>                     DeathPointInfoList;                                       // 0x0180(0x0010) (AlwaysInit, NeedCtorLink)
	float                                              WorldMapDivisionLength;                                   // 0x0190(0x0004)
	float                                              ScaleFactor;                                              // 0x0194(0x0004)
	struct FVector2D                                   Origin;                                                   // 0x0198(0x0008)
	int                                                ZoomGrade;                                                // 0x01A0(0x0004)
	int                                                LimitedMinZoomGrade;                                      // 0x01A4(0x0004)
	int                                                LimitedMaxZoomGrade;                                      // 0x01A8(0x0004)
	int                                                DefaultZoomGrade;                                         // 0x01AC(0x0004) (Config)
	float                                              MinimumDiameter;                                          // 0x01B0(0x0004) (Config)
	float                                              MaximumDiameter;                                          // 0x01B4(0x0004) (Config)
	class ABLWorldMapElement*                          MouseOverringElement;                                     // 0x01B8(0x0008) (Native)
	float                                              MouseOverTimeElapsed;                                     // 0x01C0(0x0004) (Native)
	float                                              MouseOverTriggerTime;                                     // 0x01C4(0x0004) (Native, Config)
	class ABLZoneVolume*                               CachedZoneVolume;                                         // 0x01C8(0x0008) (Native)
	unsigned long                                      bIsWorldMapMode : 1;                                      // 0x01D0(0x0004)
	unsigned long                                      bMoveHotSpot : 1;                                         // 0x01D0(0x0004)
	unsigned long                                      bNeedUpdate : 1;                                          // 0x01D0(0x0004)
	unsigned long                                      bCursorZoom : 1;                                          // 0x01D0(0x0004)
	unsigned long                                      bDrawDebugLoadedLevel : 1;                                // 0x01D0(0x0004) (Transient)
	unsigned long                                      bIsAutoPathMode : 1;                                      // 0x01D0(0x0004) (Transient)
	unsigned long                                      bIsMouseRightDownOnWorldMap : 1;                          // 0x01D0(0x0004) (Transient)
	struct FVector                                     HotSpot;                                                  // 0x01D4(0x000C)
	float                                              MoveHotSpotLimitTime;                                     // 0x01E0(0x0004) (Config)
	float                                              MoveHotSpotElapsedTime;                                   // 0x01E4(0x0004)
	class ABLWorldMapPlayerPositioning*                PlayerPositioning;                                        // 0x01E8(0x0008)
	class ABLWorldMapPinFocusingInfo*                  PinFocusing;                                              // 0x01F0(0x0008)
	TArray<class ABLWorldMapElement*>                  OnGoingQuestInfos;                                        // 0x01F8(0x0010) (NeedCtorLink)
	class ABLWorldMapElement*                          MouseClickedElement;                                      // 0x0208(0x0008) (Native)
	TEnumAsByte<EWorldMapMode>                         WorldMapMode;                                             // 0x0210(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0211(0x0003) MISSED OFFSET
	TArray<struct FPendingCameraZoom>                  PendingZoom;                                              // 0x0214(0x0010) (NeedCtorLink)
	struct FVector2D                                   ToolTipSize;                                              // 0x0224(0x0008) (Config)
	struct FVector2D                                   ToolTipShowPosition;                                      // 0x022C(0x0008) (Config)
	int                                                BackupAAType;                                             // 0x0234(0x0004) (Transient)
	TArray<struct FFieldRaidMapInfo>                   FieldRaidInfoList;                                        // 0x0238(0x0010) (AlwaysInit, NeedCtorLink)
	struct FFontConfigSizeAndColor                     ROGuildNameFont;                                          // 0x0248(0x0008) (Config)
	struct FFontConfigSizeAndColor                     ROGuildLeaderNameFont;                                    // 0x0250(0x0008) (Config)
	int                                                ROGuildMarkSizePercent;                                   // 0x0258(0x0004) (Config)
	struct FFontConfigSizeAndColor                     COGuildNameFont;                                          // 0x025C(0x0008) (Config)
	struct FFontConfigSizeAndColor                     COGuildLeaderNameFont;                                    // 0x0264(0x0008) (Config)
	int                                                COGuildMarkSizePercent;                                   // 0x026C(0x0004) (Config)
	float                                              mapNPCIconRefreshPeriod;                                  // 0x0270(0x0004) (Config)
	float                                              NPCIconUpdateCheckTime;                                   // 0x0274(0x0004)
	float                                              IconOverlapCheckSize;                                     // 0x0278(0x0004) (Config)
	struct FVector                                     AutoPathDestLoc;                                          // 0x027C(0x000C) (Transient)
	struct FVector                                     CandidateOfAutoPathDestLoc;                               // 0x0288(0x000C) (Transient)
	class ABLWorldMapElement*                          CandidateOfAutoPathDestElement;                           // 0x0294(0x0008) (Native, Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.WorldMapManager");
		return ptr;
	}


	void ArriveAutoPathDestNode();
	void CancelAutoPath();
	void SetAutoPath(bool doAutoMoving);
	void InitializeWorldMapAutoPathElements();
	void GetFieldRaidMapInfoList(TArray<struct FFieldRaidMapInfo>* OutMapInfoList);
	void CloseFieldRaid(int InRaidCid);
	void OpenFieldRaid(int InRaidCid);
	void InitializeWorldMapFieldRaidInfo();
	void ClearDeathPoint();
	void TickDeathPoint(float InDeltaTime);
	void AddDeathPoint(const struct FVector& InMarkLocation, float InRemainSeconds);
	void InitializeWorldMapDeathPointInfo();
	void ClearUnderAttack();
	void TickUnderAttack(float InDeltaTime);
	void RemoveUnderAttack(int InServerId);
	void AddUnderAttack(int InServerId, float InElapseSeconds);
	void InitializeWorldMapUnderAttackInfo();
	void TeleportMessage(struct FString* msg);
	struct FVector ConvertGameWorldLocationToWorldMapLocation(const struct FVector& InLocation, bool InitZ);
	struct FVector ConvertWorldMapLocationToGameWorldLocation(const struct FVector& InLocation, bool InitZ);
	struct FString GetZoneNameToLocation(const struct FVector& InLocation);
	bool GetZoneNameToCurrnetMouse(TEnumAsByte<ECEWorldMapType>* MapType, int* MapCID, struct FString* ZoneName, struct FVector* OutLocation);
	void ShowDebugLoadedLevel(bool Toggle);
	void CheatingTeleport();
	float STATIC_GetMinimumDiameter();
	void DragMoveWorldMap(int X, int Y);
	void FocusingMonsterBookArea(int MonsterBookID, bool bCameraSlideMove);
	void AppendMonsterBookAreaToWorld();
	void SetupMonsterBookArea(int MonsterBookID);
	void SetupAllMonsterBookArea();
	void RemoveMonsterBookArea(int MonsterBookID);
	void ClearAllMonsterBookArea();
	void MoveCameraToMonsterBook(int MonsterBookID, bool bSlideMove);
	void MoveCameraToLocation(const struct FVector& InLocation, bool bSlideMove);
	void MoveCameraToQuest(int questId, bool bCompleted, bool bSlideMove, bool bFlickering);
	void MoveCameraToBelongLocation(int LocationCId);
	void ChangeLocationInfo(TArray<struct FWorldMapLocationInfo>* Infos);
	void ReturnPlayerLocation();
	void ZoomChange();
	void Zoom(bool bCursor, bool bZoomIn);
	struct FVector GameLocationToWorldMapLocation(const struct FVector& GameLocation);
	void GetWorldMapCameraInfo(struct FBLCamera_WorldMapModeInfo* Info);
	class ACameraActor* GetWorldMapCameraActor();
	void RemoveQuestAreaElement(class ABLWorldMapQuestAreaBase* Info);
	void AddWorldMapElements(TEnumAsByte<EWorldMapPlayerIconType> InType, int Sid);
	void AddRaidMember(int Sid);
	void AddParty(int Sid);
	void RemoveWorldMapElements(int Sid);
	void RemoveRaidMember(int Sid);
	void RemoveParty(int Sid);
	void UpdatePartyPlayerIcon();
	void UpdatePartyPlayer(TArray<int>* ToUpdateElementIdx);
	void RestoreEnvironmentSetting();
	void CacheEnvironmentSetting();
	void FindEnvObject(class UClass* BaseClass, TArray<class UObject*>* ObjectList);
	struct FVector GetWorldMapDefaultTargetLocation();
	void InitWorldMapDefaultTargetLocation();
	void RemoveElements();
	void UpdateConquestWarNPCElementLocation(int InServerId, const struct FVector& InLocation);
	void RemoveConquestWarNPCElement(int InServerId);
	class ABLWorldMapNPCIcon* AddConquestWarNPCElement(int InServerId, int InCid, const struct FVector& InLocation);
	void InitializeWorldMapInstanceRevivalPointInfo();
	void InitializeWorldMapROUI(TEnumAsByte<EWorldMapMode> InMode);
	void InitializeWorldMapPropInfo();
	void InitializeWorldMapNPCInfo();
	void RemoveWorldMapCustomWaypointInfo(int InCid);
	void InitializeWorldMapCustomWaypointInfo();
	void InitializeWorldMapRaidMemberInfo();
	void InitializeWorldMapPartyInfo();
	void InitializeWorldMapPlayerInfo();
	void InitializeElements();
	void InitializeFilterUI(int Index, bool Toggle);
	void Initialize(TEnumAsByte<EWorldMapMode> Mode);
	void GetDeathPointInfo(TArray<struct FDeathPointInfo>* InfoArray);
	void GetUnderAttackInfo(TArray<struct FUnderAttackInfo>* InfoArray);
	bool GetDeadBodyIconInfo(struct FPlayerDeadBodyMapIconInfo* Info);
	void GetPropMapIconInfo(TArray<struct FPropMapIconInfo>* InfoArray);
	void GetNpcMapIconInfo(TArray<struct FNpcMapIconInfo>* InfoArray);
	void InitializeZoneVolumeNameIcon();
	void MoveCameraPlayerPosition();
	void WorldMapMoveHotSpot();
	void SetWayPointMapSubtractFilter(TEnumAsByte<EFiltering_Icon> Filter);
	void SetWayPointMapAddFilter(TEnumAsByte<EFiltering_Icon> Filter);
	void SetWorldMapSubtractFilter(TEnumAsByte<EFiltering_Icon> Filter);
	void SetWorldMapAddFilter(TEnumAsByte<EFiltering_Icon> Filter);
	void MoveCamera(const struct FVector& Dest);
	void PostInitializeWorldMap(bool bSetupWorldMapView);
	bool PreInitializeWorldMap(bool bShow, TEnumAsByte<EWorldMapMode> InMode);
	void Update(bool bTick);
	void AdjustLocationAll();
	void SortingElements();
};


// Class BLGame.FullScreenMovie
// 0x0038 (0x021C - 0x01E4)
class UFullScreenMovie : public UGFxMoviePlayer
{
public:
	struct FPointer                                    pScreenMovie;                                             // 0x01E4(0x0008) (Const, Native, Transient)
	int                                                LoadingPercentage;                                        // 0x01EC(0x0004)
	struct FDouble                                     LoadingStartTime;                                         // 0x01F0(0x0008) (Native)
	struct FString                                     RecentLoadingMessage;                                     // 0x01F8(0x0010) (Native)
	TArray<struct FASValue>                            Params;                                                   // 0x0208(0x0010) (Native)
	unsigned long                                      bInitialized : 1;                                         // 0x0218(0x0004) (Native)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.FullScreenMovie");
		return ptr;
	}


	bool SetExternalTexture(const struct FString& Resource, class UTexture* Texture);
	void UASetGameTip(const struct FString& GameTip);
	void UASetLoadImage(class UTexture* LoadingUITexture);
	void UAShieldGotoAndPlay(const struct FString& frame);
	void SetLoadingPercentage(int Percentage);
	void LoadingInitComplate();
};


// Class BLGame.ActionMappingManager
// 0x0264 (0x02C4 - 0x0060)
class UActionMappingManager : public UObject
{
public:
	TArray<struct FCoolDownInfo>                       SkillCoolDownList;                                        // 0x0060(0x0010) (AlwaysInit, NeedCtorLink)
	struct FCoolDownInfo                               GlobalSkillCoolDown;                                      // 0x0070(0x000C)
	TArray<struct FCoolDownInfo>                       ItemCoolDownList;                                         // 0x007C(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<struct FCoolDownInfo>                       SkillStackChargeTimeList;                                 // 0x008C(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<struct FStackInfo>                          SkillStackCountList;                                      // 0x009C(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<struct FCoolDownInfo>                       MountSkillCoolDownList;                                   // 0x00AC(0x0010) (AlwaysInit, NeedCtorLink)
	TEnumAsByte<EBLCombatStatus>                       RecentCombatStatus;                                       // 0x00BC(0x0001)
	TEnumAsByte<ECERiotControlStateType>               RecentTargetRCState;                                      // 0x00BD(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x00BE(0x0002) MISSED OFFSET
	TArray<TEnumAsByte<ECEEquipSlotType>>              RecentEquipmentEquipSlotTypes;                            // 0x00C0(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<int>                                        ActivatedSwitchingSkillList;                              // 0x00D0(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<int>                                        NormalAttackSkillList;                                    // 0x00E0(0x0010) (AlwaysInit, NeedCtorLink)
	struct FMap_Mirror                                 SkillLinkedInfoMap;                                       // 0x00F0(0x0048) (Const, Native)
	struct FMap_Mirror                                 SkillFastLaunchInfoMap;                                   // 0x0138(0x0048) (Const, Native)
	struct FMap_Mirror                                 SkillChangedInfoMap;                                      // 0x0180(0x0048) (Const, Native)
	TArray<int>                                        NewAcquiredSkillListForDisplay;                           // 0x01C8(0x0010) (AlwaysInit, NeedCtorLink)
	struct FBLSkillDeckInfo                            CurrentSkillDeckTactic;                                   // 0x01D8(0x009C) (NeedCtorLink)
	struct FBLSkillDeckSizeInfo                        SkillDeckSize;                                            // 0x0274(0x000C)
	int                                                UseTacticIndex;                                           // 0x0280(0x0004)
	unsigned long                                      bInitializedActionBarUI : 1;                              // 0x0284(0x0004)
	unsigned long                                      bInitializedPCUI : 1;                                     // 0x0284(0x0004)
	TArray<float>                                      LastHitResultTimeList;                                    // 0x0288(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<float>                                      LastTakeHitResultTimeList;                                // 0x0298(0x0010) (AlwaysInit, NeedCtorLink)
	float                                              LastKillHitResultTime;                                    // 0x02A8(0x0004)
	float                                              HitResultHoldingTime;                                     // 0x02AC(0x0004)
	float                                              ApplyMomentElapsedMaxTime;                                // 0x02B0(0x0004) (Const)
	float                                              ApplyMomentElapsedTime;                                   // 0x02B4(0x0004)
	int                                                FiringSkillCid;                                           // 0x02B8(0x0004)
	class UMainActionBar*                              ActionBar;                                                // 0x02BC(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.ActionMappingManager");
		return ptr;
	}


	void SetPCUITacticsButton(int InUseTacticIndex, int InUnlockSkillDeckSize, int MaxSkillDeckSize);
	void ResetStanceCoolTime();
	void ChangeStanceSkill();
	void ChangeStance();
	bool CheckStanceChange();
	void UpdateSkillDeckTactic();
	int GetOriginalCidFromTacticList(int InSkillCid);
	void CancelAutoPath();
	void MoveToAutoPath();
	void PrevFavoritePage();
	void NextFavoritePage();
	void InputFavoriteActionBarSlot(int InSlotIndex);
	void UpdateFavoriteActionBarFatigue(int InUid, int InFatigue, int InMaxFatigue);
	void UpdateCurrentFavoriteActionBarFatigue();
	void UpdateFavoriteActionBar();
	void SetFavoriteActionBarPage(int InPage);
	struct FQWord GetActionBarPetUID(int InUISlotIndex);
	struct FQWord GetActionBarMountUID(int InUISlotIndex);
	void SetActionBarMountSkill(int InSkillCid_WW, int InSkillCid_C);
	bool GetActionBarMultiSlotMountItemCidList(TArray<int>* OutResultCidList);
	void SetActionBarItemSlotLock(int InItemCid, bool bLock);
	void SetActionBarVoluntaryGuideEffect(bool bShow);
	bool SetActionBarAutoFireReadyEffect();
	bool SetActionBarAutoFireStartEffect();
	void GetActionBarAvailableSkillList(TArray<int>* OutSkillCidList);
	bool IsActionBarMultiSlotSkill(int InSkillCid);
	TEnumAsByte<EActionBarMultiSlotType> GetActionBarMultiSlotSubType(int InUISlotIndex);
	int GetActionBarMultiSlotServerIndex(int InUISlotIndex);
	int GetActionBarMountSkillCid(int InUISlotIndex);
	int GetActionBarVoluntaryCid();
	int GetActionBarItemCid(int InUISlotIndex);
	int GetActionBarItemSkillCid(int InUISlotIndex);
	int GetActionBarQTESkillCid(int InUISlotIndex);
	int GetActionBarCombatCid(int InUISlotIndex);
	int GetActionBarSkillCid(int InUISlotIndex);
	TArray<int> GetActionBarUISlotIndexByItemCid(int InCid);
	int GetActionBarUISlotIndex(TEnumAsByte<EActionBarSlotType> InActionBarSlotType, int InClientSlotIndex);
	void SwapActionBarMultiSlotItem(struct FActionBarData* InActionBarDataOne, struct FActionBarData* InActionBarDataTwo);
	void UpdateActionBarMultiSlotItemInfo(int InItemCid);
	void SetActionBarMultiSlotItem(struct FActionBarData* InActionBarData);
	void SetActionBarMultiSlotItemList(TArray<struct FActionBarData>* InActionBarDataList);
	void SetActionBarVoluntary(int InVoluntaryCid);
	void UpdateInvokableElements();
	void UpdatePetCoolDown(const struct FQWord& InPetUid);
	void UpdateAbnormalStatus();
	void UpdateSkillChange(int InFromSkillCid, int InToSkillCid);
	void UpdateKillHitResult();
	void UpdateTakeHitResult(TEnumAsByte<ECEAttackChanceType> InAttackChanceType);
	void UpdateHitResult(TEnumAsByte<ECEAttackChanceType> InAttackChanceType);
	void UpdateSkillEnded();
	void UpdateSkillFired(int InFiredSkillCid, float InFiringRate);
	void UpdateEquipments();
	void UpdateCombatStatus(TEnumAsByte<EBLCombatStatus> InCombatStatus);
	void UpdateResource();
	void UpdateInteractionTarget(int InNewTargetId, TEnumAsByte<EFriendlyTargetType> InNewTargetType);
	float GetLastKillHitResultTime();
	float GetLastTakeHitResultTime(TEnumAsByte<ECEAttackChanceType> InAttackChanceType);
	float GetLastHitResultTime(TEnumAsByte<ECEAttackChanceType> InAttackChanceType);
	class ABlessPC* GetBlessPC();
	bool IsDifferentSkillDeckTactic(struct FBLSkillDeckInfo* InStandardInfo, struct FBLSkillDeckInfo* InCheckInfo);
	bool IsLockSkillDeckTactic(int InIndex);
	struct FString GetSkillDeckTacticTooltip(int InIndex);
	bool IsRecommendSkill(int InMainSkillCid, int InCheckSkillCid);
	int GetSkillChangedResultCid(int InSkillCid);
	bool CanUseFastLaunchSkill_InFiring(int InSkillCid);
	bool CanUseSkill_InFiring(int InSkillCid);
	bool IsNormalAttackSkill(int InSkillCid);
	bool IsFastLaunchSkill(int InNowFiringSkillCid, int InCheckSkillCid);
	bool IsLearnedSkill(int InSkillCid);
	bool FindFollowSkillCids(int InSkillCid, TArray<int>* OutSkillCidList, TArray<int>* OutLearnedList);
	bool FindLinkedSkillCids(int InSkillCid, TArray<int>* OutLinkedSkillCidList, TArray<int>* OutLinkedSkillLearnedList);
	bool IsSkillCoolDown(int InSkillCid);
	class UPlayerRepInfo* GetPlayerRepInfo();
	int GetItemCount(int InItemCid);
	int GetSkillStackCount(int InSkillCid);
	void GetMountSkillCoolDown(int InMountSkillCId, float* OutRemainTime, float* OutMaxTime);
	void GetItemCoolDown(int InItemCid, float* OutRemainTime, float* OutMaxTime);
	void GetSkillStackChargeTime(int InSkillCid, float* OutRemainTime, float* OutMaxTime);
	void GetSkillCoolDown(int InSkillCid, float* OutRemainTime, float* OutMaxTime, int* OutAppliedGCD);
	TEnumAsByte<ECESkillCategoryType> GetSkillCategory(int InSkillCid);
	int GetOriginalSkillCid(int InSkillCid);
	void ApplyToActionBar();
	bool IsActivatedSwitchingSkill(int InSkillCid);
	void SetActivateSwitchingSkill(int InSkillCid, bool bActivate);
	void ReadyAutoFiringSkill();
	void ToggleAutoFiringSkill(int InUISlotIndex);
	void UpdateAutoFiringSkill(int InAutoFiringSkill);
	void SetAutoFiringSkill(int InAutoFiringSkill);
	void SetSkillStackCount(int InSkillCid, int InStackCount);
	void TickSkillStackChargeTime(float InDeltaSeconds);
	void SetSkillStackChargeTime(int InSkillCid, float InRemainTime, float InMaxTime);
	void UpdateAllCoolDown();
	void TickMountSkillCoolDown(float InDeltaSeconds);
	void SetMountSkillCoolDown(int InMountSkillCId, float InRemainTime, float InMaxTime);
	void TickItemCoolDown(float InDeltaSeconds);
	void SetItemCoolDown(int InItemCid, float InRemainTime, float InMaxTime);
	void TickApplyMomentElapsedTime(float InDeltaSeconds);
	void TickHitResult(float InDeltaSeconds);
	void TickSkillCoolDown(float InDeltaSeconds);
	void SetGlobalSkillCoolDown(float InRemainTime, float InMaxTime);
	void SetSkillCoolDown(int InSkillCid, float InRemainTime, float InMaxTime);
	void UpdateStanceCoolDown();
	void OnFinalizedPCUI_FromUI();
	void OnInitializedPCUI_FromUI();
	void OnFinalizedActionBarUI_FromUI();
	void OnInitializedActionBarUI_FromUI();
	void InitHitResult();
	void InitSkillStack();
	void InitItemCoolDown();
	void InitSkillCoolDown();
	void InitStanceCoolDown();
	void InitItem();
	void InitSkill(TArray<int>* InSkillCidList);
	void Init();
	void Tick(float InDeltaSeconds);
};


// Class BLGame.MainActionBar
// 0x0121 (0x0181 - 0x0060)
class UMainActionBar : public UObject
{
public:
	int                                                MaxItemSlotSize;                                          // 0x0060(0x0004) (Const)
	float                                              LinkedSkillActionSlotChangeSpareTime;                     // 0x0064(0x0004) (Const)
	float                                              LinkedSkillRollBackTime;                                  // 0x0068(0x0004) (Config)
	TArray<struct FActionBarSkillInfo>                 AvailableSkillList;                                       // 0x006C(0x0010) (NeedCtorLink)
	TArray<struct FLinkedSkillInfo>                    LinkedSkillInfoList;                                      // 0x007C(0x0010) (NeedCtorLink)
	struct FVoluntaryInfo                              Voluntary;                                                // 0x008C(0x0020) (NeedCtorLink)
	TArray<struct FActionBarItemInfo>                  AvailableItemList;                                        // 0x00AC(0x0010) (NeedCtorLink)
	TArray<struct FActionBarMountInfo>                 AvailableMountList;                                       // 0x00BC(0x0010) (NeedCtorLink)
	TArray<struct FActionBarPetInfo>                   AvailablePetList;                                         // 0x00CC(0x0010) (NeedCtorLink)
	TArray<struct FActionBarStanceSlotInfo>            AvailableStanceList;                                      // 0x00DC(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<struct FQTEAutoPathInfo>                    AutoPathQTEList;                                          // 0x00EC(0x0010) (NeedCtorLink)
	TArray<struct FQTESkillInfo>                       SkillQTEList;                                             // 0x00FC(0x0010) (NeedCtorLink)
	struct FQTEInteractionInfo                         InteractionQTE;                                           // 0x010C(0x0020) (NeedCtorLink)
	TArray<struct FActionBarSkillSlotInfo>             SkillSlotInfoList;                                        // 0x012C(0x0010) (NeedCtorLink)
	TArray<struct FActionBarVoluntarySlotInfo>         VoluntarySlotInfoList;                                    // 0x013C(0x0010) (NeedCtorLink)
	TArray<struct FActionBarMultiSlotInfo>             MultiSlotInfoList;                                        // 0x014C(0x0010) (NeedCtorLink)
	TArray<struct FActionBarMountSkillSlotInfo>        MountSkillSlotInfoList;                                   // 0x015C(0x0010) (NeedCtorLink)
	TArray<struct FActionBarFavoriteSlotInfo>          FavoriteMPFSlotInfoList;                                  // 0x016C(0x0010) (NeedCtorLink)
	int                                                CurrentFavoriteMPFPage;                                   // 0x017C(0x0004)
	TEnumAsByte<EBLStanceUseColor>                     StanceUseColor;                                           // 0x0180(0x0001)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.MainActionBar");
		return ptr;
	}


	class UBLSkillQTEHUDUIManager* GetSkillQTEHUDUIManager();
	class UBLActionBarUIManager* GetActionBarUIManager();
	TEnumAsByte<EQTESkillSlotType> ConvertQTESlotIndexToQTESkillType(int InSlotIndex);
	void GetSkillCoolDown(int InSkillCid, float* InRemainTime, float* InTotalTime);
	bool GetMultiSlotMountItemCidList(TArray<int>* OutResultCidList);
	void SetShowVoluntaryGuide(bool bShow);
	bool OffAutoFire();
	bool ReadyAutoFire();
	bool StartAutoFire();
	bool GetAutoFireState(int InUISlotIndex, int* OutAutoFireState);
	bool ToggleAutoFire(int InUISlotIndex, int* OutAutoFireState, int* OutAutoFireSkillRootCid);
	void GetAvailableSkillList(TArray<int>* OutAvailableSkillCidList);
	bool IsMultiSlotSkill(int InSkillCid);
	TEnumAsByte<EActionBarMultiSlotType> GetMultiSlotSubType(int InUISlotIndex);
	int GetMultiSlotServerIndex(int InUISlotIndex);
	TArray<int> GetUISlotIndexByItemCID(int InCid);
	int GetMountSkillCid(int InUISlotIndex);
	int GetQTESkillCid(int InUISlotIndex);
	struct FQWord GetPetUid(int InUISlotIndex);
	struct FQWord GetMountUid(int InUISlotIndex);
	int GetItemCid(int InUISlotIndex);
	int GetItemSkillCid(int InUISlotIndex);
	int GetCombatCid(int InUISlotIndex);
	int GetSkillCid(int InUISlotIndex);
	int GetVolunarayCid();
	void ChangeLinkedSkillActionBarSlot(int InPrevSkillCid, int InNewSkillCid);
	void OnRemovedPet(const struct FQWord& InUid);
	void OnRemovedMount(const struct FQWord& InUid);
	void ResetStanceCoolTime();
	void AddNonStanceSkill(const struct FBLSkillDeckInfo& InSkillDeckInfo);
	void AddStanceQTEChildSkill(TArray<struct FPointer>* InChildSkillNodes);
	void AddStanceQTESkill(const struct FBLSkillDeckInfo& InSkillDeckInfo);
	void ChangeStanceSkill(const struct FBLSkillDeckInfo& InSkillDeckInfo);
	void ChangeStance_Emelard();
	void ChangeStance_Pink();
	void ChangeStance();
	bool CheckStanceChange();
	bool CheckActionBarSkillPlayerAbnormalStatus(struct FActionBarSkillInfo* InActionBarSkillInfo);
	bool CheckActionBarSkillEquipItems(struct FActionBarSkillInfo* InActionBarSkillInfo);
	bool CheckActionBarSkillCombatStatus(struct FActionBarSkillInfo* InActionBarSkillInfo);
	bool CheckActionBarSkillResource(struct FActionBarSkillInfo* InActionBarSkillInfo);
	bool CheckInvokableItemEquipSlotTypes(TArray<TEnumAsByte<ECEEquipSlotType>>* InEquipSlotTypes);
	bool CheckCostResource(class UPlayerRepInfo* InPlayerRepInfo, bool bCanUseMoreThanOneCost, TArray<struct FSkillCostInfo>* InSkillCosts);
	bool CheckInvokableResource(class UPlayerRepInfo* InPlayerRepInfo, TArray<struct FInvokableElementInfo>* InSkillElements);
	bool UpdateActionBarPetInfo(const struct FQWord& InUid, struct FActionBarPetInfo* InActionBarPetInfo);
	bool FindActionBarPetInfo(const struct FQWord& InUid, struct FActionBarPetInfo* OutActionBarPetInfo);
	bool UpdateActionBarMountInfo(const struct FQWord& InUid, struct FActionBarMountInfo* InActionBarMountInfo);
	bool FindActionBarMountInfo(const struct FQWord& InUid, struct FActionBarMountInfo* OutActionBarMountInfo);
	bool UpdateActionBarItemInfo(int InItemCid, struct FActionBarItemInfo* OutActionBarItemInfo);
	bool FindActionBarItemInfo(int InItemCid, struct FActionBarItemInfo* OutActionBarItemInfo);
	int FindLinkedSkillRootPrecedeSkillCid(int InSkillCid);
	bool UpdateActionBarSkillInfo(int InSkillCid, struct FActionBarSkillInfo* OutActionBarSkillInfo);
	bool FindActionBarSkillInfo(int InSkillCid, struct FActionBarSkillInfo* OutActionBarSkillInfo);
	bool FindMultiSlotIndexList_Pet(const struct FQWord& InUid, TArray<int>* OutSlotIndexList);
	bool FindMountSkillSlotIndex(int InSkillCid, int* OutSlotIndex, TEnumAsByte<EActionBarSlotType>* OutSlotType);
	bool FindMultiSlotIndexList_Mount(const struct FQWord& InUid, TArray<int>* OutSlotIndexList);
	bool FindMultiSlotIndexList_Item(int InItemCid, TArray<int>* OutSlotIndexList);
	bool FindMultiSlotIndexList_Skill(int InSkillCid, TArray<int>* OutSlotIndexList);
	bool FindSkillSlotIndexList(int InSkillCid, TArray<int>* OutSlotIndexList, TArray<TEnumAsByte<EActionBarSlotType>>* OutSlotTypeList);
	bool FindSkillSlotIndex(int InSkillCid, bool bCheckRootSkillCid, int* OutSlotIndex, TEnumAsByte<EActionBarSlotType>* OutSlotType);
	bool IsAutoFirableSkill(int InSkillCid);
	int GetAvailableItemArrayIndex(int InItemCid);
	int GetAvailableSkillArrayIndex(int InSkillCid);
	bool GetClientSlotIndex(int InUISlotIndex, TEnumAsByte<EActionBarSlotType>* OutSlotType, int* OutSlotIndex);
	int GetUISlotIndex(TEnumAsByte<EActionBarSlotType> InSlotType, int InSlotIndex);
	void UpdateUISlotShow(TEnumAsByte<EActionBarSlotType> InSlotType, int InSlotIndex, bool bShow);
	void UpdateUISlotEffectClear(TEnumAsByte<EActionBarSlotType> InSlotType, int InSlotIndex);
	void UpdateUISlotEffect(TEnumAsByte<EActionBarSlotType> InSlotType, int InSlotIndex, TEnumAsByte<EActionBarIconEffect> InEffectType, bool bActive);
	void UpdateUISlotStackCount(TEnumAsByte<EActionBarSlotType> InSlotType, int InSlotIndex, int InStackCount);
	void UpdateUISlotStackChargeTime(TEnumAsByte<EActionBarSlotType> InSlotType, int InSlotIndex, float InRemainTime, float InMaxTime);
	void UpdateUISlotCoolDown(TEnumAsByte<EActionBarSlotType> InSlotType, int InSlotIndex, float InRemainTime, float InMaxTime, bool bGlobalCoolDown);
	void UpdateUISlotActive(TEnumAsByte<EActionBarSlotType> InSlotType, int InSlotIndex, bool bActive);
	void SetPCUITacticsButton(int InUseTacticsIndex, int InUnlockSkillDeckSize, int InMaxSkillDeckSizeconst);
	void SetUIMountSkillSlot(int InSlotIndex, int InSkillCid);
	void SetUIMultiSlot_Skill(int InSlotIndex, int InSkillCid);
	void SetUIMultiSlot_Item(int InSlotIndex, int InItemCid, int InUseSkillCid, int InItemCount, bool InStackable);
	void SetUIMultiSlot(struct FActionBarData* Data);
	void SetUIInteractionQTESlot(int InIconIndex, const struct FString& InDescription);
	void SetUIAutoPathQTESlot(int InSlotIndex);
	void SetUICombatSkillSlotLock(TEnumAsByte<EActionBarSlotType> InSlotType, int InSlotIndex, bool bLock, bool bShowUnLockEffect, int InRequireLevel, int InRequireSPLevel);
	void SetUISlotLock(TEnumAsByte<EActionBarSlotType> InSlotType, int InSlotIndex, bool bLock, bool bShowUnLockEffect);
	void SetUIVoluntarySlot(int InSlotIndex, int InVoluntaryCid);
	void SetStanceUISlot(int InSlotIndex, int InSkillCid, int InCombatSkillCid);
	void SetUISkillSlot(TEnumAsByte<EActionBarSlotType> InSlotType, int InSlotIndex, int InSkillCid, int InCombatSkillCid);
	void PrevFavoritePage();
	void NextFavoritePage();
	void InputFavoriteActionBarSlot(int InSlotIndex);
	void UpdateFavoriteActionBarFatigue(int InUid, int InFatigue, int InMaxFatigue);
	void UpdateCurrentFavoriteActionBarFatigue();
	void UpdateFavoriteActionBar();
	void InitFavoriteActionBar();
	void SetFavoriteActionBarPage(int InPage);
	void UpdateInvokableElements();
	void UpdatePetCoolDown(const struct FQWord& InPetUid);
	void UpdateSkillChange(int InFromSkillCid, int InToSkillCid);
	void UpdateSwithcingSkillState(int InSkillCid, bool bActivated);
	void UpdateKillHit();
	void UpdateTakeHit();
	void UpdateHit();
	void UpdateChangeItemInfo(int InItemCid);
	void UpdateCheckPlayerAbnormalStatus();
	void UpdateCheckEquipments();
	void UpdateCheckCombatStatus();
	void UpdateCheckResource();
	void UpdateSkillFired(int InSkillCid);
	void UpdateSkillStackCount(int InSkillCid, int InStackCount);
	void UpdateSkillStackChargeTime(int InSkillCid, float InRemainTime, float InMaxTime);
	void UpdateMountSkillCoolDown(int InMountSkillCId);
	void UpdateItemCoolDown(int InItemCid);
	void UpdateSkillGlobalCoolDown();
	void UpdateSkillCoolDown(int InSkillCid);
	void UpdateStanceCoolDown();
	void SetMountSkill(int InSkillCid_WW, int InSkill_C);
	void SetLockItemSlot(int InItemCid, bool bLock);
	void UpdateInteractionQTE(int InNewTargetId, TEnumAsByte<EFriendlyTargetType> InNewTargetType);
	void UpdateSkillQTEUI();
	void UpdateMultiSlotItem(struct FActionBarData* InActionBarData);
	void SwapMultiSlotItem(struct FActionBarData* InActionBarOne, struct FActionBarData* InActionBarDataTwo);
	void RemoveFavoriteMPF(const struct FQWord& InMPFUid);
	void AddFavoriteMPF(const struct FQWord& InMPFUid);
	void RemoveAvailablePet(const struct FQWord& InPetUid);
	void AddAvailablePet(const struct FQWord& InPetUid);
	void RemoveAvailableMount(const struct FQWord& InMountUid);
	void AddAvailableMount(const struct FQWord& InMountUid);
	void RemoveAvailableItem(int InItemCid);
	void AddAvailableItem(int InItemCid);
	void RemoveAvailableSkill(int InSkillCid);
	void AddAvailableSkill(int InSkillCid, bool bItemSkill, TEnumAsByte<EQTESkillSlotType> InQTESkillType);
	void RemoveAvailableStance(int InStanceCid);
	void AddAvailableStance(int InStanceCid);
	void RefreshCheckPlayerAbnormalStatus();
	void RefreshCheckEquipments();
	void RefreshCheckCombatStatus();
	void RefreshCheckResource();
	void RefreshLinkedSkillInfoList();
	void TickAvailableMountSkill(float InDeltaSeconds);
	void TickVoluntary(class ABLPawn* InMyPawn);
	void TickInteractionQTE(class ABLPawn* InMyPawn);
	void TickSkillQTE(class ABLPawn* InMyPawn);
	void TickAutoPathQTE(class ABLPawn* InMyPawn);
	void TickAvailablePet(float InDeltaSeconds, class ABLPawn* InMyPawn, class ABLPawn* InTargetPawn);
	void TickAvailableMount(float InDeltaSeconds, class ABLPawn* InMyPawn, class ABLPawn* InTargetPawn);
	void TickAvailableItem(float InDeltaSeconds, class ABLPawn* InMyPawn, class ABLPawn* InTargetPawn);
	void TickAvailableSkill(float InDeltaSeconds, class ABLPawn* InMyPawn, class ABLPawn* InTargetPawn);
	void TickLinkedSkill(float InDeltaSeconds);
	void TickAvailableStance(float InDeltaSeconds);
	void Tick(float InDeltaSeconds);
	void InitStanceCoolDown();
	void InitMountSkill();
	void InitMultiSlotItems(TArray<struct FActionBarData>* InActionBarDataList);
	void InitVoluntary(int InVoluntaryCid, int InCurrentEnergy);
	void InitInteractionQTE();
	void InitSkillQTE();
	void InitAutoPathQTE();
	void InitChangeableSkill();
	void InitItemSkill();
	void InitActionBarSkill(struct FBLSkillDeckInfo* InSkillDeckInfo);
	void Init();
};


// Class BLGame.AlertManager
// 0x0050 (0x00B0 - 0x0060)
class UAlertManager : public UObject
{
public:
	TArray<struct FAlertElement>                       ActiveAlertElements;                                      // 0x0060(0x0010) (NeedCtorLink)
	struct FAlertElement                               StoryAlertElement;                                        // 0x0070(0x0028)
	TArray<struct FAlertEffect>                        AlertEffects;                                             // 0x0098(0x0010) (NeedCtorLink)
	float                                              PathGuideUpdateLimitTime;                                 // 0x00A8(0x0004) (Const)
	float                                              PathGuideUpdateCheckTime;                                 // 0x00AC(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.AlertManager");
		return ptr;
	}


	void SetQuestItemCoolDown(int InQuestID, float InRemainTime, float InMaxTime);
	void QuestAvailableItem(int questId, bool bEnable);
	class UGFxObject* MakeItemGFxObject(int Quantity, bool bUsable, bool bAvailableItem, struct FItemInfoData* InItemInfo);
	struct FString MakeQuestTitleString(bool IsComplete, bool isFailed, struct FString* Title);
	struct FString MakeObjectiveTitleString(bool IsComplete, struct FString* Title);
	class UGFxObject* MakeAlertElementObjective(int Couter, int TotalCount, bool IsComplete, struct FString* Title);
	class UGFxObject* MakeAlertElement(int Id, TEnumAsByte<EAlertElementType> Type, int Stage, bool bReward, const struct FString& Title, const struct FString& Summary, bool isCompleted, bool isFailed, float QuestTimeLimit, int EffectType, bool PositioningCheckDisabled, bool IsFold);
	void StoryQuestUpdate();
	void Update();
	class UGFxObject* CreateQuestGFxObject(int InQuestID, bool IsFold, int* OutOrder);
	bool IsInAlertManager(int InCid);
	void SetActiveAlertCount();
	int STATIC_GetActiveAlertMaxCount();
	int GetActiveAlertCount();
	bool IsAddAlert();
	struct FOnHeadTagIconData GetOnHeadIconDataByNpcSid(int NpcSid);
	void Tick(float InDeltaTime);
	bool SetAlertFold(int questId, bool IsFold);
	void UpdatePathGuide(float InDeltaTime);
	bool IsAvailablePathGuideQuestObjectiveType(TEnumAsByte<ECEQuestObjectiveType> InObjectiveType);
	bool CalcPathGuideData_MonsterBookQuest(class UQuestManager* InQuestManager, class UQuestJournalManager* InQuestJournalManager, int InMonsterBookQuestID, struct FVector* InPlayerLocation, struct FRotator* InCameraRot, int* OutAngle, int* OutDist);
	bool CalcPathGuideData_OnGoingQuest(class UQuestManager* InQuestManager, int InOnGoingQuestID, struct FVector* InPlayerLocation, struct FRotator* InCameraRot, int* OutAngle, int* OutDist);
	TEnumAsByte<EAlertNotifierType> GetAlertState(TEnumAsByte<EAlertElementType> AlertType, int Id);
	void AddAlertEffect(TEnumAsByte<EAlertElementType> AlertType, int Id, TEnumAsByte<EAlertNotifierType> EffectType);
	bool IsRegistingQuestAlert(int questId);
	int GetActiveAlertOrder(int questId);
	TEnumAsByte<EAlertElementType> GetAlertElementType(TEnumAsByte<ECEAlrimiType> InAlrimiType, int InQuestID);
	bool IsAlertElement(TEnumAsByte<EAlertElementType> EType, int Id, int Stage);
	bool RemoveAlertList(TArray<struct FAlrimiData>* InAlrimiDataList);
	bool RemoveAlert(TEnumAsByte<ECEAlrimiType> EType, int Id, int Stage);
	bool AddAlertList(TArray<struct FAlrimiData>* InAlrimiDataList);
	bool AddAlert(struct FAlrimiData* InAlrimiData);
	void InitAlert(TArray<struct FAlrimiData> AlrimiDatas);
};


// Class BLGame.BLLauncherSettingManager
// 0x0050 (0x00B0 - 0x0060)
class UBLLauncherSettingManager : public UObject
{
public:
	int                                                DisplayMode;                                              // 0x0060(0x0004) (Config)
	int                                                DisplayRatio;                                             // 0x0064(0x0004) (Config)
	int                                                ResolutionIndex;                                          // 0x0068(0x0004) (Config)
	int                                                DisplayGamma;                                             // 0x006C(0x0004) (Config)
	int                                                GraphicOption;                                            // 0x0070(0x0004) (Config)
	unsigned long                                      bGraphicDetail : 1;                                       // 0x0074(0x0004) (Config)
	struct FLauncherResolution                         Resolution;                                               // 0x0078(0x0008) (Config)
	TArray<struct FLauncherResolution>                 Resolution0;                                              // 0x0080(0x0010) (Config, NeedCtorLink)
	TArray<struct FLauncherResolution>                 Resolution1;                                              // 0x0090(0x0010) (Config, NeedCtorLink)
	TArray<struct FLauncherResolution>                 Resolution2;                                              // 0x00A0(0x0010) (Config, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLLauncherSettingManager");
		return ptr;
	}

};


// Class BLGame.BLUserSettingManager
// 0x02CC (0x032C - 0x0060)
class UBLUserSettingManager : public UObject
{
public:
	struct FPointer                                    VfTable_FExec;                                            // 0x0060(0x0008) (Const, Native, NoExport)
	class UBLLauncherSettingManager*                   LauncherSettingManager;                                   // 0x0068(0x0008) (Transient)
	struct FUserSystemSettingData                      SystemSettingInitData;                                    // 0x0070(0x0088) (Transient, NeedCtorLink)
	struct FUserSystemSettingData                      SystemSettingBackupData;                                  // 0x00F8(0x0088) (Transient, NeedCtorLink)
	struct FUserSystemSettingData                      SystemSettingData;                                        // 0x0180(0x0088) (Transient, NeedCtorLink)
	struct FUserInterfaceSettingData                   InterfaceSettingInitData;                                 // 0x0208(0x003C) (Transient)
	struct FUserInterfaceSettingData                   InterfaceSettingBackupData;                               // 0x0244(0x003C) (Transient)
	struct FUserInterfaceSettingData                   InterfaceSettingData;                                     // 0x0280(0x003C) (Transient)
	int                                                MinCameraStep;                                            // 0x02BC(0x0004) (Transient)
	int                                                MaxCameraStep;                                            // 0x02C0(0x0004) (Transient)
	TArray<struct FDisplayResolution>                  DisplayResolutionList4to3;                                // 0x02C4(0x0010) (Transient, NeedCtorLink)
	TArray<struct FDisplayResolution>                  DisplayResolutionList16to9;                               // 0x02D4(0x0010) (Transient, NeedCtorLink)
	TArray<struct FDisplayResolution>                  DisplayResolutionList16to10;                              // 0x02E4(0x0010) (Transient, NeedCtorLink)
	TArray<struct FString>                             RatioList;                                                // 0x02F4(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<int>                                        RatioIndexList;                                           // 0x0304(0x0010) (Transient, NeedCtorLink)
	TArray<struct FString>                             ResolutionList;                                           // 0x0314(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	int                                                MaxRatio;                                                 // 0x0324(0x0004) (Transient)
	int                                                MaxRatioIndex;                                            // 0x0328(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLUserSettingManager");
		return ptr;
	}


	void SetAimBufferMouseSensitivity(int InAimBuffer);
	void SetMouseSensitivity(int Sensitivity);
	void SetCameraZoomStep(int CameraZoomStep);
	void SetInterfaceVolume(int Volume);
	void SetSystemVoiceMute(bool bMute);
	void SetSystemVoiceVolume(int Volume);
	void SetNPCVoiceVolume(int Volume);
	void SetEffectVolume(int Volume);
	void SetAmbientVolume(int Volume);
	void SetBackgroundMute(bool bMute);
	void SetBackgroundVolume(int Volume);
	void SetMasterVolumeMute(bool bMute);
	void SetMasterVolume(int Volume);
	void SetDisplayGamma(int DisplayGamma);
	void SetGraphicOption(int GraphicOption);
	int GetHandleMode();
	TEnumAsByte<EBLTargetingMode> GetTargetingMode();
	void OnEnterWorld();
	void ChangeToDefaultKeyCustomize();
	void CancelKeyCustomize();
	void ClampNPCRenderingValue();
	void ClampNPCLoadingValue();
	void ClampPCRenderingValue();
	void ClampPCLoadingValue();
	void OnChangeOutlineOption(TEnumAsByte<EChangeOutlineOption> InChangeOutline);
	void ChangeMoveRaidFrame(bool bMove);
	void ChangeShowMinimapExtension(bool bShow);
	void ChangeInterface();
	void ChangeAimBufferMouseSensitivity();
	void ChangeMouseSensitivity();
	void ChangeControlSystemOption();
	void ChangeCustomMaxCameraStepByTargetingMode(TEnumAsByte<EBLTargetingMode> TargetinMode);
	void ChangeCustomMaxCameraStep();
	void ChangeShowAbnormalStatusSelfStack();
	void ChangeVolume();
	void ChangeGraphicSettings(bool bForce);
	void SetGraphicDetailByOptionLevelIndex(int InOptionLevelIndex);
	void ChangeGraphicOption();
	void ChangeGamma();
	void ChangeDisplay(bool bRollback);
	void MasterVolumeTest();
	void ForceGraphicOption(int GraphicOption);
	void ViewportResized();
	void ResetInterfaceSettings();
	void CancelChangedInterfaceSettings();
	void ApplyChangedInterfaceSettings();
	void RestoreSystemSettings(int DisplayMode);
	void ResetSystemSettings();
	void CancelChangedSystemSettings();
	void ApplyChangedSystemSettings();
	void CheckInterfaceSettingData(class UBLUIPlayer* UIPlayer);
	void CheckSystemSettingData(class UBLUIPlayer* UIPlayer);
	void SendChangedUserSettings(class UBLUIPlayer* UIPlayer);
	void SendRaidFrameSettingToUI();
	void SendUserInterfaceSettingsToUI(class UBLUIPlayer* UIPlayer);
	void SendUserSystemSettingsToUI(class UBLUIPlayer* UIPlayer);
	bool SaveInterfaceSettings();
	bool LoadInterfaceSettings();
	bool SaveSystemSettings();
	bool LoadSystemSettings();
	void InitInterfaceData();
	void InitCommunityData();
	void InitControlSystemData();
	void InitCameraData();
	void InitDisplayData();
	void InitUIInterfaceSetting(class UBLUIPlayer* UIPlayer);
	void InitUISystemSetting(class UBLUIPlayer* UIPlayer);
	void InitManager();
	class UBLUserSettingManager* STATIC_GetUserSettingManager();
};


// Class BLGame.BLChannel
// 0x0020 (0x0080 - 0x0060)
class UBLChannel : public UObject
{
public:
	int                                                LocalPlayerChannelID;                                     // 0x0060(0x0004) (Transient)
	float                                              ChannelMoveCooldown;                                      // 0x0064(0x0004) (Transient)
	float                                              LastRequestChannelTime;                                   // 0x0068(0x0004) (Transient)
	unsigned long                                      bNeedUIUpdateChannelList : 1;                             // 0x006C(0x0004) (Transient)
	TArray<struct FChannelInfo>                        ChannelInfoList;                                          // 0x0070(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLChannel");
		return ptr;
	}


	void UpdateChannelList(int InLocalPlayerChannelId, bool bOpenChannelList, TArray<struct FChannelInfo>* InChannelInfoList);
	void OpenDialogSuggestFieldChange(const struct FString& OtherPlayerName, int channelId);
	int GetJamLevel(int InPlayerCount, int MaxPlayerCount);
	void TransferChannel(int channelId);
	void UpdateChannelInfo(TArray<struct FFieldChannelInfo> InFieldChannelInfoList);
	void UpdateChannelPartyMemberCount();
	void SetVisibleProtecedSpace(bool IsShow);
	void UpdateLocalPlayerChannel(int channelId);
	void UpdateChannelMoveResult(bool bSuccess, float RemainTimeInMilliseconds);
	void RequestMoveChannel(int InChannelID);
	void RequestUpdateChannelList();
	struct FChannelInfo FindChannelInfo(int channelId);
	void UpdateChannelMove();
	void InitializeChannel();
};


// Class BLGame.DeathController
// 0x00CC (0x012C - 0x0060)
class UDeathController : public UObject
{
public:
	class UMaterialInstanceTimeVarying*                DeathEffectMaterial;                                      // 0x0060(0x0008) (Transient)
	class UMaterialInstanceTimeVarying*                ReverseDeathEffectMaterial;                               // 0x0068(0x0008) (Transient)
	class ABLSpiritVolume*                             SpiritEnvVolume;                                          // 0x0070(0x0008) (Transient)
	class UDeathEffectInfo*                            DeathEffectInfo;                                          // 0x0078(0x0008) (Transient)
	class UMaterialEffect*                             LP_DeathMatEffect;                                        // 0x0080(0x0008) (Transient)
	float                                              DeadEffectPlayTime;                                       // 0x0088(0x0004) (Transient)
	float                                              DeadEffectTotalPlayTime;                                  // 0x008C(0x0004) (Transient)
	float                                              SpiritEffectPlayTime;                                     // 0x0090(0x0004) (Transient)
	float                                              SpiritEffectTotalPlayTime;                                // 0x0094(0x0004) (Transient)
	unsigned long                                      bPlayDeadEffect : 1;                                      // 0x0098(0x0004) (Transient)
	unsigned long                                      bPlaySpiritEffect : 1;                                    // 0x0098(0x0004) (Transient)
	unsigned long                                      bStandRevival : 1;                                        // 0x0098(0x0004) (Transient)
	unsigned long                                      bTutorialRevival : 1;                                     // 0x0098(0x0004) (Transient)
	unsigned long                                      bSatisfiedDistanceFromDeadbody : 1;                       // 0x0098(0x0004) (Transient)
	unsigned long                                      bSatisfiedDistanceFromRevivalPoint : 1;                   // 0x0098(0x0004) (Transient)
	unsigned long                                      bCanReviveForFalling : 1;                                 // 0x0098(0x0004) (Transient)
	unsigned long                                      bPendingReviveUI : 1;                                     // 0x0098(0x0004) (Transient)
	unsigned long                                      bUsePremiumRevival : 1;                                   // 0x0098(0x0004) (Transient)
	unsigned long                                      bIsOpendWorldMap : 1;                                     // 0x0098(0x0004)
	TEnumAsByte<ECERevivalType>                        RevivalType;                                              // 0x009C(0x0001) (Transient)
	TEnumAsByte<ERevivalState>                         CachedRevivalState;                                       // 0x009D(0x0001)
	TEnumAsByte<ERevivalState>                         PrevRevivalType;                                          // 0x009E(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x1];                                       // 0x009F(0x0001) MISSED OFFSET
	struct FDeadbodyInfo                               PlayerDeadBodyInfo;                                       // 0x00A0(0x0018) (Transient)
	float                                              CanReviveFallingAccTime;                                  // 0x00B8(0x0004) (Transient)
	float                                              CanReviveFallingTime;                                     // 0x00BC(0x0004) (Transient)
	float                                              RevivalRemainTime;                                        // 0x00C0(0x0004) (Transient)
	float                                              RevivalWaitingTime;                                       // 0x00C4(0x0004) (Transient)
	int                                                RemainPremiumRevivalCount;                                // 0x00C8(0x0004) (Transient)
	struct FMap_Mirror                                 InstanceRevivalPointMap;                                  // 0x00CC(0x0048) (Native)
	int                                                RegistedInstanceRevivalPointSid;                          // 0x0114(0x0004)
	int                                                CachedSidExecutor;                                        // 0x0118(0x0004)
	struct FString                                     CachedExecutorName;                                       // 0x011C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.DeathController");
		return ptr;
	}


	void RestartEffect();
	void ClearAllInstanceRevivalPoint();
	bool GetInstanceRevivalPoint(int InSid, struct FInstanceRevivalPointInfo* OutPoint);
	void GetAllInstanceRevivalPointList(TArray<struct FInstanceRevivalPointInfo>* OutPointList);
	void UnRegistInstanceRevivalPoint(int InSid);
	void RemoveInstanceRevivalPoint(int InSid);
	void RegistInstanceRevivalPoint(struct FCustomRevivalData* InData);
	void AddInstanceRevivalPoint(struct FCustomRevivalData* InData);
	void SC_MAKE_SURE_TO_CUSTOM_REVIVAL_IN_PERSIST_WORLD_REQ(int InLocationCid, int InReaminRevivalCount);
	void CS_MAKE_SURE_TO_CUSTOM_REVIVAL_IN_PERSIST_WORLD_ACK(bool InIsConfirm);
	void OpenPrevRevivalDialog();
	void CloseInstanceRevivalConfirmDialog();
	void OpenInstanceRevivalConfirmDialog(int InLocationCid, int InRemainCount);
	void CompleteLevelLoading();
	void OnUpdateSpirit();
	void OnUpdateDead();
	void OnUpdateAlive();
	void OnUpdateConditionalPhase(TEnumAsByte<ECEConditionPhaseType> Type);
	void Tick(float DeltaTime);
	void ClearAllDeathInfo();
	void ClearDeadbodyInfo();
	void SetDeadbodyInfo(TEnumAsByte<ECEWorldMapType> InWorldType, int InWorldCID, const struct FVector& InLocation);
	void SetSatisfiedDistanceFromRevivalPoint(bool bIsSatisfied);
	void SetSatisfiedDistanceFromDeadbody(bool bIsSatisfied);
	void SetSpiritualAwakerRevivalState();
	void SetStandaloneRevivalState();
	void DoRevivalByOther();
	void DoReiveBySelf();
	void ReturnToRevivalPoint(TEnumAsByte<ECERevivalType> revivalPointType);
	void OnSelectedRevivalChargeLumenaUI(bool bAccept);
	void OnSelectedRevivalConsumeLumenaUI(bool bAccept);
	void OnRevivalUITimeOver(TEnumAsByte<ERevivalState> revivalPointType);
	void ClearCachedRevivalUIInfo();
	void CloseAllRevivalUI();
	void CloseRevivalUI(TEnumAsByte<ERevivalState> RevivalState);
	void CloseRevivalLumenaDialog();
	void OpenRevivalChargeLumenaUI(int InNeedLumena);
	void OpenRevivalConsumeLumenaUI(int InNeedLumena);
	void OpenRevivalByOtherUI(const struct FString& CasterName, int CasterSID, bool bRevivedAtDeadbody);
	void UpdateRevivalStateUI();
	void OpenRevivalWaitingUI(float InRemainTime, TEnumAsByte<ECERevivalType> InRevivalType);
	void OpenRevivalChoiceUI(TEnumAsByte<ECERevivalType> InRevivalType, float InRemainTime, bool InIsUsePremiumRevival, int InRemainPremiumRevivalCount, bool InIsTutorial);
	void OpenRevivalDialog(TEnumAsByte<ERevivalState> RevivalState, int SidExecutor, const struct FString& ExecutorName);
	bool IsShowDialog();
	void ToggleWorldMapMode(TEnumAsByte<EWorldMapMode> Mode);
	bool CanRevive();
	void StartSpiritFogEffect();
	void ClearSpiritFogEffect();
	void ClearAllDeathEffect();
	void DestroySpiritFogVolume();
	void StartSpiritEffect(bool bImmediately);
	class ABLSpiritVolume* GetSpiritEnvVolume();
	class ABLSpiritVolume* SpawnSpiritEnvFog();
	void StartDeadEffect(bool bImmediately);
	void StopDeathEffect();
	void StartDeathEffect();
	bool CheckDeathEffectInfo();
	void Init();
	void InitializeDeathController();
};


// Class BLGame.BLConquest
// 0x00A8 (0x0108 - 0x0060)
class UBLConquest : public UObject
{
public:
	int                                                WarCid;                                                   // 0x0060(0x0004)
	unsigned long                                      bPlayingWar : 1;                                          // 0x0064(0x0004)
	TEnumAsByte<EBLWarReserveType>                     WarReserveState;                                          // 0x0068(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0069(0x0003) MISSED OFFSET
	struct FBLConquestTimerInfo                        WarTimerInfo;                                             // 0x006C(0x000C)
	struct FBLConquestListCommonInfo                   WarConquestInfo;                                          // 0x0078(0x0090) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLConquest");
		return ptr;
	}


	void OnChangeSortTypeFromWarUI(int InListIndex, int InSortIndex, int InSortDownUpType);
	void OnChangeTabFromWarUI(int InTabIndex);
	void OnClickExitButtonFromWarUI();
	void OnClickButtonFromWarListUI();
	void OnInitializeUI();
	void OnOpenWarUI();
	void OnOpenWarListUI();
	void OnLeaveWar();
	void OnEnterWar();
	bool IsInWarProcess();
	bool IsInReserveProcess();
	bool CheckWarCid(int InWarCid);
	void RequestWarInfoToServer();
	void MakeConquestWarInfo(TEnumAsByte<ECEBattleFieldWarType> InBattleFieldWarType);
	void Tick(float InDeltaTime);
	class UBLConquestManager* GetConquestManager();
	class UBLConquestUIManager* GetConquestUIManager();
	TEnumAsByte<ECEBattleFieldWarType> STATIC_OpenerTypeToWarType(TEnumAsByte<EUIOpenerType> InOpenerType);
	TEnumAsByte<ECEBattleFieldWarType> STATIC_WarUITypeToWarType(TEnumAsByte<EConquestModeType> InWarUIType);
	TEnumAsByte<EConquestModeType> STATIC_WarTypeToWarUIType(TEnumAsByte<ECEBattleFieldWarType> InWarType);
	TEnumAsByte<ECEBattleFieldWarType> STATIC_WorldMapTypeToWarType(TEnumAsByte<ECEWorldMapType> InWorldMapType);
};


// Class BLGame.BLChallengeTower
// 0x0054 (0x015C - 0x0108)
class UBLChallengeTower : public UBLConquest
{
public:
	TEnumAsByte<EBLChallengeTowerStateType>            CurrentState;                                             // 0x0108(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0109(0x0003) MISSED OFFSET
	int                                                CurrentRound;                                             // 0x010C(0x0004)
	TArray<struct FChallengeTowerLimitedCountInfoData> LimitedCountDataList;                                     // 0x0110(0x0010) (NeedCtorLink)
	struct FChallengeTowerRoundResultInfoData          RoundResultData;                                          // 0x0120(0x0010)
	struct FBLChallengeTowerTotalResultData            TotalResultData;                                          // 0x0130(0x0018) (NeedCtorLink)
	int                                                RemainEnteranceCount;                                     // 0x0148(0x0004)
	TArray<struct FBLTimerSystemMessageInfo>           RemainWaitTimeSystemMessage;                              // 0x014C(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLChallengeTower");
		return ptr;
	}


	void PostAkEvent(class UAkEvent* InAkEvent);
	void UpdateTokenUI(int InTokenCT);
	void UpdateMonsterCountUI(int InRemainCount);
	void UpdateBonusTimeUI();
	void UpdateWaitingTimeUI();
	void UpdateTotalPlayedTimeUI();
	void UpdateHolyHPUI(TArray<struct FChallengeTowerAttentionNPCData>* InHolyNpcList);
	void UpdateRoundUI(int InRound);
	void UpdateTimerTypeUI();
	void UpdateButtonInWarListUI();
	void UpdateListContentInWarListUI();
	void OpenTotalResultUI();
	void OpenRoundResultUI();
	void OpenPartyMatchingTeleportDialog();
	void SetVisibleHUD(bool InIsVisible);
	void OnClickButtonFromWarListUI();
	void OnInitializeUI();
	void OnOpenWarListUI();
	void ClearChallengeTower();
	void EndRound(TEnumAsByte<EChallengeTowerEndRoundType> InEndRoundType, struct FChallengeTowerRoundResultInfoData* InRoundResultData);
	void StartRound(int InRound);
	void EndWaitingRound();
	void StartWaitingRound(int InRound);
	void EndChallengeTower(int InCompleteRound, int InElapsedTimeToMilliseconds, TArray<struct FChallengeTowerRoundResultInfoData>* InRoundResultDataList);
	void StartChallengeTower();
	void SetState(TEnumAsByte<EBLChallengeTowerStateType> InState);
	void OnLeaveWar();
	void OnEnterWar();
	void OnUpdateContentTokenCT();
	void ReserveEnd();
	void ReserveEndByWatingCancel();
	void ReserveEnterable(bool InIsOpenUI);
	void ReserveWaiting();
	void SetReserveState(TEnumAsByte<EBLWarReserveType> InReserveType);
	void PrintRemainWaitTimeSystemMessage();
	void ClearPartyDeathSytemMessage();
	void SetPartyDeathSytemMessage(int InRemainTime);
	void SetTotalPlayedTime(const struct FQWord& InTotalPlayedToMilliseconds);
	void SetLimitedCount(TArray<struct FChallengeTowerLimitedCountInfoData>* InLimitedCountDataList);
	void RequestExitToServer();
	void RequestPartyMatchingTeleportToServer();
	void MakeConquestWarInfo(TEnumAsByte<ECEBattleFieldWarType> InBattleFieldWarType);
	bool IsInWarProcess();
	bool IsInReserveProcess();
	void Tick(float InDeltaTime);
	void InitializeUI();
	void InitializeData();
	void Init();
	struct FString STATIC_RankGradeTypeToString(TEnumAsByte<ECEGradeType> InRankType);
};


// Class BLGame.BLColosseumWar
// 0x00B8 (0x01C0 - 0x0108)
class UBLColosseumWar : public UBLConquest
{
public:
	int                                                ColosseumCid;                                             // 0x0108(0x0004) (Transient)
	int                                                MatchWaitCount;                                           // 0x010C(0x0004) (Transient)
	unsigned long                                      bAcceptedJoin : 1;                                        // 0x0110(0x0004) (Transient)
	unsigned long                                      bIsJoinTime : 1;                                          // 0x0110(0x0004) (Transient)
	unsigned long                                      bDirtyTeamScore : 1;                                      // 0x0110(0x0004) (Transient)
	unsigned long                                      bDirtyScoreList : 1;                                      // 0x0110(0x0004) (Transient)
	struct FColosseumConfirmRegisterInfo               RegisterInfo;                                             // 0x0114(0x0020) (Transient, NeedCtorLink)
	TArray<TEnumAsByte<EEColosseumMemberRegisterState>> RegisterStateList;                                        // 0x0134(0x0010) (Transient, NeedCtorLink)
	struct FQWord                                      JoinEndTime;                                              // 0x0144(0x0008) (Transient)
	struct FQWord                                      BattleStartTime;                                          // 0x014C(0x0008) (Transient)
	struct FQWord                                      BattleEndTime;                                            // 0x0154(0x0008) (Transient)
	struct FQWord                                      BattleExitTime;                                           // 0x015C(0x0008) (Transient)
	struct FQWord                                      RejoinEndTime;                                            // 0x0164(0x0008) (Transient)
	TArray<struct FString>                             UnionPawnName;                                            // 0x016C(0x0010) (Transient, NeedCtorLink)
	TArray<struct FString>                             HieronPawnName;                                           // 0x017C(0x0010) (Transient, NeedCtorLink)
	int                                                UnionAliveCount;                                          // 0x018C(0x0004) (Transient)
	int                                                HieronAliveCount;                                         // 0x0190(0x0004) (Transient)
	TEnumAsByte<EEColosseumResultType>                 BattleResult;                                             // 0x0194(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0195(0x0003) MISSED OFFSET
	int                                                UnionTeamScore;                                           // 0x0198(0x0004) (Transient)
	int                                                HieronTeamScore;                                          // 0x019C(0x0004) (Transient)
	TArray<struct FColosseumScoreInfo>                 UnionScoreList;                                           // 0x01A0(0x0010) (Transient, NeedCtorLink)
	TArray<struct FColosseumScoreInfo>                 HieronScoreList;                                          // 0x01B0(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLColosseumWar");
		return ptr;
	}


	void SetColosseumWarDayPlayTimeUI();
	void OnClickExit();
	void OnClickEnter();
	void Answer(bool IsOk);
	void OnEnd();
	void OnBegin();
	void StateTick(float InDeltaTime);
	void Tick(float InDeltaTime);
	void UpdateAttendeeInfo();
	bool IsAllRegistered();
	void UpdateMatchMakingInfo(bool bShow, bool bMatchingSuccess, int InStandNumber);
	void SetBattleResult(bool IsBattle);
	TEnumAsByte<EColosseumWinLoseType> GetWinLose();
	void SetIsJoinTime(bool bIsInSchedule);
	void SetVisibleEndTimer(bool bVisible);
	void UpdateScoreBoardTime();
	void SetVisibleScoreBoard(bool bVisible);
	void UpdateScoreList();
	void UpdateTeamScore();
	int RemainSec(const struct FQWord& inTime);
	bool CheckLocalPlayerCondition_Enter();
	bool CheckLocalPlayerCondition_BattleExit();
	bool CheckRegisterableCondition_PartyMember();
	bool CheckRegisterableCondition();
	bool CheckLPLevel();
	void OnExitedColosseum();
	void OnBattleEnd(int InColosseum_cid, TEnumAsByte<EEColosseumResultType> InresultType, const struct FQWord& InExit_time);
	void OnUpdateBattle(int InColosseum_cid, int InUnion_count, int InHieron_count);
	void OnBattleRestartWait(int InColosseum_cid, const struct FQWord& InStart_time);
	void OnBattleStart(int InColosseum_cid, int InUnion_count, int InHieron_count, const struct FQWord& InExpire_time);
	void OnEnterColosseum(int InColosseumCid, const struct FQWord& InStart_time, TArray<struct FString> InUnionPawnName, TArray<struct FString> InHieronPawnName);
	void OnWaitToRejoin(int InColosseumCid, const struct FQWord& InExpireTime);
	void OnJoinColosseumQuery_Retry(int InColosseumCid);
	void OnJoinUpdateRegister(int InColosseumCid, struct FColosseumConfirmRegisterInfo* InColosseumRegisterInfo);
	void OnOpenedJoinColosseum();
	void OnJoinFail(int InColosseumCid);
	void OnJoinWaitOther(int InColosseumCid);
	void OnJoinColosseumQuery(int InColosseumCid, struct FColosseumConfirmRegisterInfo* InColosseumRegisterInfo);
	void OnUpdateScore(int InUnionWinCount, int InHieronWinCount, TArray<struct FColosseumScoreData>* InUnionScoreDataList, TArray<struct FColosseumScoreData>* InHieronScoreDataList);
	void OnUpdateWaitCount(int InColosseumCid, int InWaitCount);
	void OnUnegister();
	void OnRegisterPartyMember(int InColosseumCid, int InWaitCount);
	void OnRegister(int InColosseumCid, int InWaitCount);
	void OnRelease();
	void SetColosseumPenaltyTimeUI(int InPenaltyTime);
	void OnClickExitButtonFromWarUI();
	void OnClickButtonFromWarListUI();
	void OnInitializeUI();
	void OnOpenWarUI();
	void OnOpenWarListUI();
	void OnLeaveWar();
	void CheckEnableWarEnter();
	bool IsInWarProcess();
	bool IsInReserveProcess();
};


// Class BLGame.BLOccupationWar
// 0x00A0 (0x01A8 - 0x0108)
class UBLOccupationWar : public UBLConquest
{
public:
	TEnumAsByte<EWarStateType>                         WarState;                                                 // 0x0108(0x0001)
	TEnumAsByte<EBLRevivalDistanceType>                RevivalDistanceType;                                      // 0x0109(0x0001)
	TEnumAsByte<ECERealmType>                          VictoryRealm;                                             // 0x010A(0x0001)
	unsigned char                                      UnknownData00[0x1];                                       // 0x010B(0x0001) MISSED OFFSET
	TArray<struct FBLOccuPationWarRevivalPropInfo>     RevivalLocationList;                                      // 0x010C(0x0010) (AlwaysInit, NeedCtorLink)
	struct FMap_Mirror                                 SystemMessageMap;                                         // 0x011C(0x0048) (Native)
	float                                              RevivalTimer;                                             // 0x0164(0x0004)
	float                                              RevivalCheckTimer;                                        // 0x0168(0x0004)
	TArray<struct FBLOccupationWarScoreInfo>           HieronOccupationWarScoreInfo;                             // 0x016C(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<struct FBLOccupationWarScoreInfo>           UnionOccupationWarScoreInfo;                              // 0x017C(0x0010) (AlwaysInit, NeedCtorLink)
	struct FBLOccupationWarScoreBoardInfo              HieronScoreBoard;                                         // 0x018C(0x000C)
	struct FBLOccupationWarScoreBoardInfo              UnionScoreBoard;                                          // 0x0198(0x000C)
	unsigned long                                      bInitializeData : 1;                                      // 0x01A4(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLOccupationWar");
		return ptr;
	}


	void UpdateScoreInWarUI();
	void UpdateRemainTimeUI();
	void RefreshWarListUI();
	void OnClickExitButtonFromWarUI();
	void OnClickButtonFromWarListUI();
	void OnInitializeUI();
	void OnOpenWarUI();
	void OnOpenWarListUI();
	void PostAkEvent(class UAkEvent* InAkEvent);
	void SetVictoryRealmScoreData();
	void SetConquestScoreBoardScoreData(struct FOccupationWarData* InOccupationWarScoreData);
	void SetScoreBoardFlagData(int InHieronFlagCount, int InUnionFlagCount);
	void SetScoreBoardScoreData(TArray<struct FSpecialWarRealmScoreData> InSpecialWarRealmScoreDataList);
	void RequestOccupationWarScoreData();
	void PrintSystemMessageByTimer(float InPrepareTime);
	void ResetRevivalTimer();
	void SetState(TEnumAsByte<EWarStateType> InWarState, int InRemainTime);
	void OpenRevivalDialog_BaseGuide();
	void OpenRevivalDialog_Waiting();
	void CheckRevivalPoint();
	void RemoveRevivalProp(int InPropCid, int InPropSid);
	void AddRevivalProp(TEnumAsByte<ECERealmType> InRealmType, int InPropCid, int InPropSid, const struct FVector& InRevivalLocation, float InRevivalRadius, float InRevivalHeight);
	void SetOccupationWarInfo(bool IsOpen, int InPenaltyTime);
	void RequestExitToServer();
	void RequestWarInfoToServer();
	void OnLeaveWar();
	void OnPrevOutWar();
	void ReserveEnd();
	void ReserveEndByJoinTimeOver();
	void ReserveEndByJoinCancel();
	void ReserveEndByWaitingCancelAck();
	void ReserveEndByWaitingCancelReq();
	void ReserveJoinable(int InOccupationWarCId, int InRemainSeconds);
	void ReserveWaiting();
	void SetReserveState(TEnumAsByte<EBLWarReserveType> InReserveType);
	bool IsScoreBoardVisible();
	bool IsInWarProcess();
	bool IsInReserveProcess();
	void Tick(float InDeltaTime);
	void InitializeTimerSystemMessage();
	void InitializeData();
	void Init();
};


// Class BLGame.BLSpecialWar
// 0x0100 (0x0208 - 0x0108)
class UBLSpecialWar : public UBLConquest
{
public:
	int                                                SelectedUITabIndex;                                       // 0x0108(0x0004)
	struct FMap_Mirror                                 SpecialWarStateInfoMap;                                   // 0x010C(0x0048) (Const, Native)
	struct FSpecialWarCommonInfo                       SpecialWarCommon;                                         // 0x0154(0x0028)
	struct FSpecialWarJoinReserveInfo                  SpecialWarJoinReserve;                                    // 0x017C(0x0010)
	struct FWarRankingSortInfo                         SpecialWarRankingSort_Hieron;                             // 0x018C(0x0008)
	struct FWarRankingSortInfo                         SpecialWarRankingSort_Union;                              // 0x0194(0x0008)
	TArray<struct FWarRankingInfo>                     SpecialWarRankingList_Hieron;                             // 0x019C(0x0010) (NeedCtorLink)
	TArray<struct FWarRankingInfo>                     SpecialWarRankingList_Union;                              // 0x01AC(0x0010) (NeedCtorLink)
	TArray<struct FSpecialWarRewardCPData>             RewardCPDataList;                                         // 0x01BC(0x0010) (NeedCtorLink)
	unsigned long                                      bVisibleScoreBoardUI : 1;                                 // 0x01CC(0x0004)
	unsigned long                                      bPlayerIsBolter : 1;                                      // 0x01CC(0x0004)
	unsigned long                                      bExistPreparedSpecialWar : 1;                             // 0x01CC(0x0004) (Transient)
	int                                                CurrentSpecialWarFee;                                     // 0x01D0(0x0004)
	int                                                TotalCPPoint;                                             // 0x01D4(0x0004)
	TArray<struct FWarMedalInfo>                       SpecialWarMedal;                                          // 0x01D8(0x0010) (NeedCtorLink)
	TArray<struct FWarLogInfo>                         SpecialWarLog;                                            // 0x01E8(0x0010) (NeedCtorLink)
	int                                                HieronHP[0x2];                                            // 0x01F8(0x0004)
	int                                                UnionHP[0x2];                                             // 0x0200(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLSpecialWar");
		return ptr;
	}


	void SetConditionDialogJoinButton(TEnumAsByte<EDialogType> Type, bool bInSuccessCondition);
	void UpddateRewardCP();
	void OnUpdateRewardCP(TArray<struct FSpecialWarRewardCPData>* InRewardCPData);
	void TestUI_MyInfo();
	void TestUI_Ranking(bool bShowVictory);
	float GetDeathPointDisplaySeconds();
	bool IsInReserveProcess();
	bool FindMyWarRankingInfo(TArray<struct FWarRankingInfo>* InRankingList, struct FString* InPlayerName, struct FWarRankingInfo* OutMyWarRankingInfo);
	bool FindRankingIndex(TArray<struct FWarRankingInfo>* InRankingList, struct FString* InPlayerName, int* OutResultIndex);
	void GenerateSpecialWarRankingNumber(TArray<struct FWarRankingInfo>* OutRankingList);
	void SortSpecialWarRankingList(int InDownUpType, TEnumAsByte<EWarRankingSortType> InSortType, TArray<struct FWarRankingInfo>* OutRankingList);
	bool IsPlayerEnuoughLumena(int InFee);
	void OnUpdateLumena();
	void OnChangeSortTypeFromWarUI(int InListIndex, int InSortIndex, int InSortDownUpType);
	void OnChangeTabFromWarUI(int InTabIndex);
	void OnClickExitButtonFromWarUI();
	void OnClickButtonFromWarListUI();
	void OnOpenWarUI();
	void OnOpenWarListUI();
	void ShowMidResultUI();
	void UpdateSpecialWarJoinReserveDialog_ToUI();
	void UpdateSpecialWarPlayerMedal_ToUI();
	void UpdateSpecialWarPlayerLog_ToUI();
	void UpdateRemainTimeUI();
	void UpdateSpecialWarSortType_ToUI();
	void UpdateSpecialWarRanking_ToUI();
	void UpdateSpecialWarScoreBoardScore_ToUI();
	void UpdateSpecialWarScoreBoardVisible_ToUI();
	void UpdateSpecialWarScore_ToUI();
	void UpdateSpecialWarState_ToUI();
	void UpdateConquestOpener_ToUI();
	void InitConquestUI_ToUI();
	void OnLeaveWar();
	void RequestSpecialWarPlayerData();
	void UpdateSpecialWarPlayerData(struct FSpecialWarPlayerWarLogData* InPlayerData);
	void RequestWarInfoToServer();
	void UpdateSpecialWarNPCInfo(int InNPCCid, int HPRatio);
	void UpdateSpecialWarLeave(int InErrorCode);
	void UpdateSpecialWarCancelWait(int InErrorCode);
	void UpdateSpecialWarJoinReserve(int InErrorCode);
	void UpdateSpecialWarJoinReserveState(int InSpecialWarCid, int InRemainSeconds, TEnumAsByte<ESpecialWarJoinType> InJoinType, bool bInFirstJoin, bool bInSuccessCondition);
	void UpdateSpecialWarTime(TEnumAsByte<ESpecialWarStateType> InWarStateType, int InRemainSeconds);
	void UpdateSpecialWarScore(TArray<struct FSpecialWarRealmScoreData> InScoreDataList);
	void UpdateSpecialWarAttackAlert(bool bIsOn, struct FSpecialWarAttackAlertData* InAlertData);
	void UpdateSpecialWarData(bool InIsBolterPlayer, struct FSpecialWarInfoData* InSpecialWarData);
	bool FindSpecialWarStateInfo(int InWarCid, struct FSpecialWarStateInfo* OutWarInfo);
	void UpdateSpecialWarJoinType(int InWarCid, TEnumAsByte<ESpecialWarJoinType> InWarJoinType);
	void UpdateSpecialWarStateType(int InWarCid, TEnumAsByte<ESpecialWarStateType> InWarStateType);
	void UpdateSpecialWarList(TArray<struct FSpecialWarListData>* InSpecialWarDataList);
	void ClearSpecialWar();
	void OnInitializeUI();
	void Init();
	void Tick(float InDeltaTime);
};


// Class BLGame.BLConquestManager
// 0x0058 (0x00B8 - 0x0060)
class UBLConquestManager : public UObject
{
public:
	TArray<class UBLConquest*>                         WarList;                                                  // 0x0060(0x0010) (NeedCtorLink)
	TEnumAsByte<ECEBattleFieldWarType>                 SelectedWarType;                                          // 0x0070(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0071(0x0003) MISSED OFFSET
	class UBLConquest*                                 SelectedWar;                                              // 0x0074(0x0008)
	class UBLConquest*                                 EnterWar;                                                 // 0x007C(0x0008)
	class UBLSpecialWar*                               SpecialWar;                                               // 0x0084(0x0008)
	class UBLColosseumWar*                             ColosseumWar;                                             // 0x008C(0x0008)
	class UBLOccupationWar*                            SpermaWar;                                                // 0x0094(0x0008)
	class UBLChallengeTower*                           ChallengeTower;                                           // 0x009C(0x0008)
	int                                                SelectedTabIndex;                                         // 0x00A4(0x0004)
	int                                                SelectedListIndex;                                        // 0x00A8(0x0004)
	int                                                FirstTabIndex;                                            // 0x00AC(0x0004)
	int                                                FirstListIndex;                                           // 0x00B0(0x0004)
	unsigned long                                      IsNeedRefreshWarList : 1;                                 // 0x00B4(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLConquestManager");
		return ptr;
	}


	void PostAkEvent(class UAkEvent* InAkEvent);
	void SetScoreBoardTime(int inTime, int InLimitTime);
	void StopScoreBoardTime();
	void SetScoreBoardVisible(bool Invisible);
	void UpdateScoreBoard();
	void OnChangeSortTypeFromWarUI(int InListIndex, int InSortIndex, int InSortDownUpType);
	void OnChangeTabFromWarUI(int InTabIndex);
	void OnClickExitButtonFromWarUI();
	void OnClickButtonFromWarListUI();
	void OnInitializeUI();
	void CloseWarUI();
	void OnOpenWarUI();
	void OnOpenWarListUI();
	void UnLockAllElementInWarListUI();
	void LockAllElementInWarListUI();
	void LockRemainElementInWarListUI(int InTabIndexOfExcludeListIndex, int InExcludeListIndex);
	void RefreshWarListUI();
	void SetNeedRefreshWarListUI();
	bool SelectWarByWarType(TEnumAsByte<ECEBattleFieldWarType> InWarType);
	bool SelectReserveProcessWar();
	bool SelectFirstWarInWarList(int InTabIndex);
	void SetUIWarListByReserveState(TEnumAsByte<ECEBattleFieldWarType> InWarType, TEnumAsByte<EBLWarReserveType> InReserveType);
	void SetUIWarListByWarType(TEnumAsByte<ECEBattleFieldWarType> InWarType);
	void SetUIWarListIndex(int InTabIndex, int InListIndex);
	void SetListIndex(int InListIndex);
	void SetTabIndex(int InTabIndex);
	void OnLeaveWar(TEnumAsByte<ECEWorldMapType> InWorldMapType);
	void OnEnterWar(TEnumAsByte<ECEWorldMapType> InWorldMapType);
	void SetStateTimer(TEnumAsByte<EWarStateType> InWarState, int InRemainTime);
	void SetWarTypeState(TEnumAsByte<ECEBattleFieldWarType> InWarType);
	TEnumAsByte<ECEWorldMapType> GetLocalPlayerWorldMapType();
	void GetWarListByTabIndex(int InTabIndex, TArray<class UBLConquest*>* OutWarList);
	class UBLConquest* GetReserveProcessWar();
	class UBLConquest* GetFirstWarInWarList(int InTabIndex);
	class UBLConquest* GetWarByUIWarListIndex(int InTabIndex, int InListIndex);
	class UBLConquest* GetWarByWarType(TEnumAsByte<ECEBattleFieldWarType> InWarType);
	class UBLConquestUIManager* GetConquestUIManager();
	void SortWarList();
	void Tick(float InDeltaTime);
	void Init();
};


// Class BLGame.CitadelOwnershipAuction
// 0x0050 (0x00B0 - 0x0060)
class UCitadelOwnershipAuction : public UObject
{
public:
	struct FMap_Mirror                                 Citadels;                                                 // 0x0060(0x0048) (Native, Transient)
	int                                                SelectedCitadelIndex;                                     // 0x00A8(0x0004) (Transient)
	unsigned long                                      IsInCitadelAuctionTime : 1;                               // 0x00AC(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CitadelOwnershipAuction");
		return ptr;
	}


	void SetDialogStaticText(TEnumAsByte<ECERealmType> InRealmType);
	void SetRemainAuctionTime(const struct FQWord& ExpireTime);
	void Update(TArray<struct FCitadelOwnershipInfoData> InCitadels);
	struct FCitadelOwnershipInfoData Get(int citadelCid);
	void Clear();
	void SetIsInAuctionTime(bool IsIn);
	bool IsInAuctionTime();
	void Res_BidCitadel();
	void Req_BidCitadel(const struct FString& bidCP);
	void ShowBidCitadelConfirmDialog(const struct FString& bidCP);
	void ShowBidCitadelDialog();
	void ShowSelectCitadelInfo(int citadelCid, const struct FString& GuildName, const struct FString& guildMasterName, int guildMemberCount, int guildBidCP, bool IsEnableBid);
	void SelectCitadel(int SelectIndex);
	void OnChangedWindowVisible(bool IsVisible);
	void Initialize();
};


// Class BLGame.RealmOwnershipBattle
// 0x0174 (0x01D4 - 0x0060)
class URealmOwnershipBattle : public UObject
{
public:
	TEnumAsByte<EROBattleSide>                         BattleSide;                                               // 0x0060(0x0001) (Transient)
	TEnumAsByte<EROStateType>                          ROState;                                                  // 0x0061(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x2];                                       // 0x0062(0x0002) MISSED OFFSET
	struct FROBattleRegisterCommonInfo                 RegisterCommonInfo;                                       // 0x0064(0x00AC) (Transient, NeedCtorLink)
	struct FROBattleRegisterBtnInfo                    RegisterBtnInfo;                                          // 0x0110(0x0008) (Transient)
	struct FROBattleRegisterRequestInfo                RegisterRequestInfo;                                      // 0x0118(0x0008) (Transient)
	struct FROBattleResultCommonInfo                   ResultCommonInfo;                                         // 0x0120(0x0034) (Transient, NeedCtorLink)
	struct FWarRankingSortInfo                         ResultRankingSort_Attack;                                 // 0x0154(0x0008) (Transient)
	struct FWarRankingSortInfo                         ResultRankingSort_Defense;                                // 0x015C(0x0008) (Transient)
	TArray<struct FWarRankingInfo>                     ResultRankingList_Attack;                                 // 0x0164(0x0010) (Transient, NeedCtorLink)
	TArray<struct FWarRankingInfo>                     ResultRankingList_Defense;                                // 0x0174(0x0010) (Transient, NeedCtorLink)
	TArray<struct FWarRankingInfo>                     ResultRankingList_Attack_UI;                              // 0x0184(0x0010) (Transient, NeedCtorLink)
	TArray<struct FWarRankingInfo>                     ResultRankingList_Defense_UI;                             // 0x0194(0x0010) (Transient, NeedCtorLink)
	struct FROBattleRemainTimeInfo                     RemainTimeInfo;                                           // 0x01A4(0x0010) (Transient)
	float                                              RequestRegisterReserveTimer;                              // 0x01B4(0x0004) (Transient)
	float                                              FlashingSoundTimer;                                       // 0x01B8(0x0004) (Transient)
	int                                                AttackerCount;                                            // 0x01BC(0x0004) (Transient)
	int                                                DefenderCount;                                            // 0x01C0(0x0004) (Transient)
	TArray<struct FRoWarNPCData>                       RoWarNpcList;                                             // 0x01C4(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.RealmOwnershipBattle");
		return ptr;
	}


	void CollectRoWarNpcList(TArray<struct FRoWarNPCData>* OutList);
	int RemoveRoWarNpc(const struct FRoWarNPCData& InData);
	void UpdateRoWarNpc(const struct FRoWarNPCData& InData);
	void UpdatePlayerCount(int InAttackerCount, int InDefenderCount);
	void TestResultUI();
	void TestProgressUI(bool bOn);
	bool CanOpenProgressUI();
	class UBLConquestUIManager* GetConquestUIManager();
	bool FindRankingIndex(TArray<struct FWarRankingInfo>* InRankingList, struct FString* InPlayerName, int* OutResultIndex);
	void GenerateRankingNumber(TArray<struct FWarRankingInfo>* OutRankingList);
	void SortRankingList(int InDownUpType, TEnumAsByte<EWarRankingSortType> InSortType, TArray<struct FWarRankingInfo>* OutRankingList);
	void ConvertRemainSecondsToMinutes(float InRemainSeconds, int* OutRemainMinutes);
	void ConvertRemainSecondsToRemainText(float InRemainSeconds, struct FString* OutRemainText);
	void ConvertSecondsToROBattleDateTime(const struct FQWord& InSeconds, struct FROBattleDateTime* OutTime);
	void OnSelectedResultLeave_FromUI();
	void OnSelectedResultSortType_FromUI(int InListIndex, int InSortIndex, int InSortDownUpType);
	void OnOpenedResult_FromUI();
	void OnOpenedProgress_FromUI();
	void OnSelectedRegisterDefenseInOut_FromUI();
	void OnSelectedRegisterAttackInOut_FromUI();
	void OnOpenedRegister_FromUI();
	void UpdateResultInfo_ToUI();
	void UpdateResultSortType_ToUI();
	void UpdateResultRanking_ToUI(bool bForce, TArray<struct FWarRankingInfo>* InNewRankingList_Attack, TArray<struct FWarRankingInfo>* InNewRankingList_Defense);
	void UpdateRemainTimeUI();
	void UpdateRegisterButton_ToUI();
	void UpdateRegisterChangeSelectionRemainTime_ToUI();
	void UpdateRegisterStartRemainTime_ToUI();
	void UpdateRegisterReserveRemainTime_ToUI();
	void UpdateRegisterAll_ToUI();
	void OnLeaveROField();
	void OnEnterROField();
	void OnUpdateProcessRemainTime(float PrevTime, float NextTime);
	void UpdateROAttendStart(TEnumAsByte<ECERealmType> InRealmType);
	void UpdateStateAndTime(TEnumAsByte<EROStateType> InStateType, int InRemainSeconds);
	void UpdateEnterWorldInfo(bool bInAttacker, int InprocessTime);
	void UpdateResultData(struct FROResultData* InData);
	void UpdateRegisterCancelWait(int InErrorCode, int InRemainModifyTime);
	void UpdateRegisterJoinReserve(int InErrorCode, int InRemainModifyTime);
	void UpdateRegisterData(int InErrorCode, bool bInReserved, bool bInAttacker, bool bInCanReserve, int InRemainModifyTime, struct FROAttendInfoData* InData);
	void ReserveRequestRegisterData(float InSeconds);
	void RequestProgressData();
	void RequestRegisterCancelWait();
	void RequestRegisterJoinReserve(bool bAttacker);
	void RequestRegisterData();
	void Clear();
	void Init();
	void Tick(float InDeltaSeconds);
};


// Class BLGame.BLAweWebViewComponent
// 0x003C (0x05D0 - 0x0594)
class UBLAweWebViewComponent : public UAweWebViewComponent
{
public:
	struct FString                                     WebViewName;                                              // 0x0594(0x0010) (AlwaysInit, NeedCtorLink)
	class UTexture2D*                                  DefaultTexture;                                           // 0x05A4(0x0008)
	int                                                HelpComponentSizeX;                                       // 0x05AC(0x0004)
	int                                                HelpComponentSizeY;                                       // 0x05B0(0x0004)
	int                                                ShopComponentSizeX;                                       // 0x05B4(0x0004)
	int                                                ShopComponentSizeY;                                       // 0x05B8(0x0004)
	struct FString                                     UIRenderTargetName;                                       // 0x05BC(0x0010) (NeedCtorLink)
	unsigned long                                      bPendingGainFocus : 1;                                    // 0x05CC(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAweWebViewComponent");
		return ptr;
	}


	void OnUpdateIMEImpl(int Type, int CaretX, int CaretY);
	void UpdateTexture(bool Reattach);
	void ClearRenderTarget();
	void WeblinkURL(const struct FString& URL);
	void Weblink();
	void SwfPlay(int first, float Second, const struct FString& Third);
	void ResetSpecialKey();
	void ForceReleaseTextInputFocus();
	void LoseFocus();
	void GainFocus();
	void LoadHelpFile(const struct FString& HelpFileName);
	void LoadFile(const struct FString& Filename);
	void InitializeWebURL(const struct FString& URL);
	void InitializeLocalPath(const struct FString& URL);
	struct FString GetWebViewName();
	void SetWebViewName(const struct FString& NewName);
};


// Class BLGame.BLCostumeHelper
// 0x0090 (0x00F0 - 0x0060)
class UBLCostumeHelper : public UObject
{
public:
	struct FMap_Mirror                                 EquipSlotVisibility;                                      // 0x0060(0x0048) (Native, Transient)
	struct FMap_Mirror                                 PendingVisibility;                                        // 0x00A8(0x0048) (Native, Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLCostumeHelper");
		return ptr;
	}


	void Tick();
	void STATIC_SplitCostume(TArray<struct FEquipedItemData> InTotal, TArray<struct FEquipedItemData>* OutCostume, TArray<struct FEquipedItemData>* OutOther);
	void UpdateVisibilityWithFactor(TEnumAsByte<ECEEquipSlotType> InKey, bool InVal);
	void UpdateVisibility(int InFlag);
	void MakeShowData(TArray<struct FEquipedItemData> InTotal, TArray<struct FEquipedItemData>* OutShow);
};


// Class BLGame.EquipmentCustom
// 0x0114 (0x0174 - 0x0060)
class UEquipmentCustom : public UObject
{
public:
	struct FColor                                      NewStatsGreaterColor;                                     // 0x0060(0x0004) (Config)
	struct FColor                                      NewStatsEqualColor;                                       // 0x0064(0x0004) (Config)
	struct FColor                                      NewStatslessColor;                                        // 0x0068(0x0004) (Config)
	struct FNormalCustomInfo                           NormalCustom;                                             // 0x006C(0x0084) (NeedCtorLink)
	struct FSpecialCustomInfo                          SpecialCustom;                                            // 0x00F0(0x0028) (NeedCtorLink)
	struct FPotentialOpenInfo                          PotentialOpen;                                            // 0x0118(0x0040) (NeedCtorLink)
	struct FPotentialDisjointInfo                      PotentialDisjoint;                                        // 0x0158(0x0010)
	int                                                RequestItemSid;                                           // 0x0168(0x0004)
	int                                                ProcessItemSid;                                           // 0x016C(0x0004)
	unsigned long                                      IsWaitingEquipCustom : 1;                                 // 0x0170(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.EquipmentCustom");
		return ptr;
	}


	void StartSpecialCustomResultRouletteToUI(int InRouletteSelectOption);
	void UpdateNormalCustomResultToUI();
	void UpdatePotentialDisjointReadyToUI();
	void UpdatePotentialOpenReadyToUI();
	void UpdateSpecialCustomReadyToUI();
	void UpdateNormalCustomReadyToUI();
	void UpdateItemParameterToUI();
	void UpdateItemToUI();
	void OnUpdatePotentialDisjointConfirmResult(int InErrorCode, bool bGreatSuccess, const struct FQWord& InCinis, const struct FQWord& InGold);
	void OnUpdatePotentialOpenConfirmResult(int InErrorCode, int InPotentialLevel);
	void OnUpdateSpecialCustomConfirmResult(int InErrorCode, int InNewOptionCid);
	void OnUpdateNormalCustomConfirmResult(int InErrorCode);
	void OnUpdateNormalCustomResult(int InErrorCode, TArray<struct FStatData>* InNewStats);
	void OnRegisterItem(int InErrorCode);
	void OnSelectedPotentialDisjointFromDialogUI();
	void OnCompletedPotentialDisjointFromUI();
	void OnSelectedPotentialDisjointReturnFromUI();
	void OnSelectedPotentialDisjointConfirmFromUI();
	void OnSelectedPotentialOpenConfirmFromUI();
	void OnCompletedSpecialCustomRouletteFromUI();
	void OnSelectedSpecialCustomConfirmFromUI();
	void OnSelectedNormalCustomConfirmFromUI(bool bNewCustom);
	void OnSelectedNormalCustomPaymentFromUI(bool bLumenaType);
	void OnSelectedPotentialDisjointFromUI();
	void OnSelectedPotentialOpenFromUI();
	void OnSelectedSpecialCustomFromUI();
	void OnSelectedNormalCustomFromUI();
	void OnRemovedItemFromUI(int InItemSid);
	void OnAddedItemFromUI(int InItemSid);
	void OnClosedFromUI();
	void OnOpenedFromUI();
	void UpdatePotentialDisjointInfo();
	void UpdatePotentialOpenInfo();
	void UpdateSpecialCustomInfo();
	void UpdateNormalCustomInfo();
	void UpdateRegisterItem();
	void ResetEquipCustom();
	void ClearCustomInfo();
	void Init();
};


// Class BLGame.BLGroundManager
// 0x0020 (0x0080 - 0x0060)
class UBLGroundManager : public UObject
{
public:
	TArray<struct FRealmOwnerGuildData>                RealmOwnerDataList;                                       // 0x0060(0x0010) (Transient, NeedCtorLink)
	TArray<struct FCitadelOwnerGuildData>              CitadelOwnerDataList;                                     // 0x0070(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLGroundManager");
		return ptr;
	}


	bool IsSubZone(int InParentCid, int InChildCid);
	bool IsCapitalZone(int InLocationCid);
	void UpdateRealmOwnerGuildMark(TEnumAsByte<ECERealmType> InRealmType, struct FGuildMarkData* InData);
	void UpdateRealmOwnerLeaderName(TEnumAsByte<ECERealmType> InRealmType, struct FString* InName);
	void UpdateCitadelOwnerGuildMark(TArray<int>* InCitadelList, struct FGuildMarkData* InData);
	void UpdateCitadelOwnerLeaderName(TArray<int>* InCitadelList, struct FString* InName);
	bool GetRealmOwnerData(TEnumAsByte<ECERealmType> InRealmType, struct FRealmOwnerGuildData* OutData);
	bool GetGroundOwnerData(int InLocationCid, TEnumAsByte<ECERealmType> InRealmType, struct FCitadelOwnerGuildData* OutData);
	bool GetCitadelOwnerGuildData(int InCitadelCid, struct FCitadelOwnerGuildData* OutData);
	void InitRealmOwnerDataList(TArray<struct FRealmOwnerGuildData>* InDataList);
	void InitCitadelOwnerDataList(TArray<struct FCitadelOwnerGuildData>* InDataList);
};


// Class BLGame.BLAutoPathFindPoint
// 0x0030 (0x0280 - 0x0250)
class ABLAutoPathFindPoint : public AActor
{
public:
	unsigned long                                      bStickToTerrain : 1;                                      // 0x0250(0x0004) (Edit)
	struct FColor                                      EditorLineColor;                                          // 0x0254(0x0004) (Edit)
	TArray<class ABLAutoPathFindPoint*>                LinkedPointList;                                          // 0x0258(0x0010) (NeedCtorLink)
	class USpriteComponent*                            SpriteComp;                                               // 0x0268(0x0008) (ExportObject, Transient, Component, EditInline)
	class ULineBatchComponent*                         LineBatchComp;                                            // 0x0270(0x0008) (ExportObject, Transient, Component, EditInline)
	int                                                MyIndex;                                                  // 0x0278(0x0004) (Transient)
	float                                              defaultScale;                                             // 0x027C(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAutoPathFindPoint");
		return ptr;
	}


	void UpdateSprite();
	bool IsLinked(class ABLAutoPathFindPoint* InAutoPathFindPoint);
	void DestroyPoint();
	void RemoveLink(class ABLAutoPathFindPoint* InAutoPathFindPoint);
	void SetLink(class ABLAutoPathFindPoint* InAutoPathFindPoint);
};


// Class BLGame.BLAutoPathManager
// 0x004C (0x00AC - 0x0060)
class UBLAutoPathManager : public UObject
{
public:
	TEnumAsByte<EAutoPath_Type>                        AutoPathType;                                             // 0x0060(0x0001) (Transient)
	TEnumAsByte<EAlertElementType>                     PathQuestAlertElementType;                                // 0x0061(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x2];                                       // 0x0062(0x0002) MISSED OFFSET
	unsigned long                                      IsUpdated : 1;                                            // 0x0064(0x0004) (Transient)
	unsigned long                                      bAutoMoving : 1;                                          // 0x0064(0x0004)
	unsigned long                                      bAirMount : 1;                                            // 0x0064(0x0004)
	int                                                PathQuestID;                                              // 0x0068(0x0004) (Transient)
	class UParticleSystemComponent*                    DirectionPSC;                                             // 0x006C(0x0008) (ExportObject, Transient, Component, EditInline)
	class UParticleSystemComponent*                    DestinationPSC;                                           // 0x0074(0x0008) (ExportObject, Transient, Component, EditInline)
	class UBLAutoPathRouteViewer*                      RouteViewer;                                              // 0x007C(0x0008)
	int                                                DestIndex;                                                // 0x0084(0x0004)
	struct FVector                                     UpdateLocation;                                           // 0x0088(0x000C)
	struct FPointer                                    CurrentDestNode;                                          // 0x0094(0x0008) (Native)
	TArray<struct FAutoPathDestInfo>                   DestinationsList;                                         // 0x009C(0x0010) (Native, AlwaysInit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAutoPathManager");
		return ptr;
	}


	void UpdateDestinationVFX();
	void UpdateDirectionVFX(float DeltaSeconds);
	void MoveToAutoPath();
	void CancelAutoMoving();
	void CancelAutoPath();
	void CheckDestArrive();
	void ArriveDestNode();
	bool NeedUpdate();
	void UpdateDestNodes(int InIndex);
	void FindAutoPath(const struct FVector& InStartLoc, const struct FVector& InEndLoc, bool IsIconDest);
	struct FVector GetDestinationLoc();
	void SetAutoPathOfMonsterBook(int InMonsterBookId);
	void SetAutoPathOfQuest(int InQuestID, TEnumAsByte<EAlertElementType> InAlertElementType);
	void SetAutoPathOfFreeDest(const struct FVector& InDestLoc, bool InNeedToCheckTerrainZ);
	void SetAutoPath(const struct FVector& InDestLoc, bool InNeedToCheckTerrainZ);
	void SetAutoPathIconDest();
	void SetAutoPathFreeDest();
	int GetActiveDestCnt();
	void RemoveDestInfo(int InIndex);
	bool UpdateDestInfo(int InIndex, const struct FAutoPathDestInfo& InDestInfo);
	int AddDestInfo(const struct FAutoPathDestInfo& InDestInfo, bool IsIconDest);
	bool IsAirTypeMount();
	bool AvailableWorldID();
	bool AvailableQuest();
	bool AvailableDestListCnt();
	bool IsDestInList(const struct FVector& InDesLoc);
	bool AvailableCheck(const struct FVector& InDesLoc);
	bool IsActivate();
	void Initialize();
	void Tick(float DeltaSeconds);
};


// Class BLGame.BLAutoPathMeshActor
// 0x0008 (0x0258 - 0x0250)
class ABLAutoPathMeshActor : public AActor
{
public:
	class UStaticMeshComponent*                        StaticMeshComponent;                                      // 0x0250(0x0008) (Const, ExportObject, Component, EditInline)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAutoPathMeshActor");
		return ptr;
	}

};


// Class BLGame.BLAutoPathRouteViewer
// 0x003C (0x009C - 0x0060)
class UBLAutoPathRouteViewer : public UObject
{
public:
	int                                                DestIndex;                                                // 0x0060(0x0004)
	int                                                SettingNodeIndex;                                         // 0x0064(0x0004)
	float                                              UpdateRemainTime;                                         // 0x0068(0x0004)
	TArray<class ABLAutoPathMeshActor*>                AutoPathMeshpool;                                         // 0x006C(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<class ABLAutoPathMeshActor*>                NoHiddenContainer;                                        // 0x007C(0x0010) (Transient, AlwaysInit, NeedCtorLink)
	TArray<struct FAutoPathViewNode>                   ViewNodeList;                                             // 0x008C(0x0010) (Transient, AlwaysInit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAutoPathRouteViewer");
		return ptr;
	}


	bool SetNextNodeToSettingIndex();
	bool SetPreNodeToSettingIndex();
	void EmptyingNoHiddenContainer();
	void ClearPathMeshPool();
	void ReturnAllMeshesForUpdate();
	void ReturnAllMeshesToPool();
	int GetActiveMeshCnt();
	void ReturnPathMeshForUpdate(class ABLAutoPathMeshActor* InAutoPathMeshActor);
	void ReturnPathMeshToPool(class ABLAutoPathMeshActor* InAutoPathMeshActor);
	class ABLAutoPathMeshActor* GetPathMeshFromPool(const struct FVector& InLocation, const struct FRotator& InRotation, bool bGetFromOtherNode);
	void Tick(float DeltaSeconds);
	bool RefineValue(const struct FVector& InDir, struct FVector* OutVector, struct FRotator* OutRotator);
	class ABLAutoPathMeshActor* GetMeshFromLastNode();
	void UpdateRoute();
	void RemoveRoute(int InIndex);
	void SetRoute(const struct FAutoPathDestInfo& InDestInfo, int ManagerIndex);
	void Init();
};


// Class BLGame.AnimaManager
// 0x0064 (0x00C4 - 0x0060)
class UAnimaManager : public UObject
{
public:
	TEnumAsByte<EAnimaUIStateType>                     CurrentUIState;                                           // 0x0060(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	int                                                TargetAnimaSid;                                           // 0x0064(0x0004)
	struct FAnimaTargetUISlotData                      TargetAnimaData;                                          // 0x0068(0x0014)
	TArray<struct FAnimaMPFResultData>                 AnimaMPFResultDataList;                                   // 0x007C(0x0010) (NeedCtorLink)
	TArray<struct FAnimaItemResultData>                AnimaItemResultDataList;                                  // 0x008C(0x0010) (NeedCtorLink)
	struct FAnimaMPFResultData                         BonusMPFData;                                             // 0x009C(0x0028)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.AnimaManager");
		return ptr;
	}


	void OnRemovedItem(int InSid);
	void OnUpdateItem(int InSid);
	void OnClickResultItem(int InSlotIndex);
	void RequestAnimaOpenResult();
	void OnStartHatch(int InCount);
	void OnClosedFromUI();
	void OnOpenedFromUI();
	void UpdateSelectUI(int InIndex);
	void FailHatch();
	void SuccessHatch(int InMPFCount, TArray<struct FV2MPFItemData>* InItemList);
	void DeleteAnimaItem();
	void AddAnimaItem(int InSid);
	void UpdateResultTarget(TEnumAsByte<ECEItemGradeType> InGrade, TEnumAsByte<ECECompanionType> InCompanionType, int InLookCid);
	void SetAnimaResultViewport(TEnumAsByte<ECECompanionType> InMPFType, int InLookInfoCid);
	void UpdateResultUI();
	void UpdateAnimaUI();
	void UpdateAnimaUISlot();
	void InitUI();
	void Init();
};


// Class BLGame.CollectionBook
// 0x00F0 (0x0150 - 0x0060)
class UCollectionBook : public UObject
{
public:
	int                                                CurrentSelectedSlotIndex;                                 // 0x0060(0x0004)
	TEnumAsByte<ECollectionBookTabEnum>                CurrentSelectedEnum;                                      // 0x0064(0x0001)
	TEnumAsByte<ECB_UIFilterType>                      FilterType;                                               // 0x0065(0x0001)
	TEnumAsByte<ECB_SubUIType>                         CurrentOpenedSubUIType;                                   // 0x0066(0x0001)
	unsigned char                                      UnknownData00[0x1];                                       // 0x0067(0x0001) MISSED OFFSET
	struct FQWord                                      CurrentSelectedUid;                                       // 0x0068(0x0008)
	struct FCollectionListUIData                       CurrentMoveUIData;                                        // 0x0070(0x006C) (NeedCtorLink)
	int                                                MaxSlotCount;                                             // 0x00DC(0x0004)
	TArray<struct FCollectionBookTabListData>          CollectionBookList;                                       // 0x00E0(0x0010) (NeedCtorLink)
	TArray<struct FCollectionBookFavoriteDataList>     FavoriteList;                                             // 0x00F0(0x0010) (NeedCtorLink)
	int                                                CurrentFavoritePage;                                      // 0x0100(0x0004)
	unsigned long                                      IsDescendSort : 1;                                        // 0x0104(0x0004)
	unsigned long                                      IsUncommon : 1;                                           // 0x0104(0x0004)
	unsigned long                                      IsRare : 1;                                               // 0x0104(0x0004)
	unsigned long                                      IsEpic : 1;                                               // 0x0104(0x0004)
	unsigned long                                      IsLegendary : 1;                                          // 0x0104(0x0004)
	unsigned long                                      IsHuman : 1;                                              // 0x0104(0x0004)
	unsigned long                                      IsCreature : 1;                                           // 0x0104(0x0004)
	unsigned long                                      IsBarbarian : 1;                                          // 0x0104(0x0004)
	unsigned long                                      IsUndead : 1;                                             // 0x0104(0x0004)
	unsigned long                                      IsOpenedCollectionBook : 1;                               // 0x0104(0x0004)
	class UCB_FatigueRecoveryManager*                  FatigueRecoveryManager;                                   // 0x0108(0x0008)
	class UCB_GradeUpAddManager*                       GradeUpAddManager;                                        // 0x0110(0x0008)
	class UCB_ExpUpManager*                            ExpUpManager;                                             // 0x0118(0x0008)
	class UCB_GradeUpManager*                          GradeUpManager;                                           // 0x0120(0x0008)
	class UCB_MonsterBallManager*                      MonsterBallManager;                                       // 0x0128(0x0008)
	class UCB_MPFSkillChangeManager*                   MPFSkillChangeManager;                                    // 0x0130(0x0008)
	float                                              FatigueExpRemainUpdateTime;                               // 0x0138(0x0004)
	int                                                CompanionStat_Title_Size;                                 // 0x013C(0x0004) (Config)
	struct FColor                                      CompanionStat_Title_Color;                                // 0x0140(0x0004) (Config)
	int                                                CompanionStat_Size;                                       // 0x0144(0x0004) (Config)
	struct FColor                                      CompanionStat_Color1;                                     // 0x0148(0x0004) (Config)
	struct FColor                                      CompanionStat_Color2;                                     // 0x014C(0x0004) (Config)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CollectionBook");
		return ptr;
	}


	void ExtractionClickConfirm();
	void FatigueRecoveryClickUseButton(int InSlotIndex);
	void SkillChangeClickHelpButton(int InSlotIndex);
	void SkillChangeClickConfirmButton();
	void GradeToAddClickUseButton(int InSlotIndex);
	void GradeUpClickConfirm();
	void GradeUpClickAmountSubMaterial(int InSlotIndex);
	void GradeUpClickProbability(bool InIsCheck);
	void GradeUpClickProtection(bool InIsCheck);
	void GradeUpRemoveMaterial(const struct FQWord& InSid);
	void GradeUpAddMaterial(const struct FQWord& InSid);
	void ExpUpClickConfirm();
	void ExpUpClickAmountSubMaterial(int InSlotIndex);
	void ExpUpClickSubMaterial(bool InIsCheck);
	void ExpUpRemoveMaterial(const struct FQWord& InSid, int InSlotIndex);
	void ExpUpSwapMaterial(int InTargetIndex, int IndraggedSlotIndex);
	void ExpUpAddMaterial(const struct FQWord& InSid, int InSlotIndex);
	void SetCollectionBookOpenLevel();
	void UIClearSubUIContents();
	void UISetSubUIDescription(bool InbVisble);
	void AllSubUIClearAllMPFMaterial();
	void AllUIDetailDisableButton();
	void UpdateUIDetailDisableButton();
	void ClearTabNewCount(int InTabIndex);
	void ShowLegendaryAppearance();
	void UpdateCurrentSubUISetSubMaterialItem();
	void OpenSubUI_SkillChange();
	void OpenSubUI_GradeUpAdd();
	void OpenSubUI_FatigueRecovery();
	void OpenSubUI_MonsterBall();
	void OpenSubUI_GradeUP();
	void OpenSubUI_ExpUP();
	void OpenSubUI(TEnumAsByte<ECB_SubUIType> InUIType);
	bool FilterCheck(const struct FCollectionListUIData& InData);
	void ConfirmFilter(int InTabIndex, int InFilterType, bool InIsDsc, bool InIsUnc, bool InIsRare, bool InIsEpic, bool InIsLegend, bool InIsHuman, bool InIsBarbarian, bool InIsCreature, bool InIsUndead);
	void SortCollectionUIList(TArray<struct FCollectionListUIData> InUIList, TArray<struct FCollectionListUIData>* OutUIList);
	void OnOpenFilter();
	bool IsFavoriteCollection(const struct FQWord& InSid);
	void RequestFatigueExpUpdate();
	void SetLock(bool InIsLock);
	void UseFavoriteMPF(const struct FQWord& InUid);
	void UseMainActionBarFavoriteSlot(int InFavoritePage, int InFavoriteSlot);
	void UseCollectionBookFavoriteSlot(int InFavoriteSlot);
	void SelectFavoriteSlot(int InFavoriteSlot);
	void MoveFavoriteSlot(int InFromIndex, int InToIndex);
	bool GetFavoriteDataList(int InPage, TArray<struct FFavoriteSlotData>* outDataList);
	void UpdateFavoriteActionBar();
	void RequestUnRegistFavoriteUI(int InSlotIndex);
	void RequestRegistFavoriteUI(int InSlotIndex, const struct FQWord& InUid);
	void UpdateFavoriteFatigue();
	bool UpdateFavoriteSlotData(struct FCollectionListUIData* InData);
	void UpdateAllFavoriteSlotData();
	void SetFavoriteSlotList(TArray<struct FMPFActionBarData>* InDataList);
	void SetFavoriteSlot(struct FMPFActionBarData* InData);
	void UpdateFavoriteUIList();
	bool GetFavoriteUIObject(class UGFxObject* OutUIObject, const struct FFavoriteSlotData& InData);
	void SetFavoritePage(int InPage);
	void InitFavoritePage();
	void OnUpdateItem(int InSid);
	void OnRemovedItem(int InSid);
	void OnRemovedMPF(const struct FQWord& InUid);
	void OnUpdateMPF(const struct FQWord& InUid);
	int GetCid(int TabIndex, int Index, struct FString* Sid);
	void CloseAllSubUI();
	void NewCollectionBookClickedByUid(int TabIndex, const struct FQWord& InUid);
	void NewCollectionBookClicked(struct FString* Sid);
	void OnClosedFromUI();
	void OnOpenedFromUI();
	struct FString GetMPFSlotCountText();
	int GetCurrentMaxSlotCount();
	int GetHoldingTotalCount();
	void UpdateNewCollectionTotalCount();
	void UpdateNewCollectionCount(int TabIndex, int COUNT);
	void CurrentManagerSetTatget();
	void UpdateCollectionBook(bool bForce);
	void UA_Update_CurrentSelectedMP_DetailData_Fatigue(int InFatigue, int InFatigueMin, int InFatigueMax, int InExpValue, int InExpMin, int InExpMax);
	void UA_Set_CurrentSelectedMP_DetailData(struct FCollectionDetailData* InData);
	void SelectCollectionSlot(const struct FQWord& Uid);
	void ClearDetailInfo();
	void SettingShowOnlyHoldingList();
	void ChangeCollectionBookTab(int TabIndex);
	void UpdateUIListElemByUid(const struct FQWord& InUid);
	void UpdateUIListElem(int ListIndex);
	void UpdateUIList();
	int GetSelectTabNumber(const struct FQWord& InTargetUID);
	bool GetCollectionBookSelectedDetailData(const struct FQWord& InUid, struct FCollectionDetailData* Data);
	void GetCollectionBookListUIObject(int TabIndex, int Index, class UGFxObject** Object);
	void GetCollectionBookListUIObjectList(int TabIndex, TArray<class UGFxObject*>* List);
	void UpdateFatigue(const struct FQWord& InUid, float InFatigue, float InMaxFatigue);
	void OnRemovedCollectionBookData(const struct FQWord& Uid);
	void UpdateCollectionBookList(int TabIndex);
	void UpdateCollectionBookListDataByUID(const struct FQWord& Uid);
	void UpdateCollectionBookListDataByIndex(int TabIndex, int Index);
	void UpdateCollectionBookListData(int TabIndex, struct FCollectionListUIData* Data);
	void UpdateCollectionBookFellowListDataFromMission(struct FCM_FellowData* Data);
	void UpdateCollectionBookFellowListData(struct FCM_FellowData* Data);
	void UpdateCollectionBookPetListData(struct FCM_PetData* Data);
	void UpdateCollectionBookMountListData(struct FCM_MountData* Data);
	bool AddCollectionBook(TEnumAsByte<ECollectionBookTabEnum> TabIndex, const struct FQWord& Uid);
	void OnClickedCollectionBookTab(int InTabIndex);
	void InitAllCollectionBookList();
};


// Class BLGame.CollectionBookSubUIBase
// 0x0030 (0x0090 - 0x0060)
class UCollectionBookSubUIBase : public UObject
{
public:
	unsigned long                                      bOpenedUI : 1;                                            // 0x0060(0x0004)
	unsigned long                                      bIsProcessing : 1;                                        // 0x0060(0x0004)
	struct FCB_MPFData                                 TargetData;                                               // 0x0064(0x000C)
	TArray<struct FCB_MPFData>                         MPFMaterialIList;                                         // 0x0070(0x0010) (NeedCtorLink)
	TArray<struct FCB_ItemMaterialData>                ItemMaterialList;                                         // 0x0080(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CollectionBookSubUIBase");
		return ptr;
	}


	void SendDoProcess();
};


// Class BLGame.CB_ExpUpManager
// 0x0028 (0x00B8 - 0x0090)
class UCB_ExpUpManager : public UCollectionBookSubUIBase
{
public:
	unsigned long                                      bDoingExpUpFX : 1;                                        // 0x0090(0x0004)
	unsigned long                                      ExpUpFXLevelUp : 1;                                       // 0x0090(0x0004)
	unsigned long                                      bIsUseSubMaterial : 1;                                    // 0x0090(0x0004)
	struct FQWord                                      ExpUpFXTargetUid;                                         // 0x0094(0x0008)
	int                                                ExpUpFXStartLevel;                                        // 0x009C(0x0004)
	int                                                ExpUpFXEndLevel;                                          // 0x00A0(0x0004)
	int                                                ExpUpFXStartExp;                                          // 0x00A4(0x0004)
	int                                                ExpUpFXEndExp;                                            // 0x00A8(0x0004)
	int                                                ExpUpFXNextExp;                                           // 0x00AC(0x0004)
	int                                                ExpUpFXRequireExp;                                        // 0x00B0(0x0004)
	int                                                UseSubMaterialCount;                                      // 0x00B4(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CB_ExpUpManager");
		return ptr;
	}


	void SendDoProcess();
	void UISetSubMaterialItem();
	void UseSubMaterialAmount(int InCount);
	void UseSubMaterial(bool InbIsUseSubMaterial);
	void SetSwapMPFMaterial(int InTargetIndex, int InSelectIndex);
};


// Class BLGame.CB_FatigueRecoveryManager
// 0x001C (0x00AC - 0x0090)
class UCB_FatigueRecoveryManager : public UCollectionBookSubUIBase
{
public:
	int                                                CurrentFatigue;                                           // 0x0090(0x0004)
	int                                                MaxFatigue;                                               // 0x0094(0x0004)
	int                                                RecoverFatigue;                                           // 0x0098(0x0004)
	int                                                ResultFatigue;                                            // 0x009C(0x0004)
	int                                                RemainItemUseCount;                                       // 0x00A0(0x0004)
	unsigned long                                      IsShowResult : 1;                                         // 0x00A4(0x0004)
	int                                                SelectSlotIndex;                                          // 0x00A8(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CB_FatigueRecoveryManager");
		return ptr;
	}


	void SendDoProcess();
	void UISetSubMaterialItem();
};


// Class BLGame.CB_FosterManager
// 0x0000 (0x0090 - 0x0090)
class UCB_FosterManager : public UCollectionBookSubUIBase
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CB_FosterManager");
		return ptr;
	}

};


// Class BLGame.CB_GradeUpAddManager
// 0x0010 (0x00A0 - 0x0090)
class UCB_GradeUpAddManager : public UCollectionBookSubUIBase
{
public:
	int                                                CurrentGradeUpCount;                                      // 0x0090(0x0004)
	int                                                ResetGradeUpChanceItemUseCnt;                             // 0x0094(0x0004)
	int                                                ResultGradeUpCount;                                       // 0x0098(0x0004)
	int                                                SelectSlotIndex;                                          // 0x009C(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CB_GradeUpAddManager");
		return ptr;
	}


	void SendDoProcess();
	void UISetSubMaterialItem();
};


// Class BLGame.CB_GradeUpManager
// 0x0010 (0x00A0 - 0x0090)
class UCB_GradeUpManager : public UCollectionBookSubUIBase
{
public:
	unsigned long                                      bIsUseProtectionItem : 1;                                 // 0x0090(0x0004)
	unsigned long                                      bIsUseProbabilityItem : 1;                                // 0x0090(0x0004)
	unsigned long                                      ResultSuccess : 1;                                        // 0x0090(0x0004)
	int                                                ProbabilityCount;                                         // 0x0094(0x0004)
	float                                              ResultBeforeAccumulatedChance;                            // 0x0098(0x0004)
	float                                              ResultAfterAccumulatedChance;                             // 0x009C(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CB_GradeUpManager");
		return ptr;
	}


	void ShowGradeUpResultDialog();
	void SendDoProcess();
	void UISetSubMaterialItem();
	void UseSubMaterialAmount(int InCount);
	void UseProbabilityItem(bool InIsUseProbabilityItem);
	void UseProtectionItem(bool InIsUseProtectionItem);
};


// Class BLGame.CB_MonsterBallManager
// 0x001C (0x00AC - 0x0090)
class UCB_MonsterBallManager : public UCollectionBookSubUIBase
{
public:
	int                                                ResultMPFCid;                                             // 0x0090(0x0004)
	int                                                ResultMPFIconIndex;                                       // 0x0094(0x0004)
	TEnumAsByte<ECECompanionGradeType>                 ResultTargetGrade;                                        // 0x0098(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0099(0x0003) MISSED OFFSET
	struct FString                                     ResultTargetName;                                         // 0x009C(0x0010) (AlwaysInit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CB_MonsterBallManager");
		return ptr;
	}


	void SendDoProcess();
	void UISetResultItem();
	void UISetSubMaterialItem();
};


// Class BLGame.CB_MPFSkillChangeManager
// 0x0018 (0x00A8 - 0x0090)
class UCB_MPFSkillChangeManager : public UCollectionBookSubUIBase
{
public:
	int                                                SkilChangeItemSid[0x3];                                   // 0x0090(0x0004)
	int                                                SkilCid[0x3];                                             // 0x009C(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CB_MPFSkillChangeManager");
		return ptr;
	}


	void SendDoProcess();
	void ClickHelpBtn(int InIndex);
	void UISetSubMaterialItem();
};


// Class BLGame.CompanionManager
// 0x017C (0x01DC - 0x0060)
class UCompanionManager : public UObject
{
public:
	struct FMap_Mirror                                 MountList;                                                // 0x0060(0x0048) (Const, Native, Transient)
	struct FMap_Mirror                                 PetDataList;                                              // 0x00A8(0x0048) (Const, Native, Transient)
	struct FMap_Mirror                                 PetUpdatedTimeList;                                       // 0x00F0(0x0048) (Const, Native, Transient)
	float                                              AutoLootingDelayTime;                                     // 0x0138(0x0004) (Transient)
	struct FMap_Mirror                                 FellowDataList;                                           // 0x013C(0x0048) (Const, Native, Transient)
	struct FQWord                                      CurrentSummonMount;                                       // 0x0184(0x0008)
	struct FQWord                                      CurrentSummonPet;                                         // 0x018C(0x0008)
	float                                              CurrentMountConsumeTick;                                  // 0x0194(0x0004)
	float                                              CurrentMountRestoreTick;                                  // 0x0198(0x0004)
	float                                              accumulatedMountGradeUpFailureChance;                     // 0x019C(0x0004)
	float                                              accumulatedPetGradeUpFailureChance;                       // 0x01A0(0x0004)
	float                                              accumulatedFellowGradeUpFailureChance;                    // 0x01A4(0x0004)
	unsigned long                                      bInitGradeUpConstInfo : 1;                                // 0x01A8(0x0004)
	struct FFosterGradeUPConstInfo                     GradeUpConstInfo;                                         // 0x01AC(0x0030) (Const)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.CompanionManager");
		return ptr;
	}


	void ShowAcquireSystemMessage(TEnumAsByte<ECECompanionGradeType> InGrade, const struct FString& InName, TEnumAsByte<EAcquireSystemMsgType> InMsgType);
	void SetFellowLock(const struct FQWord& InUid, bool InLock);
	void SetPetLock(const struct FQWord& InUid, bool InLock);
	void SetMountLock(const struct FQWord& InUid, bool InLock);
	bool IsFellowOperatingMission(const struct FQWord& Uid);
	bool FindFellow(const struct FQWord& InKey, struct FCM_FellowData* OutData);
	void ClearFellow();
	void RemoveFellow(const struct FQWord& Uid);
	void UpdateFellowFatigueList(TArray<struct FCM_FatigueData>* InPetFatigueDataList);
	void UpdateFellowFatigue(const struct FQWord& InFellowUid, float InFatigue);
	void UpdateFellow(struct FCM_FellowData* InValue);
	void UpdateFellowList(TArray<struct FCM_FellowData>* InList);
	bool FindSummonPetData(struct FCM_PetData* OutPetData);
	void SummonPet(bool bSummon, const struct FQWord& Uid);
	void PCRequestSummonPet(class ABlessPC* PC, const struct FQWord& Uid);
	bool FindPetOwnData(const struct FQWord& InPetUid, struct FCM_PetData* OutPetOwnData);
	float GetPetCoolTime(const struct FQWord& InPetUid);
	void RemovePet(const struct FQWord& Uid);
	void UpdatePetActionBar(const struct FQWord& InPetUid);
	void UpdatePetFatigue(const struct FQWord& Uid, int Fatigue);
	void UpdatePetFatigueList(TArray<struct FCM_FatigueData>* InPetFatigueDataList);
	void UpdatePet(struct FCM_PetData* InPetData);
	void UpdatePetList(TArray<struct FCM_PetData>* InPetOwnDataList);
	void UpdateExpFatigueList(TArray<struct FV2MPFFatigue_N_ExpData>* InDataList);
	void UpdateFatigue(TEnumAsByte<ECECompanionType> InCompanionType, const struct FQWord& InUid, int InFatigue);
	void OnSummonMount(bool bMount, const struct FQWord& Uid);
	void PCRequestMount(class ABlessPC* PC, const struct FQWord& Uid);
	bool FindMount(const struct FQWord& InMountUid, struct FCM_MountData* OutMountData);
	void ClearMountList();
	void RemoveMount(const struct FQWord& Uid);
	void UpdateCurrentVehicleGrowthInfo();
	void UpdateMountFatigue(const struct FQWord& Uid, int Fatigue);
	void UpdateMountExp(const struct FQWord& Uid, int Exp);
	void UpdateMount(struct FCM_MountData* InMountData);
	void UpdateMountFatigueList(TArray<struct FCM_FatigueData> InMountFatigueDataList);
	void UpdateMountList(TArray<struct FCM_MountData>* InMountList);
	int GetMountLevel(const struct FQWord& Uid);
	int GetCurrentMountMaxFatigue();
	int GetCurrentMountFatigue();
	void UpdateFavoriteActionBarFatigue(int InUid, int InFatigue, int InMaxFatigue);
	void UpdateCurrentFavoriteActionBarFatigue();
	void UpdateMPFSkill(const struct FQWord& InUid, TEnumAsByte<ECECompanionGradeType> InSkillGradeType, int InSkillCid);
	void UpdateMPFGradeUpParam(const struct FQWord& InUid, TEnumAsByte<ECECompanionType> InCompanionType, int InGradeUpCount, int InItemUsableCount);
};


// Class BLGame.BLItemDesynthesis
// 0x0010 (0x0070 - 0x0060)
class UBLItemDesynthesis : public UObject
{
public:
	int                                                DesynthesisTargetItemSid;                                 // 0x0060(0x0004)
	int                                                DesynthesisItemCount;                                     // 0x0064(0x0004)
	TEnumAsByte<EDesynthesisStep>                      DesynthesisStep;                                          // 0x0068(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0069(0x0003) MISSED OFFSET
	unsigned long                                      bDesynthesis : 1;                                         // 0x006C(0x0004)
	unsigned long                                      bRequestSlots_Normal : 1;                                 // 0x006C(0x0004)
	unsigned long                                      bRequestSlots_Costume : 1;                                // 0x006C(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLItemDesynthesis");
		return ptr;
	}


	void DestroyedInventoryItem(int ItemSid, bool IsDestroyed);
	void DestroyedEquipItem(int ItemSid, bool IsDestroyed);
	void LockInventoryItem(int ItemSid, bool IsLock);
	void LockEquipItem(int ItemSid, bool IsLock);
	bool IsInitInventoryTab(int InTabIndex);
	void RestartDesynthesis();
	void CheckEquipRuneDialog(int ItemCount);
	void StartDesynthesisAction(float CastingTime);
	void SetDesynthesisStep(TEnumAsByte<EDesynthesisStep> InDesynthesisStep);
	void StartDesynthesisResult(TEnumAsByte<EItemDesynthesisResultType> DesynthesisResult);
	void AllClearDesynthesisItem();
	void SetDisableConfirmButton(bool Disable);
	void SetCountDesynthesisItem(int COUNT);
	void ClearTargetDesynthesisItem();
	void SetTargetDesynthesisItem(int TargetSId);
	void SetDisableInventorySlotToDesynthesis();
	void SetDisableEquipSlotToDesynthesis(int TargetSId);
	void OnDesynthesisByNPC();
	void OpenDesynthesisUIByNPC();
	void SetDesynthesisMode(bool IsDesynthesisMode);
};


// Class BLGame.BLItemDurabilityHUD
// 0x0028 (0x0088 - 0x0060)
class UBLItemDurabilityHUD : public UObject
{
public:
	TArray<struct FEquipItemDurabilityHudUIWeaponInfo> WeaponDurabilityHUD;                                      // 0x0060(0x0010) (AlwaysInit, NeedCtorLink)
	TArray<struct FEquipItemDurabilityHudUIArmorInfo>  ArmorDurabilityHUD;                                       // 0x0070(0x0010) (AlwaysInit, NeedCtorLink)
	TEnumAsByte<ECEClassType>                          HUDClassType;                                             // 0x0080(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0081(0x0003) MISSED OFFSET
	unsigned long                                      InitDurabilityHUD : 1;                                    // 0x0084(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLItemDurabilityHUD");
		return ptr;
	}


	void ClearDurabilityHUD();
	void OnUpdateArmorDurabilityGrade(int EquipItemHUDType, int ConditionGrade);
	void OnUpdateWeaponDurabilityGrade(int EquipItemHUDType, int ConditionGrade);
	void UpdateArmorDurability(int ArmorType, int ConditionGrade);
	void UpdateWeaponDurability(int WeaponType, int ConditionGrade);
	void CloseDurabilityHUD();
	void OpenDurabilityHUD();
	void CheckVisibleDurabilityHUD();
	void InitAllCondition(TEnumAsByte<ECEClassType> ClassType);
	void InitEquipmentItemDurabilityHUD(TEnumAsByte<ECEClassType> ClassType);
};


// Class BLGame.BLItemEquipUpgrade
// 0x0034 (0x0094 - 0x0060)
class UBLItemEquipUpgrade : public UObject
{
public:
	int                                                EquipUpgradeTargetItemSid;                                // 0x0060(0x0004)
	int                                                EquipUpgradeMaterialCid;                                  // 0x0064(0x0004)
	TArray<struct FEquipUpgradeSubMaterialInfo>        EquipUpgradeSubMaterialList;                              // 0x0068(0x0010) (AlwaysInit, NeedCtorLink)
	TEnumAsByte<EEquipUpgradeStep>                     EquipUpgradeStep;                                         // 0x0078(0x0001)
	TEnumAsByte<EItemUpgradeLevelResultType>           EquipUpgradeLevelResultType;                              // 0x0079(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x007A(0x0002) MISSED OFFSET
	unsigned long                                      bEquipUpgrading : 1;                                      // 0x007C(0x0004)
	unsigned long                                      bRequestSlots_Normal : 1;                                 // 0x007C(0x0004)
	unsigned long                                      bRequestSlots_Costume : 1;                                // 0x007C(0x0004)
	TArray<struct FStatData>                           BeforeItemStatDataList;                                   // 0x0080(0x0010) (AlwaysInit, NeedCtorLink)
	int                                                UpgreadItemSid;                                           // 0x0090(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLItemEquipUpgrade");
		return ptr;
	}


	void DestroyedInventoryItem(int ItemSid, bool IsDestroyed);
	void DestroyedEquipItem(int ItemSid, bool IsDestroyed);
	void LockInventoryItem(int ItemSid, bool IsLock);
	void LockEquipItem(int ItemSid, bool IsLock);
	void SetEquipUpgradeResultData(TEnumAsByte<EItemUpgradeLevelResultType> InEquipUpgradeLevelResultType, int InUpgreadItemSid);
	void SetEquipUpgradeResult();
	void MakeEquipUpgradeResultParam(class UBLItem* InItemData, TArray<struct FStatData> BeforeItemStatList, TArray<class UGFxObject*>* InStatObjectList);
	class UGFxObject* MakeEquipUpgradeGFxObject(const struct FString& CodeName, int AfterItemStatValue, int BeforeItemStatValue);
	bool IsInitInventoryTab(int InTabIndex);
	void UpdateSubMaterialCheck(int InSubMaterialCid, bool bIsCheck);
	void StopProgressEquipUpgrade();
	void StartProgressEquipUpgrade();
	void SetEquipUpgradeStep(TEnumAsByte<EEquipUpgradeStep> InEquipUpgradeStep);
	void AllClearEquipUpgradeItem();
	void SetEquipUpgradeConfirmButton();
	void SetEquipUpgradeSuccessRate(TEnumAsByte<EEquipUpgradeStep> InEquipUpgradeStep);
	void SetEquipUpgradeNeedGold(TEnumAsByte<EEquipUpgradeStep> InEquipUpgradeStep);
	void ClearSubMaterialEquipUpgradeItem();
	void SetSubMaterialEquipUpgradeItem(struct FEquipUpgradeMaterialInfo* InMaterialInfo);
	void ClearMaterialEquipUpgradeItem();
	void SetMaterialEquipUpgradeItem(struct FUpgradeMaterialInfo* InMaterialInfo);
	void ClearTargetEquipUpgradeItem();
	void RequestSetTargetEquipUpgradeItem();
	void SetTargetEquipUpgradeItem(int TargetSId);
	void SetDisableInventorySlotToUpgrade();
	void OnEquipUpgradeByNPC();
	void OpenEquipUpgradeUIByNPC();
	void SetEquipUpgradeMode(bool IsEquipUpgradeMode);
	struct FEquipUpgradeSubMaterialInfo GetEquipUpgradeSubMaterial(TEnumAsByte<EEquipUpgradeSubMaterialType> InSubMaterialType);
};


// Class BLGame.BLItemEvolution
// 0x0014 (0x0074 - 0x0060)
class UBLItemEvolution : public UObject
{
public:
	int                                                EvolutionTargetItemSid;                                   // 0x0060(0x0004)
	int                                                EvolutionMaterialItemCid;                                 // 0x0064(0x0004)
	TEnumAsByte<EEvolutionStep>                        EvolutionStep;                                            // 0x0068(0x0001)
	TEnumAsByte<EItemEvolutionResultType>              ResultType;                                               // 0x0069(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x006A(0x0002) MISSED OFFSET
	unsigned long                                      bRequestSlots_Normal : 1;                                 // 0x006C(0x0004)
	unsigned long                                      bRequestSlots_Costume : 1;                                // 0x006C(0x0004)
	int                                                EvolutionResultItemSid;                                   // 0x0070(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLItemEvolution");
		return ptr;
	}


	void DestroyedInventoryItem(int ItemSid, bool IsDestroyed);
	void DestroyedEquipItem(int ItemSid, bool IsDestroyed);
	void LockInventoryItem(int ItemSid, bool IsLock);
	void LockEquipItem(int ItemSid, bool IsLock);
	void SetItemEvolutionResult(TEnumAsByte<EItemEvolutionResultType> InresultType, int InEvolutionResultItemSid);
	void OpenItemEvolutionResultUI();
	bool IsInitInventoryTab(int InTabIndex);
	void OpenItemEvolutionDialog();
	void SetDisableConfirmButton();
	void SetEvolutionStep(TEnumAsByte<EEvolutionStep> InEvolutionStep);
	void AllClearEvolutionItem();
	void SetRequirementEvolutionItem(class UBLItem* InTargetItem, int MaterialSid);
	void SetTargetEvolutionItem(int TargetSId);
	void SetDisabledInventorySlotToEvolution();
	void SetDisabledEquipSlotToEvolution();
	void OnEvolutionEquipItemsByNPC();
	void OpenEvolutionUIByNPC();
	void SetEvolutionMode(bool IsEvolutionMode);
};


// Class BLGame.BLItemRecover
// 0x001C (0x007C - 0x0060)
class UBLItemRecover : public UObject
{
public:
	int                                                RecoverTargetItemSid;                                     // 0x0060(0x0004)
	TArray<int>                                        RecoverMaterialItemSidList;                               // 0x0064(0x0010) (AlwaysInit, NeedCtorLink)
	TEnumAsByte<ERecoverStep>                          RecoverStep;                                              // 0x0074(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0075(0x0003) MISSED OFFSET
	unsigned long                                      bRequestSlots : 1;                                        // 0x0078(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLItemRecover");
		return ptr;
	}


	void DestroyedInventoryItem(int ItemSid, bool IsDestroyed);
	void DestroyedEquipItem(int ItemSid, bool IsDestroyed);
	void LockInventoryItem(int ItemSid, bool IsLock);
	void LockEquipItem(int ItemSid, bool IsLock);
	void SetRecoverStep(TEnumAsByte<ERecoverStep> InRecoverStep);
	void AllClearRecoverItem();
	void SetRecoverProgressBar(TEnumAsByte<ERecoverStep> InRecoverStep);
	void ClearMaterialRecoverItem(bool IsAll, int SlotIndex);
	void SetMaterialRecoverItem(int MaterialSid, int SlotIndex);
	void SetMaterialRecoverItemSwap(int InSrcSlotIndex, const struct FString& InSrcSid, int InDestSlotIndex, const struct FString& InDestSid);
	void SetMaterialRecoverItemChoiceSlotIndex(int MaterialSid, int SlotIndex);
	void SetMaterialRecoverItemSequential(int MaterialSid);
	void ClearTargetRecoverItem();
	void SetTargetRecoverItem(int TargetSId);
	void SetDestroyedInventorySlotToRecover(TEnumAsByte<ERecoverStep> InRecoverStep);
	void SetDestroyedEquipSlotToRecover();
	void OnRecoverEquipItemsByNPC();
	void OpenRecoverUIByNPC();
	void SetRecoverMode(bool IsRecoverMode);
};


// Class BLGame.BLItemRepair
// 0x0020 (0x0080 - 0x0060)
class UBLItemRepair : public UObject
{
public:
	float                                              RepairWeight;                                             // 0x0060(0x0004)
	TArray<struct FRepairEquipInfo>                    RepairEquipmentList;                                      // 0x0064(0x0010) (AlwaysInit, NeedCtorLink)
	struct FRepairToolInfo                             RepairToolData;                                           // 0x0074(0x0008)
	unsigned long                                      bOpenRepairDialog : 1;                                    // 0x007C(0x0004)
	unsigned long                                      bRequestSlots : 1;                                        // 0x007C(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLItemRepair");
		return ptr;
	}


	void DestroyedInventoryItem(int ItemSid, bool IsDestroyed);
	void DestroyedEquipItem(int ItemSid, bool IsDestroyed);
	void LockInventoryItem(int ItemSid, bool IsLock);
	void LockEquipItem(int ItemSid, bool IsLock);
	void SetEquipRepairAllString();
	void CloseSplitItemRepairDialog();
	void CloseRepairCostDialog();
	TEnumAsByte<EItemUseEffectType> GetRepairToolType(int InRepairToolCid);
	void ClearRepairToolAmountData();
	void SetRepairToolData(int RepairToolCid);
	void ClearRepairEquipmentList();
	void CtrlLButtonRepairAction(class UBLItem* InRepairItem);
	void LButtonRepairAction(TArray<struct FRepairEquipInfo>* RepairEquipItemList);
	int GetRepaireCost_CollectRepairEquip(TArray<struct FRepairEquipInfo> InRepairEquipInfo);
	void MakeRepairCost_Dialog(int Cost);
	void RequestDestroyedSlotToRepair();
	void SetDestroyedInventorySlotToRepairMax();
	void SetDestroyedEquipSlotToRepairMax();
	void SetDestroyedInventorySlotToRepair();
	void SetDestroyedEquipSlotToRepair();
	void GetRepairEquipItems(TArray<struct FRepairEquipInfo>* InRepairEquipInfo);
	void OnRepairEquipItemsByItem(int RepairToolAmount);
	void OnRepairEquipItemsByNPC();
	void RequestItemRepairMode();
	void OpenRepairUIByItem(int RepairToolCid);
	void OpenRepairUIByNPC(float SuccessRate, float Weight);
	void SetItemRepairMode(bool IsRepairMode);
	void SetNPCRepairMode(bool IsRepairMode);
};


// Class BLGame.BLItemSucceed
// 0x002C (0x008C - 0x0060)
class UBLItemSucceed : public UObject
{
public:
	int                                                SucceedTargetItemSid;                                     // 0x0060(0x0004)
	int                                                SucceedSourceItemSid;                                     // 0x0064(0x0004)
	int                                                SucceedMaterialCid;                                       // 0x0068(0x0004)
	TArray<struct FSucceedSubMaterialInfo>             SucceedSubMaterialList;                                   // 0x006C(0x0010) (AlwaysInit, NeedCtorLink)
	TEnumAsByte<ESucceedStep>                          SucceedStep;                                              // 0x007C(0x0001)
	TEnumAsByte<EItemSucceedResultType>                SucceedResultType;                                        // 0x007D(0x0001)
	unsigned char                                      UnknownData00[0x2];                                       // 0x007E(0x0002) MISSED OFFSET
	int                                                PreSourceItemUpgradeLevel;                                // 0x0080(0x0004)
	unsigned long                                      bRequestSlots_Normal : 1;                                 // 0x0084(0x0004)
	unsigned long                                      bRequestSlots_Costume : 1;                                // 0x0084(0x0004)
	int                                                SucceedItemSid;                                           // 0x0088(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLItemSucceed");
		return ptr;
	}


	void DestroyedInventoryItem(int ItemSid, bool IsDestroyed);
	void DestroyedEquipItem(int ItemSid, bool IsDestroyed);
	void LockInventoryItem(int ItemSid, bool IsLock);
	void LockEquipItem(int ItemSid, bool IsLock);
	void SetSucceedResultData(TEnumAsByte<EItemSucceedResultType> InSucceedResultType, int InSucceedItemSid);
	void SetSucceedResult();
	bool IsInitInventoryTab(int InTabIndex);
	void OpenItemSucceedDialog();
	int GetSucceedMainMaterialNeedCount();
	void UpdateSubMaterialCheck(TEnumAsByte<ESucceedSubMaterialType> SubMaterialType, bool bIsCheck);
	void SetSucceedStep(TEnumAsByte<EEquipUpgradeStep> InEquipUpgradeStep);
	void AllClearSucceedItem();
	void SetSucceedConfirmButton();
	void ClearSubMaterialSucceedItem();
	void SetSubMaterialSucceedItem();
	void ClearMaterialSucceedItem();
	void SetMaterialSucceedItem();
	void SetExpectSucceedItem();
	void ClearSourceSucceedItem();
	void SetSourceSucceedItem(int SourceSid);
	void ClearTargetSucceedItem();
	void SetTargetSucceedItem(int TargetSId);
	void SetDisableInventorySlotToSucceed(TEnumAsByte<ESucceedStep> InSucceedStep);
	void OnSucceedByNPC();
	void OpenSucceedUIByNPC();
	void SetSucceedMode(bool IsSucceedMode);
	struct FSucceedSubMaterialInfo GetSucceedSubMaterial(TEnumAsByte<ESucceedSubMaterialType> InSubMaterialType);
};


// Class BLGame.LobbyCharacterStateBase
// 0x0000 (0x0060 - 0x0060)
class ULobbyCharacterStateBase : public UObject
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.LobbyCharacterStateBase");
		return ptr;
	}


	struct FString GetCharacterSelectMatineeName(TEnumAsByte<ECERaceType> InRaceType);
	void OnMatineeLevelLoaded();
	void CreateLobbyPawn(const struct FName& InPlayerStartName, bool bCastDynamicShadow, bool bCastStaticShadow, bool bSelfShadowOnly, bool bOnePassLightingOnTranslucency, bool bApplyForcedLODLevel, class ABLPlayer** NewPawn);
	void GetPCDefaultEquipItems(const struct FPCInfoKey& InPCInfoKey, TArray<struct FEquipedItemData>* OutEquipItems);
	void GetCustomizingEquipedItems(const struct FPCInfoKey& InPCInfoKey, TArray<struct FEquipedItemData>* OutEquipItems);
	void SetLobbyCamera();
	void UnCacheCustomizeData();
	void CacheCustomizeData();
	class ABLPawn* GetCustomizingTarget();
	void Tick(float InDeltaTime);
	void UpdatePawnRotationBtnVisible();
	void End();
	void SetupCharacter();
	void Start();
	class APlayerController* GetPC();
	class UBlessLocalPlayer* GetLP();
};


// Class BLGame.LobbyCharacterCustomize
// 0x000C (0x006C - 0x0060)
class ULobbyCharacterCustomize : public ULobbyCharacterStateBase
{
public:
	TEnumAsByte<ECustomizeActionScriptMenuEnum>        CurrentSubMenu;                                           // 0x0060(0x0001)
	TEnumAsByte<ECustomizeActionScriptMenuEnum>        CurrentLargeCategory;                                     // 0x0061(0x0001)
	TEnumAsByte<ECECustomizingUIModeType>              CustomizingUIMode;                                        // 0x0062(0x0001)
	unsigned char                                      UnknownData00[0x1];                                       // 0x0063(0x0001) MISSED OFFSET
	unsigned long                                      bCustomizingUIDetailMode : 1;                             // 0x0064(0x0004)
	unsigned long                                      bEquipCustomizingItems : 1;                               // 0x0064(0x0004)
	unsigned long                                      bIsClosedEyeCustomingPawn : 1;                            // 0x0064(0x0004)
	int                                                CustomizingCameraLevel;                                   // 0x0068(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.LobbyCharacterCustomize");
		return ptr;
	}


	void SetVoiceUI();
	void ResetCustomizeInSubMenu(TEnumAsByte<ECustomizeActionScriptMenuEnum> InSubMenuUIEnum);
	void ResetAllCustomizing();
	void SetCustomizingDetailMode(bool InIsDetailMode);
	void OnSelectedCustomizingSubMenu(TEnumAsByte<ECustomizeActionScriptMenuEnum> InSubMenuEnum);
	TEnumAsByte<ECECustomizingUIModeType> ToCustomizingUIMode(TEnumAsByte<ECustomizeActionScriptMenuEnum> InLargeCategory);
	void CustomizingCamera(bool bCustomizingMode, bool bImmediately);
	void OpenEyeCustomizingPawn();
	void CloseEyeCustomizingPawn();
	void InitUI();
	void EquipCustomizingItems(bool bEquip);
	void UpdateCustomizingPawnAnim();
	void ChangeAppearanceType(TEnumAsByte<ECEAppearanceType> AppearanceType);
	void SetLobbyCamera();
	void LoadTemporaryCustomizeFile();
	void RemoveTemporaryCustomizeFile();
	void CheckTemporaryCustomizeFile();
	void UpdatePawnRotationBtnVisible();
	void End();
	void SetupCharacter();
	void Start();
};


// Class BLGame.LobbyLoading
// 0x0004 (0x0064 - 0x0060)
class ULobbyLoading : public ULobbyCharacterStateBase
{
public:
	unsigned long                                      bIsLoadingComplete : 1;                                   // 0x0060(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.LobbyLoading");
		return ptr;
	}


	void Tick(float InDeltaTime);
	void SetLobbyCamera();
	void End();
	void Start();
};


// Class BLGame.LobbySelectCharacter
// 0x0014 (0x0074 - 0x0060)
class ULobbySelectCharacter : public ULobbyCharacterStateBase
{
public:
	unsigned long                                      bUseMatinee : 1;                                          // 0x0060(0x0004)
	struct FString                                     CurrentEventName;                                         // 0x0064(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.LobbySelectCharacter");
		return ptr;
	}


	void PlayRemoteEvent();
	void OnMatineeLevelLoaded();
	void SetLobbyCamera();
	void End();
	void SetupCharacter();
	void Start();
};


// Class BLGame.LobbySelectGenderRaceJob
// 0x0000 (0x0060 - 0x0060)
class ULobbySelectGenderRaceJob : public ULobbyCharacterStateBase
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.LobbySelectGenderRaceJob");
		return ptr;
	}


	void InitUI();
	void End();
	void SetupCharacter();
	void Start();
};


// Class BLGame.LobbySelectGenderRaceJobCinematic
// 0x0014 (0x0074 - 0x0060)
class ULobbySelectGenderRaceJobCinematic : public ULobbySelectGenderRaceJob
{
public:
	struct FString                                     CurrentEventName;                                         // 0x0060(0x0010) (NeedCtorLink)
	unsigned long                                      IsLevelLoaded : 1;                                        // 0x0070(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.LobbySelectGenderRaceJobCinematic");
		return ptr;
	}


	void PlayRemoteEventSetCharacter();
	void OnMatineeLevelLoaded();
	void PlayRemoteEvent();
	void StopRemoteEvent();
	struct FString GetRemoteEventName(TEnumAsByte<ECERaceType> InRaceType, TEnumAsByte<ECEGenderType> InGenderType, TEnumAsByte<ECEClassType> InClassType);
	void End();
	void SetupCharacter();
	void Start();
};


// Class BLGame.LobbySetName
// 0x0014 (0x0074 - 0x0060)
class ULobbySetName : public ULobbyCharacterStateBase
{
public:
	unsigned long                                      bUseMatinee : 1;                                          // 0x0060(0x0004)
	struct FString                                     CurrentEventName;                                         // 0x0064(0x0010) (NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.LobbySetName");
		return ptr;
	}


	void SetVoiceUI();
	void PlayRemoteEvent();
	void OnMatineeLevelLoaded();
	void SetLobbyCamera();
	void End();
	void SetupCharacter();
	void Start();
};


// Class BLGame.LobbyManager
// 0x0088 (0x00E8 - 0x0060)
class ULobbyManager : public UObject
{
public:
	TEnumAsByte<ELobbyState>                           CurrentLobbyState;                                        // 0x0060(0x0001) (Transient)
	TEnumAsByte<ELobbyState>                           PendedLobbyState;                                         // 0x0061(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x2];                                       // 0x0062(0x0002) MISSED OFFSET
	int                                                PendedUIState;                                            // 0x0064(0x0004) (Transient)
	class ULobbyCharacterStateBase*                    LobbyCharacterState;                                      // 0x0068(0x0008) (Transient)
	int                                                UIState;                                                  // 0x0070(0x0004) (Transient)
	struct FLobbyProperties                            LobbyPropertiesContainer;                                 // 0x0074(0x0050) (Transient, NeedCtorLink)
	unsigned long                                      bStartLobbyCharacterCustomizingCache : 1;                 // 0x00C4(0x0004)
	unsigned long                                      IsRequesteEnterAppearanceChange : 1;                      // 0x00C4(0x0004) (Transient)
	float                                              IntroTime;                                                // 0x00C8(0x0004) (Transient)
	float                                              IntroTimeLimit;                                           // 0x00CC(0x0004) (Transient)
	float                                              TimeCounter_1Sec;                                         // 0x00D0(0x0004) (Transient)
	float                                              Time_1Sec;                                                // 0x00D4(0x0004) (Transient)
	int                                                PrevDay;                                                  // 0x00D8(0x0004) (Transient)
	int                                                PrevHour;                                                 // 0x00DC(0x0004) (Transient)
	int                                                PrevMin;                                                  // 0x00E0(0x0004) (Transient)
	int                                                PrevSec;                                                  // 0x00E4(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.LobbyManager");
		return ptr;
	}


	void OnSelectedRealmFromUI(TEnumAsByte<ECERealmType> InRealmType);
	void ResetCustomizeInSubMenu(TEnumAsByte<ECustomizeActionScriptMenuEnum> InSubMenuUIEnum);
	void ResetAllCustomizing();
	void ClearDefaultCustomizeData();
	void SetDefaultCustomizeData(struct FCustomizeData* InData);
	void EnableMovingPrevState();
	void PlaceOnGroundLobbyPawn();
	void SetVoiceData(TEnumAsByte<ECERaceType> InRaceType, TEnumAsByte<ECEGenderType> InGenderType, int InVoiceType, float InVoicePitch);
	void InitVoiceData(TEnumAsByte<ECERaceType> InRaceType, TEnumAsByte<ECEGenderType> InGenderType);
	void NextClick(int InNextUIState);
	void CompleteChangeAppearance(TArray<struct FSelectPCData> PCDataList, const struct FString& PlayerName);
	void SetCustomizingDetailMode(bool InIsDetailMode);
	void OnSelectedCustomizingSubMenu(TEnumAsByte<ECustomizeActionScriptMenuEnum> InSubMenuEnum);
	void LoadTemporaryCustomizeFile();
	void RemoveTemporaryCustomizeFile();
	void OpenEyeCustomizingPawn();
	void CloseEyeCustomizingPawn();
	void EquipCustomizingItems(bool bEquip);
	void ChangeAppearanceType(TEnumAsByte<ECEAppearanceType> AppearanceType);
	bool IsCinematicLevelLoaded();
	void PlayRemoteEventSetCharacter();
	void OnMatineeEnded();
	void OnMatineeLevelLoaded();
	void SetRaceGenderJobForCharacterCreating(TEnumAsByte<ECERaceType> InRaceType, TEnumAsByte<ECEGenderType> InGenderType, TEnumAsByte<ECEClassType> InClassType);
	void LobbySelect(int InIndex);
	void LobbyCS();
	void UpdatePawnRotationBtnVisible();
	float GetIntroTimeLimit();
	void StartLogin();
	void LoginIntro_End();
	void LobbyIntro(bool DisableUI);
	void LobbyLogin();
	void LobbyOpening();
	bool SetPrevPageOnChangeAppearanceGender();
	bool SetNextPageOnChangeAppearanceGender();
	void CacheLobbyCustomizingResource();
	void CancelEscapeAppearanceChange();
	void EscapeAppearanceChange(const struct FString& InName);
	void OpenDialogEscapeAppearanceChange(const struct FString& InName);
	void EnterAppearanceChange();
	void ExpireAppearanceItem(int InIndex);
	void UpdateAppearanceChangeLabel(TEnumAsByte<ELookChangeType> InType, int InDay, int InHour, int InMinute, int InSeconds);
	void UpdateAppearanceChangeButton(TEnumAsByte<ELookChangeType> InType);
	void UpdateAppearanceChangeInfo();
	void StartCharacterCustomizingCache();
	int GetSelectedCharacterIndex();
	void SetSelectedCharacterIndex(int InIndex);
	void SetLastCharacterIndex();
	TEnumAsByte<ELobbyState> GetLobbyState();
	void ChangeState(TEnumAsByte<ELobbyState> InLobbyState);
	void Tick(float InDeltaTime);
	void OnFinishUIState(int InUIState);
	void OnStartUIState(int InUIState);
	class ULobbyManager* STATIC_GetLobbyManager();
	void Init(class UBLGameEngine* InGameEngine);
	class APlayerController* GetPC();
	class UBlessLocalPlayer* GetLP();
};


// Class BLGame.BLMissionManager
// 0x0040 (0x00A0 - 0x0060)
class UBLMissionManager : public UObject
{
public:
	TArray<struct FBLMissionTabData>                   TabList;                                                  // 0x0060(0x0010) (Transient, NeedCtorLink)
	int                                                CurrentUnlockedLevel;                                     // 0x0070(0x0004) (Transient)
	int                                                SelectedMissionLevel;                                     // 0x0074(0x0004) (Transient)
	int                                                SelectedMissionStage;                                     // 0x0078(0x0004) (Transient)
	int                                                TicketCount;                                              // 0x007C(0x0004) (Transient)
	int                                                MaxTicketCount;                                           // 0x0080(0x0004) (Transient)
	int                                                ResetTime;                                                // 0x0084(0x0004) (Transient)
	int                                                CurrentTicketUse;                                         // 0x0088(0x0004) (Transient)
	struct FColor                                      MissionStatRank1st;                                       // 0x008C(0x0004) (Config)
	struct FColor                                      MissionStatRank2nd;                                       // 0x0090(0x0004) (Config)
	struct FColor                                      MissionStatRank3rd;                                       // 0x0094(0x0004) (Config)
	struct FColor                                      MissionStatRankOther;                                     // 0x0098(0x0004) (Config)
	struct FColor                                      MissionStatRankNone;                                      // 0x009C(0x0004) (Config)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLMissionManager");
		return ptr;
	}


	void UpdateMissionOpener();
	void CS_RequestReward(int InMissionTabLevel);
	void CS_RequestMissionAssign(int InMissionTabLevel);
	void CS_SwapFellowSlot(int InFromMissionCid, int InFromSlot, int InToMissionCid, int InToSlot);
	void CS_UnregistFellowToMission(int InStageIndex, int InSlotIndex);
	void CS_RegistFellowToMission(const struct FQWord& InFellowUid, int InStageIndex, int InSlotIndex);
	void SC_UpdateUnlockLevel(int InLevel);
	void SC_ReceiveReward();
	void SC_UpdateMissionTabState(int InTabIndex, TEnumAsByte<EV2MissionTabState> InServerState);
	void SC_UpdateMissionTicket(int InTicket);
	void SC_UpdateMissionDataList(TArray<struct FV2MissionLevelTabInfo>* InServerTabList, TArray<struct FBLMissionData>* InList);
	void SC_UpdateMissionData(struct FBLMissionData* InData);
	void UpdateUI_MissionOpenerCount();
	void UpdateUI_MissionButton();
	void UpdateUI_MissionStageList();
	void UpdateUI_MissionTabList();
	void UpdateUI_MissionTab(int InTabIndex, bool InAnimPlay);
	void UpdateUI_MissionTitle();
	TEnumAsByte<EBLMissionState> GetFellowMissionState(const struct FQWord& InFellowUid);
	TEnumAsByte<EBLMissionTabState> GetFellowMissionTabState(const struct FQWord& InFellowUid);
	void OnClickButton();
	void UpdateUnlockTabState(int InTabIndex);
	void SetTabState(int InTabIndex, TEnumAsByte<EV2MissionTabState> InServerState);
	void SelectTab(int InIndex);
	void SetCurrentUnlockedLevel(int InLevel, bool InUnlockAnim);
	struct FQWord SetFellowToMission(int InFellowUid, int InMissionTab, int InMissionCID, int InSlotIndex);
	void Initialize();
};


// Class BLGame.BLTimerComponent
// 0x0048 (0x00B8 - 0x0070)
class UBLTimerComponent : public UComponent
{
public:
	TArray<struct FBLTimerData>                        Timers;                                                   // 0x0070(0x0010) (NeedCtorLink)
	class UObject*                                     Owner;                                                    // 0x0080(0x0008)
	struct FScriptDelegate                             __OnUpdateCountUpTimer__Delegate;                         // 0x0088(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData00[0x4];                                       // 0x0088(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY
	struct FScriptDelegate                             __OnUpdateCountDownTimer__Delegate;                       // 0x0098(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData01[0x4];                                       // 0x0098(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY
	struct FScriptDelegate                             __OnEndTimer__Delegate;                                   // 0x00A8(0x000C) (NeedCtorLink)
	unsigned char                                      UnknownData02[0x4];                                       // 0x00A8(0x0004) FIX WRONG TYPE SIZE OF PREVIOUS PROPERTY

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLTimerComponent");
		return ptr;
	}


	void ClearTimer(class UObject* InTargetObj, const struct FName& InFuncName, const struct FName& InEndFuncName);
	void SetCountDownTimerRepeatable(float InDuration, float InRate, class UObject* InTargetObj, const struct FName& InFuncName, const struct FName& InEndFuncName);
	void SetCountUpTimerRepeatable(float InElapsedTime, float InRate, class UObject* InTargetObj, const struct FName& InFuncName);
	void SetTimer(float InRate, class UObject* InTargetObj, const struct FName& InEndFuncName);
	void Tick(float InDeltaTime);
	void OnEndTimer();
	void OnUpdateCountDownTimer(float InRemainTime, float InDuration);
	void OnUpdateCountUpTimer(float InElapsedTime);
};


// Class BLGame.BSM_Skill_Custom
// 0x0000 (0x01D4 - 0x01D4)
class UBSM_Skill_Custom : public UBSM_Skill_Tool
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_Skill_Custom");
		return ptr;
	}

};


// Class BLGame.BSM_Skill_Taming
// 0x001C (0x01F0 - 0x01D4)
class UBSM_Skill_Taming : public UBSM_Skill_Custom
{
public:
	unsigned long                                      bRotateToTarget : 1;                                      // 0x01D4(0x0004) (Transient)
	float                                              SkillTime;                                                // 0x01D8(0x0004) (Transient)
	float                                              ProgressTime;                                             // 0x01DC(0x0004) (Transient)
	TArray<struct FTamingProgress>                     Progress;                                                 // 0x01E0(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_Skill_Taming");
		return ptr;
	}


	void OnApplyMoment(int InKey);
	void SetTamingResult(bool IsSuccess);
	void Tick(float a_DeltaTime);
	void CancelSpecialMove();
	void SpecialMoveEnded(const struct FName& PrevMove, const struct FName& NextMove);
	void SpecialMoveStarted(bool bForced, const struct FName& PrevMove);
	int GetNpcTamedIconIndex(const struct FNPCInfoData& RefInfo);
	void SetBroadway(class UBroadwayGameInfo* InBroadway, float InSkillTime, float InOriginalSkillTime, const struct FVector& InTargetLocation, int InSelectedTargetPawnID);
	void SetProgressData(float InSkillTime);
};


// Class BLGame.BSM_RuneSynthesize_Casting
// 0x0000 (0x0144 - 0x0144)
class UBSM_RuneSynthesize_Casting : public UBSM_Base
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_RuneSynthesize_Casting");
		return ptr;
	}


	void CancelSpecialMove();
	void SpecialMoveEnded(const struct FName& PrevMove, const struct FName& NextMove);
	bool PlaySequence(struct FSeqPlayInfo* a_Info);
	void SetBroadway(class UBroadwayGameInfo* InBroadway);
};


// Class BLGame.AttackActionComponent
// 0x0000 (0x0070 - 0x0070)
class UAttackActionComponent : public UPawnComponent
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.AttackActionComponent");
		return ptr;
	}

};


// Class BLGame.BLAnimNotify_SpecialMove
// 0x0008 (0x006C - 0x0064)
class UBLAnimNotify_SpecialMove : public UAnimNotify_Scripted
{
public:
	struct FName                                       Info;                                                     // 0x0064(0x0008) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNotify_SpecialMove");
		return ptr;
	}


	void NotifyEnd(class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator);
	void Notify(class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator);
};


// Class BLGame.BLAnimNotify_AnimationChainOutPoint
// 0x0000 (0x006C - 0x006C)
class UBLAnimNotify_AnimationChainOutPoint : public UBLAnimNotify_SpecialMove
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNotify_AnimationChainOutPoint");
		return ptr;
	}

};


// Class BLGame.BLAnimNotify_AnimationChainPoint
// 0x0000 (0x006C - 0x006C)
class UBLAnimNotify_AnimationChainPoint : public UBLAnimNotify_SpecialMove
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNotify_AnimationChainPoint");
		return ptr;
	}

};


// Class BLGame.BLAnimNotify_EnclosedMoveTime
// 0x0000 (0x006C - 0x006C)
class UBLAnimNotify_EnclosedMoveTime : public UBLAnimNotify_SpecialMove
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNotify_EnclosedMoveTime");
		return ptr;
	}

};


// Class BLGame.BLAnimNotify_InputEnabledTime
// 0x0000 (0x006C - 0x006C)
class UBLAnimNotify_InputEnabledTime : public UBLAnimNotify_SpecialMove
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLAnimNotify_InputEnabledTime");
		return ptr;
	}

};


// Class BLGame.BLBasicPopulationManager
// 0x0000 (0x034C - 0x034C)
class ABLBasicPopulationManager : public AGameCrowdPopulationManager
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLBasicPopulationManager");
		return ptr;
	}


	void OnBasicCrowdSpawner(class UBLSeqAct_BasicCrowdSpawner* inAction);
};


// Class BLGame.BLSeqAct_BasicCrowdSpawner
// 0x0000 (0x019C - 0x019C)
class UBLSeqAct_BasicCrowdSpawner : public USeqAct_GameCrowdSpawner
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLSeqAct_BasicCrowdSpawner");
		return ptr;
	}

};


// Class BLGame.BLCamera_CutIn
// 0x0000 (0x0260 - 0x0260)
class ABLCamera_CutIn : public ASceneCapture2DActor
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLCamera_CutIn");
		return ptr;
	}

};


// Class BLGame.BLCameraActor
// 0x0000 (0x0508 - 0x0508)
class ABLCameraActor : public ACameraActor
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLCameraActor");
		return ptr;
	}


	void PostBeginPlay();
};


// Class BLGame.BSM_RC_Hitup
// 0x0014 (0x01D4 - 0x01C0)
class UBSM_RC_Hitup : public UBSM_RC_Base
{
public:
	class UBLInterpCurveData*                          HitUpCurveData;                                           // 0x01C0(0x0008)
	float                                              HeightFromLand;                                           // 0x01C8(0x0004) (Transient)
	float                                              FlightTime;                                               // 0x01CC(0x0004) (Transient)
	unsigned long                                      testOn : 1;                                               // 0x01D0(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_RC_Hitup");
		return ptr;
	}


	void OnUpdateState(float DeltaTime);
	float GetOffset(float inTime);
	void SpecialMoveEnded(const struct FName& PrevMove, const struct FName& NextMove);
	void SpecialMoveStarted(bool bForced, const struct FName& PrevMove);
};


// Class BLGame.BLCheatManagerInLobby
// 0x0000 (0x0080 - 0x0080)
class UBLCheatManagerInLobby : public UCheatManager
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLCheatManagerInLobby");
		return ptr;
	}


	void TestInputDialog();
	void ForceUIGC();
	void UIDebug(bool bVisible);
	void ToggleUIPlayer();
	void ReloadUIPlayer();
	void CloseUIPlayer();
	void PrintUI();
	void UnLoadUI(const struct FString& UIName);
	void LoadUI(const struct FString& UIName);
	void RealmData();
	void SubtractRealm(int InRealm, int InRace, int InClass, int InGender);
	void AddRealm(int InRealm, int InRace, int InClass, int InGender);
	void TestDialog(int Step);
};


// Class BLGame.BLConsole
// 0x0004 (0x0274 - 0x0270)
class UBLConsole : public UConsole
{
public:
	unsigned long                                      DefaultBehavior : 1;                                      // 0x0270(0x0004) (Transient)
	unsigned long                                      CtrlPressed : 1;                                          // 0x0270(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLConsole");
		return ptr;
	}


	bool InputKey(int ControllerId, const struct FName& Key, TEnumAsByte<EInputEvent> Event, float AmountDepressed, bool bGamepad);
	void Initialized();
};


// Class BLGame.BLContentDB
// 0x0000 (0x0060 - 0x0060)
class UBLContentDB : public UObject
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLContentDB");
		return ptr;
	}

};


// Class BLGame.BLDamageType
// 0x000C (0x009C - 0x0090)
class UBLDamageType : public UDamageType
{
public:
	float                                              HitReactionTimeScale;                                     // 0x0090(0x0004) (Const)
	class UClass*                                      ImpactLightClass;                                         // 0x0094(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLDamageType");
		return ptr;
	}

};


// Class BLGame.BLImpactLight
// 0x0000 (0x0270 - 0x0270)
class UBLImpactLight : public UUDKExplosionLight
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLImpactLight");
		return ptr;
	}

};


// Class BLGame.BLDevGFxUITeleportBookMark_Clik
// 0x00BC (0x015C - 0x00A0)
class UBLDevGFxUITeleportBookMark_Clik : public UGFxObject
{
public:
	class UGFxClikWidget*                              BookListView;                                             // 0x00A0(0x0008)
	class UGFxClikWidget*                              TabBar;                                                   // 0x00A8(0x0008)
	class UGFxClikWidget*                              BtnAdd;                                                   // 0x00B0(0x0008)
	class UGFxClikWidget*                              BtnDel;                                                   // 0x00B8(0x0008)
	class UGFxClikWidget*                              AddBoard;                                                 // 0x00C0(0x0008)
	class UGFxClikWidget*                              BtnAutoCB;                                                // 0x00C8(0x0008)
	class UGFxClikWidget*                              TxtNameInput;                                             // 0x00D0(0x0008)
	class UGFxClikWidget*                              TxtLocationX;                                             // 0x00D8(0x0008)
	class UGFxClikWidget*                              TxtLocationY;                                             // 0x00E0(0x0008)
	class UGFxClikWidget*                              TxtLocationZ;                                             // 0x00E8(0x0008)
	class UGFxClikWidget*                              TxtDescInput;                                             // 0x00F0(0x0008)
	class UGFxClikWidget*                              BtnAddOK;                                                 // 0x00F8(0x0008)
	class UGFxClikWidget*                              BtnAddCancel;                                             // 0x0100(0x0008)
	class UGFxClikWidget*                              BtnClose;                                                 // 0x0108(0x0008)
	class UGFxClikWidget*                              DelBoard;                                                 // 0x0110(0x0008)
	class UGFxClikWidget*                              TxtName;                                                  // 0x0118(0x0008)
	class UGFxClikWidget*                              TxtDelLocationX;                                          // 0x0120(0x0008)
	class UGFxClikWidget*                              TxtDelLocationY;                                          // 0x0128(0x0008)
	class UGFxClikWidget*                              TxtDelLocationZ;                                          // 0x0130(0x0008)
	class UGFxClikWidget*                              TxtDesc;                                                  // 0x0138(0x0008)
	class UGFxClikWidget*                              BtnDelOK;                                                 // 0x0140(0x0008)
	class UGFxClikWidget*                              BtnDelCancel;                                             // 0x0148(0x0008)
	class UBLDevGFxUIPlayer*                           UIPlayer;                                                 // 0x0150(0x0008)
	int                                                TabSelectedIndex;                                         // 0x0158(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLDevGFxUITeleportBookMark_Clik");
		return ptr;
	}


	void OnActivated();
	void SetDelBoardText();
	bool IsTextInput(class UGFxObject* InTarget);
	void SetLocationInputEnabled(bool bEnabled);
	void SetTeleportBookEnabled(bool bEnabled);
	class UGFxClikWidget* GetDelBoard();
	class UGFxClikWidget* GetAddBoard();
	void OnDelCancel(const struct FEventData& ev);
	void OnDelOK(const struct FEventData& ev);
	void OnTeleportBookClose(const struct FEventData& ev);
	void OnTeleportBookMarkListChange(const struct FEventData& ev);
	void OnTeleportBookMarkDoubleClick(const struct FEventData& ev);
	void OnAutoSaveCheckBox(const struct FEventData& ev);
	void OnAddCancel(const struct FEventData& ev);
	void OnAddOK(const struct FEventData& ev);
	void OnDelBoardOpen(const struct FEventData& ev);
	void OnAddBoardOpen(const struct FEventData& ev);
	void UAListDataProvider();
	void UATabDataProvider();
	struct FString GetBookMarkLabel(const struct FTeleportBookMark& inBookMark);
	class UGFxObject* GetBookMarkData(const struct FTeleportBookMark& inBookMark);
	void UpdateBookMarkData(int Type);
	void SetButtunActivate(bool bActivate);
	void OnTabIndexChange(const struct FEventData& ev);
	void SetTeleportBookMarkTabNames();
	bool WidgetInitialized(const struct FName& WidgetName, const struct FName& WidgetPath, class UGFxObject* Widget);
};


// Class BLGame.BLDevGFxUITeleportBookMark
// 0x0000 (0x00A0 - 0x00A0)
class UBLDevGFxUITeleportBookMark : public UGFxObject
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLDevGFxUITeleportBookMark");
		return ptr;
	}


	void UAListDataChange(int TabIndex);
};


// Class BLGame.TeleportBookMarkLocal
// 0x0000 (0x0084 - 0x0084)
class UTeleportBookMarkLocal : public UTeleportBookMarkCommon
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.TeleportBookMarkLocal");
		return ptr;
	}

};


// Class BLGame.BlessCamera
// 0x0000 (0x0D4C - 0x0D4C)
class ABlessCamera : public ABLCamera
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BlessCamera");
		return ptr;
	}

};


// Class BLGame.GFxUI_CharInfo
// 0x0018 (0x00C8 - 0x00B0)
class UGFxUI_CharInfo : public UGFxObjectBase
{
public:
	unsigned long                                      IsInit : 1;                                               // 0x00B0(0x0004)
	TArray<struct FParameterMapping>                   ParameterMappings;                                        // 0x00B4(0x0010) (NeedCtorLink)
	int                                                PreGearScore;                                             // 0x00C4(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.GFxUI_CharInfo");
		return ptr;
	}


	void ListParamDataList();
	void UA_Refresh_UI(const struct FString& PCName, const struct FString& PcLevel, const struct FString& RankName, int RankWeeklyGainedExp, const struct FString& RankWeeklyExpectingRank, const struct FString& PcClass, int PCRace, int PCGender, int PCConceptStatID, const struct FString& FightRecord, int GearScore);
	void UA_Set_Equip_BtnLevel_Disable(bool bDisable);
	struct FString ConvertGearScoreString(int InGearScore);
	void UpdateDataProvider(bool bForce);
	void OnUpdateComplete();
	void OnUpdateData();
	bool IsType(TArray<TEnumAsByte<ECEParamType>> Target, TEnumAsByte<ECEParamType> InType);
	void OnSingleUpdateParams(struct FParamData* InParamData);
	struct FString GetToolTipString(TEnumAsByte<ECEClassType> InClass, const struct FString& InParamName, const struct FString& InSubSction);
	void Toggle();
	void InitUpdateHandler();
	void Init(class UBLUIPlayer* Player);
};


// Class BLGame.BLNetHandler
// 0x0000 (0x018C - 0x018C)
class UBLNetHandler : public UBLNetHandlerBase
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLNetHandler");
		return ptr;
	}


	void SC_NOTIFY_EXCHANGE_ITEM_COUNT_REP(int ExchangeItemCount);
	void SC_NOTIFY_GIFTBOX_COUNT_REP(int InGiftBoxCount);
	void SC_UNREGISTER_ALL_DUNGEON_PARTY_MATCHING_REP();
	void SC_REFRESH_DUNGEON_PARTY_MATCHING_UI_ACK(TEnumAsByte<EDungeonPartyMatchingErrorCode> InErrCode, int IndungeonCId, TArray<struct FDungeonPartyMatchingData>* IndungeonPartyMatchingDataList);
	void SC_OPEN_DUNGEON_PARTY_MATCHING_UI_ACK(TEnumAsByte<EDungeonPartyMatchingErrorCode> InErrCode, int IndungeonCId, TArray<struct FDungeonPartyMatchingData>* IndungeonPartyMatchingDataList);
	void SC_UNREGISTER_DUNGEON_PARTY_MATCHING_ACK(TEnumAsByte<EDungeonPartyMatchingErrorCode> InErrorCode, int IndungeonCId);
	void SC_REGISTER_DUNGEON_PARTY_MATCHING_ACK(TEnumAsByte<EDungeonPartyMatchingErrorCode> InErrorCode, int IndungeonCId);
	void SC_COLOSSEUM_SCORE_REP(int InUnionWinCount, int InHieronWinCount, TArray<struct FColosseumScoreData>* InUnionScoreDataList, TArray<struct FColosseumScoreData>* InHieronScoreDataList);
	void SC_EXITED_FROM_COLOSSEUM_REP();
	void SC_END_COLOSSEUM_REP(int InColosseum_cid, TEnumAsByte<EEColosseumResultType> InresultType, const struct FQWord& InExpire_time);
	void SC_UPDATE_BATTLE_CONDITION_REP(int InColosseum_cid, int InUnion_count, int InHieron_count);
	void SC_UPDATE_CONFIRM_REGISTER_COLOSSEUM_REP(int InColosseum_cid, struct FColosseumConfirmRegisterInfo* Incolosseum_register_info);
	void SC_RESTART_WAIT_COLOSSEUM_REP(int InColosseum_cid, const struct FQWord& InStart_time);
	void SC_START_COLOSSEUM_REP(int InColosseum_cid, int InUnion_count, int InHieron_count, const struct FQWord& InExpire_time);
	void SC_ENTER_COLOSSEUM_REP(int InColosseum_cid, const struct FQWord& InStart_time, TArray<struct FString>* Inunion_member_name, TArray<struct FString>* Inhieron_member_name);
	void SC_FAIL_ENTER_COLOSSEUM_REP(int InColosseum_cid, const struct FQWord& InExpire_time);
	void SC_CONFIRM_REGISTER_COLOSSEUM_ACK(bool InSuccess, int InColosseum_cid, bool InisWaitingStage);
	void SC_START_CONFIRM_REGISTER_COLOSSEUM_REP(int InColosseum_cid, struct FColosseumConfirmRegisterInfo* Incolosseum_register_info);
	void SC_UPDATE_COLOSSEUM_WAITCOUNT_REP(int InColosseum_cid, int Inwait_count);
	void SC_CANCELED_REGISTER_COLOSSEUM_REP(int InColosseum_cid, bool Inreturned_queue);
	void SC_REGISTERED_PARTY_COLOSSEUM_REP(int InColosseum_cid, int wait_count);
	void SC_REGISTER_COLOSSEUM_REP(bool InSuccess, int InColosseum_cid, int Inwait_count);
	void SC_REGISTER_COLOSSEUM_ACK(bool InSuccess, int InColosseum_cid, int Inwait_count);
	void SC_END_V2CRAFT_REP();
	void SC_PROGRESS_V2CRAFT_REP(int InCraftCId, int InCurrentIndex, int InMaxIndex, int IncastingTimeInMilliSeconds);
	void SC_MAKE_V2CRAFT_ACK(bool InbSuccess);
	void SC_END_CRAFT_REP();
	void SC_PROGRESS_CRAFT_REP(int InCraftCId, int InCurrentIndex, int InMaxIndex, int IncastingTimeInMilliSeconds);
	void SC_MAKE_CRAFT_ACK(bool InbSuccess);
	void SC_END_NPC_CRAFT_REP();
	void SC_PROGRESS_NPC_CRAFT_REP(int InCraftCId, int InCurrentIndex, int InMaxIndex);
	void SC_MAKE_NPC_CRAFT_ACK(bool InbSuccess);
	void SC_OPEN_NPC_CRAFT_UI_REP(int InactorSId);
	void SC_OPEN_UI_REP(TEnumAsByte<ECEOpenUIType> InUIType);
	void SC_SKILL_AUTO_FIRING_NOTIFY_REP(int InSkillCid);
	void SC_SUGGEST_FIELD_CHANNEL_REP(int InChannelID, struct FString* InOtherPlayerName);
	void SC_WORLD_INOUT_REP(int InplayerSId, TEnumAsByte<ECEWorldMapType> InWorldMapType, int InworldMapWrapperCId, bool InIsEnter);
	void SC_FIELD_CHANNEL_TRANSFER_RESULT_REP(int InChannelID, bool Success, int RemainTimeInMilliseconds);
	void SC_FIELD_CHANNEL_LIST_ACK(TArray<struct FFieldChannelInfo>* InFieldChannelInfoList);
	void SC_FIELD_CHANNEL_NOTIFY_REP(int InChannelID);
	void SC_WAYPOINT_TIME_REP(int Inplayer_sid, struct FWaypointProgressInfo* InWaypointInfo);
	void SC_PARTY_MEMBER_POS_REP(int InPartyID, TArray<struct FPartyMemberPosData>* InPosDataList);
	void SC_TALK_END_ACK(int InNpcID, TEnumAsByte<ETalkEndType> InEndType);
	void SC_TALK_CHOOSE_SELECTION_ACK(int InNpcID, int InsecondaryNpcId, struct FTalkDialogInfo* InDialogInfo);
	void SC_TALK_START_REP(int InNpcID, int InsecondaryNpcId, struct FTalkDialogInfo* InDialogInfo);
	void SC_UPDATE_PARAM_STATE_REP(int InSid, TEnumAsByte<EParamStatusUpdateType> InType, int InValue);
	void SC_POSE_ACTION_ACK(TEnumAsByte<ECEStatePoseType> InStatePose, bool InStandingForce, bool InSuccess);
	void SC_POSE_ACTION_CANCELED_REP(int InSid, TEnumAsByte<ECEStatePoseType> InStatePose);
	void SC_POSE_ACTION_REP(int InSid, TEnumAsByte<ECEStatePoseType> InStatePose, bool InStandingForce);
	void SC_DROP_QUEST_ACK(int InQuestID);
	void SC_UPDATE_QUEST_INFO_REP(struct FQuestProgressInfo* InquestInfo);
	void SC_REWARD_QUEST_ACK(int InQuestID);
	void SC_GET_QUEST_ACK(int InQuestID);
	void SC_UPDATE_COMBAT_FLAIR_DATA_REP(int PlayerSid, TArray<struct FCombatFlairData>* InDataList);
	void SC_INITIAL_PAWN_PARAM_REP(int InPawnSID, TArray<struct FParamData>* InDataList);
	void SC_UPDATE_PARAM_REP(int InPawnSID, struct FParamData* InParamData);
	void SC_UPDATE_PARAM_LIST_REP(int InPawnSID, TArray<struct FParamData>* InParamDataList);
	void SC_BROADCAST_UPDATE_LEVEL_REP(int InSid, struct FPawnParamData* InPawnParamData);
	void SC_UPDATE_LEVEL_REP(int InSidRPC, struct FPawnParam* InprevPawnParam, struct FPawnParam* InpawnParam);
	void SC_UPDATE_PARTYMEMBER_ABNORMAL_STATUS_REP(int InPartyMemberSid, struct FAbnormalStatusData* InData);
	void SC_MOVE_PARTY_MEMBER_REP(int InPartyID, int InSlotIndex, int InNewIndex);
	void SC_LOGOUT_PARTY_MEMBER_REP(int InPartyID, int InMemberSID, int InmemberSlotIndex);
	void SC_LOGIN_PARTY_MEMBER_REP(int InPartyID, int InPrevSID, struct FPartyMemberPCData* InMemberData);
	void SC_REMOVE_PARTY_MEMBER_REP(int InPartyID, int InMemberSID, int InmemberSlotIndex);
	void SC_ADD_PARTY_MEMBER_REP(int InPartyID, struct FPartyMemberPCData* InMemberData);
	void SC_UPDATE_PARTY_DATA_REP(int InPartyID, int InLeaderSID, TEnumAsByte<EPartyDistributeMethod> InDistributeMethod, int InDistributorID);
	void SC_DELETE_PARTY_REP(int InPartyID);
	void SC_CREATE_PARTY_REP(struct FPartyData* InPartyData);
	void SC_ACQUIRE_ITEM_REP(TArray<struct FInventoryItemData>* InacquireItemList);
	void SC_REMOVE_INVEN_ITEM_ACK(struct FInventoryItemData* InNewItemData);
	void SC_MOVE_INVEN_ITEM_ACK(TArray<struct FInventoryItemData>* InItemDataListArray);
	void SC_UPDATE_ITEM_DATA_LIST_REP(TArray<struct FInventoryItemData>* InupdatedItemDataList);
	void SC_REMOVE_EQUIP_ITEM_REP(TEnumAsByte<ECEEquipSlotType> InSlotId);
	void SC_TAKEOFF_SLOT_ITEM_ACK(TEnumAsByte<EItemEquipErrorCode> InErrorCode, TArray<struct FInventoryItemData>* InItemDataListArray);
	void SC_EQUIP_INVEN_ITEM_ACK(TEnumAsByte<EItemEquipErrorCode> InErrorCode, TArray<struct FInventoryItemData>* InItemDataListArray);
	void GetEquipAndUnEquipItemList(TArray<struct FInventoryItemData> InItemDataListArray, TArray<struct FInventoryItemData>* EquipItemList, TArray<struct FInventoryItemData>* UnEquipItemList);
	void PlayUnEquipSound(class ABLPlayer* PlayerPawn, TArray<struct FInventoryItemData> InItemDataListArray);
	void PlayEquipSound(class ABLPlayer* PlayerPawn, TArray<struct FInventoryItemData> InItemDataListArray);
	void SC_SELECT_PC_DATA_LIST_ACK(int InCharacterSlotExpansionCount, TArray<struct FSelectPCData>* InSelectPCDataArray);
	void SC_REMOVE_PC_ACK(TArray<struct FSelectPCData>* InPCDataList);
	void SC_CREATE_PC_ACK_FAILED(int InErrorCode, struct FString* InForbidString);
	void SC_CREATE_PC_ACK(bool InCanDirectEnterWorld, bool CanDirectTutorial, TArray<struct FSelectPCData>* InPCDataList);
};


// Class BLGame.BSM_Craft_Casting
// 0x0000 (0x0144 - 0x0144)
class UBSM_Craft_Casting : public UBSM_Base
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_Craft_Casting");
		return ptr;
	}


	void CancelSpecialMove();
	void SpecialMoveEnded(const struct FName& PrevMove, const struct FName& NextMove);
	bool PlaySequence(struct FSeqPlayInfo* a_Info);
	void SetBroadway(class UBroadwayGameInfo* InBroadway);
};


// Class BLGame.BLSpawnableEmitter
// 0x0000 (0x0264 - 0x0264)
class ABLSpawnableEmitter : public AEmitter
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLSpawnableEmitter");
		return ptr;
	}

};


// Class BLGame.BlessFlyMountPC
// 0x0000 (0x09FC - 0x09FC)
class ABlessFlyMountPC : public ABlessPC
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BlessFlyMountPC");
		return ptr;
	}

};


// Class BLGame.BLFireDamageType
// 0x0000 (0x009C - 0x009C)
class UBLFireDamageType : public UBLDamageType
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLFireDamageType");
		return ptr;
	}

};


// Class BLGame.BLFireImpactLight
// 0x0000 (0x0270 - 0x0270)
class UBLFireImpactLight : public UBLImpactLight
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLFireImpactLight");
		return ptr;
	}

};


// Class BLGame.BLGame
// 0x0000 (0x0060 - 0x0060)
class UBLGame : public UObject
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLGame");
		return ptr;
	}

};


// Class BLGame.BLGameTestCrowdAgent
// 0x0000 (0x0584 - 0x0584)
class ABLGameTestCrowdAgent : public AGameCrowdAgentSkeletal
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLGameTestCrowdAgent");
		return ptr;
	}

};


// Class BLGame.BLIceDamageType
// 0x0000 (0x009C - 0x009C)
class UBLIceDamageType : public UBLDamageType
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLIceDamageType");
		return ptr;
	}

};


// Class BLGame.BLIceImpactLight
// 0x0000 (0x0270 - 0x0270)
class UBLIceImpactLight : public UBLImpactLight
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLIceImpactLight");
		return ptr;
	}

};


// Class BLGame.PawnOutLineComponent
// 0x0044 (0x00B4 - 0x0070)
class UPawnOutLineComponent : public UPawnComponent
{
public:
	unsigned long                                      bDisableOutLine : 1;                                      // 0x0070(0x0004) (Config)
	struct FColor                                      PropMouseOverColor;                                       // 0x0074(0x0004) (Config)
	struct FColor                                      FriendlyPawnMouseOverColor;                               // 0x0078(0x0004) (Config)
	struct FColor                                      DefensivePawnMouseOverColor;                              // 0x007C(0x0004) (Config)
	struct FColor                                      AggressivePawnMouseOverColor;                             // 0x0080(0x0004) (Config)
	struct FColor                                      StoryQuesteColor;                                         // 0x0084(0x0004) (Config)
	struct FColor                                      EpisodeQuestColor;                                        // 0x0088(0x0004) (Config)
	struct FColor                                      OwnerFocusColor;                                          // 0x008C(0x0004) (Config)
	struct FColor                                      TargetFocusColor;                                         // 0x0090(0x0004) (Config)
	TArray<struct FOutLineActiveInfo>                  PawnOutLineStack;                                         // 0x0094(0x0010) (Transient, NeedCtorLink)
	TArray<struct FColor>                              OutLineColorInfos;                                        // 0x00A4(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PawnOutLineComponent");
		return ptr;
	}


	void DeactivateOutLine();
	void ActivateOutLine(TEnumAsByte<EPawnOutLineColorType> ColorType);
	void HideOutLine(TEnumAsByte<EPawnOutLineType> OutLineType);
	void ShowOutLine(TEnumAsByte<EPawnOutLineType> OutLineType, TEnumAsByte<EPawnOutLineColorType> OutLineColorType);
	int InsertOutLineInfo(const struct FOutLineActiveInfo& Info);
	int FindOutLineType(TEnumAsByte<EPawnOutLineType> OutLineType);
	void ClearAllOutLine();
};


// Class BLGame.BSM_SA_DeathAction
// 0x0004 (0x0148 - 0x0144)
class UBSM_SA_DeathAction : public UBSM_Base
{
public:
	float                                              AccumTime;                                                // 0x0144(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_SA_DeathAction");
		return ptr;
	}


	void BS_AnimEndNotify(const struct FName& AnimSeqName, int InAnimSeqKey, float PlayedTime, float ExcessTime);
	void SpecialMoveEnded(const struct FName& PrevMove, const struct FName& NextMove);
	bool PlaySequence(struct FSeqPlayInfo* a_Info);
	void SpecialMoveStarted(bool bForced, const struct FName& PrevMove);
	bool CanOverrideMoveWith(const struct FName& NewMove);
	bool InternalCanDoSpecialMove();
};


// Class BLGame.BSM_SA_Death
// 0x0008 (0x0150 - 0x0148)
class UBSM_SA_Death : public UBSM_SA_DeathAction
{
public:
	int                                                DeathStartPitch;                                          // 0x0148(0x0004) (Transient)
	float                                              DeathAnimLength;                                          // 0x014C(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_SA_Death");
		return ptr;
	}


	void BS_AnimEndNotify(const struct FName& AnimSeqName, int InAnimSeqKey, float PlayedTime, float ExcessTime);
	void SpecialMoveSkipped(bool bIsCauseFromExternalFactor, const struct FName& CurrentSpecialMove);
	void Tick(float DeltaTime);
	void SpecialMoveStarted(bool bForced, const struct FName& PrevMove);
};


// Class BLGame.BSM_SA_DeadBody
// 0x0000 (0x0148 - 0x0148)
class UBSM_SA_DeadBody : public UBSM_SA_DeathAction
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_SA_DeadBody");
		return ptr;
	}


	void SpecialMoveStarted(bool bForced, const struct FName& PrevMove);
};


// Class BLGame.BSM_SA_DeadBodyDespawn
// 0x000C (0x0154 - 0x0148)
class UBSM_SA_DeadBodyDespawn : public UBSM_SA_DeathAction
{
public:
	class UBroadwayInfo*                               DespawnBroadway;                                          // 0x0148(0x0008) (Transient)
	float                                              DespawnAnimLength;                                        // 0x0150(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_SA_DeadBodyDespawn");
		return ptr;
	}


	void SpecialMoveEnded(const struct FName& PrevMove, const struct FName& NextMove);
	void Tick(float DeltaTime);
	void SpecialMoveStarted(bool bForced, const struct FName& PrevMove);
};


// Class BLGame.BSM_SA_DownDeadBody
// 0x0000 (0x0148 - 0x0148)
class UBSM_SA_DownDeadBody : public UBSM_SA_DeathAction
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_SA_DownDeadBody");
		return ptr;
	}


	bool PlaySequence(struct FSeqPlayInfo* a_Info);
	void SpecialMoveStarted(bool bForced, const struct FName& PrevMove);
};


// Class BLGame.BSM_SA_Revive
// 0x0008 (0x014C - 0x0144)
class UBSM_SA_Revive : public UBSM_Base
{
public:
	class UBSM_SA_ReviveParameter*                     ReviveParameter;                                          // 0x0144(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_SA_Revive");
		return ptr;
	}


	void SpecialMoveEnded(const struct FName& PrevMove, const struct FName& NextMove);
	void Tick(float DeltaTime);
	bool PlaySequence(struct FSeqPlayInfo* a_Info);
	void SpecialMoveStarted(bool bForced, const struct FName& PrevMove);
	void SetSpecialMoveParameter(class UBSM_BaseParameter* InSMParam);
	bool CanOverrideMoveWith(const struct FName& NewMove);
};


// Class BLGame.BSM_PhaseAction
// 0x0030 (0x0174 - 0x0144)
class UBSM_PhaseAction : public UBSM_Base
{
public:
	TArray<struct FPhaseActionData>                    PhaseActionSequence;                                      // 0x0144(0x0010) (NeedCtorLink)
	TArray<struct FPhaseSeqPlayInfo>                   SeqPlayInfoList;                                          // 0x0154(0x0010) (NeedCtorLink)
	int                                                CurrentPhaseIndex;                                        // 0x0164(0x0004) (Transient)
	float                                              CurrentPhaseDuration;                                     // 0x0168(0x0004) (Transient)
	float                                              AccumTime;                                                // 0x016C(0x0004) (Transient)
	unsigned long                                      MoveStarted : 1;                                          // 0x0170(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_PhaseAction");
		return ptr;
	}


	void OnPhaseChanged(int PrevPhaseIndex, int NextPhaseIndex);
	void ChangePhase(int NextPhaseIndex, bool bInForceChange);
	void ChangePhaseByType(int PhaseType);
	int GetPhaseIndex(int PhaseType);
	bool IsCurrentPhase(int InPhase);
	void OnUpdatePhase(float DeltaTime);
	void Tick(float DeltaTime);
	bool PlayPhaseSequence(struct FPhaseSeqPlayInfo* a_PhaseSeqInfo);
	void ChangeNextPhase();
	void BS_AnimEndNotify(const struct FName& AnimSeqName, int InAnimSeqKey, float PlayedTime, float ExcessTime);
	void SpecialMoveStarted(bool bForced, const struct FName& PrevMove);
};


// Class BLGame.BSM_SA_SitDown
// 0x0000 (0x0174 - 0x0174)
class UBSM_SA_SitDown : public UBSM_PhaseAction
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_SA_SitDown");
		return ptr;
	}


	bool IsAllowIK(TEnumAsByte<EEffectiveIK> IKIndex);
	void ForceUpdatePhase();
	void StandUp(bool a_bImmediately);
	void SpecialMoveEnded(const struct FName& PrevMove, const struct FName& NextMove);
	void SpecialMoveStarted(bool bForced, const struct FName& PrevMove);
};


// Class BLGame.BSM_SA_Loot
// 0x0008 (0x017C - 0x0174)
class UBSM_SA_Loot : public UBSM_PhaseAction
{
public:
	unsigned long                                      bCastingStarted : 1;                                      // 0x0174(0x0004) (Transient)
	float                                              StartAnimSequenceLength;                                  // 0x0178(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_SA_Loot");
		return ptr;
	}


	void Tick(float a_DeltaTime);
	void StandUp(bool a_bImmediately);
	void SpecialMoveEnded(const struct FName& PrevMove, const struct FName& NextMove);
	void SpecialMoveStarted(bool bForced, const struct FName& PrevMove);
	bool CanOverrideMoveWith(const struct FName& NewMove);
};


// Class BLGame.BSM_SA_Carry
// 0x0010 (0x0184 - 0x0174)
class UBSM_SA_Carry : public UBSM_PhaseAction
{
public:
	class UBSM_CarryParameter*                         CarryParameter;                                           // 0x0174(0x0008) (Transient)
	struct FName                                       BakIdleName;                                              // 0x017C(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_SA_Carry");
		return ptr;
	}


	void BS_AnimEndNotify(const struct FName& AnimSeqName, int InAnimSeqKey, float PlayedTime, float ExcessTime);
	void OnPhaseChanged(int PrevPhaseIndex, int NextPhaseIndex);
	bool PlayPhaseSequence(struct FPhaseSeqPlayInfo* a_PhaseSeqInfo);
	void PutDown();
	void SpecialMoveEnded(const struct FName& PrevMove, const struct FName& NextMove);
	void SpecialMoveStarted(bool bForced, const struct FName& PrevMove);
	bool CanOverrideMoveWith(const struct FName& NewMove);
	void SetSpecialMoveParameter(class UBSM_BaseParameter* InSMParam);
};


// Class BLGame.BSM_RC_Push
// 0x0000 (0x01C0 - 0x01C0)
class UBSM_RC_Push : public UBSM_RC_Base
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_RC_Push");
		return ptr;
	}

};


// Class BLGame.BSM_RC_Pull
// 0x0000 (0x01C0 - 0x01C0)
class UBSM_RC_Pull : public UBSM_RC_Base
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_RC_Pull");
		return ptr;
	}

};


// Class BLGame.BSM_RC_Down
// 0x0000 (0x01C0 - 0x01C0)
class UBSM_RC_Down : public UBSM_RC_Base
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_RC_Down");
		return ptr;
	}

};


// Class BLGame.BSM_RC_GetUp
// 0x0000 (0x01C0 - 0x01C0)
class UBSM_RC_GetUp : public UBSM_RC_Base
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_RC_GetUp");
		return ptr;
	}

};


// Class BLGame.BSM_Sheathe
// 0x0000 (0x0144 - 0x0144)
class UBSM_Sheathe : public UBSM_Base
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_Sheathe");
		return ptr;
	}


	bool IsAllowIK(TEnumAsByte<EEffectiveIK> IKIndex);
	void SpecialMoveEnded(const struct FName& PrevMove, const struct FName& NextMove);
	void SpecialMoveSkipped(bool bIsCauseFromExternalFactor, const struct FName& CurrentSpecialMove);
	void SpecialMoveStarted(bool bForced, const struct FName& PrevMove);
};


// Class BLGame.BSM_Unsheathe
// 0x0004 (0x0148 - 0x0144)
class UBSM_Unsheathe : public UBSM_Base
{
public:
	unsigned long                                      bPeacefulPosture : 1;                                     // 0x0144(0x0004) (Transient)
	unsigned long                                      bAnimPlayed : 1;                                          // 0x0144(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_Unsheathe");
		return ptr;
	}


	bool IsAllowIK(TEnumAsByte<EEffectiveIK> IKIndex);
	void SpecialMoveEnded(const struct FName& PrevMove, const struct FName& NextMove);
	void BS_AnimEndNotify(const struct FName& AnimSeqName, int InAnimSeqKey, float PlayedTime, float ExcessTime);
	void SpecialMoveSkipped(bool bIsCauseFromExternalFactor, const struct FName& CurrentSpecialMove);
	void Tick(float DeltaTime);
	void SpecialMoveStarted(bool bForced, const struct FName& PrevMove);
};


// Class BLGame.BSM_Skill_Attack
// 0x0000 (0x01D4 - 0x01D4)
class UBSM_Skill_Attack : public UBSM_Skill_Tool
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_Skill_Attack");
		return ptr;
	}


	void SpecialMoveEnded(const struct FName& PrevMove, const struct FName& NextMove);
	void SetBroadway(class UBroadwayGameInfo* InBroadway, float InSkillTime, float InOriginalSkillTime, const struct FVector& InTargetLocation, int InSelectedTargetPawnID);
};


// Class BLGame.BSM_Skill_Casting
// 0x0004 (0x01D8 - 0x01D4)
class UBSM_Skill_Casting : public UBSM_Skill_Tool
{
public:
	unsigned long                                      bRotateToTarget : 1;                                      // 0x01D4(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_Skill_Casting");
		return ptr;
	}


	void Tick(float a_DeltaTime);
	void CancelSpecialMove();
	void SpecialMoveEnded(const struct FName& PrevMove, const struct FName& NextMove);
	void SetBroadway(class UBroadwayGameInfo* InBroadway, float InSkillTime, float InOriginalSkillTime, const struct FVector& InTargetLocation, int InSelectedTargetPawnID);
};


// Class BLGame.BSM_MountAttackMove
// 0x0060 (0x01D8 - 0x0178)
class UBSM_MountAttackMove : public UBSM_BasicMove
{
public:
	class UBSM_MountAttackMoveParameter*               MountAttackMoveParameter;                                 // 0x0178(0x0008) (Transient)
	TEnumAsByte<EMountAttackMovePhase>                 MovePhase;                                                // 0x0180(0x0001)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0181(0x0003) MISSED OFFSET
	struct FVector                                     TraceDestination;                                         // 0x0184(0x000C) (Transient)
	float                                              TraceDistance;                                            // 0x0190(0x0004) (Transient)
	class ABLVehiclePawn*                              VehiclePawn;                                              // 0x0194(0x0008) (Transient)
	class ABlessPC*                                    CurrentController;                                        // 0x019C(0x0008) (Transient)
	float                                              OldAccelRate;                                             // 0x01A4(0x0004) (Transient)
	float                                              OldAirSpeed;                                              // 0x01A8(0x0004) (Transient)
	float                                              OldFOV;                                                   // 0x01AC(0x0004) (Transient)
	float                                              TraceMoveTimeout;                                         // 0x01B0(0x0004) (Transient)
	float                                              TraceRemainMoveTimeout;                                   // 0x01B4(0x0004) (Transient)
	float                                              AttackMoveTimeout;                                        // 0x01B8(0x0004) (Transient)
	float                                              CurrentPhaseTime;                                         // 0x01BC(0x0004) (Transient)
	struct FRotator                                    TraceRotation;                                            // 0x01C0(0x000C) (Transient)
	class UParticleSystemComponent*                    VehicleTraceEffectInstance;                               // 0x01CC(0x0008) (ExportObject, Component, EditInline)
	unsigned long                                      bInterpolateFOV : 1;                                      // 0x01D4(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_MountAttackMove");
		return ptr;
	}


	void SpecialMoveEnded(const struct FName& PrevMove, const struct FName& NextMove);
	void OnParticleSystemFinished(class UParticleSystemComponent* InPSC);
	void BS_AnimEndNotify(const struct FName& AnimSeqName, int InAnimSeqKey, float PlayedTime, float ExcessTime);
	void AnimNotify(class UAnimNodeSequence* SeqNode, class UBLAnimNotify_SpecialMove* NotifyObject);
	void StartUnMount();
	void Tick(float DeltaTime);
	void SetRadialBlurEffect();
	void SetupStartEffect();
	void SpecialMoveStarted(bool bForced, const struct FName& PrevMove);
	bool IsNeedToBlockMovement();
	bool InternalCanDoSpecialMove();
	bool CanOverrideMoveWith(const struct FName& NewMove);
	void SetSpecialMoveParameter(class UBSM_BaseParameter* InSMParam);
};


// Class BLGame.BSM_SocialAction
// 0x0000 (0x0144 - 0x0144)
class UBSM_SocialAction : public UBSM_Base
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_SocialAction");
		return ptr;
	}


	void BS_AnimEndNotify(const struct FName& AnimSeqName, int InAnimSeqKey, float PlayedTime, float ExcessTime);
	void SpecialMoveSkipped(bool bIsCauseFromExternalFactor, const struct FName& CurrentSpecialMove);
	void SpecialMoveEnded(const struct FName& PrevMove, const struct FName& NextMove);
	bool PlaySequence(struct FSeqPlayInfo* a_Info);
	void SpecialMoveStarted(bool bForced, const struct FName& PrevMove);
	bool CanOverrideMoveWith(const struct FName& NewMove);
};


// Class BLGame.BSM_NpcTalk
// 0x0008 (0x014C - 0x0144)
class UBSM_NpcTalk : public UBSM_Base
{
public:
	class UBSM_NpcTalkParameter*                       TalkParameter;                                            // 0x0144(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_NpcTalk");
		return ptr;
	}


	void SpecialMoveSkipped(bool bIsCauseFromExternalFactor, const struct FName& CurrentSpecialMove);
	void SpecialMoveEnded(const struct FName& PrevMove, const struct FName& NextMove);
	bool PlaySequence(struct FSeqPlayInfo* a_Info);
	void SpecialMoveStarted(bool bForced, const struct FName& PrevMove);
	void SetSpecialMoveParameter(class UBSM_BaseParameter* InSMParam);
	bool CanOverrideMoveWith(const struct FName& NewMove);
};


// Class BLGame.BSM_NpcInteraction
// 0x0008 (0x014C - 0x0144)
class UBSM_NpcInteraction : public UBSM_Base
{
public:
	class UBSM_NpcInteractionParameter*                NpcInteractionParameter;                                  // 0x0144(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_NpcInteraction");
		return ptr;
	}


	void BS_AnimEndNotify(const struct FName& AnimSeqName, int InAnimSeqKey, float PlayedTime, float ExcessTime);
	void SpecialMoveEnded(const struct FName& PrevMove, const struct FName& NextMove);
	bool PlayApproachAnimation(struct FSeqPlayInfo* seqInfo);
	void SpecialMoveStarted(bool bForced, const struct FName& PrevMove);
	bool CanOverrideMoveWith(const struct FName& NewMove);
	bool CanOverrideSpecialMove(const struct FName& InMove);
	void SetSpecialMoveParameter(class UBSM_BaseParameter* InSMParam);
};


// Class BLGame.BSM_NpcDisposableAction
// 0x000C (0x0150 - 0x0144)
class UBSM_NpcDisposableAction : public UBSM_Base
{
public:
	class UBSM_NpcDisposableActionParameter*           NpcDisposableActionParameter;                             // 0x0144(0x0008) (Transient)
	float                                              PlayTime;                                                 // 0x014C(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_NpcDisposableAction");
		return ptr;
	}


	void BS_AnimEndNotify(const struct FName& AnimSeqName, int InAnimSeqKey, float PlayedTime, float ExcessTime);
	void SpecialMoveEnded(const struct FName& PrevMove, const struct FName& NextMove);
	void Tick(float DeltaTime);
	bool PlaySequence(struct FSeqPlayInfo* a_Info);
	void SpecialMoveStarted(bool bForced, const struct FName& PrevMove);
	bool CanOverrideMoveWith(const struct FName& NewMove);
	void SetSpecialMoveParameter(class UBSM_BaseParameter* InSMParam);
};


// Class BLGame.BSM_Skill_Charging
// 0x0000 (0x01D8 - 0x01D8)
class UBSM_Skill_Charging : public UBSM_Skill_Casting
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_Skill_Charging");
		return ptr;
	}

};


// Class BLGame.BSM_NpcMountSpecialAction
// 0x0004 (0x0148 - 0x0144)
class UBSM_NpcMountSpecialAction : public UBSM_Base
{
public:
	float                                              SpecialAnimPlayTime;                                      // 0x0144(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_NpcMountSpecialAction");
		return ptr;
	}


	void BS_AnimEndNotify(const struct FName& AnimSeqName, int InAnimSeqKey, float PlayedTime, float ExcessTime);
	void SpecialMoveEnded(const struct FName& PrevMove, const struct FName& NextMove);
	void Tick(float DeltaTime);
	bool PlaySpecial();
	void SpecialMoveStarted(bool bForced, const struct FName& PrevMove);
	bool CanOverrideMoveWith(const struct FName& NewMove);
	bool CanOverrideSpecialMove(const struct FName& InMove);
};


// Class BLGame.BSM_Mount_Skill
// 0x0000 (0x01D4 - 0x01D4)
class UBSM_Mount_Skill : public UBSM_Skill_Tool
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_Mount_Skill");
		return ptr;
	}


	void SpecialMoveEnded(const struct FName& PrevMove, const struct FName& NextMove);
	void SetTwoBroadway(class UBroadwayGameInfo* InFirstBroadway, class UBroadwayGameInfo* InSecondBroadway, float InSkillTime, float InSkillOriginalTime, const struct FVector& InTargetLocation, int InSelectedTargetPawnID);
	void SetBroadway(class UBroadwayGameInfo* InBroadway, float InSkillTime, float InSkillOriginalTime, const struct FVector& InTargetLocation, int InSelectedTargetPawnID);
	bool PlayDriverSequence(struct FSeqPlayInfo* a_Info);
	bool CanOverrideMoveWith(const struct FName& NewMove);
};


// Class BLGame.BSM_Skill_Flash
// 0x0022 (0x01F6 - 0x01D4)
class UBSM_Skill_Flash : public UBSM_Skill_Custom
{
public:
	class UBroadwayGameInfo*                           SecondBroadway;                                           // 0x01D4(0x0008) (Transient)
	float                                              SkillTime;                                                // 0x01DC(0x0004) (Transient)
	float                                              SkillOriginalTime;                                        // 0x01E0(0x0004) (Transient)
	struct FVector                                     DestLocation;                                             // 0x01E4(0x000C) (Transient)
	int                                                SelectedTargetPawnID;                                     // 0x01F0(0x0004) (Transient)
	TEnumAsByte<ECESkillRushType>                      RushType;                                                 // 0x01F4(0x0001) (Transient)
	TEnumAsByte<EFlashStepType>                        CurrentStep;                                              // 0x01F5(0x0001) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_Skill_Flash");
		return ptr;
	}


	void BS_AnimEndNotify(const struct FName& AnimSeqName, int InAnimSeqKey, float PlayedTime, float ExcessTime);
	void SetTwoBroadway(class UBroadwayGameInfo* InFirstBroadway, class UBroadwayGameInfo* InSecondBroadway, float InSkillTime, float InSkillOriginalTime, const struct FVector& InTargetLocation, int InSelectedTargetPawnID);
	void CancelSpecialMove();
	void EndSM(const struct FName& SpecialMoveToEnd);
};


// Class BLGame.BSM_Gathering
// 0x0000 (0x0144 - 0x0144)
class UBSM_Gathering : public UBSM_Base
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_Gathering");
		return ptr;
	}


	void CancelSpecialMove();
	void SpecialMoveEnded(const struct FName& PrevMove, const struct FName& NextMove);
	bool PlaySequence(struct FSeqPlayInfo* a_Info);
	void SetBroadway(class UBroadwayGameInfo* InBroadway);
};


// Class BLGame.NameTagUIPlayer
// 0x0008 (0x01EC - 0x01E4)
class UNameTagUIPlayer : public UGFxMoviePlayer
{
public:
	class UGFxUI_NameTagObject*                        NameTagObject;                                            // 0x01E4(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.NameTagUIPlayer");
		return ptr;
	}


	void SetQuestMark(TEnumAsByte<EQuestMarker> QuestMarker);
	class UGFxUI_NameTagObject* GetNameTagObject();
	void ASSetPawnNameTag(int PawnType, const struct FString& PawnNameStr, int HP, int MaxHP);
};


// Class BLGame.BSM_VoluntaryActionParameter
// 0x0004 (0x00A0 - 0x009C)
class UBSM_VoluntaryActionParameter : public UBSM_BaseParameter
{
public:
	unsigned long                                      bMovable : 1;                                             // 0x009C(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_VoluntaryActionParameter");
		return ptr;
	}

};


// Class BLGame.BSM_SA_ReviveParameter
// 0x0004 (0x00A0 - 0x009C)
class UBSM_SA_ReviveParameter : public UBSM_BaseParameter
{
public:
	unsigned long                                      bRevivalbyOther : 1;                                      // 0x009C(0x0004)
	unsigned long                                      bRevivalAtDeadbody : 1;                                   // 0x009C(0x0004)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_SA_ReviveParameter");
		return ptr;
	}

};


// Class BLGame.BSM_Test
// 0x0000 (0x01D4 - 0x01D4)
class UBSM_Test : public UBSM_Skill_Tool
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_Test");
		return ptr;
	}


	void CamTest();
	void CutIn();
	void Test();
	void SpecialMoveStarted(bool bForced, const struct FName& PrevMove);
};


// Class BLGame.BSM_NpcTalkParameter
// 0x0010 (0x00AC - 0x009C)
class UBSM_NpcTalkParameter : public UBSM_BaseParameter
{
public:
	struct FName                                       TalkAnimSeqName;                                          // 0x009C(0x0008)
	class UAkEvent*                                    TalkSoundEvent;                                           // 0x00A4(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_NpcTalkParameter");
		return ptr;
	}

};


// Class BLGame.BSM_NpcInteractionParameter
// 0x0010 (0x00AC - 0x009C)
class UBSM_NpcInteractionParameter : public UBSM_BaseParameter
{
public:
	unsigned long                                      bPlayLoop : 1;                                            // 0x009C(0x0004) (Transient)
	struct FName                                       AnimSeqName;                                              // 0x00A0(0x0008) (Transient)
	int                                                MonologID;                                                // 0x00A8(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_NpcInteractionParameter");
		return ptr;
	}

};


// Class BLGame.BLNpcSimulated
// 0x0000 (0x0F04 - 0x0F04)
class ABLNpcSimulated : public ABLNpc
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLNpcSimulated");
		return ptr;
	}

};


// Class BLGame.BLPathFindPreviewInterface
// 0x0000 (0x0250 - 0x0250)
class ABLPathFindPreviewInterface : public AActor
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLPathFindPreviewInterface");
		return ptr;
	}

};


// Class BLGame.BLPathFindPreviewPoint
// 0x0000 (0x0250 - 0x0250)
class ABLPathFindPreviewPoint : public AActor
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLPathFindPreviewPoint");
		return ptr;
	}

};


// Class BLGame.BLPathFindPreviewVolume
// 0x0000 (0x028C - 0x028C)
class ABLPathFindPreviewVolume : public AVolume
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLPathFindPreviewVolume");
		return ptr;
	}

};


// Class BLGame.BLPawnFX
// 0x0000 (0x0060 - 0x0060)
class UBLPawnFX : public UObject
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLPawnFX");
		return ptr;
	}

};


// Class BLGame.BSM_Mount_Prepare
// 0x0000 (0x0144 - 0x0144)
class UBSM_Mount_Prepare : public UBSM_Base
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_Mount_Prepare");
		return ptr;
	}


	void CancelSpecialMove();
	void SpecialMoveEnded(const struct FName& PrevMove, const struct FName& NextMove);
	bool PlaySequence(struct FSeqPlayInfo* a_Info);
	void SetBroadway(class UBroadwayGameInfo* InBroadway);
};


// Class BLGame.BSM_CarryParameter
// 0x0004 (0x00A0 - 0x009C)
class UBSM_CarryParameter : public UBSM_BaseParameter
{
public:
	int                                                CarryObjectCID;                                           // 0x009C(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_CarryParameter");
		return ptr;
	}

};


// Class BLGame.BSM_SkillDeckSwap_Complete
// 0x0000 (0x0144 - 0x0144)
class UBSM_SkillDeckSwap_Complete : public UBSM_Base
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_SkillDeckSwap_Complete");
		return ptr;
	}


	void SpecialMoveEnded(const struct FName& PrevMove, const struct FName& NextMove);
	bool PlaySequence(struct FSeqPlayInfo* a_Info);
	void SetBroadway(class UBroadwayGameInfo* InBroadway);
};


// Class BLGame.BSM_SkillDeckSwap_Casting
// 0x0000 (0x0144 - 0x0144)
class UBSM_SkillDeckSwap_Casting : public UBSM_Base
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_SkillDeckSwap_Casting");
		return ptr;
	}


	void CancelSpecialMove();
	void SpecialMoveEnded(const struct FName& PrevMove, const struct FName& NextMove);
	bool PlaySequence(struct FSeqPlayInfo* a_Info);
	void SetBroadway(class UBroadwayGameInfo* InBroadway);
};


// Class BLGame.BLSeqAct_ToggleCinematicModeWithHidingNPC
// 0x0004 (0x0158 - 0x0154)
class UBLSeqAct_ToggleCinematicModeWithHidingNPC : public USeqAct_ToggleCinematicMode
{
public:
	unsigned long                                      bHideNPC : 1;                                             // 0x0154(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLSeqAct_ToggleCinematicModeWithHidingNPC");
		return ptr;
	}


	void Activated();
};


// Class BLGame.BLPropEffectPlayer
// 0x0018 (0x0078 - 0x0060)
class UBLPropEffectPlayer : public UObject
{
public:
	class UBLPropStateAgent*                           OwnerAgent;                                               // 0x0060(0x0008) (Transient)
	class ABLProp*                                     OwnerProp;                                                // 0x0068(0x0008) (Transient)
	class UMaterialInstanceConstant*                   StaticMeshPossibilityEffectMIC;                           // 0x0070(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLPropEffectPlayer");
		return ptr;
	}


	void UpdateComponentAdjustOffset(class UPrimitiveComponent* InComponent, const struct FPropAdjustData& InAdjustData);
	void CleanupDecal(class UDecalComponent** InDecal);
	class UDecalComponent* SpawnDecal(const struct FPropEffectData_SpawnDecal& InSpawnDecalData);
	void StopSound();
	void PlaySound(const struct FPropEffectData_PlaySound& InPlaySoundData);
	void SetIdleAnimation(const struct FPropEffectData_PlayAnimation& InPlayAnimationData);
	void PlayAnimation(const struct FPropEffectData_PlayAnimation& InPlayAnimationData);
	void SetSkeletalMeshData(const struct FPropEffectData_ChangeSkeletalMesh& InChangeSkeletalMeshData);
	bool IsEmptySkeletalMesh();
	bool IsSameSkeletalMesh(class USkeletalMesh* InSkeletalMesh);
	void SetStaticMeshData(const struct FPropEffectData_ChangeStaticMesh& InChangeStaticMeshData);
	bool IsEmptyStaticMesh();
	bool IsSameStaticMesh(class UStaticMesh* InStaticMesh);
	void PlayPossibilityMIC(bool bTurnOn);
	void CleanupEmitters(TArray<class UParticleSystemComponent*>* OutPSCs);
	class UParticleSystemComponent* SpawnEmitter(class UParticleSystem* InParticleSystem, const struct FPropAdjustData& InAdjustData);
	void Cleanup();
	void Init(class UBLPropStateAgent* InAgent, class ABLProp* InProp);
};


// Class BLGame.BLPropStateHandler
// 0x0070 (0x00D0 - 0x0060)
class UBLPropStateHandler : public UObject
{
public:
	TEnumAsByte<EClientPropStateType>                  CurrentState;                                             // 0x0060(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0061(0x0003) MISSED OFFSET
	unsigned long                                      bVisible : 1;                                             // 0x0064(0x0004) (Transient)
	class UBLPropStateAgent*                           OwnerAgent;                                               // 0x0068(0x0008) (Transient)
	class UBLPropEffectPlayer*                         EffectPlayer;                                             // 0x0070(0x0008) (Transient)
	TArray<struct FPropEffectDataSet_InState>          PropEffectDataSets_InState;                               // 0x0078(0x0010) (Transient, NeedCtorLink)
	TArray<struct FPropEffectDataSet_OnStart>          PropEffectDataSets_OnStart;                               // 0x0088(0x0010) (Transient, NeedCtorLink)
	TArray<class UParticleSystemComponent*>            InStateEffectPSCs;                                        // 0x0098(0x0010) (ExportObject, Transient, Component, NeedCtorLink, EditInline)
	TArray<class UParticleSystemComponent*>            OnStartEffectPSCs;                                        // 0x00A8(0x0010) (ExportObject, Transient, Component, NeedCtorLink, EditInline)
	class UDecalComponent*                             InStateDecalComponent;                                    // 0x00B8(0x0008) (ExportObject, Transient, Component, EditInline)
	TArray<struct FPropStateTriggerTableItem>          PropStateTriggerTable;                                    // 0x00C0(0x0010) (Transient, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLPropStateHandler");
		return ptr;
	}


	void OnChangeVisionShared(bool bInVisionShared);
	void RefreshVisibility();
	void StopEffect(TArray<class UParticleSystemComponent*>* OutResultPSCs);
	void PlayEffect(TArray<struct FPropEffectData_SpawnParticle> InSpawnParticleData, TArray<class UParticleSystemComponent*>* OutResultPSCs);
	bool GetPropOnStartEffectDataSet(TEnumAsByte<EPropEffectTriggerType_OnStart> InTrigger, struct FPropEffectDataSet_OnStart* OutData);
	bool GetPropInStateEffectDataSet(TEnumAsByte<EPropEffectTriggerType_InState> InTrigger, struct FPropEffectDataSet_InState* OutData);
	void StopInStateEffect(TEnumAsByte<EPropEffectTriggerType_InState> InTrigger);
	void StopOnStartEffect(TEnumAsByte<EPropEffectTriggerType_OnStart> InTrigger);
	void PlayInStateEffect(TEnumAsByte<EPropEffectTriggerType_InState> InTrigger);
	void PlayOnStartEffect(TEnumAsByte<EPropEffectTriggerType_OnStart> InTrigger);
	void OnEndState(TEnumAsByte<EClientPropStateType> PrevState);
	void OnBeginState(TEnumAsByte<EClientPropStateType> NewState);
	void ChangeState(TEnumAsByte<EClientPropStateType> NewState);
	void SetVisible(bool bInVisible);
	void SetState(TEnumAsByte<ECEPropStateType> NewState);
	void Refresh();
	void Cleanup();
	void OnAssetLoaded(TArray<struct FPropEffectDataSet_InState> InPropEffectDataSets_InState, TArray<struct FPropEffectDataSet_OnStart> InPropEffectDataSets_OnStart);
	void Init(class UBLPropStateAgent* InAgent, class UBLPropEffectPlayer* InEffectPlayer);
};


// Class BLGame.BLScout
// 0x0000 (0x060C - 0x060C)
class ABLScout : public AScout
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLScout");
		return ptr;
	}

};


// Class BLGame.BLSeqAct_BreakBone
// 0x0020 (0x0170 - 0x0150)
class UBLSeqAct_BreakBone : public USequenceAction
{
public:
	struct FName                                       BoneNameToBreak;                                          // 0x0150(0x0008) (Edit)
	struct FVector                                     Impulse;                                                  // 0x0158(0x000C) (Edit)
	struct FVector                                     HitLocation;                                              // 0x0164(0x000C) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLSeqAct_BreakBone");
		return ptr;
	}

};


// Class BLGame.BLSeqAct_FilterButtonInput
// 0x0010 (0x0160 - 0x0150)
class UBLSeqAct_FilterButtonInput : public USequenceAction
{
public:
	TArray<struct FName>                               FilterInputNames;                                         // 0x0150(0x0010) (Edit, NeedCtorLink)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLSeqAct_FilterButtonInput");
		return ptr;
	}

};


// Class BLGame.BLSeqAct_MakeRagdoll
// 0x0000 (0x0150 - 0x0150)
class UBLSeqAct_MakeRagdoll : public USequenceAction
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLSeqAct_MakeRagdoll");
		return ptr;
	}

};


// Class BLGame.BLSeqAct_ShowHideActorByTag
// 0x0014 (0x0164 - 0x0150)
class UBLSeqAct_ShowHideActorByTag : public USequenceAction
{
public:
	struct FString                                     ActorTag;                                                 // 0x0150(0x0010) (Edit, NeedCtorLink)
	unsigned long                                      bHidden : 1;                                              // 0x0160(0x0004) (Edit)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLSeqAct_ShowHideActorByTag");
		return ptr;
	}


	void Activated();
};


// Class BLGame.BLShockImpactLight
// 0x0000 (0x0270 - 0x0270)
class UBLShockImpactLight : public UBLImpactLight
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLShockImpactLight");
		return ptr;
	}

};


// Class BLGame.BLSwordDamageType
// 0x0000 (0x009C - 0x009C)
class UBLSwordDamageType : public UBLDamageType
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLSwordDamageType");
		return ptr;
	}

};


// Class BLGame.BLSwordImpactLight
// 0x0000 (0x0270 - 0x0270)
class UBLSwordImpactLight : public UBLImpactLight
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLSwordImpactLight");
		return ptr;
	}

};


// Class BLGame.GFxWidget_Dialog
// 0x0000 (0x00B8 - 0x00B8)
class UGFxWidget_Dialog : public UClikWidgetBase
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.GFxWidget_Dialog");
		return ptr;
	}


	int UA_Close_Latest_Dialog(int DialogIndex);
	void UA_Set_Button_Disable(int DialogIndex, bool Disable, unsigned char Flags);
	class UGFxObject* CreateDialogStyleObject(const struct FString& Text, int iValue, bool DisableFlag);
	TArray<class UGFxObject*> GetButtonDataByStyle(TEnumAsByte<EDialogStyle> DialogStyle, unsigned char ButtonFlags);
	void DialogHandler(const struct FEventData& ev);
	int UA_Close_Dialog(int DialogIndex);
	int UA_Open_Dialog(TEnumAsByte<EDialogType> DialogType, const struct FString& DialogText, TEnumAsByte<EDialogStyle> DialogStyle, TArray<class UGFxObject*> ButtonDatas, TEnumAsByte<EDialogOption> DialogOption, int TimeOut, bool IsModal, TEnumAsByte<EDialogAlign> DialogAlign, int OffsetX, int OffsetY, const struct FString& DialogOwner);
	int OpenDialogEx(TEnumAsByte<EDialogType> DialogType, const struct FString& DialogText, TEnumAsByte<EDialogStyle> DialogStyle, unsigned char ButtonFlags, TEnumAsByte<EDialogOption> DialogOption, int TimeOut, bool IsModal, TEnumAsByte<EDialogAlign> DialogAlign, int OffsetX, int OffsetY, const struct FString& DialogOwner);
	void Unload();
	void Init(class UBLUIPlayer* BLUIPlayer);
};


// Class BLGame.BLWeapon
// 0x0010 (0x03CC - 0x03BC)
class ABLWeapon : public AUDKWeapon
{
public:
	class USkeletalMeshComponent*                      SkelMesh;                                                 // 0x03BC(0x0008) (Edit, ExportObject, Component, EditInline)
	class UClass*                                      ExplosionLightClass;                                      // 0x03C4(0x0008)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLWeapon");
		return ptr;
	}


	void RigidBodyCollision(class UPrimitiveComponent* HitComponent, class UPrimitiveComponent* OtherComponent, int ContactIndex, struct FCollisionImpactData* RigidCollisionData);
	void TestFX(const struct FVector& a_Location, const struct FRotator& a_Rotation, class AActor* a_AttachActor);
};


// Class BLGame.BLWindSource
// 0x0000 (0x0258 - 0x0258)
class ABLWindSource : public AWindDirectionalSource
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BLWindSource");
		return ptr;
	}

};


// Class BLGame.BSM_MountAttackMoveParameter
// 0x0060 (0x0174 - 0x0114)
class UBSM_MountAttackMoveParameter : public UBSM_BasicMoveParameter
{
public:
	struct FName                                       VehicleTraceAnimSeqName;                                  // 0x0114(0x0008) (Edit)
	struct FName                                       DriverTraceAnimSeqName;                                   // 0x011C(0x0008) (Edit)
	struct FName                                       VehicleDisappearAnimSeqName;                              // 0x0124(0x0008) (Edit)
	struct FName                                       DriverAttackAnimSeqName;                                  // 0x012C(0x0008) (Edit)
	float                                              DistanceBetweenTargetAndTraceDestination_XY;              // 0x0134(0x0004) (Edit)
	float                                              DistanceBetweenTargetAndTraceDestination_Z;               // 0x0138(0x0004) (Edit)
	float                                              TraceAccelRateModifier;                                   // 0x013C(0x0004) (Edit)
	float                                              MaxAirSpeedModifier;                                      // 0x0140(0x0004) (Edit)
	class UParticleSystem*                             VehicleTraceEffect;                                       // 0x0144(0x0008) (Edit)
	class UParticleSystem*                             LandingAttackEffect;                                      // 0x014C(0x0008) (Edit)
	struct FName                                       LandingAttackEffectStartNotifyName;                       // 0x0154(0x0008) (Edit)
	float                                              DiveFOV;                                                  // 0x015C(0x0004) (Edit)
	float                                              RadialBlurMaxBlurAmountScale;                             // 0x0160(0x0004) (Edit)
	float                                              RadialBlurMaxBlurAmountOpacity;                           // 0x0164(0x0004) (Edit)
	unsigned long                                      bUseRadialBlurMaxBlurAmountScale : 1;                     // 0x0168(0x0004) (Edit)
	unsigned long                                      bUseRadialBlurMaxBlurAmountOpacity : 1;                   // 0x0168(0x0004) (Edit)
	unsigned long                                      bRenderAsVelocity : 1;                                    // 0x0168(0x0004) (Edit)
	struct FName                                       VechicleTraceEffectBoneName;                              // 0x016C(0x0008) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_MountAttackMoveParameter");
		return ptr;
	}

};


// Class BLGame.BSM_SA_SprintReady
// 0x0000 (0x0174 - 0x0174)
class UBSM_SA_SprintReady : public UBSM_PhaseAction
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_SA_SprintReady");
		return ptr;
	}


	void OnPhaseChanged(int PrevPhaseIndex, int NextPhaseIndex);
	void SpecialMoveEnded(const struct FName& PrevMove, const struct FName& NextMove);
	void SpecialMoveStarted(bool bForced, const struct FName& PrevMove);
	void BS_AnimEndNotify(const struct FName& AnimSeqName, int InAnimSeqKey, float PlayedTime, float ExcessTime);
};


// Class BLGame.BSM_Skill_BaseAttack
// 0x0000 (0x01D4 - 0x01D4)
class UBSM_Skill_BaseAttack : public UBSM_Skill_Tool
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_Skill_BaseAttack");
		return ptr;
	}

};


// Class BLGame.BSM_SystemAction
// 0x00F0 (0x0234 - 0x0144)
class UBSM_SystemAction : public UBSM_Base
{
public:
	TEnumAsByte<ESkillPhase>                           Phase;                                                    // 0x0144(0x0001) (Transient)
	unsigned char                                      UnknownData00[0x3];                                       // 0x0145(0x0003) MISSED OFFSET
	struct FSeqPlayInfo                                StartedInfo;                                              // 0x0148(0x0038) (Transient)
	struct FSeqPlayInfo                                CastingInfo;                                              // 0x0180(0x0038) (Transient)
	struct FSeqPlayInfo                                ReadyInfo;                                                // 0x01B8(0x0038) (Transient)
	struct FSeqPlayInfo                                ShootInfo;                                                // 0x01F0(0x0038) (Transient)
	struct FName                                       CachedSequenceName;                                       // 0x0228(0x0008) (Transient)
	unsigned long                                      bCastingCompleted : 1;                                    // 0x0230(0x0004) (Transient)
	unsigned long                                      bCastingCanceled : 1;                                     // 0x0230(0x0004) (Transient)

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.BSM_SystemAction");
		return ptr;
	}


	bool IsInPhase(TEnumAsByte<ESkillPhase> a_Phase);
	void SetPhase(TEnumAsByte<ESkillPhase> a_Phase);
	TEnumAsByte<ESkillPhase> GetNextPhase(TEnumAsByte<ESkillPhase> a_Phase);
	void ProcessPhase();
	TEnumAsByte<ESkillPhase> ProcessShoot();
	TEnumAsByte<ESkillPhase> ProcessCancel();
	TEnumAsByte<ESkillPhase> ProcessDone();
	TEnumAsByte<ESkillPhase> ProcessReturn();
	TEnumAsByte<ESkillPhase> ProcessReady();
	TEnumAsByte<ESkillPhase> ProcessCasting();
	TEnumAsByte<ESkillPhase> ProcessStarted();
	void BS_AnimEndNotify(const struct FName& AnimSeqName, int InAnimSeqKey, float PlayedTime, float ExcessTime);
	bool PlaySequence(struct FSeqPlayInfo* a_Info);
	bool CanChainMove(const struct FName& NextMove);
	void Tick(float a_DeltaTime);
	bool IsDone();
	void CancelSpecialMove();
	void CompleteCasting();
	void SpecialMoveEnded(const struct FName& PrevMove, const struct FName& NextMove);
	void SpecialMoveStarted(bool bForced, const struct FName& PrevMove);
};


// Class BLGame.EditorGame
// 0x0000 (0x04C8 - 0x04C8)
class AEditorGame : public ABlessGame
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.EditorGame");
		return ptr;
	}

};


// Class BLGame.EditorPC
// 0x0000 (0x09FC - 0x09FC)
class AEditorPC : public ABlessPC
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.EditorPC");
		return ptr;
	}

};


// Class BLGame.OnlineDataSet
// 0x0000 (0x0060 - 0x0060)
class UOnlineDataSet : public UObject
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.OnlineDataSet");
		return ptr;
	}

};


// Class BLGame.PawnCommonInfo
// 0x0000 (0x0060 - 0x0060)
class UPawnCommonInfo : public UObject
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PawnCommonInfo");
		return ptr;
	}

};


// Class BLGame.PawnInfo
// 0x0000 (0x0098 - 0x0098)
class UPawnInfo : public UContentInfo
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.PawnInfo");
		return ptr;
	}

};


// Class BLGame.SkillActionComponent
// 0x0000 (0x0070 - 0x0070)
class USkillActionComponent : public UPawnComponent
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.SkillActionComponent");
		return ptr;
	}

};


// Class BLGame.SocialActionComponent
// 0x0000 (0x0070 - 0x0070)
class USocialActionComponent : public UPawnComponent
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.SocialActionComponent");
		return ptr;
	}

};


// Class BLGame.Utils
// 0x0000 (0x0060 - 0x0060)
class UUtils : public UObject
{
public:

	static UClass* StaticClass()
	{
		static UClass* ptr = nullptr; 
 if (!ptr) ptr = UObject::FindClass("Class BLGame.Utils");
		return ptr;
	}

};


}

#ifdef _MSC_VER
	#pragma pack(pop)
#endif
